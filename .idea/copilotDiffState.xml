<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game_logic/cursor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/cursor.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False&#10;" />
              <option name="updatedContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/map.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/map.py" />
              <option name="originalContent" value="# map.py&#10;# Room.txt 기반 간단한 맵 로더 및 타일 엔티티 빌더&#10;# 작성자: 자동 생성&#10;# 사용 가정(중요):&#10;# - Room.txt 파일은 섹션 단위(예: [ground], [upper_ground], [walls], [cliff], [props])의 텍스트로 존재하며,&#10;#   각 섹션 밑에는 콤마(,)로 구분된 정수 타일 인덱스 행들이 있음.&#10;#   예:&#10;#   [ground]&#10;#   1,1,1,0,0&#10;#   1,2,2,0,0&#10;#&#10;# - 0은 빈 타일(배치 없음)을 의미.&#10;# - props 섹션은 현재 무시합니다.&#10;#&#10;# 제공하는 기능:&#10;# - Map.load_from_room_txt(path): Room.txt 파싱&#10;# - Map.build_into_world(world, tile_size=32, origin=(0,0)): world의 레이어들에 타일 엔티티를 추가&#10;# - TileEntity: 최소한의 update()/draw() 인터페이스(프로젝트의 실제 렌더링 파이프라인에 맞춰 확장 가능)&#10;&#10;import os&#10;from typing import Dict, List, Tuple, Optional&#10;&#10;try:&#10;    from pico2d import draw_rectangle&#10;except Exception:&#10;    # pico2d가 없으면 draw_rectangle을 대체하는 더미 함수로 허용&#10;    def draw_rectangle(l, b, r, t):&#10;        # no-op in headless/static analysis&#10;        return&#10;&#10;&#10;SUPPORTED_SECTIONS = ['ground', 'upper_ground', 'walls', 'cliff', 'props']&#10;&#10;&#10;class TileEntity:&#10;    &quot;&quot;&quot;맵에 배치되는 간단한 타일 엔티티.&#10;    실제 프로젝트에서는 이미지(tileset)과 애니메이션, 충돌박스 등을 연결해서 사용하면 됩니다.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, tile_id: int, x: int, y: int, size: int, layer: str):&#10;        self.tile_id = int(tile_id)&#10;        self.x = int(x)&#10;        self.y = int(y)&#10;        self.size = int(size)&#10;        self.layer = layer&#10;&#10;    def update(self):&#10;        # 기본 타일은 고정이므로 True를 반환하여 계속 유지&#10;        return True&#10;&#10;    def draw(self):&#10;        # 디버그용 간단한 사각형 그리기 (pico2d가 있으면 보임)&#10;        l = self.x&#10;        b = self.y&#10;        r = self.x + self.size&#10;        t = self.y + self.size&#10;        draw_rectangle(l, b, r, t)&#10;&#10;&#10;class Map:&#10;    def __init__(self, tile_size: int = 32):&#10;        self.tile_size = int(tile_size)&#10;        # 각 섹션에 대해 2D 리스트(행 리스트)로 타일 인덱스를 보관&#10;        self.layers: Dict[str, List[List[int]]] = {s: [] for s in SUPPORTED_SECTIONS}&#10;        self.width = 0&#10;        self.height = 0&#10;&#10;    @staticmethod&#10;    def _normalize_section_name(name: str) -&gt; str:&#10;        return name.strip().lower()&#10;&#10;    def load_from_room_txt(self, path: str) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Room.txt 형식(간단한 INI 스타일)을 파싱하여 self.layers에 채웁니다.&#10;        빈 라인 또는 주석(//, ;, #)은 무시합니다.&#10;&#10;        변경: 토큰 구분자는 공백(whitespace)을 사용합니다. 라인 내의 ','는 공백으로 대체되어&#10;        기존 콤마 형식과도 호환됩니다. 토큰 '0' 및 'X'/'x'는 빈 타일(0)으로 처리됩니다.&#10;        &quot;&quot;&quot;&#10;        if not os.path.isfile(path):&#10;            raise FileNotFoundError(f&quot;Room file not found: {path}&quot;)&#10;&#10;        current = None&#10;        with open(path, 'r', encoding='utf-8') as f:&#10;            for raw_line in f:&#10;                line = raw_line.strip()&#10;                if not line:&#10;                    continue&#10;                if line.startswith('//') or line.startswith('#') or line.startswith(';'):&#10;                    continue&#10;                if line.startswith('[') and line.endswith(']'):&#10;                    sec = self._normalize_section_name(line[1:-1])&#10;                    if sec not in SUPPORTED_SECTIONS:&#10;                        # 새 섹션을 만드려 하지 말고 지원되는 섹션만 처리&#10;                        current = None&#10;                        continue&#10;                    current = sec&#10;                    # reset existing content for the section&#10;                    self.layers[current] = []&#10;                    continue&#10;&#10;                if current is None:&#10;                    # 섹션 밖의 데이터는 무시&#10;                    continue&#10;&#10;                # ',' 구분자를 공백으로 바꿔 공백 분할을 사용하여 유연하게 처리&#10;                normalized = line.replace(',', ' ')&#10;                parts = [p.strip() for p in normalized.split() if p.strip() != '']&#10;                if not parts:&#10;                    continue&#10;                row: List[int] = []&#10;                for p in parts:&#10;                    # '0' 과 'X' 또는 'x' 를 빈타일로 처리&#10;                    if p == '0' or p.lower() == 'x':&#10;                        row.append(0)&#10;                        continue&#10;                    try:&#10;                        row.append(int(p))&#10;                    except ValueError:&#10;                        # 숫자로 변환할 수 없는 토큰이 있으면 빈타일로 처리&#10;                        row.append(0)&#10;                self.layers[current].append(row)&#10;&#10;        # 맵 전체 크기 계산 (가장 큰 폭/높이 사용)&#10;        max_w = 0&#10;        max_h = 0&#10;        for sec in SUPPORTED_SECTIONS:&#10;            h = len(self.layers.get(sec, []))&#10;            if h &gt; max_h:&#10;                max_h = h&#10;            for row in self.layers.get(sec, []):&#10;                if len(row) &gt; max_w:&#10;                    max_w = len(row)&#10;        self.width = max_w&#10;        self.height = max_h&#10;&#10;    def build_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0), replace: bool = True) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        파싱된 레이어 데이터를 바탕으로 `world` 딕셔너리의 레이어 리스트에 TileEntity들을 추가합니다.&#10;        - world: main.py에서 사용되는 world 딕셔너리 (예: keys: 'ground','upper_ground','walls',...)&#10;        - tile_size: 맵의 타일 픽셀 크기 (기본은 Map.tile_size)&#10;        - origin: (x0,y0) 맵 원점 좌표 (왼쪽 하단 기준)&#10;        - replace: True이면 이 함수가 추가할 레이어(ground/upper_ground/walls)의 기존 리스트를 비우고 새로 채웁니다.&#10;&#10;        이 함수는 props 섹션은 현재 무시합니다.&#10;        &quot;&quot;&quot;&#10;        ts = int(tile_size) if tile_size is not None else self.tile_size&#10;        x0, y0 = origin&#10;&#10;        target_layers = ['ground', 'upper_ground', 'walls']&#10;        if replace:&#10;            for tl in target_layers:&#10;                if tl in world and isinstance(world[tl], list):&#10;                    world[tl].clear()&#10;&#10;        # 맵 데이터의 행렬은 텍스트 상에서는 보통 위에서 아래로 작성됨을 가정.&#10;        # 여기서는 텍스트 행(0)이 맵의 &quot;상단&quot;이라고 가정하고 화면 좌표로는 높이를 고려해 y를 계산합니다.&#10;        for sec in ['ground', 'upper_ground', 'walls', 'cliff']:&#10;            rows = self.layers.get(sec, [])&#10;            h = len(rows)&#10;            for row_idx, row in enumerate(rows):&#10;                # 텍스트의 첫 행 -&gt; 맵 상단이므로 y 계산&#10;                # 맵 상단을 origin_y + (height - 1 - row_idx) * ts 로 배치&#10;                for col_idx, tile_id in enumerate(row):&#10;                    if tile_id == 0:&#10;                        continue&#10;                    # compute position&#10;                    # bottom-left origin&#10;                    x = x0 + col_idx * ts&#10;                    y = y0 + (self.height - 1 - row_idx) * ts&#10;                    ent = TileEntity(tile_id=tile_id, x=x, y=y, size=ts, layer=sec)&#10;                    # 저장된 그리드 좌표를 붙여 두면 나중에 크기 변경 시 재계산에 사용 가능&#10;                    ent._grid_col = col_idx&#10;                    ent._grid_row = row_idx&#10;                    ent._map_height = self.height&#10;                    ent._origin = (x0, y0)&#10;                    # 월드에 맞는 레이어 키가 존재하면 append&#10;                    if sec == 'ground':&#10;                        world.setdefault('ground', []).append(ent)&#10;                    elif sec == 'upper_ground':&#10;                        world.setdefault('upper_ground', []).append(ent)&#10;                    elif sec == 'walls' or sec == 'cliff':&#10;                        # 벽/절벽은 충돌 처리용으로 walls 레이어에 넣음&#10;                        world.setdefault('walls', []).append(ent)&#10;                    else:&#10;                        # props 등은 현재 무시&#10;                        pass&#10;&#10;    def rebuild_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        편의 메서드: 기존 내용을 교체(replace=True)하여 다시 빌드합니다.&#10;        &quot;&quot;&quot;&#10;        self.build_into_world(world, tile_size=tile_size, origin=origin, replace=True)&#10;&#10;    def apply_tile_size_to_world(self, world: Dict[str, list], new_tile_size: int, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        기존에 world에 배치된 TileEntity들이 그리드 좌표를 가지고 있다면,&#10;        각 엔티티의 size와 x,y를 새 타일 크기에 맞게 in-place로 갱신합니다.&#10;        - world: 월드 딕셔너리&#10;        - new_tile_size: 적용할 새 타일 크기&#10;        - origin: 맵 원점&#10;&#10;        이 방법은 엔티티를 새로 생성하지 않으므로 외부 참조가 유지됩니다.&#10;        만약 엔티티에 그리드 좌표가 없다면 동작하지 않습니다(그럴 경우 재빌드 필요).&#10;        &quot;&quot;&quot;&#10;        ts = int(new_tile_size)&#10;        x0, y0 = origin&#10;        layers = ['ground', 'upper_ground', 'walls']&#10;        updated = 0&#10;        for layer in layers:&#10;            for ent in list(world.get(layer, [])):&#10;                # ent가 grid 정보(_grid_col/_grid_row/_map_height)를 가지고 있으면 위치 재계산&#10;                if hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height'):&#10;                    col = int(ent._grid_col)&#10;                    row = int(ent._grid_row)&#10;                    map_h = int(ent._map_height)&#10;                    ent.size = ts&#10;                    ent.x = x0 + col * ts&#10;                    ent.y = y0 + (map_h - 1 - row) * ts&#10;                    # update stored origin too&#10;                    ent._origin = (x0, y0)&#10;                    updated += 1&#10;                else:&#10;                    # grid 정보가 없으면 이 엔티티는 무시 (재빌드를 권장)&#10;                    continue&#10;        try:&#10;            print(f&quot;apply_tile_size_to_world: applied new_tile_size={ts}, updated_entities={updated}&quot;)&#10;        except Exception:&#10;            pass&#10;&#10;    def set_tile_size(self, new_tile_size: int, world: Optional[Dict[str, list]] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Map의 기본 타일 크기를 변경합니다. 만약 `world`를 전달하면 해당 월드에 대해&#10;        가능한 경우 in-place로 크기/위치를 갱신하고, grid 정보가 부족하면 재빌드를 수행합니다.&#10;        &quot;&quot;&quot;&#10;        self.tile_size = int(new_tile_size)&#10;        if world is not None:&#10;            # 먼저 시도: in-place 적용 (grid 좌표가 있는 경우)&#10;            # 검사: 모든 엔티티들이 grid 좌표를 가지고 있는지 확인&#10;            ok = True&#10;            total = 0&#10;            for layer in ['ground', 'upper_ground', 'walls']:&#10;                for ent in world.get(layer, []):&#10;                    total += 1&#10;                    if not (hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height')):&#10;                        ok = False&#10;                        break&#10;                if not ok:&#10;                    break&#10;            if ok:&#10;                try:&#10;                    self.apply_tile_size_to_world(world, self.tile_size, origin)&#10;                    print(f&quot;set_tile_size: in-place applied to {total} entities, new_tile_size={self.tile_size}&quot;)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91mset_tile_size: in-place apply failed: {e}\033[0m&quot;)&#10;            else:&#10;                # 일부 엔티티에 grid 정보가 없으면 안전하게 재빌드&#10;                try:&#10;                    self.rebuild_into_world(world, tile_size=self.tile_size, origin=origin)&#10;                    print(f&quot;set_tile_size: rebuilt world with new_tile_size={self.tile_size}&quot;)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91mset_tile_size: rebuild failed: {e}\033[0m&quot;)&#10;&#10;&#10;# 간단한 자기검증 스크립트&#10;if __name__ == '__main__':&#10;    # 간단한 Room 텍스트 샘플을 메모리로 만들고 파싱 테스트&#10;    sample = '''&#10;[ground]&#10;1,1,1,0,0&#10;1,2,2,0,0&#10;&#10;[upper_ground]&#10;0,0,3,3,0&#10;&#10;[walls]&#10;0,4,0,0,0&#10;'''&#10;    import tempfile&#10;&#10;    p = tempfile.gettempdir() + os.sep + 'sample_room.txt'&#10;    with open(p, 'w', encoding='utf-8') as f:&#10;        f.write(sample)&#10;&#10;    m = Map(tile_size=128)&#10;    m.load_from_room_txt(p)&#10;    print('width,height:', m.width, m.height)&#10;    world = {k: [] for k in ['ground', 'upper_ground', 'walls', 'effects_back', 'effects_front', 'ui', 'cursor']}&#10;    m.build_into_world(world, origin=(0, 0))&#10;    for k in world:&#10;        print(k, len(world[k]))&#10;" />
              <option name="updatedContent" value="# map.py&#13;&#10;# Room.txt 기반 간단한 맵 로더 및 타일 엔티티 빌더&#13;&#10;# 작성자: 자동 생성&#13;&#10;# 사용 가정(중요):&#13;&#10;# - Room.txt 파일은 섹션 단위(예: [ground], [upper_ground], [walls], [cliff], [props])의 텍스트로 존재하며,&#13;&#10;#   각 섹션 밑에는 콤마(,)로 구분된 정수 타일 인덱스 행들이 있음.&#13;&#10;#   예:&#13;&#10;#   [ground]&#13;&#10;#   1,1,1,0,0&#13;&#10;#   1,2,2,0,0&#13;&#10;#&#13;&#10;# - 0은 빈 타일(배치 없음)을 의미.&#13;&#10;# - props 섹션은 현재 무시합니다.&#13;&#10;#&#13;&#10;# 제공하는 기능:&#13;&#10;# - Map.load_from_room_txt(path): Room.txt 파싱&#13;&#10;# - Map.build_into_world(world, tile_size=32, origin=(0,0)): world의 레이어들에 타일 엔티티를 추가&#13;&#10;# - TileEntity: 최소한의 update()/draw() 인터페이스(프로젝트의 실제 렌더링 파이프라인에 맞춰 확장 가능)&#13;&#10;&#13;&#10;import os&#13;&#10;from typing import Dict, List, Tuple, Optional&#13;&#10;&#13;&#10;try:&#13;&#10;    from pico2d import draw_rectangle&#13;&#10;except Exception:&#13;&#10;    # pico2d가 없으면 draw_rectangle을 대체하는 더미 함수로 허용&#13;&#10;    def draw_rectangle(l, b, r, t):&#13;&#10;        # no-op in headless/static analysis&#13;&#10;        return&#13;&#10;&#13;&#10;&#13;&#10;SUPPORTED_SECTIONS = ['ground', 'upper_ground', 'walls', 'cliff', 'props']&#13;&#10;&#13;&#10;&#13;&#10;class TileEntity:&#13;&#10;    &quot;&quot;&quot;맵에 배치되는 간단한 타일 엔티티.&#13;&#10;    실제 프로젝트에서는 이미지(tileset)과 애니메이션, 충돌박스 등을 연결해서 사용하면 됩니다.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;&#13;&#10;    def __init__(self, tile_id: int, x: int, y: int, size: int, layer: str):&#13;&#10;        self.tile_id = int(tile_id)&#13;&#10;        self.x = int(x)&#13;&#10;        self.y = int(y)&#13;&#10;        self.size = int(size)&#13;&#10;        self.layer = layer&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        # 기본 타일은 고정이므로 True를 반환하여 계속 유지&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self):&#13;&#10;        # 디버그용 간단한 사각형 그리기 (pico2d가 있으면 보임)&#13;&#10;        l = self.x&#13;&#10;        b = self.y&#13;&#10;        r = self.x + self.size&#13;&#10;        t = self.y + self.size&#13;&#10;        draw_rectangle(l, b, r, t)&#13;&#10;&#13;&#10;&#13;&#10;class Map:&#13;&#10;    def __init__(self, tile_size: int = 32):&#13;&#10;        self.tile_size = int(tile_size)&#13;&#10;        # 각 섹션에 대해 2D 리스트(행 리스트)로 타일 인덱스를 보관&#13;&#10;        self.layers: Dict[str, List[List[int]]] = {s: [] for s in SUPPORTED_SECTIONS}&#13;&#10;        self.width = 0&#13;&#10;        self.height = 0&#13;&#10;&#13;&#10;    @staticmethod&#13;&#10;    def _normalize_section_name(name: str) -&gt; str:&#13;&#10;        return name.strip().lower()&#13;&#10;&#13;&#10;    def load_from_room_txt(self, path: str) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Room.txt 형식(간단한 INI 스타일)을 파싱하여 self.layers에 채웁니다.&#13;&#10;        빈 라인 또는 주석(//, ;, #)은 무시합니다.&#13;&#10;&#13;&#10;        변경: 토큰 구분자는 공백(whitespace)을 사용합니다. 라인 내의 ','는 공백으로 대체되어&#13;&#10;        기존 콤마 형식과도 호환됩니다. 토큰 '0' 및 'X'/'x'는 빈 타일(0)으로 처리됩니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not os.path.isfile(path):&#13;&#10;            raise FileNotFoundError(f&quot;Room file not found: {path}&quot;)&#13;&#10;&#13;&#10;        current = None&#13;&#10;        with open(path, 'r', encoding='utf-8') as f:&#13;&#10;            for raw_line in f:&#13;&#10;                line = raw_line.strip()&#13;&#10;                if not line:&#13;&#10;                    continue&#13;&#10;                if line.startswith('//') or line.startswith('#') or line.startswith(';'):&#13;&#10;                    continue&#13;&#10;                if line.startswith('[') and line.endswith(']'):&#13;&#10;                    sec = self._normalize_section_name(line[1:-1])&#13;&#10;                    if sec not in SUPPORTED_SECTIONS:&#13;&#10;                        # 새 섹션을 만드려 하지 말고 지원되는 섹션만 처리&#13;&#10;                        current = None&#13;&#10;                        continue&#13;&#10;                    current = sec&#13;&#10;                    # reset existing content for the section&#13;&#10;                    self.layers[current] = []&#13;&#10;                    continue&#13;&#10;&#13;&#10;                if current is None:&#13;&#10;                    # 섹션 밖의 데이터는 무시&#13;&#10;                    continue&#13;&#10;&#13;&#10;                # ',' 구분자를 공백으로 바꿔 공백 분할을 사용하여 유연하게 처리&#13;&#10;                normalized = line.replace(',', ' ')&#13;&#10;                parts = [p.strip() for p in normalized.split() if p.strip() != '']&#13;&#10;                if not parts:&#13;&#10;                    continue&#13;&#10;                row: List[int] = []&#13;&#10;                for p in parts:&#13;&#10;                    # '0' 과 'X' 또는 'x' 를 빈타일로 처리&#13;&#10;                    if p == '0' or p.lower() == 'x':&#13;&#10;                        row.append(0)&#13;&#10;                        continue&#13;&#10;                    try:&#13;&#10;                        row.append(int(p))&#13;&#10;                    except ValueError:&#13;&#10;                        # 숫자로 변환할 수 없는 토큰이 있으면 빈타일로 처리&#13;&#10;                        row.append(0)&#13;&#10;                self.layers[current].append(row)&#13;&#10;&#13;&#10;        # 맵 전체 크기 계산 (가장 큰 폭/높이 사용)&#13;&#10;        max_w = 0&#13;&#10;        max_h = 0&#13;&#10;        for sec in SUPPORTED_SECTIONS:&#13;&#10;            h = len(self.layers.get(sec, []))&#13;&#10;            if h &gt; max_h:&#13;&#10;                max_h = h&#13;&#10;            for row in self.layers.get(sec, []):&#13;&#10;                if len(row) &gt; max_w:&#13;&#10;                    max_w = len(row)&#13;&#10;        self.width = max_w&#13;&#10;        self.height = max_h&#13;&#10;&#13;&#10;    def build_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0), replace: bool = True) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        파싱된 레이어 데이터를 바탕으로 `world` 딕셔너리의 레이어 리스트에 TileEntity들을 추가합니다.&#13;&#10;        - world: main.py에서 사용되는 world 딕셔너리 (예: keys: 'ground','upper_ground','walls',...)&#13;&#10;        - tile_size: 맵의 타일 픽셀 크기 (기본은 Map.tile_size)&#13;&#10;        - origin: (x0,y0) 맵 원점 좌표 (왼쪽 하단 기준)&#13;&#10;        - replace: True이면 이 함수가 추가할 레이어(ground/upper_ground/walls)의 기존 리스트를 비우고 새로 채웁니다.&#13;&#10;&#13;&#10;        이 함수는 props 섹션은 현재 무시합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        ts = int(tile_size) if tile_size is not None else self.tile_size&#13;&#10;        x0, y0 = origin&#13;&#10;&#13;&#10;        target_layers = ['ground', 'upper_ground', 'walls']&#13;&#10;        if replace:&#13;&#10;            for tl in target_layers:&#13;&#10;                if tl in world and isinstance(world[tl], list):&#13;&#10;                    world[tl].clear()&#13;&#10;&#13;&#10;        # 맵 데이터의 행렬은 텍스트 상에서는 보통 위에서 아래로 작성됨을 가정.&#13;&#10;        # 여기서는 텍스트 행(0)이 맵의 &quot;상단&quot;이라고 가정하고 화면 좌표로는 높이를 고려해 y를 계산합니다.&#13;&#10;        for sec in ['ground', 'upper_ground', 'walls', 'cliff']:&#13;&#10;            rows = self.layers.get(sec, [])&#13;&#10;            h = len(rows)&#13;&#10;            for row_idx, row in enumerate(rows):&#13;&#10;                # 텍스트의 첫 행 -&gt; 맵 상단이므로 y 계산&#13;&#10;                # 맵 상단을 origin_y + (height - 1 - row_idx) * ts 로 배치&#13;&#10;                for col_idx, tile_id in enumerate(row):&#13;&#10;                    if tile_id == 0:&#13;&#10;                        continue&#13;&#10;                    # compute position&#13;&#10;                    # bottom-left origin&#13;&#10;                    x = x0 + col_idx * ts&#13;&#10;                    y = y0 + (self.height - 1 - row_idx) * ts&#13;&#10;                    ent = TileEntity(tile_id=tile_id, x=x, y=y, size=ts, layer=sec)&#13;&#10;                    # 저장된 그리드 좌표를 붙여 두면 나중에 크기 변경 시 재계산에 사용 가능&#13;&#10;                    ent._grid_col = col_idx&#13;&#10;                    ent._grid_row = row_idx&#13;&#10;                    ent._map_height = self.height&#13;&#10;                    ent._origin = (x0, y0)&#13;&#10;                    # 월드에 맞는 레이어 키가 존재하면 append&#13;&#10;                    if sec == 'ground':&#13;&#10;                        world.setdefault('ground', []).append(ent)&#13;&#10;                    elif sec == 'upper_ground':&#13;&#10;                        world.setdefault('upper_ground', []).append(ent)&#13;&#10;                    elif sec == 'walls' or sec == 'cliff':&#13;&#10;                        # 벽/절벽은 충돌 처리용으로 walls 레이어에 넣음&#13;&#10;                        world.setdefault('walls', []).append(ent)&#13;&#10;                    else:&#13;&#10;                        # props 등은 현재 무시&#13;&#10;                        pass&#13;&#10;&#13;&#10;    def rebuild_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        편의 메서드: 기존 내용을 교체(replace=True)하여 다시 빌드합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.build_into_world(world, tile_size=tile_size, origin=origin, replace=True)&#13;&#10;&#13;&#10;    def apply_tile_size_to_world(self, world: Dict[str, list], new_tile_size: int, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        기존에 world에 배치된 TileEntity들이 그리드 좌표를 가지고 있다면,&#13;&#10;        각 엔티티의 size와 x,y를 새 타일 크기에 맞게 in-place로 갱신합니다.&#13;&#10;        - world: 월드 딕셔너리&#13;&#10;        - new_tile_size: 적용할 새 타일 크기&#13;&#10;        - origin: 맵 원점&#13;&#10;&#13;&#10;        이 방법은 엔티티를 새로 생성하지 않으므로 외부 참조가 유지됩니다.&#13;&#10;        만약 엔티티에 그리드 좌표가 없다면 동작하지 않습니다(그럴 경우 재빌드 필요).&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        ts = int(new_tile_size)&#13;&#10;        x0, y0 = origin&#13;&#10;        layers = ['ground', 'upper_ground', 'walls']&#13;&#10;        updated = 0&#13;&#10;        for layer in layers:&#13;&#10;            for ent in list(world.get(layer, [])):&#13;&#10;                # ent가 grid 정보(_grid_col/_grid_row/_map_height)를 가지고 있으면 위치 재계산&#13;&#10;                if hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height'):&#13;&#10;                    col = int(ent._grid_col)&#13;&#10;                    row = int(ent._grid_row)&#13;&#10;                    map_h = int(ent._map_height)&#13;&#10;                    ent.size = ts&#13;&#10;                    ent.x = x0 + col * ts&#13;&#10;                    ent.y = y0 + (map_h - 1 - row) * ts&#13;&#10;                    # update stored origin too&#13;&#10;                    ent._origin = (x0, y0)&#13;&#10;                    updated += 1&#13;&#10;                else:&#13;&#10;                    # grid 정보가 없으면 이 엔티티는 무시 (재빌드를 권장)&#13;&#10;                    continue&#13;&#10;        try:&#13;&#10;            print(f&quot;apply_tile_size_to_world: applied new_tile_size={ts}, updated_entities={updated}&quot;)&#13;&#10;        except Exception:&#13;&#10;            pass&#13;&#10;&#13;&#10;    def set_tile_size(self, new_tile_size: int, world: Optional[Dict[str, list]] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Map의 기본 타일 크기를 변경합니다. 만약 `world`를 전달하면 해당 월드에 대해&#13;&#10;        가능한 경우 in-place로 크기/위치를 갱신하고, grid 정보가 부족하면 재빌드를 수행합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.tile_size = int(new_tile_size)&#13;&#10;        if world is not None:&#13;&#10;            # 먼저 시도: in-place 적용 (grid 좌표가 있는 경우)&#13;&#10;            # 검사: 모든 엔티티들이 grid 좌표를 가지고 있는지 확인&#13;&#10;            ok = True&#13;&#10;            total = 0&#13;&#10;            for layer in ['ground', 'upper_ground', 'walls']:&#13;&#10;                for ent in world.get(layer, []):&#13;&#10;                    total += 1&#13;&#10;                    if not (hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height')):&#13;&#10;                        ok = False&#13;&#10;                        break&#13;&#10;                if not ok:&#13;&#10;                    break&#13;&#10;            if ok:&#13;&#10;                try:&#13;&#10;                    self.apply_tile_size_to_world(world, self.tile_size, origin)&#13;&#10;                    print(f&quot;set_tile_size: in-place applied to {total} entities, new_tile_size={self.tile_size}&quot;)&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91mset_tile_size: in-place apply failed: {e}\033[0m&quot;)&#13;&#10;            else:&#13;&#10;                # 일부 엔티티에 grid 정보가 없으면 안전하게 재빌드&#13;&#10;                try:&#13;&#10;                    self.rebuild_into_world(world, tile_size=self.tile_size, origin=origin)&#13;&#10;                    print(f&quot;set_tile_size: rebuilt world with new_tile_size={self.tile_size}&quot;)&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91mset_tile_size: rebuild failed: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;# 간단한 자기검증 스크립트&#13;&#10;if __name__ == '__main__':&#13;&#10;    # 간단한 Room 텍스트 샘플을 메모리로 만들고 파싱 테스트&#13;&#10;    sample = '''&#13;&#10;[ground]&#13;&#10;1,1,1,0,0&#13;&#10;1,2,2,0,0&#13;&#10;&#13;&#10;[upper_ground]&#13;&#10;0,0,3,3,0&#13;&#10;&#13;&#10;[walls]&#13;&#10;0,4,0,0,0&#13;&#10;'''&#13;&#10;    import tempfile&#13;&#10;&#13;&#10;    p = tempfile.gettempdir() + os.sep + 'sample_room.txt'&#13;&#10;    with open(p, 'w', encoding='utf-8') as f:&#13;&#10;        f.write(sample)&#13;&#10;&#13;&#10;    m = Map(tile_size=128)&#13;&#10;    m.load_from_room_txt(p)&#13;&#10;    print('width,height:', m.width, m.height)&#13;&#10;    world = {k: [] for k in ['ground', 'upper_ground', 'walls', 'effects_back', 'effects_front', 'ui', 'cursor']}&#13;&#10;    m.build_into_world(world, origin=(0, 0))&#13;&#10;    for k in world:&#13;&#10;        print(k, len(world[k]))" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/title_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/title_mode.py" />
              <option name="originalContent" value="# game_logic/title_mode.py&#10;&quot;&quot;&quot;타이틀 화면 모듈&quot;&quot;&quot;&#10;&#10;import pico2d as p2&#10;import ctypes&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE, SDLK_RETURN, SDLK_SPACE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_GetMouseState, SDL_MOUSEMOTION&#10;&#10;import game_framework as framework&#10;from . import lobby_mode&#10;from .cursor import TitleCursor&#10;&#10;# 타이틀 화면 이미지&#10;title_image = None&#10;title_back_image = None&#10;&#10;# Tree 애니메이션&#10;tree_begin_images = []  # TreeBegin 애니메이션 (00~29)&#10;tree_loop_images = []   # Tree 루프 애니메이션 (00~15)&#10;animation_frame = 0&#10;animation_time = 0.0&#10;animation_fps = 12  # 초당 프레임 수&#10;is_begin_phase = True  # True: TreeBegin 재생 중, False: Tree 루프 재생 중&#10;&#10;# 스케일 팩터&#10;tree_scale = 3.0  # Tree 애니메이션 스케일&#10;title_scale = 3.0  # 타이틀 로고 스케일&#10;&#10;# 월드 레이어 (play_mode와 유사한 구조)&#10;world = {&#10;    'background': [],  # 배경 이미지&#10;    'tree_animation': [],  # Tree 애니메이션&#10;    'title': [],  # 타이틀 로고&#10;    'buttons': [],  # 메뉴 버튼들&#10;    'cursor': []  # 커서&#10;}&#10;&#10;# 배경 렌더러&#10;class BackgroundRenderer:&#10;    &quot;&quot;&quot;배경 이미지를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image):&#10;        self.image = image&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;            self.image.draw(center_x, center_y, canvas_width, canvas_height)&#10;&#10;# Tree 애니메이션 렌더러&#10;class TreeAnimationRenderer:&#10;    &quot;&quot;&quot;Tree 애니메이션을 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, begin_images, loop_images, scale):&#10;        self.begin_images = begin_images&#10;        self.loop_images = loop_images&#10;        self.scale = scale&#10;        self.current_frame = 0&#10;        self.animation_time = 0.0&#10;        self.animation_fps = 12&#10;        self.is_begin_phase = True&#10;&#10;    def update(self):&#10;        dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;        self.animation_time += dt&#10;&#10;        frame_time = 1.0 / self.animation_fps&#10;&#10;        if self.animation_time &gt;= frame_time:&#10;            self.animation_time -= frame_time&#10;&#10;            if self.is_begin_phase:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.begin_images):&#10;                    self.is_begin_phase = False&#10;                    self.current_frame = 0&#10;                    print(&quot;[title_mode] TreeBegin 완료, Tree 루프 시작&quot;)&#10;            else:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.loop_images):&#10;                    self.current_frame = 0&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        canvas_width = p2.get_canvas_width()&#10;        canvas_height = p2.get_canvas_height()&#10;        center_x = canvas_width // 2&#10;        center_y = canvas_height // 2&#10;&#10;        if self.is_begin_phase and self.begin_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.begin_images):&#10;                tree_img = self.begin_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;        elif not self.is_begin_phase and self.loop_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.loop_images):&#10;                tree_img = self.loop_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;&#10;# 타이틀 로고 렌더러&#10;class TitleRenderer:&#10;    &quot;&quot;&quot;타이틀 로고를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image, scale):&#10;        self.image = image&#10;        self.scale = scale&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;&#10;            title_width = int(self.image.w * self.scale)&#10;            title_height = int(self.image.h * self.scale)&#10;            self.image.draw(center_x, int(center_y * 0.7), title_width, title_height)&#10;&#10;# 메뉴 버튼&#10;class MenuButton:&#10;    &quot;&quot;&quot;클릭 가능한 메뉴 버튼 클래스&quot;&quot;&quot;&#10;    _font = None  # 클래스 변수로 폰트 공유&#10;&#10;    def __init__(self, text, x, y, width, height, callback):&#10;        self.text = text&#10;        self.x = x  # 중심 x 좌표&#10;        self.y = y  # 중심 y 좌표&#10;        self.width = width&#10;        self.height = height&#10;        self.callback = callback&#10;        self.hovered = False&#10;&#10;        # 폰트 로드 (최초 1회만)&#10;        if MenuButton._font is None:&#10;            try:&#10;                from pico2d import load_font&#10;                import os&#10;                # 폰트 경로 후보 (한글 지원 폰트 우선)&#10;                font_candidates = [&#10;                    'resources/Fonts/pixelroborobo.otf',&#10;                ]&#10;                for font_path in font_candidates:&#10;                    try:&#10;                        MenuButton._font = load_font(font_path, 40)  # 버튼용 폰트 크기 40으로 증가&#10;                        print(f&quot;[MenuButton] 폰트 로드 성공: {font_path}&quot;)&#10;                        break&#10;                    except Exception:&#10;                        continue&#10;            except Exception as ex:&#10;                print(f'\033[91m[MenuButton] 폰트 로드 실패: {ex}\033[0m')&#10;&#10;    def contains_point(self, px, py):&#10;        &quot;&quot;&quot;점이 버튼 내부에 있는지 확인&quot;&quot;&quot;&#10;        left = self.x - self.width // 2&#10;        right = self.x + self.width // 2&#10;        bottom = self.y - self.height // 2&#10;        top = self.y + self.height // 2&#10;        return left &lt;= px &lt;= right and bottom &lt;= py &lt;= top&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치에 따라 hover 상태 업데이트&quot;&quot;&quot;&#10;        # 마우스 위치 가져오기&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        mouse_x = mx_ptr.value&#10;        mouse_y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        self.hovered = self.contains_point(mouse_x, mouse_y)&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;버튼 그리기&quot;&quot;&quot;&#10;        # 버튼 배경 박스&#10;        if self.hovered:&#10;            # hover 상태: 밝은 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;        else:&#10;            # 일반 상태: 어두운 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;&#10;        # 텍스트 표시&#10;        if MenuButton._font:&#10;            # 텍스트 색상 (hover 상태에 따라 변경)&#10;            if self.hovered:&#10;                # hover 상태: 밝은 흰색&#10;                text_color = (255, 255, 150)&#10;                shadow_color = (0, 0, 0)&#10;            else:&#10;                # 일반 상태: 회색&#10;                text_color = (200, 200, 200)&#10;                shadow_color = (50, 50, 50)&#10;&#10;            # 그림자 효과 (가독성 향상)&#10;            MenuButton._font.draw(self.x - 2, self.y - 2, self.text, shadow_color)&#10;            MenuButton._font.draw(self.x - 1, self.y - 1, self.text, shadow_color)&#10;            # 실제 텍스트&#10;            MenuButton._font.draw(self.x, self.y, self.text, text_color)&#10;&#10;    def on_click(self):&#10;        &quot;&quot;&quot;버튼 클릭 시 콜백 실행&quot;&quot;&quot;&#10;        if self.callback:&#10;            self.callback()&#10;&#10;# 메뉴 버튼 리스트&#10;mouse_x, mouse_y = 0, 0&#10;&#10;def start_game():&#10;    &quot;&quot;&quot;게임 시작 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 시작&quot;)&#10;    import game_logic.play_mode as play_mode&#10;    import game_logic.lobby_mode as lobby_mode&#10;    framework.change_state(lobby_mode)&#10;&#10;def quit_game():&#10;    &quot;&quot;&quot;게임 종료 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 종료&quot;)&#10;    framework.quit()&#10;&#10;def enter():&#10;    &quot;&quot;&quot;타이틀 모드 진입&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images&#10;    global animation_frame, animation_time, is_begin_phase, world&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 진입&quot;)&#10;&#10;    # 월드 레이어 초기화&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    # 이미지 로드 (예외 방지)&#10;    try:&#10;        title_back_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title_Back.png')&#10;    except Exception as ex:&#10;        print(f'\033[91m[title_mode] 타이틀 배경 이미지 로드 실패: {ex}\033[0m')&#10;        title_back_image = None&#10;    try:&#10;        title_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title.png')&#10;    except Exception as ex:&#10;        print(f'\033[91m[title_mode] 타이틀 로고 이미지 로드 실패: {ex}\033[0m')&#10;        title_image = None&#10;&#10;    # Tree Begin 애니메이션 로드 (00~29)&#10;    tree_begin_images = []&#10;    for i in range(30):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_TreeBegin{i:02d}.png'&#10;        try:&#10;            tree_begin_images.append(p2.load_image(path))&#10;        except Exception as ex:&#10;            print(f'\033[91m[title_mode] TreeBegin 이미지 로드 실패: {path}, {ex}\033[0m')&#10;&#10;    # Tree 루프 애니메이션 로드 (00~15)&#10;    tree_loop_images = []&#10;    for i in range(16):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_TreeLoop{i:02d}.png'&#10;        try:&#10;            tree_loop_images.append(p2.load_image(path))&#10;        except Exception as ex:&#10;            print(f'\033[91m[title_mode] TreeLoop 이미지 로드 실패: {path}, {ex}\033[0m')&#10;&#10;    # world에 렌더러 추가&#10;    if title_back_image:&#10;        world['background'].append(BackgroundRenderer(title_back_image))&#10;    if tree_begin_images or tree_loop_images:&#10;        world['tree_animation'].append(TreeAnimationRenderer(tree_begin_images, tree_loop_images, tree_scale))&#10;    if title_image:&#10;        world['title'].append(TitleRenderer(title_image, title_scale))&#10;&#10;    # 버튼 추가&#10;    start_btn = MenuButton(&#10;        text=&quot;게임 시작&quot;,&#10;        x=p2.get_canvas_width() // 2,&#10;        y=p2.get_canvas_height() // 2 - 100,&#10;        width=300,&#10;        height=80,&#10;        callback=start_game&#10;    )&#10;    quit_btn = MenuButton(&#10;        text=&quot;게임 종료&quot;,&#10;        x=p2.get_canvas_width() // 2,&#10;        y=p2.get_canvas_height() // 2 - 200,&#10;        width=300,&#10;        height=80,&#10;        callback=quit_game&#10;    )&#10;    world['buttons'].append(start_btn)&#10;    world['buttons'].append(quit_btn)&#10;&#10;    # 커서&#10;    try:&#10;        cursor = TitleCursor()&#10;        world['cursor'].append(cursor)&#10;    except Exception as ex:&#10;        print(f'\033[91m[title_mode] 커서 생성 실패: {ex}\033[0m')&#10;&#10;    print(&quot;[title_mode] 타이틀 이미지 로드 완료&quot;)&#10;&#10;def exit():&#10;    &quot;&quot;&quot;타이틀 모드 종료&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images, world&#10;&#10;    title_image = None&#10;    title_back_image = None&#10;    tree_begin_images = []&#10;    tree_loop_images = []&#10;&#10;    # 월드 레이어 정리&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 종료&quot;)&#10;&#10;def update():&#10;    &quot;&quot;&quot;타이틀 화면 업데이트&quot;&quot;&quot;&#10;    # 모든 레이어의 객체 업데이트&#10;    for layer_name in ['background', 'tree_animation', 'title', 'buttons', 'cursor']:&#10;        layer = world.get(layer_name, [])&#10;        new_list = []&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'update'):&#10;                    keep = obj.update()&#10;                    if keep is None or keep:&#10;                        new_list.append(obj)&#10;            except Exception as ex:&#10;                print(f'\033[91m[title_mode] Update error in {layer_name}: {ex}\033[0m')&#10;                new_list.append(obj)&#10;        world[layer_name] = new_list&#10;&#10;def draw():&#10;    &quot;&quot;&quot;타이틀 화면 그리기&quot;&quot;&quot;&#10;    p2.clear_canvas()&#10;&#10;    # 레이어 순서대로 그리기&#10;    render_order = ['background', 'tree_animation', 'title', 'buttons', 'cursor']&#10;&#10;    for layer_name in render_order:&#10;        layer = world.get(layer_name, [])&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[title_mode] Draw error in {layer_name}: {ex}\033[0m')&#10;&#10;    p2.update_canvas()&#10;&#10;def handle_events():&#10;    &quot;&quot;&quot;이벤트 처리 (framework가 호출하는 함수)&quot;&quot;&quot;&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            framework.quit()&#10;        elif e.type == SDL_KEYDOWN:&#10;            if e.key == SDLK_ESCAPE:&#10;                framework.quit()&#10;            elif e.key == SDLK_RETURN or e.key == SDLK_SPACE:&#10;                # Enter 또는 Space 키를 누르면 게임 시작 (기존 동작 유지)&#10;                print(&quot;[title_mode] 게임 시작&quot;)&#10;                import game_logic.play_mode as play_mode&#10;                framework.change_state(play_mode)&#10;        elif e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                # 마우스 클릭 시 버튼 체크&#10;                for button in world.get('buttons', []):&#10;                    if button.hovered:&#10;                        button.on_click()&#10;                        break&#10;&#10;        # 커서에 이벤트 전달 (클릭 애니메이션 처리)&#10;        for cursor in world.get('cursor', []):&#10;            try:&#10;                if hasattr(cursor, 'handle_event'):&#10;                    cursor.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[title_mode] Cursor handle_event error: {e}\033[0m')&#10;&#10;def pause():&#10;    &quot;&quot;&quot;타이틀 모드 일시 정지&quot;&quot;&quot;&#10;    pass&#10;&#10;def resume():&#10;    &quot;&quot;&quot;타이틀 모드 재개&quot;&quot;&quot;&#10;    pass&#10;" />
              <option name="updatedContent" value="# game_logic/title_mode.py&#10;&quot;&quot;&quot;타이틀 화면 모듈&quot;&quot;&quot;&#10;&#10;import pico2d as p2&#10;import ctypes&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE, SDLK_RETURN, SDLK_SPACE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_GetMouseState, SDL_MOUSEMOTION&#10;&#10;import game_framework as framework&#10;from . import lobby_mode&#10;from .cursor import TitleCursor&#10;&#10;# 타이틀 화면 이미지&#10;title_image = None&#10;title_back_image = None&#10;&#10;# Tree 애니메이션&#10;tree_begin_images = []  # TreeBegin 애니메이션 (00~29)&#10;tree_loop_images = []   # Tree 루프 애니메이션 (00~15)&#10;animation_frame = 0&#10;animation_time = 0.0&#10;animation_fps = 12  # 초당 프레임 수&#10;is_begin_phase = True  # True: TreeBegin 재생 중, False: Tree 루프 재생 중&#10;&#10;# 스케일 팩터&#10;tree_scale = 3.0  # Tree 애니메이션 스케일&#10;title_scale = 3.0  # 타이틀 로고 스케일&#10;&#10;# 월드 레이어 (play_mode와 유사한 구조)&#10;world = {&#10;    'background': [],  # 배경 이미지&#10;    'tree_animation': [],  # Tree 애니메이션&#10;    'title': [],  # 타이틀 로고&#10;    'buttons': [],  # 메뉴 버튼들&#10;    'cursor': []  # 커서&#10;}&#10;&#10;# 배경 렌더러&#10;class BackgroundRenderer:&#10;    &quot;&quot;&quot;배경 이미지를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image):&#10;        self.image = image&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;            self.image.draw(center_x, center_y, canvas_width, canvas_height)&#10;&#10;# Tree 애니메이션 렌더러&#10;class TreeAnimationRenderer:&#10;    &quot;&quot;&quot;Tree 애니메이션을 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, begin_images, loop_images, scale):&#10;        self.begin_images = begin_images&#10;        self.loop_images = loop_images&#10;        self.scale = scale&#10;        self.current_frame = 0&#10;        self.animation_time = 0.0&#10;        self.animation_fps = 12&#10;        self.is_begin_phase = True&#10;&#10;    def update(self):&#10;        dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;        self.animation_time += dt&#10;&#10;        frame_time = 1.0 / self.animation_fps&#10;&#10;        if self.animation_time &gt;= frame_time:&#10;            self.animation_time -= frame_time&#10;&#10;            if self.is_begin_phase:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.begin_images):&#10;                    self.is_begin_phase = False&#10;                    self.current_frame = 0&#10;                    print(&quot;[title_mode] TreeBegin 완료, Tree 루프 시작&quot;)&#10;            else:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.loop_images):&#10;                    self.current_frame = 0&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        canvas_width = p2.get_canvas_width()&#10;        canvas_height = p2.get_canvas_height()&#10;        center_x = canvas_width // 2&#10;        center_y = canvas_height // 2&#10;&#10;        if self.is_begin_phase and self.begin_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.begin_images):&#10;                tree_img = self.begin_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;        elif not self.is_begin_phase and self.loop_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.loop_images):&#10;                tree_img = self.loop_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;&#10;# 타이틀 로고 렌더러&#10;class TitleRenderer:&#10;    &quot;&quot;&quot;타이틀 로고를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image, scale):&#10;        self.image = image&#10;        self.scale = scale&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;&#10;            title_width = int(self.image.w * self.scale)&#10;            title_height = int(self.image.h * self.scale)&#10;            self.image.draw(center_x, int(center_y * 0.7), title_width, title_height)&#10;&#10;# 메뉴 버튼&#10;class MenuButton:&#10;    &quot;&quot;&quot;클릭 가능한 메뉴 버튼 클래스&quot;&quot;&quot;&#10;    _font = None  # 클래스 변수로 폰트 공유&#10;&#10;    def __init__(self, text, x, y, width, height, callback):&#10;        self.text = text&#10;        self.x = x  # 중심 x 좌표&#10;        self.y = y  # 중심 y 좌표&#10;        self.width = width&#10;        self.height = height&#10;        self.callback = callback&#10;        self.hovered = False&#10;&#10;        # 폰트 로드 (최초 1회만)&#10;        if MenuButton._font is None:&#10;            try:&#10;                from pico2d import load_font&#10;                import os&#10;                # 폰트 경로 후보 (한글 지원 폰트 우선)&#10;                font_candidates = [&#10;                    'resources/Fonts/pixelroborobo.otf',&#10;                ]&#10;                for font_path in font_candidates:&#10;                    try:&#10;                        MenuButton._font = load_font(font_path, 40)  # 버튼용 폰트 크기 40으로 증가&#10;                        print(f&quot;[MenuButton] 폰트 로드 성공: {font_path}&quot;)&#10;                        break&#10;                    except Exception:&#10;                        continue&#10;            except Exception as ex:&#10;                print(f'\033[91m[MenuButton] 폰트 로드 실패: {ex}\033[0m')&#10;&#10;    def contains_point(self, px, py):&#10;        &quot;&quot;&quot;점이 버튼 내부에 있는지 확인&quot;&quot;&quot;&#10;        left = self.x - self.width // 2&#10;        right = self.x + self.width // 2&#10;        bottom = self.y - self.height // 2&#10;        top = self.y + self.height // 2&#10;        return left &lt;= px &lt;= right and bottom &lt;= py &lt;= top&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치에 따라 hover 상태 업데이트&quot;&quot;&quot;&#10;        # 마우스 위치 가져오기&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        mouse_x = mx_ptr.value&#10;        mouse_y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        self.hovered = self.contains_point(mouse_x, mouse_y)&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;버튼 그리기&quot;&quot;&quot;&#10;        # 버튼 배경 박스&#10;        if self.hovered:&#10;            # hover 상태: 밝은 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;        else:&#10;            # 일반 상태: 어두운 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;&#10;        # 텍스트 표시&#10;        if MenuButton._font:&#10;            # 텍스트 색상 (hover 상태에 따라 변경)&#10;            if self.hovered:&#10;                # hover 상태: 밝은 흰색&#10;                text_color = (255, 255, 150)&#10;                shadow_color = (0, 0, 0)&#10;            else:&#10;                # 일반 상태: 회색&#10;                text_color = (200, 200, 200)&#10;                shadow_color = (50, 50, 50)&#10;&#10;            # 그림자 효과 (가독성 향상)&#10;            MenuButton._font.draw(self.x - 2, self.y - 2, self.text, shadow_color)&#10;            MenuButton._font.draw(self.x - 1, self.y - 1, self.text, shadow_color)&#10;            # 실제 텍스트&#10;            MenuButton._font.draw(self.x, self.y, self.text, text_color)&#10;&#10;    def on_click(self):&#10;        &quot;&quot;&quot;버튼 클릭 시 콜백 실행&quot;&quot;&quot;&#10;        if self.callback:&#10;            self.callback()&#10;&#10;# 메뉴 버튼 리스트&#10;mouse_x, mouse_y = 0, 0&#10;&#10;def start_game():&#10;    &quot;&quot;&quot;게임 시작 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 시작&quot;)&#10;    import game_logic.play_mode as play_mode&#10;    import game_logic.lobby_mode as lobby_mode&#10;    framework.change_state(lobby_mode)&#10;&#10;def quit_game():&#10;    &quot;&quot;&quot;게임 종료 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 종료&quot;)&#10;    framework.quit()&#10;&#10;def enter():&#10;    &quot;&quot;&quot;타이틀 모드 진입&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images&#10;    global animation_frame, animation_time, is_begin_phase, world&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 진입&quot;)&#10;&#10;    # 월드 레이어 초기화&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    # 이미지 로드 (예외 방지)&#10;    try:&#10;        title_back_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title_Back.png')&#10;    except Exception as ex:&#10;        print(f'\033[91m[title_mode] 타이틀 배경 이미지 로드 실패: {ex}\033[0m')&#10;        title_back_image = None&#10;    try:&#10;        title_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title.png')&#10;    except Exception as ex:&#10;        print(f'\033[91m[title_mode] 타이틀 로고 이미지 로드 실패: {ex}\033[0m')&#10;        title_image = None&#10;&#10;    # Tree Begin 애니메이션 로드 (00~29)&#10;    tree_begin_images = []&#10;    for i in range(30):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_TreeBegin{i:02d}.png'&#10;        try:&#10;            tree_begin_images.append(p2.load_image(path))&#10;        except Exception as ex:&#10;            print(f'\033[91m[title_mode] TreeBegin 이미지 로드 실패: {path}, {ex}\033[0m')&#10;&#10;    # Tree 루프 애니메이션 로드 (00~15)&#10;    tree_loop_images = []&#10;    for i in range(16):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_TreeLoop{i:02d}.png'&#10;        try:&#10;            tree_loop_images.append(p2.load_image(path))&#10;        except Exception as ex:&#10;            print(f'\033[91m[title_mode] TreeLoop 이미지 로드 실패: {path}, {ex}\033[0m')&#10;&#10;    # world에 렌더러 추가&#10;    if title_back_image:&#10;        world['background'].append(BackgroundRenderer(title_back_image))&#10;    if tree_begin_images or tree_loop_images:&#10;        world['tree_animation'].append(TreeAnimationRenderer(tree_begin_images, tree_loop_images, tree_scale))&#10;    if title_image:&#10;        world['title'].append(TitleRenderer(title_image, title_scale))&#10;&#10;    # 버튼 추가&#10;    start_btn = MenuButton(&#10;        text=&quot;게임 시작&quot;,&#10;        x=p2.get_canvas_width() // 2,&#10;        y=p2.get_canvas_height() // 2 - 100,&#10;        width=300,&#10;        height=80,&#10;        callback=start_game&#10;    )&#10;    quit_btn = MenuButton(&#10;        text=&quot;게임 종료&quot;,&#10;        x=p2.get_canvas_width() // 2,&#10;        y=p2.get_canvas_height() // 2 - 200,&#10;        width=300,&#10;        height=80,&#10;        callback=quit_game&#10;    )&#10;    world['buttons'].append(start_btn)&#10;    world['buttons'].append(quit_btn)&#10;&#10;    # 커서&#10;    try:&#10;        cursor = TitleCursor()&#10;        world['cursor'].append(cursor)&#10;    except Exception as ex:&#10;        print(f'\033[91m[title_mode] 커서 생성 실패: {ex}\033[0m')&#10;&#10;    print(&quot;[title_mode] 타이틀 이미지 로드 완료&quot;)&#10;&#10;def exit():&#10;    &quot;&quot;&quot;타이틀 모드 종료&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images, world&#10;&#10;    title_image = None&#10;    title_back_image = None&#10;    tree_begin_images = []&#10;    tree_loop_images = []&#10;&#10;    # 월드 레이어 정리&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 종료&quot;)&#10;&#10;def update():&#10;    &quot;&quot;&quot;타이틀 화면 업데이트&quot;&quot;&quot;&#10;    # 모든 레이어의 객체 업데이트&#10;    for layer_name in ['background', 'tree_animation', 'title', 'buttons', 'cursor']:&#10;        layer = world.get(layer_name, [])&#10;        new_list = []&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'update'):&#10;                    keep = obj.update()&#10;                    if keep is None or keep:&#10;                        new_list.append(obj)&#10;            except Exception as ex:&#10;                print(f'\033[91m[title_mode] Update error in {layer_name}: {ex}\033[0m')&#10;                new_list.append(obj)&#10;        world[layer_name] = new_list&#10;&#10;def draw():&#10;    &quot;&quot;&quot;타이틀 화면 그리기&quot;&quot;&quot;&#10;    p2.clear_canvas()&#10;&#10;    # 레이어 순서대로 그리기&#10;    render_order = ['background', 'tree_animation', 'title', 'buttons', 'cursor']&#10;&#10;    for layer_name in render_order:&#10;        layer = world.get(layer_name, [])&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[title_mode] Draw error in {layer_name}: {ex}\033[0m')&#10;&#10;    p2.update_canvas()&#10;&#10;def handle_events():&#10;    &quot;&quot;&quot;이벤트 처리 (framework가 호출하는 함수)&quot;&quot;&quot;&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            framework.quit()&#10;        elif e.type == SDL_KEYDOWN:&#10;            if e.key == SDLK_ESCAPE:&#10;                framework.quit()&#10;            elif e.key == SDLK_RETURN or e.key == SDLK_SPACE:&#10;                # Enter 또는 Space 키를 누르면 게임 시작 (기존 동작 유지)&#10;                print(&quot;[title_mode] 게임 시작&quot;)&#10;                import game_logic.play_mode as play_mode&#10;                framework.change_state(play_mode)&#10;        elif e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                # 마우스 클릭 시 버튼 체크&#10;                for button in world.get('buttons', []):&#10;                    if button.hovered:&#10;                        button.on_click()&#10;                        break&#10;&#10;        # 커서에 이벤트 전달 (클릭 애니메이션 처리)&#10;        for cursor in world.get('cursor', []):&#10;            try:&#10;                if hasattr(cursor, 'handle_event'):&#10;                    cursor.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[title_mode] Cursor handle_event error: {e}\033[0m')&#10;&#10;def pause():&#10;    &quot;&quot;&quot;타이틀 모드 일시 정지&quot;&quot;&quot;&#10;    pass&#10;&#10;def resume():&#10;    &quot;&quot;&quot;타이틀 모드 재개&quot;&quot;&quot;&#10;    pass" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>