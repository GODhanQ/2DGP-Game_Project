<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game_logic/cursor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/cursor.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False&#10;" />
              <option name="updatedContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/monsters/panther_assassin.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/monsters/panther_assassin.py" />
              <option name="originalContent" value="import pico2d as p2&#10;import math&#10;import random&#10;import game_framework as framework&#10;from ..behavior_tree import BehaviorTree, Selector, Sequence, Action, Condition, RandomSelector&#10;from ..projectile import Projectile&#10;from .. import image_asset_manager as iam&#10;from ..damage_indicator import DamageIndicator&#10;from ..ui_overlay import MonsterHealthBar&#10;&#10;# ==================== 공격 패턴 클래스 참조 ====================&#10;from .Boss_Logic.panther_assassin_1pattern import AttackPattern1Action&#10;from .Boss_Logic.panther_assassin_2pattern import AttackPattern2Action&#10;from .Boss_Logic.panther_assassin_3pattern import AttackPattern3Action&#10;from .Boss_Logic.panther_assassin_4pattern import AttackPattern4Action&#10;from .Boss_Logic.panther_assassin_5pattern import AttackPattern5Action&#10;from .Boss_Logic.panther_assassin_6pattern import AttackPattern6Action&#10;&#10;# ==================== BT Action Wrapper 클래스 ====================&#10;&#10;class BTActionWrapper(Action):&#10;    &quot;&quot;&quot;&#10;    BT Action Wrapper 클래스&#10;&#10;    행동 트리의 Action 노드가 패턴 클래스의 update() 메서드를 호출할 수 있도록&#10;    래핑하는 헬퍼 클래스입니다.&#10;&#10;    사용 목적:&#10;    - BT 프레임워크는 Action 노드를 인자 없이 호출하는 구조&#10;    - 패턴 클래스는 인스턴스 메서드로 상태를 관리&#10;    - 이 래퍼가 둘 사이의 다리 역할을 수행&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, name, action_instance):&#10;        &quot;&quot;&quot;&#10;        BTActionWrapper 초기화&#10;&#10;        Args:&#10;            name: 노드 이름 (디버깅용)&#10;            action_instance: 실제 패턴 Action 클래스의 인스턴스&#10;                            (예: AttackPattern1Action의 인스턴스)&#10;        &quot;&quot;&quot;&#10;        self.name = name&#10;        self.action_instance = action_instance&#10;        self.value = BehaviorTree.UNDEF&#10;        self.has_condition = False&#10;&#10;    def tag_condition(self):&#10;        &quot;&quot;&quot;Action 노드는 조건 노드가 아님&quot;&quot;&quot;&#10;        self.has_condition = False&#10;&#10;    def reset(self):&#10;        &quot;&quot;&quot;노드 상태 초기화&quot;&quot;&quot;&#10;        self.value = BehaviorTree.UNDEF&#10;&#10;    def add_child(self, child, probability=1.0):&#10;        &quot;&quot;&quot;Leaf 노드에는 자식을 추가할 수 없음&quot;&quot;&quot;&#10;        print(&quot;ERROR: you cannot add child node to leaf node&quot;)&#10;&#10;    def add_children(self, *children):&#10;        &quot;&quot;&quot;Leaf 노드에는 자식을 추가할 수 없음&quot;&quot;&quot;&#10;        print(&quot;ERROR: you cannot add children node to leaf node&quot;)&#10;&#10;    def run(self):&#10;        &quot;&quot;&quot;&#10;        Action 실행: 패턴 인스턴스의 update() 메서드 호출&#10;&#10;        Returns:&#10;            BehaviorTree.SUCCESS, BehaviorTree.RUNNING, 또는 BehaviorTree.FAIL&#10;        &quot;&quot;&quot;&#10;        # 현재 실행 중인 패턴 인스턴스를 PantherAssassin에 저장&#10;        # 이를 통해 PantherAssassin.draw()에서 패턴의 draw() 메서드를 호출할 수 있음&#10;        self.action_instance.panther.current_action_instance = self.action_instance&#10;&#10;        self.value = self.action_instance.update()&#10;        return self.value&#10;&#10;# ==================== PantherAssassin 보스 클래스 ====================&#10;&#10;class PantherAssassin:&#10;    &quot;&quot;&quot;&#10;    팬서 암살자 보스 몬스터&#10;&#10;    특징:&#10;    - 6가지 공격 패턴을 랜덤하게 사용&#10;    - 행동 트리 기반 AI&#10;    - 높은 체력과 공격력&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, x, y):&#10;        &quot;&quot;&quot;&#10;        PantherAssassin 초기화&#10;&#10;        Args:&#10;            x, y: 스폰 위치&#10;        &quot;&quot;&quot;&#10;        # 위치 및 기본 속성&#10;        self.x = x&#10;        self.y = y&#10;        self.spawn_x = x  # 스폰 위치 기억&#10;        self.spawn_y = y&#10;&#10;        # 스탯&#10;        from ..stats import PantherAssassinStats&#10;        self.stats = PantherAssassinStats()&#10;&#10;        # 애니메이션&#10;        self.frame = 0&#10;        self.frame_timer = 0.0&#10;        self.frame_speed = 15.0  # 초당 프레임 수&#10;        self.scale_factor = 4.0&#10;        self.animation_frames = 11 # 애니메이션 프레임 수&#10;&#10;        # 충돌 박스&#10;        self.collision_width = 24 * self.scale_factor&#10;        self.collision_height = 26 * self.scale_factor&#10;        self.collision_box_offset_x = 0&#10;        self.collision_box_offset_y = -10 * self.scale_factor&#10;&#10;        # 타겟 (플레이어)&#10;        self.target = None&#10;&#10;        # 월드 참조 (투사체 생성을 위해)&#10;        from ..play_mode import world&#10;        self.world = world&#10;&#10;        # 투사체 관리 (보스 전용 투사체 리스트)&#10;        self.projectiles = []&#10;&#10;        # 공격 관련&#10;        self.recognition_distance = 400 # 플레이어 인식 거리&#10;        self.unrecognition_distance = 800 # 플레이어 미인식 거리&#10;        self.attack_range = 800  # 공격 범위 (추가)&#10;        self.attack_cooldown = 2.0  # 공격 쿨타임 (초)&#10;        self.attack_timer = 0.0  # 현재 쿨타임 타이머&#10;&#10;        # 무적시간 관련 변수 (피격 판정 중복 방지)&#10;        self.invincible = False&#10;        self.invincible_timer = 0.0&#10;        self.invincible_duration = 0.3  # 무적 지속 시간 (초)&#10;&#10;        # 제거 플래그&#10;        self.mark_for_removal = False&#10;&#10;        # 체력바 UI&#10;        self.health_bar = MonsterHealthBar(self)&#10;&#10;        # 현재 실행 중인 공격 패턴 인스턴스 (드로잉 책임 위임용)&#10;        self.current_action_instance = None&#10;&#10;        # 6가지 공격 패턴 클래스 인스턴스 생성&#10;        self.pattern1_action = AttackPattern1Action(self)&#10;        self.pattern2_action = AttackPattern2Action(self)&#10;        self.pattern3_action = AttackPattern3Action(self)&#10;        self.pattern4_action = AttackPattern4Action(self)&#10;        self.pattern5_action = AttackPattern5Action(self)&#10;        self.pattern6_action = AttackPattern6Action(self)&#10;&#10;        # 임시 스프라이트 (실제 게임에서는 이미지 로드)&#10;        # 일반적으로 Idle 애니메이션 스프라이트 시트 사용&#10;        # 사망시 Death 애니메이션 스프라이트 시트 사용&#10;        self.images = None&#10;        self.clone_images = None&#10;&#10;        # 사망 애니메이션 관련 변수&#10;        self.is_dead = False&#10;        self.death_images = None&#10;        self.death_frame = 0&#10;        self.death_frame_timer = 0.0&#10;        self.death_frame_speed = 5.0  # 초당 프레임 수&#10;        self.death_animation_frames = 16  # 0~15 총 16개 프레임&#10;&#10;        try:&#10;            # Idle 애니메이션 로드&#10;            for i in range(self.animation_frames):&#10;                try:&#10;                    img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_Idle{i:02d}.png'&#10;                    img = p2.load_image(img_path)&#10;                    if self.images is None:&#10;                        self.images = []&#10;                    self.images.append(img)&#10;&#10;                    # 경로 등록 후 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    if self.clone_images is None:&#10;                        self.clone_images = []&#10;                    self.clone_images.append(clone_img)&#10;&#10;                    # DEBUG: 이미지 로드 확인&#10;                    # print(f'[PantherAssassin] 이미지 로드 성공: PantherAssassin_Idle{i:02d}.png')&#10;&#10;                except FileNotFoundError as e:&#10;                    print(f'\033[91m[PantherAssassin] 이미지 로드 실패: {e}\033[0m')&#10;&#10;            # Death 애니메이션 로드 (0~15)&#10;            self.death_images = []&#10;&#10;            for i in range(3):&#10;                try:&#10;                    Airborne_img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_Airborne{i:02d}.png'&#10;                    Airborne_img = p2.load_image(Airborne_img_path)&#10;                    self.death_images.append(Airborne_img)&#10;                    # print(f'[PantherAssassin] 사망 애니메이션 로드 성공: PantherAssassin_Knockback{i:02d}.png')&#10;                except FileNotFoundError as e:&#10;                    print(f'\033[91m[PantherAssassin] 사망 애니메이션 로드 실패: {e}\033[0m')&#10;&#10;            for i in range(self.death_animation_frames):&#10;                try:&#10;                    death_img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_TrueDie{i:02d}.png'&#10;                    death_img = p2.load_image(death_img_path)&#10;                    self.death_images.append(death_img)&#10;                    # print(f'[PantherAssassin] 사망 애니메이션 로드 성공: PantherAssassin_TrueDie{i:02d}.png')&#10;                except FileNotFoundError as e:&#10;                    print(f'\033[91m[PantherAssassin] 사망 애니메이션 로드 실패: {e}\033[0m')&#10;&#10;        except Exception as e:&#10;            print(f'\033[91m[PantherAssassin] 이미지 로드 중 오류 발생: {e}\033[0m')&#10;&#10;        # 행동 트리 빌드&#10;        self.build_behavior_tree()&#10;&#10;        print(f&quot;[PantherAssassin] 생성됨 at ({x}, {y})&quot;)&#10;&#10;    def build_behavior_tree(self):&#10;        &quot;&quot;&quot;&#10;        행동 트리 구축&#10;&#10;        구조:&#10;        Root Selector&#10;        ├── Attack Sequence (공격 시도)&#10;        │   ├── Condition: 쿨타임 준비됨&#10;        │   ├── Condition: 공격 범위 내&#10;        │   └── RandomSelector: 6가지 패턴 중 랜덤 선택&#10;        │       ├── BTActionWrapper: 패턴1 - 120도 방사형으로 플레이어를 향해 2단 표창 투척&#10;        │       ├── BTActionWrapper: 패턴2 - 은신 후 다른 곳에서 나타나 플레이어를 향해 강한 돌진 공격 2회&#10;        │       ├── BTActionWrapper: 패턴3 - 3단 콤보 공격&#10;        │       │   # 그림자 분신과 함게하는 패턴 4, 5, 6&#10;        │       ├── BTActionWrapper: 패턴4 - 은신과 분신 2체를 랜덤 위치에 소환 후 플레이어를 향해 수리검 10회 연속 투척 이후 본체 은신 풀림&#10;        │       ├── BTActionWrapper: 패턴5 - 분신 1체 랜덤 위치에 소환후 모든 방향 방사형으로 수리검 투척 2회 ( 두 번째 투척 수리검의 속도는 첫 번째 투척 속도의 반 )&#10;        │       └── BTActionWrapper: 패턴6 - 분신 2체 램덤 위치에 소환후 본체, 분신 2체 번갈아 가며 플레이어를 향해 수리검 5개 방사형으로 3회씩 투척&#10;        └── Action: 대기 ( Idle )&#10;&#10;        ★ 핵심: BTActionWrapper를 사용하여 패턴 클래스 인스턴스를 BT에 연결&#10;        &quot;&quot;&quot;&#10;&#10;        # 6가지 공격 패턴을 RandomSelector로 구성&#10;        # BTActionWrapper를 사용하여 패턴 클래스 인스턴스를 감쌈&#10;        attack_pattern_selector = RandomSelector(&#10;            &quot;Random Attack Pattern&quot;,&#10;            # BTActionWrapper(&quot;Pattern1: ThrowingStars&quot;, self.pattern1_action),&#10;            # BTActionWrapper(&quot;Pattern2: DashAttack&quot;, self.pattern2_action),&#10;            # BTActionWrapper(&quot;Pattern3: ComboAttack&quot;, self.pattern3_action),&#10;            # BTActionWrapper(&quot;Pattern4: Teleport&quot;, self.pattern4_action),&#10;            # BTActionWrapper(&quot;Pattern5: Whirlwind&quot;, self.pattern5_action),&#10;            BTActionWrapper(&quot;Pattern6: Shadow Clone&quot;, self.pattern6_action)&#10;        )&#10;&#10;        # 공격 시퀀스: 쿨타임 체크 -&gt; 범위 체크 -&gt; 패턴 실행&#10;        attack_sequence = Sequence(&#10;            &quot;Try Attack&quot;,&#10;            Condition(&quot;Attack Ready&quot;, self.is_attack_ready),&#10;            Condition(&quot;In Attack Range&quot;, self.is_in_attack_range),&#10;            attack_pattern_selector&#10;        )&#10;&#10;        # 루트 셀렉터: 공격 가능하면 공격, 아니면 대기/순찰&#10;        root = Selector(&#10;            &quot;Root&quot;,&#10;            attack_sequence,&#10;            Action(&quot;Idle or Patrol&quot;, self.handle_idle_action)&#10;        )&#10;&#10;        # 행동 트리 생성&#10;        self.behavior_tree = BehaviorTree(root)&#10;        print(&quot;[PantherAssassin] 행동 트리 빌드 완료 (BTActionWrapper 적용 완료)&quot;)&#10;&#10;    # ==================== 조건 체크 메서드 ====================&#10;&#10;    def is_attack_ready(self):&#10;        &quot;&quot;&quot;공격 쿨타임이 준비되었는지 확인&quot;&quot;&quot;&#10;        return self.attack_timer &lt;= 0.0&#10;&#10;    def is_in_attack_range(self):&#10;        &quot;&quot;&quot;타겟이 공격 범위 내에 있는지 확인&quot;&quot;&quot;&#10;        if self.target is None:&#10;            return False&#10;&#10;        dx = self.target.x - self.x&#10;        dy = self.target.y - self.y&#10;        distance = math.sqrt(dx**2 + dy**2)&#10;&#10;        return distance &lt;= self.attack_range&#10;&#10;    # ==================== 행동 액션 메서드 ====================&#10;&#10;    def handle_idle_action(self):&#10;        &quot;&quot;&quot;&#10;        대기 행동&#10;&#10;        PantherAssassin은 패턴 기반 보스이므로 플레이어를 추적하지 않고&#10;        제자리에서 대기합니다.&#10;        &quot;&quot;&quot;&#10;        # 플레이어 추적 로직 제거 - 패턴으로만 위치 이동&#10;        return BehaviorTree.SUCCESS&#10;&#10;    # ==================== 업데이트 &amp; 렌더링 ====================&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;매 프레임 업데이트&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 사망 상태일 경우 사망 애니메이션만 재생&#10;        if self.is_dead:&#10;            self.death_frame_timer += dt&#10;            if self.death_frame_timer &gt;= 1.0 / self.death_frame_speed:&#10;                self.death_frame += 1&#10;                self.death_frame_timer = 0.0&#10;&#10;                # 사망 애니메이션이 끝나면 (0~15 프레임 완료)&#10;                if self.death_frame &gt;= self.death_animation_frames:&#10;                    print(&quot;[PantherAssassin] 사망 애니메이션 완료 - 제거&quot;)&#10;                    self.mark_for_removal = True&#10;            return  # 사망 애니메이션 진행 중 - 아무것도 반환하지 않음&#10;&#10;        # 무적시간 업데이트&#10;        if self.invincible:&#10;            self.invincible_timer -= dt&#10;            if self.invincible_timer &lt;= 0:&#10;                self.invincible = False&#10;                self.invincible_timer = 0.0&#10;&#10;        # 쿨타임 업데이트&#10;        if self.attack_timer &gt; 0:&#10;            self.attack_timer -= dt&#10;&#10;        # 애니메이션 프레임 업데이트&#10;        self.frame_timer += dt&#10;        if self.frame_timer &gt;= 1.0 / self.frame_speed:&#10;            # 이미지가 로드되었을 때만 프레임 업데이트&#10;            if self.images and len(self.images) &gt; 0:&#10;                self.frame = (self.frame + 1) % len(self.images)&#10;            else:&#10;                self.frame = 0&#10;            self.frame_timer = 0.0&#10;&#10;        # 플레이어 인식 거리 체크 (target이 None일 때 예외 처리)&#10;        if self.target is not None:&#10;            dx = self.target.x - self.x&#10;            dy = self.target.y - self.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            # 인식 거리를 벗어나면 타겟 해제&#10;            if distance &gt;= self.unrecognition_distance:&#10;                self.set_target(None)&#10;                print(f'[PantherAssassin] 타겟 상실 (거리: {distance:.1f})')&#10;        else:&#10;            # 타겟이 없을 때 플레이어 탐색&#10;            if self.world and 'player' in self.world:&#10;                player = self.world['player']&#10;                dx = player.x - self.x&#10;                dy = player.y - self.y&#10;                distance = math.sqrt(dx**2 + dy**2)&#10;&#10;                # 인식 거리 내에 들어오면 타겟 설정&#10;                if distance &lt;= self.recognition_distance:&#10;                    self.set_target(player)&#10;                    print(f'[PantherAssassin] 타겟 인식: 플레이어 at ({player.x}, {player.y}), 거리: {distance:.1f}')&#10;&#10;        # 투사체 업데이트 (보스 전용 투사체 관리)&#10;        self.projectiles = [proj for proj in self.projectiles if proj.update()]&#10;&#10;        # 행동 트리 실행&#10;        if self.behavior_tree:&#10;            self.behavior_tree.run()&#10;&#10;&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        몬스터 렌더링&#10;&#10;        렌더링 우선순위:&#10;        1. 사망 상태일 경우 사망 애니메이션 출력&#10;        2. 패턴 공격 중이면 패턴 전용 모션 출력 (IDLE 모션 숨김)&#10;        3. 패턴 공격이 아니면 IDLE 모션 출력&#10;&#10;        일반적 Hit 일땐 대미지만 적용, (hit 판정의 이미지 시퀀스 x )&#10;        Death 상태 일땐 현재 이미지 시퀀스를 Death 이미지로 교체 후 재생&#10;        1. Hit 판정시 이미지 시퀀스 교체 없이 대미지만 적용&#10;        2. Death 판정시 이미지 시퀀스를 Death 이미지로 교체&#10;        3. Death 이미지 시퀀스 재생 완료 후 몬스터 제거&#10;&#10;        TODO: 1. 몬스터 사망 후 아이템 드랍 구현&#10;        &quot;&quot;&quot;&#10;        # 사망 상태일 경우 사망 애니메이션 출력&#10;        if self.is_dead:&#10;            if self.death_images and len(self.death_images) &gt; 0:&#10;                # 사망 프레임 인덱스가 범위를 벗어나지 않도록 보정&#10;                death_frame_idx = min(self.death_frame, len(self.death_images) - 1)&#10;                death_img = self.death_images[death_frame_idx]&#10;                if death_img:&#10;                    death_img.draw(draw_x, draw_y, death_img.w * self.scale_factor, death_img.h * self.scale_factor)&#10;            return  # 사망 애니메이션 출력 후 나머지는 렌더링하지 않음&#10;&#10;        # 현재 실행 중인 패턴이 있는지 확인&#10;        has_active_pattern = (self.current_action_instance is not None and&#10;                             hasattr(self.current_action_instance, 'phase') and&#10;                             self.current_action_instance.phase &gt; 0)&#10;&#10;        # 패턴 5 실행 중일 때 특별 처리: Phase 1(분신 이동), Phase 6(분신 소멸)에서는 IDLE 모션 표시&#10;        should_show_idle = False&#10;        if (has_active_pattern and&#10;            self.current_action_instance == self.pattern5_action and&#10;            hasattr(self.current_action_instance, 'phase')):&#10;            # Phase 1: 분신 이동 중 - IDLE 모션 표시&#10;            # Phase 6: 분신 소멸 중 - IDLE 모션 표시&#10;            if self.current_action_instance.phase in [1, 6]:&#10;                should_show_idle = True&#10;&#10;        # 패턴 6 실행 중일 때 특별 처리: Phase 1(분신 이동), Phase 4(분신 소멸)에서는 IDLE 모션 표시&#10;        if (has_active_pattern and&#10;            self.current_action_instance == self.pattern6_action and&#10;            hasattr(self.current_action_instance, 'phase')):&#10;            # Phase 1: 분신 이동 중 - IDLE 모션 표시&#10;            # Phase 4: 분신 소멸 중 - IDLE 모션 표시&#10;            if self.current_action_instance.phase in [1, 4]:&#10;                should_show_idle = True&#10;&#10;        # 패턴 4 실행 중일 때는 패턴의 draw() 메서드로 본체 그리기&#10;        if (has_active_pattern and&#10;            self.current_action_instance == self.pattern4_action and&#10;            hasattr(self.current_action_instance, 'draw')):&#10;            # 패턴 4의 draw() 메서드 호출 (은신/해제 애니메이션 처리)&#10;            self.current_action_instance.draw(draw_x, draw_y)&#10;&#10;        # 패턴 5의 특정 phase 또는 패턴 공격 중이 아닐 때 IDLE 모션 드로잉&#10;        elif not has_active_pattern or should_show_idle:&#10;            if self.images and len(self.images) &gt; 0:&#10;                # 프레임 인덱스가 범위를 벗어나지 않도록 보정&#10;                if self.frame &gt;= len(self.images):&#10;                    self.frame = 0&#10;&#10;                img = self.images[self.frame]&#10;                img.draw(draw_x, draw_y, img.w * self.scale_factor, img.h * self.scale_factor)&#10;            else:&#10;                # 디버그 렌더링 (이미지 없을 때)&#10;                p2.draw_rectangle(&#10;                    self.x - self.collision_width / 2,&#10;                    self.y - self.collision_height / 2,&#10;                    self.x + self.collision_width / 2,&#10;                    self.y + self.collision_height / 2&#10;                )&#10;&#10;        # 현재 실행 중인 패턴 인스턴스의 이펙트 드로잉 (드로잉 책임 위임)&#10;        # 패턴이 활성화되어 있으면 패턴의 draw 메서드가 캐릭터 모션과 이펙트를 모두 그림&#10;        # 단, 패턴 5의 Phase 1, 6은 제외 (IDLE 모션만 표시)&#10;        if self.current_action_instance is not None and not should_show_idle:&#10;            # 패턴 인스턴스가 draw 메서드를 가지고 있는지 확인 후 호출&#10;            if hasattr(self.current_action_instance, 'draw'):&#10;                self.current_action_instance.draw(draw_x, draw_y)&#10;&#10;        # 보스 전용 투사체 드로잉 (카메라 좌표 변환 적용)&#10;        for projectile in self.projectiles:&#10;            # 투사체의 월드 좌표를 카메라 좌표로 변환&#10;            proj_draw_x = projectile.x - self.x + draw_x&#10;            proj_draw_y = projectile.y - self.y + draw_y&#10;            projectile.draw(proj_draw_x, proj_draw_y)&#10;&#10;        # 체력바 렌더링 (카메라 좌표 적용)&#10;        self.health_bar.draw(draw_x, draw_y - 70)&#10;&#10;        # DEBUG : 충돌 박스 및 플레이어 인식 범위 그리기&#10;        # 충돌 박스 : 카메라 좌표계로 변환 후 그리기&#10;        Left, Bottom, Right, Top = self.get_bb()&#10;        Left -= self.x - draw_x&#10;        Right -= self.x - draw_x&#10;        Bottom -= self.y - draw_y&#10;        Top -= self.y - draw_y&#10;        p2.draw_rectangle(Left, Bottom, Right, Top, r=255, g=0, b=0)&#10;&#10;        # 공격 범위&#10;        radius = self.recognition_distance&#10;        p2.draw_circle(draw_x, draw_y, int(radius), r=255, g=255, b=0)&#10;&#10;        # 타겟 놓치는 거리&#10;        radius = self.unrecognition_distance&#10;        p2.draw_circle(draw_x, draw_y, int(radius), r=0, g=255, b=255)&#10;&#10;        # 분신 드로잉 (디버그용)&#10;        # if self.clone_images:&#10;        #     offset = 200&#10;        #     self.clone_images[self.frame].draw(draw_x - offset, draw_y,&#10;        #                                        self.clone_images[self.frame].w * self.scale_factor,&#10;        #                                        self.clone_images[self.frame].h * self.scale_factor)&#10;&#10;&#10;    def get_bb(self):&#10;        &quot;&quot;&quot;충돌 박스 반환 (left, bottom, right, top)&quot;&quot;&quot;&#10;        half_w = self.collision_width / 2&#10;        half_h = self.collision_height / 2&#10;        return (&#10;            self.x - half_w + self.collision_box_offset_x,&#10;            self.y - half_h + self.collision_box_offset_y,&#10;            self.x + half_w + self.collision_box_offset_x,&#10;            self.y + half_h + self.collision_box_offset_y&#10;        )&#10;&#10;    def take_damage(self, damage):&#10;        &quot;&quot;&quot;피해를 받음&quot;&quot;&quot;&#10;        # 이미 사망 상태면 무시&#10;        if self.is_dead:&#10;            return False&#10;&#10;        current_health = self.stats.get('health')&#10;        self.stats.set_base('health', max(0, current_health - damage))&#10;        print(f&quot;[PantherAssassin] 피해 {damage}, 남은 HP: {self.stats.get('health')}/{self.stats.get('max_health')}&quot;)&#10;&#10;        if self.stats.get('health') &lt;= 0:&#10;            print(&quot;[PantherAssassin] 사망 - 애니메이션 시작!&quot;)&#10;            # 사망 애니메이션 플래그 설정&#10;            self.is_dead = True&#10;            self.death_frame = 0&#10;            self.death_frame_timer = 0.0&#10;            # 즉시 제거하지 않고 애니메이션이 끝날 때까지 기다림&#10;        return False  # 사망 상태라도 애니메이션이 끝날 때까지 False 반환&#10;&#10;    def set_target(self, target):&#10;        &quot;&quot;&quot;타겟 설정 (주로 플레이어)&quot;&quot;&quot;&#10;        self.target = target&#10;&#10;    # ==================== 피격 판정 메서드 ====================&#10;&#10;    def check_collision_with_effect(self, effect):&#10;        &quot;&quot;&quot;&#10;        플레이어 공격 이펙트와의 충돌 감지&#10;&#10;        Args:&#10;            effect: VFX_Tier1_Sword_Swing 등의 공격 이펙트 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 사망 상태이거나 무적 상태이면 충돌 무시&#10;        if self.is_dead or self.invincible:&#10;            return False&#10;&#10;        # 이펙트의 크기 계산&#10;        if hasattr(effect, 'frames') and len(effect.frames) &gt; 0:&#10;            effect_img = effect.frames[min(effect.frame, len(effect.frames) - 1)]&#10;            effect_width = effect_img.w * effect.scale_factor&#10;            effect_height = effect_img.h * effect.scale_factor&#10;        else:&#10;            # 기본값&#10;            effect_width = 200&#10;            effect_height = 200&#10;&#10;        # AABB 충돌 감지&#10;        panther_left = self.x - self.collision_width / 2&#10;        panther_right = self.x + self.collision_width / 2&#10;        panther_bottom = self.y - self.collision_height / 2&#10;        panther_top = self.y + self.collision_height / 2&#10;&#10;        effect_left = effect.x - effect_width / 2&#10;        effect_right = effect.x + effect_width / 2&#10;        effect_bottom = effect.y - effect_height / 2&#10;        effect_top = effect.y + effect_height / 2&#10;&#10;        # 충돌 검사&#10;        if (panther_left &lt; effect_right and panther_right &gt; effect_left and&#10;            panther_bottom &lt; effect_top and panther_top &gt; effect_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(effect)&#10;            return True&#10;&#10;        return False&#10;&#10;    def check_collision_with_projectile(self, projectile):&#10;        &quot;&quot;&quot;&#10;        플레이어 투사체와의 충돌 감지&#10;&#10;        Args:&#10;            projectile: Projectile을 상속받은 발사체 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 무적 상태이면 충돌 무시&#10;        if self.invincible:&#10;            return False&#10;&#10;        # 발사체 크기&#10;        if hasattr(projectile, 'get_collision_box'):&#10;            projectile_width, projectile_height = projectile.get_collision_box()&#10;        else:&#10;            projectile_width = 30&#10;            projectile_height = 30&#10;&#10;        # AABB 충돌 감지&#10;        panther_left = self.x - self.collision_width / 2&#10;        panther_right = self.x + self.collision_width / 2&#10;        panther_bottom = self.y - self.collision_height / 2&#10;        panther_top = self.y + self.collision_height / 2&#10;&#10;        proj_left = projectile.x - projectile_width / 2&#10;        proj_right = projectile.x + projectile_width / 2&#10;        proj_bottom = projectile.y - projectile_height / 2&#10;        proj_top = projectile.y + projectile_height / 2&#10;&#10;        # 충돌 검사&#10;        if (panther_left &lt; proj_right and panther_right &gt; proj_left and&#10;            panther_bottom &lt; proj_top and panther_top &gt; proj_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(projectile)&#10;            return True&#10;&#10;        return False&#10;&#10;    def on_hit(self, attacker):&#10;        &quot;&quot;&quot;&#10;        피격 시 호출되는 메서드&#10;&#10;        Args:&#10;            attacker: 공격한 객체 (투사체, 이펙트 등)&#10;        &quot;&quot;&quot;&#10;        # 무적 상태라면 무시&#10;        if self.invincible:&#10;            print(f&quot;[PantherAssassin] 무적 상태로 피격 무시 (남은 무적시간: {self.invincible_timer:.2f}초)&quot;)&#10;            return&#10;&#10;        # 무적시간 활성화&#10;        self.invincible = True&#10;        self.invincible_timer = self.invincible_duration&#10;&#10;        # 데미지 계산&#10;        damage = 0&#10;        if hasattr(attacker, 'damage'):&#10;            damage = attacker.damage&#10;        elif hasattr(attacker, 'owner') and hasattr(attacker.owner, 'statss'):&#10;            # 공격자의 스탯에서 데미지 가져오기&#10;            damage = attacker.owner.statss.get('attack_damage')&#10;        else:&#10;            damage = 10.0  # 기본 데미지&#10;&#10;        # 방어력 적용&#10;        defense = self.stats.get('defense')&#10;        final_damage = max(1.0, damage - defense)&#10;&#10;        # 체력 감소&#10;        current_health = self.stats.get('health')&#10;        max_health = self.stats.get('max_health')&#10;        new_health = max(0, current_health - final_damage)&#10;        self.stats.set_base('health', new_health)&#10;&#10;        # 데미지 인디케이터 생성 (월드에 추가)&#10;        if self.world and 'effects_front' in self.world:&#10;            try:&#10;                # 보스 위치 위쪽에 데미지 인디케이터 생성&#10;                damage_indicator = DamageIndicator(&#10;                    self.x,&#10;                    self.y + 50,  # 보스 위치보다 50 픽셀 위에 표시&#10;                    final_damage,&#10;                    duration=1.0,&#10;                    font_size=40  # 보스는 큰 폰트 사용&#10;                )&#10;                self.world['effects_front'].append(damage_indicator)&#10;                print(f&quot;[PantherAssassin] 데미지 인디케이터 생성: {int(final_damage)} 데미지&quot;)&#10;            except Exception as e:&#10;                print(f&quot;[PantherAssassin] 데미지 인디케이터 생성 실패: {e}&quot;)&#10;&#10;        # 피격 정보 출력 (디버그)&#10;        attacker_name = attacker.__class__.__name__&#10;        print(f&quot;\n{'=' * 60}&quot;)&#10;        print(f&quot;[PantherAssassin 피격] at ({int(self.x)}, {int(self.y)})&quot;)&#10;        print(f&quot;  공격자: {attacker_name}&quot;)&#10;        print(f&quot;  원본 데미지: {damage:.1f}&quot;)&#10;        print(f&quot;  방어력: {defense:.1f}&quot;)&#10;        print(f&quot;  최종 데미지: {final_damage:.1f}&quot;)&#10;        print(f&quot;  체력 변화: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})&quot;)&#10;        print(f&quot;  체력 비율: {(new_health / max_health) * 100:.1f}%&quot;)&#10;        print(f&quot;  무적시간: {self.invincible_duration}초 활성화&quot;)&#10;&#10;        # 체력이 0 이하면 사망 처리&#10;        if new_health &lt;= 0:&#10;            print(f&quot;  &gt;&gt;&gt; PantherAssassin 체력 0 - 사망 애니메이션 시작!&quot;)&#10;            print(f&quot;{'=' * 60}\n&quot;)&#10;            # 사망 애니메이션 플래그 설정&#10;            self.is_dead = True&#10;            self.death_frame = 0&#10;            self.death_frame_timer = 0.0&#10;            # 즉시 제거하지 않고 애니메이션이 끝날 때까지 기다림&#10;        else:&#10;            print(f&quot;{'=' * 60}\n&quot;)&#10;&#10;&#10;# ==================== PantherThrowingStar 투사체 클래스 ====================&#10;&#10;class PantherThrowingStar(Projectile):&#10;    &quot;&quot;&quot;&#10;    팬서 암살자 보스의 표창 투사체&#10;    회전하는 애니메이션과 함께 날아가는 표창입니다.&#10;    &quot;&quot;&quot;&#10;    image_seq = []&#10;&#10;    def __init__(self, x, y, target_x, target_y, speed=400, from_player=False, damage=15, scale=1.2):&#10;        &quot;&quot;&quot;&#10;        PantherThrowingStar 초기화&#10;&#10;        Args:&#10;            x, y: 시작 위치&#10;            target_x, target_y: 목표 위치&#10;            speed: 투사체 속도&#10;            from_player: 플레이어가 발사했는지 여부&#10;            damage: 투사체 피해량&#10;            scale: 이미지 크기 배율&#10;        &quot;&quot;&quot;&#10;        super().__init__(x, y, target_x, target_y, speed, from_player)&#10;&#10;        # 투사체 속성&#10;        self.damage = damage&#10;        self.scale = scale&#10;        self.collision_width = int(13 * scale)&#10;        self.collision_height = int(20 * scale)&#10;&#10;        # 애니메이션 관련 변수&#10;        self.animation_timer = 0.0&#10;        self.animation_frame = 0&#10;        self.animation_frame_duration = 0.1  # 각 프레임당 0.1초&#10;&#10;        # 이미지 로드 (클래스 레벨에서 한 번만)&#10;        if not PantherThrowingStar.image_seq:&#10;            try:&#10;                for i in range(4):&#10;                    img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/FX/PantherAssassin_ShurikenBullet{i:02d}.png'&#10;                    PantherThrowingStar.image_seq.append(p2.load_image(img_path))&#10;                print(f'[PantherThrowingStar] 이미지 로드 완료: {len(PantherThrowingStar.image_seq)}개 애니메이션 프레임')&#10;            except FileNotFoundError as e:&#10;                print(f'\033[91m[PantherThrowingStar] 이미지 로드 실패: {e}\033[0m')&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;표창 업데이트&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 애니메이션 업데이트&#10;        self.animation_timer += dt&#10;        if self.animation_timer &gt;= self.animation_frame_duration:&#10;            self.animation_timer -= self.animation_frame_duration&#10;            self.animation_frame = (self.animation_frame + 1) % len(PantherThrowingStar.image_seq)&#10;&#10;        # 일반 이동 로직&#10;        self.x += self.dx * self.speed * dt&#10;        self.y += self.dy * self.speed * dt&#10;&#10;        # 화면 밖으로 나가면 제거&#10;        if (self.x &lt; -1000 or self.x &gt; 5000 or&#10;            self.y &lt; -1000 or self.y &gt; 5000):&#10;            return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;표창 드로잉&quot;&quot;&quot;&#10;        if PantherThrowingStar.image_seq and self.animation_frame &lt; len(PantherThrowingStar.image_seq):&#10;            # 애니메이션 프레임 렌더링 (회전 없이)&#10;            img = PantherThrowingStar.image_seq[self.animation_frame]&#10;            if img:&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;        else:&#10;            # 디버그 렌더링 (이미지 없을 때)&#10;            size = int(10 * self.scale)&#10;            p2.draw_rectangle(&#10;                draw_x - size, draw_y - size,&#10;                draw_x + size, draw_y + size&#10;            )&#10;&#10;        # DEBUG: 충돌 박스 그리기&#10;        # Left = draw_x - self.collision_width / 2&#10;        # Right = draw_x + self.collision_width / 2&#10;        # Bottom = draw_y - self.collision_height / 2&#10;        # Top = draw_y + self.collision_height / 2&#10;        # p2.draw_rectangle(Left, Bottom, Right, Top, r=0, g=255, b=0)&#10;&#10;    def on_hit(self):&#10;        &quot;&quot;&quot;투사체가 타겟에 명중했을 때 호출&quot;&quot;&quot;&#10;        pass&#10;&#10;    def get_collision_box(self):&#10;        &quot;&quot;&quot;충돌 박스 반환&quot;&quot;&quot;&#10;        return (self.collision_width, self.collision_height)&#10;&#10;# ==================== PantherShuriken 투사체 클래스 ====================&#10;class PantherShuriken(Projectile):&#10;    &quot;&quot;&quot;&#10;    팬서 암살자 보스의 단검 투사체&#10;    날아가는 동안은 ThrowingDagger0.png를 표시하고,&#10;    소멸 시에는 ThrowingDagger1~4 애니메이션을 재생합니다.&#10;    &quot;&quot;&quot;&#10;    flying_image = None&#10;    dissolve_images = []&#10;&#10;    def __init__(self, x, y, target_x, target_y, speed=400, from_player=False, damage=15, scale=1.2):&#10;        &quot;&quot;&quot;&#10;        PantherShuriken 초기화&#10;&#10;        Args:&#10;            x, y: 시작 위치&#10;            target_x, target_y: 목표 위치&#10;            speed: 투사체 속도&#10;            from_player: 플레이어가 발사했는지 여부&#10;            damage: 투사체 피해량&#10;            scale: 이미지 크기 배율&#10;        &quot;&quot;&quot;&#10;        super().__init__(x, y, target_x, target_y, speed, from_player)&#10;&#10;        # 투사체 속성&#10;        self.damage = damage&#10;        self.scale = scale&#10;        self.collision_width = int(13 * scale)&#10;        self.collision_height = int(41 * scale) // 2&#10;&#10;        # 회전 각도 계산 (원본 이미지가 위쪽을 바라봄, +y 방향 기준)&#10;        # math.atan2를 사용하여 방향 벡터로부터 각도 계산&#10;        import math&#10;        self.rotation_angle = math.atan2(self.dy, self.dx) + math.radians(-90) # 라디안 단위&#10;&#10;        # 상태 관리 변수&#10;        self.is_dissolving = False  # 소멸 애니메이션 재생 중인지&#10;        self.dissolve_frame = 0  # 현재 소멸 애니메이션 프레임&#10;        self.dissolve_timer = 0.0  # 소멸 애니메이션 타이머&#10;        self.dissolve_frame_duration = 0.08  # 각 소멸 프레임당 0.08초&#10;&#10;        # 이미지 로드 (클래스 레벨에서 한 번만)&#10;        if PantherShuriken.flying_image is None or not PantherShuriken.dissolve_images:&#10;            try:&#10;                # 비행 중 이미지 (ThrowingDagger0.png)&#10;                flying_img_path = 'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/FX/ThrowingDagger0.png'&#10;                PantherShuriken.flying_image = p2.load_image(flying_img_path)&#10;                print(f'[PantherShuriken] 비행 이미지 로드 완료: {flying_img_path}')&#10;&#10;                # 소멸 애니메이션 이미지 (ThrowingDagger1.png ~ ThrowingDagger4.png)&#10;                PantherShuriken.dissolve_images = []&#10;                for i in range(1, 5):  # 1, 2, 3, 4&#10;                    dissolve_img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/FX/ThrowingDagger{i}.png'&#10;                    PantherShuriken.dissolve_images.append(p2.load_image(dissolve_img_path))&#10;                print(f'[PantherShuriken] 소멸 애니메이션 이미지 로드 완료: {len(PantherShuriken.dissolve_images)}개 프레임')&#10;            except FileNotFoundError as e:&#10;                print(f'\033[91m[PantherShuriken] 이미지 로드 실패: {e}\033[0m')&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;단검 업데이트&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 소멸 애니메이션 중이면 애니메이션만 업데이트&#10;        if self.is_dissolving:&#10;            self.dissolve_timer += dt&#10;            if self.dissolve_timer &gt;= self.dissolve_frame_duration:&#10;                self.dissolve_timer -= self.dissolve_frame_duration&#10;                self.dissolve_frame += 1&#10;&#10;                # 모든 소멸 프레임을 다 재생했으면 제거&#10;                if self.dissolve_frame &gt;= len(PantherShuriken.dissolve_images):&#10;                    return False&#10;&#10;            return True&#10;&#10;        # 일반 비행 로직&#10;        self.x += self.dx * self.speed * dt&#10;        self.y += self.dy * self.speed * dt&#10;&#10;        # 화면 밖으로 나가면 소멸 애니메이션 시작&#10;        if (self.x &lt; -1000 or self.x &gt; 5000 or&#10;            self.y &lt; -1000 or self.y &gt; 5000):&#10;            self.start_dissolve()&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;단검 드로잉 (회전 적용)&quot;&quot;&quot;&#10;        # 소멸 애니메이션 중이면 소멸 이미지 그리기 (회전 적용)&#10;        if self.is_dissolving:&#10;            if (PantherShuriken.dissolve_images and&#10;                self.dissolve_frame &lt; len(PantherShuriken.dissolve_images)):&#10;                img = PantherShuriken.dissolve_images[self.dissolve_frame]&#10;                if img:&#10;                    # 회전을 적용하여 그리기&#10;                    img.rotate_draw(self.rotation_angle, draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;        else:&#10;            # 비행 중이면 비행 이미지 그리기 (회전 적용)&#10;            if PantherShuriken.flying_image:&#10;                img = PantherShuriken.flying_image&#10;                # 회전을 적용하여 그리기&#10;                img.rotate_draw(self.rotation_angle, draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;            else:&#10;                # 디버그 렌더링 (이미지 없을 때)&#10;                size = int(10 * self.scale)&#10;                p2.draw_rectangle(&#10;                    draw_x - size, draw_y - size,&#10;                    draw_x + size, draw_y + size&#10;                )&#10;&#10;        # DEBUG: 충돌 박스 그리기 (필요 시 주석 해제)&#10;        Left = draw_x - self.collision_width / 2&#10;        Right = draw_x + self.collision_width / 2&#10;        Bottom = draw_y - self.collision_height / 2&#10;        Top = draw_y + self.collision_height / 2&#10;        p2.draw_rectangle(Left, Bottom, Right, Top, r=0, g=255, b=0)&#10;&#10;    def on_hit(self):&#10;        &quot;&quot;&quot;투사체가 타겟에 명중했을 때 호출 - 소멸 애니메이션 시작&quot;&quot;&quot;&#10;        self.start_dissolve()&#10;&#10;    def start_dissolve(self):&#10;        &quot;&quot;&quot;소멸 애니메이션 시작&quot;&quot;&quot;&#10;        if not self.is_dissolving:&#10;            self.is_dissolving = True&#10;            self.dissolve_frame = 0&#10;            self.dissolve_timer = 0.0&#10;&#10;    def get_collision_box(self):&#10;        &quot;&quot;&quot;충돌 박스 반환&quot;&quot;&quot;&#10;        # 소멸 중일 때는 충돌 판정 없음&#10;        if self.is_dissolving:&#10;            return (0, 0)&#10;        return (self.collision_width, self.collision_height)&#10;&#10;&#10;class Clone:&#10;    &quot;&quot;&quot;&#10;    분신 객체 - 시각 효과 전용&#10;&#10;    주의: play_mode의 entities 레이어에서 정상 작동하려면&#10;          일부 더미 속성/메서드가 필요합니다.&#10;    &quot;&quot;&quot;&#10;    def __init__(self, start_x, start_y, target_x, target_y, images, scale_factor):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            start_x, start_y: 시작 위치 (본체 위치)&#10;            target_x, target_y: 목표 위치 (이동할 위치)&#10;            images: 애니메이션에 사용할 이미지 딕셔너리 {'throw_1st': [...], 'throw_2nd': [...], 'move': [...], 'die': [...]}&#10;            scale_factor: 본체의 스케일 팩터&#10;        &quot;&quot;&quot;&#10;        print(f&quot;[Clone.__init__] 분신 생성 시작 - 시작: ({start_x:.0f}, {start_y:.0f}), 목표: ({target_x:.0f}, {target_y:.0f})&quot;)&#10;&#10;        self.start_x = start_x&#10;        self.start_y = start_y&#10;        self.x = start_x&#10;        self.y = start_y&#10;        self.target_x = target_x&#10;        self.target_y = target_y&#10;        self.images = images&#10;        self.scale_factor = scale_factor  # 본체와 동일한 스케일 사용&#10;&#10;        # 이미지 딕셔너리 검증&#10;        print(f&quot;[Clone.__init__] 이미지 딕셔너리 키: {list(images.keys())}&quot;)&#10;        for key, img_list in images.items():&#10;            print(f&quot;[Clone.__init__] {key}: {len(img_list)}개 이미지&quot;)&#10;            if len(img_list) == 0:&#10;                print(f&quot;[Clone.__init__] 경고: {key} 이미지 리스트가 비어있음!&quot;)&#10;&#10;        # 이동 관련&#10;        self.move_duration = 1.5  # 이동 시간 (1.5초로 변경)&#10;        self.move_timer = 0.0&#10;        self.is_moving = True&#10;&#10;        # 잔상 효과&#10;        self.afterimage_alpha = 1.0  # 시작 위치의 잔상 투명도&#10;        self.afterimage_fade_duration = 0.5  # 잔상 사라지는 시간&#10;&#10;        # 애니메이션&#10;        self.current_animation = 'move'&#10;        self.frame = 0&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.1  # 프레임당 시간&#10;&#10;        # 사라지는 애니메이션 관련&#10;        self.is_dying = False  # 사라지는 애니메이션 재생 중 플래그&#10;        self.die_frame = 0  # Die 애니메이션 현재 프레임&#10;        self.die_frame_duration = 0.08  # Die 애니메이션 프레임당 시간&#10;        self.die_animation_frames = 11  # Die 애니메이션 프레임 수 (0~10)&#10;&#10;        # 제거 플래그 (entities에서 자동 제거되도록)&#10;        self.to_be_removed = False&#10;&#10;        print(f&quot;[Clone.__init__] 분신 생성 완료!&quot;)&#10;&#10;        # play_mode 호환성을 위한 더미 속성 추가&#10;        self.mark_for_removal = False  # play_mode의 제거 플래그&#10;        self.hp = 1  # 더미 체력 (충돌 검사에서 필요할 수 있음)&#10;        self.is_dead = False  # 더미 사망 플래그&#10;&#10;        # 디버깅: 생성 직후 첫 업데이트 강제 호출 테스트&#10;        print(f&quot;[Clone.__init__] 테스트: 생성 직후 update() 호출 가능 여부 확인&quot;)&#10;        try:&#10;            # update()를 호출하지는 않고, 대신 필수 속성들이 모두 있는지만 확인&#10;            assert hasattr(self, 'x'), &quot;x 속성 누락!&quot;&#10;            assert hasattr(self, 'y'), &quot;y 속성 누락!&quot;&#10;            assert hasattr(self, 'images'), &quot;images 속성 누락!&quot;&#10;            assert hasattr(self, 'update'), &quot;update 메서드 누락!&quot;&#10;            assert hasattr(self, 'draw'), &quot;draw 메서드 누락!&quot;&#10;            print(f&quot;[Clone.__init__] ✓ 필수 속성/메서드 검증 완료&quot;)&#10;        except AssertionError as e:&#10;            print(f&quot;\033[91m[Clone.__init__] ✗ 속성 검증 실패: {e}\033[0m&quot;)&#10;&#10;    def start_dying(self):&#10;        &quot;&quot;&quot;&#10;        분신 사라지는 애니메이션 시작&#10;        외부에서 이 메서드를 호출하여 분신을 제거 시작&#10;        &quot;&quot;&quot;&#10;        if not self.is_dying:&#10;            print(f&quot;[Clone.start_dying] 분신 사라지는 애니메이션 시작 - 위치: ({self.x:.0f}, {self.y:.0f})&quot;)&#10;            self.is_dying = True&#10;            self.die_frame = 0&#10;            self.frame_timer = 0.0&#10;            self.current_animation = 'die'&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;분신 업데이트 (play_mode에서 파라미터 없이 호출됨)&quot;&quot;&quot;&#10;        try:&#10;            # 첫 업데이트에만 로그 출력&#10;            if not hasattr(self, '_update_logged'):&#10;                print(f&quot;[Clone.update] 첫 업데이트 - 위치: ({self.x:.0f}, {self.y:.0f}), is_moving: {self.is_moving}&quot;)&#10;                self._update_logged = True&#10;&#10;            # dt는 내부에서 가져오기&#10;            dt = framework.get_delta_time()&#10;&#10;            # 사라지는 애니메이션 재생 중&#10;            if self.is_dying:&#10;                self.frame_timer += dt&#10;                if self.frame_timer &gt;= self.die_frame_duration:&#10;                    self.frame_timer = 0.0&#10;                    self.die_frame += 1&#10;                    &#10;                    # Die 애니메이션 완료 시 제거 플래그 설정&#10;                    if self.die_frame &gt;= self.die_animation_frames:&#10;                        print(f&quot;[Clone.update] Die 애니메이션 완료 - 제거 플래그 설정&quot;)&#10;                        self.mark_for_removal = True&#10;                        self.to_be_removed = True&#10;                        return True  # 제거 대기&#10;                &#10;                return True  # 애니메이션 재생 중&#10;&#10;            # 일반 동작 (이동 및 투척 애니메이션)&#10;            if self.is_moving:&#10;                self.move_timer += dt&#10;                progress = min(1.0, self.move_timer / self.move_duration)&#10;&#10;                # 부드러운 이동 (easeOutCubic)&#10;                ease_progress = 1 - pow(1 - progress, 3)&#10;                self.x = self.start_x + (self.target_x - self.start_x) * ease_progress&#10;                self.y = self.start_y + (self.target_y - self.start_y) * ease_progress&#10;&#10;                # 잔상 투명도 감소&#10;                self.afterimage_alpha = max(0.0, 1.0 - (self.move_timer / self.afterimage_fade_duration))&#10;&#10;                if progress &gt;= 1.0:&#10;                    self.is_moving = False&#10;                    self.current_animation = 'throw_1st'  # 이동 완료 후 투척 준비&#10;                    self.frame = 0&#10;                    print(f&quot;[Clone.update] 이동 완료! 위치: ({self.x:.0f}, {self.y:.0f})&quot;)&#10;&#10;            # 프레임 애니메이션&#10;            self.frame_timer += dt&#10;            if self.frame_timer &gt;= self.frame_duration:&#10;                self.frame_timer = 0.0&#10;&#10;                # 현재 애니메이션에 따라 프레임 업데이트&#10;                if self.current_animation in self.images:&#10;                    img_list = self.images[self.current_animation]&#10;&#10;                    if self.current_animation == 'move':&#10;                        # Move 애니메이션은 반복 재생&#10;                        if len(img_list) &gt; 0:&#10;                            self.frame = (self.frame + 1) % len(img_list)&#10;                    elif self.current_animation in ['whirlwind']:&#10;                        # Whirlwind 애니메이션은 반복 재생&#10;                        if len(img_list) &gt; 0:&#10;                            self.frame = (self.frame + 1) % len(img_list)&#10;                    elif self.current_animation in ['throw_1st', 'throw_2nd', 'withdraw']:&#10;                        # 투척 및 Withdraw 애니메이션은 한 번만 재생&#10;                        if len(img_list) &gt; 0 and self.frame &lt; len(img_list) - 1:&#10;                            self.frame += 1&#10;                else:&#10;                    print(f&quot;[Clone.update] 경고: {self.current_animation} 이미지가 없음!&quot;)&#10;&#10;            # update 메서드는 True를 반환해야 entities에서 유지됨&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Clone.update] 오류 발생: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            return True  # 오류가 나도 객체는 유지&#10;&#10;    def switch_animation(self, animation_type):&#10;        &quot;&quot;&quot;&#10;        애니메이션 변경&#10;        Args:&#10;            animation_type: 'move', 'whirlwind', 'withdraw', 'throw_1st', 'throw_2nd', 'die'&#10;        &quot;&quot;&quot;&#10;        try:&#10;            print(f&quot;[Clone.switch_animation] {self.current_animation} -&gt; {animation_type}&quot;)&#10;            self.current_animation = animation_type&#10;            self.frame = 0&#10;            self.frame_timer = 0.0&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Clone.switch_animation] 오류: {e}\033[0m&quot;)&#10;&#10;    def switch_throw_animation(self, throw_type):&#10;        &quot;&quot;&quot;투척 애니메이션 변경 (1st &lt;-&gt; 2nd) - 하위 호환성 유지&quot;&quot;&quot;&#10;        self.switch_animation(throw_type)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        분신 그리기&#10;        Args:&#10;            draw_x, draw_y: 카메라가 적용된 화면 좌표&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # 디버그: 첫 프레임에만 로그 출력&#10;            if not hasattr(self, '_draw_logged'):&#10;                print(f&quot;[Clone.draw] 첫 그리기 - 화면좌표: ({draw_x:.0f}, {draw_y:.0f}), 월드좌표: ({self.x:.0f}, {self.y:.0f})&quot;)&#10;                print(f&quot;[Clone.draw] 애니메이션: {self.current_animation}, 프레임: {self.frame}&quot;)&#10;                print(f&quot;[Clone.draw] 이미지 개수: {len(self.images.get(self.current_animation, []))}&quot;)&#10;                self._draw_logged = True&#10;&#10;            # Die 애니메이션 재생 중&#10;            if self.is_dying and 'die' in self.images:&#10;                die_img_list = self.images['die']&#10;                if len(die_img_list) &gt; 0 and 0 &lt;= self.die_frame &lt; len(die_img_list):&#10;                    die_img = die_img_list[self.die_frame]&#10;                    die_img.draw(&#10;                        draw_x, draw_y,&#10;                        die_img.w * self.scale_factor,&#10;                        die_img.h * self.scale_factor&#10;                    )&#10;                return  # Die 애니메이션 중에는 다른 것 그리지 않음&#10;&#10;            # 일반 애니메이션 (move, whirlwind, withdraw, throw_1st, throw_2nd)&#10;            if self.current_animation in self.images:&#10;                img_list = self.images[self.current_animation]&#10;                if len(img_list) == 0:&#10;                    print(f&quot;[Clone.draw] 경고: {self.current_animation} 이미지 리스트가 비어있음!&quot;)&#10;                    return&#10;&#10;                if 0 &lt;= self.frame &lt; len(img_list):&#10;                    current_img = img_list[self.frame]&#10;&#10;                    # 현재 위치에 분신 그리기 (카메라 좌표 이미 적용됨)&#10;                    current_img.draw(&#10;                        draw_x, draw_y,&#10;                        current_img.w * self.scale_factor,&#10;                        current_img.h * self.scale_factor&#10;                    )&#10;&#10;                    # 이동 중일 때 잔상 효과 (시작 위치)&#10;                    if self.is_moving and self.afterimage_alpha &gt; 0.0:&#10;                        # 잔상 위치도 카메라 좌표로 변환 필요&#10;                        # play_mode의 camera를 통해 변환&#10;                        from game_logic import play_mode&#10;                        if play_mode.camera is not None:&#10;                            afterimage_draw_x, afterimage_draw_y = play_mode.camera.apply(self.start_x, self.start_y)&#10;                        else:&#10;                            afterimage_draw_x, afterimage_draw_y = self.start_x, self.start_y&#10;&#10;                        current_img.opacify(self.afterimage_alpha)&#10;                        current_img.draw(&#10;                            afterimage_draw_x, afterimage_draw_y,&#10;                            current_img.w * self.scale_factor,&#10;                            current_img.h * self.scale_factor&#10;                        )&#10;                        current_img.opacify(1.0)  # 원래대로 복구&#10;                else:&#10;                    print(f&quot;[Clone.draw] 경고: 프레임 인덱스 범위 초과 - frame={self.frame}, max={len(img_list)-1}&quot;)&#10;            else:&#10;                print(f&quot;[Clone.draw] 경고: {self.current_animation} 키가 이미지 딕셔너리에 없음!&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Clone.draw] 오류 발생: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;" />
              <option name="updatedContent" value="import pico2d as p2&#10;import math&#10;import random&#10;import game_framework as framework&#10;from ..behavior_tree import BehaviorTree, Selector, Sequence, Action, Condition, RandomSelector&#10;from ..projectile import Projectile&#10;from .. import image_asset_manager as iam&#10;from ..damage_indicator import DamageIndicator&#10;from ..ui_overlay import MonsterHealthBar&#10;&#10;# ==================== 공격 패턴 클래스 참조 ====================&#10;from .Boss_Logic.panther_assassin_1pattern import AttackPattern1Action&#10;from .Boss_Logic.panther_assassin_2pattern import AttackPattern2Action&#10;from .Boss_Logic.panther_assassin_3pattern import AttackPattern3Action&#10;from .Boss_Logic.panther_assassin_4pattern import AttackPattern4Action&#10;from .Boss_Logic.panther_assassin_5pattern import AttackPattern5Action&#10;from .Boss_Logic.panther_assassin_6pattern import AttackPattern6Action&#10;&#10;# ==================== BT Action Wrapper 클래스 ====================&#10;&#10;class BTActionWrapper(Action):&#10;    &quot;&quot;&quot;&#10;    BT Action Wrapper 클래스&#10;&#10;    행동 트리의 Action 노드가 패턴 클래스의 update() 메서드를 호출할 수 있도록&#10;    래핑하는 헬퍼 클래스입니다.&#10;&#10;    사용 목적:&#10;    - BT 프레임워크는 Action 노드를 인자 없이 호출하는 구조&#10;    - 패턴 클래스는 인스턴스 메서드로 상태를 관리&#10;    - 이 래퍼가 둘 사이의 다리 역할을 수행&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, name, action_instance):&#10;        &quot;&quot;&quot;&#10;        BTActionWrapper 초기화&#10;&#10;        Args:&#10;            name: 노드 이름 (디버깅용)&#10;            action_instance: 실제 패턴 Action 클래스의 인스턴스&#10;                            (예: AttackPattern1Action의 인스턴스)&#10;        &quot;&quot;&quot;&#10;        self.name = name&#10;        self.action_instance = action_instance&#10;        self.value = BehaviorTree.UNDEF&#10;        self.has_condition = False&#10;&#10;    def tag_condition(self):&#10;        &quot;&quot;&quot;Action 노드는 조건 노드가 아님&quot;&quot;&quot;&#10;        self.has_condition = False&#10;&#10;    def reset(self):&#10;        &quot;&quot;&quot;노드 상태 초기화&quot;&quot;&quot;&#10;        self.value = BehaviorTree.UNDEF&#10;&#10;    def add_child(self, child, probability=1.0):&#10;        &quot;&quot;&quot;Leaf 노드에는 자식을 추가할 수 없음&quot;&quot;&quot;&#10;        print(&quot;ERROR: you cannot add child node to leaf node&quot;)&#10;&#10;    def add_children(self, *children):&#10;        &quot;&quot;&quot;Leaf 노드에는 자식을 추가할 수 없음&quot;&quot;&quot;&#10;        print(&quot;ERROR: you cannot add children node to leaf node&quot;)&#10;&#10;    def run(self):&#10;        &quot;&quot;&quot;&#10;        Action 실행: 패턴 인스턴스의 update() 메서드 호출&#10;&#10;        Returns:&#10;            BehaviorTree.SUCCESS, BehaviorTree.RUNNING, 또는 BehaviorTree.FAIL&#10;        &quot;&quot;&quot;&#10;        # 현재 실행 중인 패턴 인스턴스를 PantherAssassin에 저장&#10;        # 이를 통해 PantherAssassin.draw()에서 패턴의 draw() 메서드를 호출할 수 있음&#10;        self.action_instance.panther.current_action_instance = self.action_instance&#10;&#10;        self.value = self.action_instance.update()&#10;        return self.value&#10;&#10;# ==================== PantherAssassin 보스 클래스 ====================&#10;&#10;class PantherAssassin:&#10;    &quot;&quot;&quot;&#10;    팬서 암살자 보스 몬스터&#10;&#10;    특징:&#10;    - 6가지 공격 패턴을 랜덤하게 사용&#10;    - 행동 트리 기반 AI&#10;    - 높은 체력과 공격력&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, x, y):&#10;        &quot;&quot;&quot;&#10;        PantherAssassin 초기화&#10;&#10;        Args:&#10;            x, y: 스폰 위치&#10;        &quot;&quot;&quot;&#10;        # 위치 및 기본 속성&#10;        self.x = x&#10;        self.y = y&#10;        self.spawn_x = x  # 스폰 위치 기억&#10;        self.spawn_y = y&#10;&#10;        # 스탯&#10;        from ..stats import PantherAssassinStats&#10;        self.stats = PantherAssassinStats()&#10;&#10;        # 애니메이션&#10;        self.frame = 0&#10;        self.frame_timer = 0.0&#10;        self.frame_speed = 15.0  # 초당 프레임 수&#10;        self.scale_factor = 4.0&#10;        self.animation_frames = 11 # 애니메이션 프레임 수&#10;&#10;        # 충돌 박스&#10;        self.collision_width = 24 * self.scale_factor&#10;        self.collision_height = 26 * self.scale_factor&#10;        self.collision_box_offset_x = 0&#10;        self.collision_box_offset_y = -10 * self.scale_factor&#10;&#10;        # 타겟 (플레이어)&#10;        self.target = None&#10;&#10;        # 월드 참조 (투사체 생성을 위해)&#10;        from ..play_mode import world&#10;        self.world = world&#10;&#10;        # 투사체 관리 (보스 전용 투사체 리스트)&#10;        self.projectiles = []&#10;&#10;        # 공격 관련&#10;        self.recognition_distance = 400 # 플레이어 인식 거리&#10;        self.unrecognition_distance = 800 # 플레이어 미인식 거리&#10;        self.attack_range = 800  # 공격 범위 (추가)&#10;        self.attack_cooldown = 2.0  # 공격 쿨타임 (초)&#10;        self.attack_timer = 0.0  # 현재 쿨타임 타이머&#10;&#10;        # 무적시간 관련 변수 (피격 판정 중복 방지)&#10;        self.invincible = False&#10;        self.invincible_timer = 0.0&#10;        self.invincible_duration = 0.3  # 무적 지속 시간 (초)&#10;&#10;        # 제거 플래그&#10;        self.mark_for_removal = False&#10;&#10;        # 체력바 UI&#10;        self.health_bar = MonsterHealthBar(self)&#10;&#10;        # 현재 실행 중인 공격 패턴 인스턴스 (드로잉 책임 위임용)&#10;        self.current_action_instance = None&#10;&#10;        # 6가지 공격 패턴 클래스 인스턴스 생성&#10;        self.pattern1_action = AttackPattern1Action(self)&#10;        self.pattern2_action = AttackPattern2Action(self)&#10;        self.pattern3_action = AttackPattern3Action(self)&#10;        self.pattern4_action = AttackPattern4Action(self)&#10;        self.pattern5_action = AttackPattern5Action(self)&#10;        self.pattern6_action = AttackPattern6Action(self)&#10;&#10;        # 임시 스프라이트 (실제 게임에서는 이미지 로드)&#10;        # 일반적으로 Idle 애니메이션 스프라이트 시트 사용&#10;        # 사망시 Death 애니메이션 스프라이트 시트 사용&#10;        self.images = None&#10;        self.clone_images = None&#10;&#10;        # 사망 애니메이션 관련 변수&#10;        self.is_dead = False&#10;        self.death_images = None&#10;        self.death_frame = 0&#10;        self.death_frame_timer = 0.0&#10;        self.death_frame_speed = 5.0  # 초당 프레임 수&#10;        self.death_animation_frames = 16  # 0~15 총 16개 프레임&#10;&#10;        try:&#10;            # Idle 애니메이션 로드&#10;            for i in range(self.animation_frames):&#10;                try:&#10;                    img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_Idle{i:02d}.png'&#10;                    img = p2.load_image(img_path)&#10;                    if self.images is None:&#10;                        self.images = []&#10;                    self.images.append(img)&#10;&#10;                    # 경로 등록 후 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    if self.clone_images is None:&#10;                        self.clone_images = []&#10;                    self.clone_images.append(clone_img)&#10;&#10;                    # DEBUG: 이미지 로드 확인&#10;                    # print(f'[PantherAssassin] 이미지 로드 성공: PantherAssassin_Idle{i:02d}.png')&#10;&#10;                except FileNotFoundError as e:&#10;                    print(f'\033[91m[PantherAssassin] 이미지 로드 실패: {e}\033[0m')&#10;&#10;            # Death 애니메이션 로드 (0~15)&#10;            self.death_images = []&#10;&#10;            for i in range(3):&#10;                try:&#10;                    Airborne_img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_Airborne{i:02d}.png'&#10;                    Airborne_img = p2.load_image(Airborne_img_path)&#10;                    self.death_images.append(Airborne_img)&#10;                    # print(f'[PantherAssassin] 사망 애니메이션 로드 성공: PantherAssassin_Knockback{i:02d}.png')&#10;                except FileNotFoundError as e:&#10;                    print(f'\033[91m[PantherAssassin] 사망 애니메이션 로드 실패: {e}\033[0m')&#10;&#10;            for i in range(self.death_animation_frames):&#10;                try:&#10;                    death_img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_TrueDie{i:02d}.png'&#10;                    death_img = p2.load_image(death_img_path)&#10;                    self.death_images.append(death_img)&#10;                    # print(f'[PantherAssassin] 사망 애니메이션 로드 성공: PantherAssassin_TrueDie{i:02d}.png')&#10;                except FileNotFoundError as e:&#10;                    print(f'\033[91m[PantherAssassin] 사망 애니메이션 로드 실패: {e}\033[0m')&#10;&#10;        except Exception as e:&#10;            print(f'\033[91m[PantherAssassin] 이미지 로드 중 오류 발생: {e}\033[0m')&#10;&#10;        # 행동 트리 빌드&#10;        self.build_behavior_tree()&#10;&#10;        print(f&quot;[PantherAssassin] 생성됨 at ({x}, {y})&quot;)&#10;&#10;    def build_behavior_tree(self):&#10;        &quot;&quot;&quot;&#10;        행동 트리 구축&#10;&#10;        구조:&#10;        Root Selector&#10;        ├── Attack Sequence (공격 시도)&#10;        │   ├── Condition: 쿨타임 준비됨&#10;        │   ├── Condition: 공격 범위 내&#10;        │   └── RandomSelector: 6가지 패턴 중 랜덤 선택&#10;        │       ├── BTActionWrapper: 패턴1 - 120도 방사형으로 플레이어를 향해 2단 표창 투척&#10;        │       ├── BTActionWrapper: 패턴2 - 은신 후 다른 곳에서 나타나 플레이어를 향해 강한 돌진 공격 2회&#10;        │       ├── BTActionWrapper: 패턴3 - 3단 콤보 공격&#10;        │       │   # 그림자 분신과 함게하는 패턴 4, 5, 6&#10;        │       ├── BTActionWrapper: 패턴4 - 은신과 분신 2체를 랜덤 위치에 소환 후 플레이어를 향해 수리검 10회 연속 투척 이후 본체 은신 풀림&#10;        │       ├── BTActionWrapper: 패턴5 - 분신 1체 랜덤 위치에 소환후 모든 방향 방사형으로 수리검 투척 2회 ( 두 번째 투척 수리검의 속도는 첫 번째 투척 속도의 반 )&#10;        │       └── BTActionWrapper: 패턴6 - 분신 2체 램덤 위치에 소환후 본체, 분신 2체 번갈아 가며 플레이어를 향해 수리검 5개 방사형으로 3회씩 투척&#10;        └── Action: 대기 ( Idle )&#10;&#10;        ★ 핵심: BTActionWrapper를 사용하여 패턴 클래스 인스턴스를 BT에 연결&#10;        &quot;&quot;&quot;&#10;&#10;        # 6가지 공격 패턴을 RandomSelector로 구성&#10;        # BTActionWrapper를 사용하여 패턴 클래스 인스턴스를 감쌈&#10;        attack_pattern_selector = RandomSelector(&#10;            &quot;Random Attack Pattern&quot;,&#10;            # BTActionWrapper(&quot;Pattern1: ThrowingStars&quot;, self.pattern1_action),&#10;            # BTActionWrapper(&quot;Pattern2: DashAttack&quot;, self.pattern2_action),&#10;            # BTActionWrapper(&quot;Pattern3: ComboAttack&quot;, self.pattern3_action),&#10;            # BTActionWrapper(&quot;Pattern4: Teleport&quot;, self.pattern4_action),&#10;            # BTActionWrapper(&quot;Pattern5: Whirlwind&quot;, self.pattern5_action),&#10;            BTActionWrapper(&quot;Pattern6: Shadow Clone&quot;, self.pattern6_action)&#10;        )&#10;&#10;        # 공격 시퀀스: 쿨타임 체크 -&gt; 범위 체크 -&gt; 패턴 실행&#10;        attack_sequence = Sequence(&#10;            &quot;Try Attack&quot;,&#10;            Condition(&quot;Attack Ready&quot;, self.is_attack_ready),&#10;            Condition(&quot;In Attack Range&quot;, self.is_in_attack_range),&#10;            attack_pattern_selector&#10;        )&#10;&#10;        # 루트 셀렉터: 공격 가능하면 공격, 아니면 대기/순찰&#10;        root = Selector(&#10;            &quot;Root&quot;,&#10;            attack_sequence,&#10;            Action(&quot;Idle or Patrol&quot;, self.handle_idle_action)&#10;        )&#10;&#10;        # 행동 트리 생성&#10;        self.behavior_tree = BehaviorTree(root)&#10;        print(&quot;[PantherAssassin] 행동 트리 빌드 완료 (BTActionWrapper 적용 완료)&quot;)&#10;&#10;    # ==================== 조건 체크 메서드 ====================&#10;&#10;    def is_attack_ready(self):&#10;        &quot;&quot;&quot;공격 쿨타임이 준비되었는지 확인&quot;&quot;&quot;&#10;        return self.attack_timer &lt;= 0.0&#10;&#10;    def is_in_attack_range(self):&#10;        &quot;&quot;&quot;타겟이 공격 범위 내에 있는지 확인&quot;&quot;&quot;&#10;        if self.target is None:&#10;            return False&#10;&#10;        dx = self.target.x - self.x&#10;        dy = self.target.y - self.y&#10;        distance = math.sqrt(dx**2 + dy**2)&#10;&#10;        return distance &lt;= self.attack_range&#10;&#10;    # ==================== 행동 액션 메서드 ====================&#10;&#10;    def handle_idle_action(self):&#10;        &quot;&quot;&quot;&#10;        대기 행동&#10;&#10;        PantherAssassin은 패턴 기반 보스이므로 플레이어를 추적하지 않고&#10;        제자리에서 대기합니다.&#10;        &quot;&quot;&quot;&#10;        # 플레이어 추적 로직 제거 - 패턴으로만 위치 이동&#10;        return BehaviorTree.SUCCESS&#10;&#10;    # ==================== 업데이트 &amp; 렌더링 ====================&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;매 프레임 업데이트&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 사망 상태일 경우 사망 애니메이션만 재생&#10;        if self.is_dead:&#10;            self.death_frame_timer += dt&#10;            if self.death_frame_timer &gt;= 1.0 / self.death_frame_speed:&#10;                self.death_frame += 1&#10;                self.death_frame_timer = 0.0&#10;&#10;                # 사망 애니메이션이 끝나면 (0~15 프레임 완료)&#10;                if self.death_frame &gt;= self.death_animation_frames:&#10;                    print(&quot;[PantherAssassin] 사망 애니메이션 완료 - 제거&quot;)&#10;                    self.mark_for_removal = True&#10;            return  # 사망 애니메이션 진행 중 - 아무것도 반환하지 않음&#10;&#10;        # 무적시간 업데이트&#10;        if self.invincible:&#10;            self.invincible_timer -= dt&#10;            if self.invincible_timer &lt;= 0:&#10;                self.invincible = False&#10;                self.invincible_timer = 0.0&#10;&#10;        # 쿨타임 업데이트&#10;        if self.attack_timer &gt; 0:&#10;            self.attack_timer -= dt&#10;&#10;        # 애니메이션 프레임 업데이트&#10;        self.frame_timer += dt&#10;        if self.frame_timer &gt;= 1.0 / self.frame_speed:&#10;            # 이미지가 로드되었을 때만 프레임 업데이트&#10;            if self.images and len(self.images) &gt; 0:&#10;                self.frame = (self.frame + 1) % len(self.images)&#10;            else:&#10;                self.frame = 0&#10;            self.frame_timer = 0.0&#10;&#10;        # 플레이어 인식 거리 체크 (target이 None일 때 예외 처리)&#10;        if self.target is not None:&#10;            dx = self.target.x - self.x&#10;            dy = self.target.y - self.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            # 인식 거리를 벗어나면 타겟 해제&#10;            if distance &gt;= self.unrecognition_distance:&#10;                self.set_target(None)&#10;                print(f'[PantherAssassin] 타겟 상실 (거리: {distance:.1f})')&#10;        else:&#10;            # 타겟이 없을 때 플레이어 탐색&#10;            if self.world and 'player' in self.world:&#10;                player = self.world['player']&#10;                dx = player.x - self.x&#10;                dy = player.y - self.y&#10;                distance = math.sqrt(dx**2 + dy**2)&#10;&#10;                # 인식 거리 내에 들어오면 타겟 설정&#10;                if distance &lt;= self.recognition_distance:&#10;                    self.set_target(player)&#10;                    print(f'[PantherAssassin] 타겟 인식: 플레이어 at ({player.x}, {player.y}), 거리: {distance:.1f}')&#10;&#10;        # 투사체 업데이트 (보스 전용 투사체 관리)&#10;        self.projectiles = [proj for proj in self.projectiles if proj.update()]&#10;&#10;        # 행동 트리 실행&#10;        if self.behavior_tree:&#10;            self.behavior_tree.run()&#10;&#10;&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        몬스터 렌더링&#10;&#10;        렌더링 우선순위:&#10;        1. 사망 상태일 경우 사망 애니메이션 출력&#10;        2. 패턴 공격 중이면 패턴 전용 모션 출력 (IDLE 모션 숨김)&#10;        3. 패턴 공격이 아니면 IDLE 모션 출력&#10;&#10;        일반적 Hit 일땐 대미지만 적용, (hit 판정의 이미지 시퀀스 x )&#10;        Death 상태 일땐 현재 이미지 시퀀스를 Death 이미지로 교체 후 재생&#10;        1. Hit 판정시 이미지 시퀀스 교체 없이 대미지만 적용&#10;        2. Death 판정시 이미지 시퀀스를 Death 이미지로 교체&#10;        3. Death 이미지 시퀀스 재생 완료 후 몬스터 제거&#10;&#10;        TODO: 1. 몬스터 사망 후 아이템 드랍 구현&#10;        &quot;&quot;&quot;&#10;        # 사망 상태일 경우 사망 애니메이션 출력&#10;        if self.is_dead:&#10;            if self.death_images and len(self.death_images) &gt; 0:&#10;                # 사망 프레임 인덱스가 범위를 벗어나지 않도록 보정&#10;                death_frame_idx = min(self.death_frame, len(self.death_images) - 1)&#10;                death_img = self.death_images[death_frame_idx]&#10;                if death_img:&#10;                    death_img.draw(draw_x, draw_y, death_img.w * self.scale_factor, death_img.h * self.scale_factor)&#10;            return  # 사망 애니메이션 출력 후 나머지는 렌더링하지 않음&#10;&#10;        # 현재 실행 중인 패턴이 있는지 확인&#10;        has_active_pattern = (self.current_action_instance is not None and&#10;                             hasattr(self.current_action_instance, 'phase') and&#10;                             self.current_action_instance.phase &gt; 0)&#10;&#10;        # 패턴 5 실행 중일 때 특별 처리: Phase 1(분신 이동), Phase 6(분신 소멸)에서는 IDLE 모션 표시&#10;        should_show_idle = False&#10;        if (has_active_pattern and&#10;            self.current_action_instance == self.pattern5_action and&#10;            hasattr(self.current_action_instance, 'phase')):&#10;            # Phase 1: 분신 이동 중 - IDLE 모션 표시&#10;            # Phase 6: 분신 소멸 중 - IDLE 모션 표시&#10;            if self.current_action_instance.phase in [1, 6]:&#10;                should_show_idle = True&#10;&#10;        # 패턴 6 실행 중일 때 특별 처리: Phase 1(분신 이동), Phase 4(분신 소멸)에서는 IDLE 모션 표시&#10;        if (has_active_pattern and&#10;            self.current_action_instance == self.pattern6_action and&#10;            hasattr(self.current_action_instance, 'phase')):&#10;            # Phase 1: 분신 이동 중 - IDLE 모션 표시&#10;            # Phase 4: 분신 소멸 중 - IDLE 모션 표시&#10;            if self.current_action_instance.phase in [1, 4]:&#10;                should_show_idle = True&#10;&#10;        # 패턴 4 실행 중일 때는 패턴의 draw() 메서드로 본체 그리기&#10;        if (has_active_pattern and&#10;            self.current_action_instance == self.pattern4_action and&#10;            hasattr(self.current_action_instance, 'draw')):&#10;            # 패턴 4의 draw() 메서드 호출 (은신/해제 애니메이션 처리)&#10;            self.current_action_instance.draw(draw_x, draw_y)&#10;&#10;        # 패턴 5의 특정 phase 또는 패턴 공격 중이 아닐 때 IDLE 모션 드로잉&#10;        elif not has_active_pattern or should_show_idle:&#10;            if self.images and len(self.images) &gt; 0:&#10;                # 프레임 인덱스가 범위를 벗어나지 않도록 보정&#10;                if self.frame &gt;= len(self.images):&#10;                    self.frame = 0&#10;&#10;                img = self.images[self.frame]&#10;                img.draw(draw_x, draw_y, img.w * self.scale_factor, img.h * self.scale_factor)&#10;            else:&#10;                # 디버그 렌더링 (이미지 없을 때)&#10;                p2.draw_rectangle(&#10;                    self.x - self.collision_width / 2,&#10;                    self.y - self.collision_height / 2,&#10;                    self.x + self.collision_width / 2,&#10;                    self.y + self.collision_height / 2&#10;                )&#10;&#10;        # 현재 실행 중인 패턴 인스턴스의 이펙트 드로잉 (드로잉 책임 위임)&#10;        # 패턴이 활성화되어 있으면 패턴의 draw 메서드가 캐릭터 모션과 이펙트를 모두 그림&#10;        # 단, 패턴 5의 Phase 1, 6은 제외 (IDLE 모션만 표시)&#10;        if self.current_action_instance is not None and not should_show_idle:&#10;            # 패턴 인스턴스가 draw 메서드를 가지고 있는지 확인 후 호출&#10;            if hasattr(self.current_action_instance, 'draw'):&#10;                self.current_action_instance.draw(draw_x, draw_y)&#10;&#10;        # 보스 전용 투사체 드로잉 (카메라 좌표 변환 적용)&#10;        for projectile in self.projectiles:&#10;            # 투사체의 월드 좌표를 카메라 좌표로 변환&#10;            proj_draw_x = projectile.x - self.x + draw_x&#10;            proj_draw_y = projectile.y - self.y + draw_y&#10;            projectile.draw(proj_draw_x, proj_draw_y)&#10;&#10;        # 체력바 렌더링 (카메라 좌표 적용)&#10;        self.health_bar.draw(draw_x, draw_y - 70)&#10;&#10;        # DEBUG : 충돌 박스 및 플레이어 인식 범위 그리기&#10;        # 충돌 박스 : 카메라 좌표계로 변환 후 그리기&#10;        Left, Bottom, Right, Top = self.get_bb()&#10;        Left -= self.x - draw_x&#10;        Right -= self.x - draw_x&#10;        Bottom -= self.y - draw_y&#10;        Top -= self.y - draw_y&#10;        p2.draw_rectangle(Left, Bottom, Right, Top, r=255, g=0, b=0)&#10;&#10;        # 공격 범위&#10;        radius = self.recognition_distance&#10;        p2.draw_circle(draw_x, draw_y, int(radius), r=255, g=255, b=0)&#10;&#10;        # 타겟 놓치는 거리&#10;        radius = self.unrecognition_distance&#10;        p2.draw_circle(draw_x, draw_y, int(radius), r=0, g=255, b=255)&#10;&#10;        # 분신 드로잉 (디버그용)&#10;        # if self.clone_images:&#10;        #     offset = 200&#10;        #     self.clone_images[self.frame].draw(draw_x - offset, draw_y,&#10;        #                                        self.clone_images[self.frame].w * self.scale_factor,&#10;        #                                        self.clone_images[self.frame].h * self.scale_factor)&#10;&#10;&#10;    def get_bb(self):&#10;        &quot;&quot;&quot;충돌 박스 반환 (left, bottom, right, top)&quot;&quot;&quot;&#10;        half_w = self.collision_width / 2&#10;        half_h = self.collision_height / 2&#10;        return (&#10;            self.x - half_w + self.collision_box_offset_x,&#10;            self.y - half_h + self.collision_box_offset_y,&#10;            self.x + half_w + self.collision_box_offset_x,&#10;            self.y + half_h + self.collision_box_offset_y&#10;        )&#10;&#10;    def take_damage(self, damage):&#10;        &quot;&quot;&quot;피해를 받음&quot;&quot;&quot;&#10;        # 이미 사망 상태면 무시&#10;        if self.is_dead:&#10;            return False&#10;&#10;        current_health = self.stats.get('health')&#10;        self.stats.set_base('health', max(0, current_health - damage))&#10;        print(f&quot;[PantherAssassin] 피해 {damage}, 남은 HP: {self.stats.get('health')}/{self.stats.get('max_health')}&quot;)&#10;&#10;        if self.stats.get('health') &lt;= 0:&#10;            print(&quot;[PantherAssassin] 사망 - 애니메이션 시작!&quot;)&#10;            # 사망 애니메이션 플래그 설정&#10;            self.is_dead = True&#10;            self.death_frame = 0&#10;            self.death_frame_timer = 0.0&#10;            # 즉시 제거하지 않고 애니메이션이 끝날 때까지 기다림&#10;        return False  # 사망 상태라도 애니메이션이 끝날 때까지 False 반환&#10;&#10;    def set_target(self, target):&#10;        &quot;&quot;&quot;타겟 설정 (주로 플레이어)&quot;&quot;&quot;&#10;        self.target = target&#10;&#10;    # ==================== 피격 판정 메서드 ====================&#10;&#10;    def check_collision_with_effect(self, effect):&#10;        &quot;&quot;&quot;&#10;        플레이어 공격 이펙트와의 충돌 감지&#10;&#10;        Args:&#10;            effect: VFX_Tier1_Sword_Swing 등의 공격 이펙트 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 사망 상태이거나 무적 상태이면 충돌 무시&#10;        if self.is_dead or self.invincible:&#10;            return False&#10;&#10;        # 이펙트의 크기 계산&#10;        if hasattr(effect, 'frames') and len(effect.frames) &gt; 0:&#10;            effect_img = effect.frames[min(effect.frame, len(effect.frames) - 1)]&#10;            effect_width = effect_img.w * effect.scale_factor&#10;            effect_height = effect_img.h * effect.scale_factor&#10;        else:&#10;            # 기본값&#10;            effect_width = 200&#10;            effect_height = 200&#10;&#10;        # AABB 충돌 감지&#10;        panther_left = self.x - self.collision_width / 2&#10;        panther_right = self.x + self.collision_width / 2&#10;        panther_bottom = self.y - self.collision_height / 2&#10;        panther_top = self.y + self.collision_height / 2&#10;&#10;        effect_left = effect.x - effect_width / 2&#10;        effect_right = effect.x + effect_width / 2&#10;        effect_bottom = effect.y - effect_height / 2&#10;        effect_top = effect.y + effect_height / 2&#10;&#10;        # 충돌 검사&#10;        if (panther_left &lt; effect_right and panther_right &gt; effect_left and&#10;            panther_bottom &lt; effect_top and panther_top &gt; effect_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(effect)&#10;            return True&#10;&#10;        return False&#10;&#10;    def check_collision_with_projectile(self, projectile):&#10;        &quot;&quot;&quot;&#10;        플레이어 투사체와의 충돌 감지&#10;&#10;        Args:&#10;            projectile: Projectile을 상속받은 발사체 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 무적 상태이면 충돌 무시&#10;        if self.invincible:&#10;            return False&#10;&#10;        # 발사체 크기&#10;        if hasattr(projectile, 'get_collision_box'):&#10;            projectile_width, projectile_height = projectile.get_collision_box()&#10;        else:&#10;            projectile_width = 30&#10;            projectile_height = 30&#10;&#10;        # AABB 충돌 감지&#10;        panther_left = self.x - self.collision_width / 2&#10;        panther_right = self.x + self.collision_width / 2&#10;        panther_bottom = self.y - self.collision_height / 2&#10;        panther_top = self.y + self.collision_height / 2&#10;&#10;        proj_left = projectile.x - projectile_width / 2&#10;        proj_right = projectile.x + projectile_width / 2&#10;        proj_bottom = projectile.y - projectile_height / 2&#10;        proj_top = projectile.y + projectile_height / 2&#10;&#10;        # 충돌 검사&#10;        if (panther_left &lt; proj_right and panther_right &gt; proj_left and&#10;            panther_bottom &lt; proj_top and panther_top &gt; proj_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(projectile)&#10;            return True&#10;&#10;        return False&#10;&#10;    def on_hit(self, attacker):&#10;        &quot;&quot;&quot;&#10;        피격 시 호출되는 메서드&#10;&#10;        Args:&#10;            attacker: 공격한 객체 (투사체, 이펙트 등)&#10;        &quot;&quot;&quot;&#10;        # 무적 상태라면 무시&#10;        if self.invincible:&#10;            print(f&quot;[PantherAssassin] 무적 상태로 피격 무시 (남은 무적시간: {self.invincible_timer:.2f}초)&quot;)&#10;            return&#10;&#10;        # 무적시간 활성화&#10;        self.invincible = True&#10;        self.invincible_timer = self.invincible_duration&#10;&#10;        # 데미지 계산&#10;        damage = 0&#10;        if hasattr(attacker, 'damage'):&#10;            damage = attacker.damage&#10;        elif hasattr(attacker, 'owner') and hasattr(attacker.owner, 'statss'):&#10;            # 공격자의 스탯에서 데미지 가져오기&#10;            damage = attacker.owner.statss.get('attack_damage')&#10;        else:&#10;            damage = 10.0  # 기본 데미지&#10;&#10;        # 방어력 적용&#10;        defense = self.stats.get('defense')&#10;        final_damage = max(1.0, damage - defense)&#10;&#10;        # 체력 감소&#10;        current_health = self.stats.get('health')&#10;        max_health = self.stats.get('max_health')&#10;        new_health = max(0, current_health - final_damage)&#10;        self.stats.set_base('health', new_health)&#10;&#10;        # 데미지 인디케이터 생성 (월드에 추가)&#10;        if self.world and 'effects_front' in self.world:&#10;            try:&#10;                # 보스 위치 위쪽에 데미지 인디케이터 생성&#10;                damage_indicator = DamageIndicator(&#10;                    self.x,&#10;                    self.y + 50,  # 보스 위치보다 50 픽셀 위에 표시&#10;                    final_damage,&#10;                    duration=1.0,&#10;                    font_size=40  # 보스는 큰 폰트 사용&#10;                )&#10;                self.world['effects_front'].append(damage_indicator)&#10;                print(f&quot;[PantherAssassin] 데미지 인디케이터 생성: {int(final_damage)} 데미지&quot;)&#10;            except Exception as e:&#10;                print(f&quot;[PantherAssassin] 데미지 인디케이터 생성 실패: {e}&quot;)&#10;&#10;        # 피격 정보 출력 (디버그)&#10;        attacker_name = attacker.__class__.__name__&#10;        print(f&quot;\n{'=' * 60}&quot;)&#10;        print(f&quot;[PantherAssassin 피격] at ({int(self.x)}, {int(self.y)})&quot;)&#10;        print(f&quot;  공격자: {attacker_name}&quot;)&#10;        print(f&quot;  원본 데미지: {damage:.1f}&quot;)&#10;        print(f&quot;  방어력: {defense:.1f}&quot;)&#10;        print(f&quot;  최종 데미지: {final_damage:.1f}&quot;)&#10;        print(f&quot;  체력 변화: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})&quot;)&#10;        print(f&quot;  체력 비율: {(new_health / max_health) * 100:.1f}%&quot;)&#10;        print(f&quot;  무적시간: {self.invincible_duration}초 활성화&quot;)&#10;&#10;        # 체력이 0 이하면 사망 처리&#10;        if new_health &lt;= 0:&#10;            print(f&quot;  &gt;&gt;&gt; PantherAssassin 체력 0 - 사망 애니메이션 시작!&quot;)&#10;            print(f&quot;{'=' * 60}\n&quot;)&#10;            # 사망 애니메이션 플래그 설정&#10;            self.is_dead = True&#10;            self.death_frame = 0&#10;            self.death_frame_timer = 0.0&#10;            # 즉시 제거하지 않고 애니메이션이 끝날 때까지 기다림&#10;        else:&#10;            print(f&quot;{'=' * 60}\n&quot;)&#10;&#10;&#10;# ==================== PantherThrowingStar 투사체 클래스 ====================&#10;&#10;class PantherThrowingStar(Projectile):&#10;    &quot;&quot;&quot;&#10;    팬서 암살자 보스의 표창 투사체&#10;    회전하는 애니메이션과 함께 날아가는 표창입니다.&#10;    &quot;&quot;&quot;&#10;    image_seq = []&#10;&#10;    def __init__(self, x, y, target_x, target_y, speed=400, from_player=False, damage=15, scale=1.2):&#10;        &quot;&quot;&quot;&#10;        PantherThrowingStar 초기화&#10;&#10;        Args:&#10;            x, y: 시작 위치&#10;            target_x, target_y: 목표 위치&#10;            speed: 투사체 속도&#10;            from_player: 플레이어가 발사했는지 여부&#10;            damage: 투사체 피해량&#10;            scale: 이미지 크기 배율&#10;        &quot;&quot;&quot;&#10;        super().__init__(x, y, target_x, target_y, speed, from_player)&#10;&#10;        # 투사체 속성&#10;        self.damage = damage&#10;        self.scale = scale&#10;        self.collision_width = int(13 * scale)&#10;        self.collision_height = int(20 * scale)&#10;&#10;        # 애니메이션 관련 변수&#10;        self.animation_timer = 0.0&#10;        self.animation_frame = 0&#10;        self.animation_frame_duration = 0.1  # 각 프레임당 0.1초&#10;&#10;        # 이미지 로드 (클래스 레벨에서 한 번만)&#10;        if not PantherThrowingStar.image_seq:&#10;            try:&#10;                for i in range(4):&#10;                    img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/FX/PantherAssassin_ShurikenBullet{i:02d}.png'&#10;                    PantherThrowingStar.image_seq.append(p2.load_image(img_path))&#10;                print(f'[PantherThrowingStar] 이미지 로드 완료: {len(PantherThrowingStar.image_seq)}개 애니메이션 프레임')&#10;            except FileNotFoundError as e:&#10;                print(f'\033[91m[PantherThrowingStar] 이미지 로드 실패: {e}\033[0m')&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;표창 업데이트&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 애니메이션 업데이트&#10;        self.animation_timer += dt&#10;        if self.animation_timer &gt;= self.animation_frame_duration:&#10;            self.animation_timer -= self.animation_frame_duration&#10;            self.animation_frame = (self.animation_frame + 1) % len(PantherThrowingStar.image_seq)&#10;&#10;        # 일반 이동 로직&#10;        self.x += self.dx * self.speed * dt&#10;        self.y += self.dy * self.speed * dt&#10;&#10;        # 화면 밖으로 나가면 제거&#10;        if (self.x &lt; -1000 or self.x &gt; 5000 or&#10;            self.y &lt; -1000 or self.y &gt; 5000):&#10;            return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;표창 드로잉&quot;&quot;&quot;&#10;        if PantherThrowingStar.image_seq and self.animation_frame &lt; len(PantherThrowingStar.image_seq):&#10;            # 애니메이션 프레임 렌더링 (회전 없이)&#10;            img = PantherThrowingStar.image_seq[self.animation_frame]&#10;            if img:&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;        else:&#10;            # 디버그 렌더링 (이미지 없을 때)&#10;            size = int(10 * self.scale)&#10;            p2.draw_rectangle(&#10;                draw_x - size, draw_y - size,&#10;                draw_x + size, draw_y + size&#10;            )&#10;&#10;        # DEBUG: 충돌 박스 그리기&#10;        # Left = draw_x - self.collision_width / 2&#10;        # Right = draw_x + self.collision_width / 2&#10;        # Bottom = draw_y - self.collision_height / 2&#10;        # Top = draw_y + self.collision_height / 2&#10;        # p2.draw_rectangle(Left, Bottom, Right, Top, r=0, g=255, b=0)&#10;&#10;    def on_hit(self):&#10;        &quot;&quot;&quot;투사체가 타겟에 명중했을 때 호출&quot;&quot;&quot;&#10;        pass&#10;&#10;    def get_collision_box(self):&#10;        &quot;&quot;&quot;충돌 박스 반환&quot;&quot;&quot;&#10;        return (self.collision_width, self.collision_height)&#10;&#10;# ==================== PantherShuriken 투사체 클래스 ====================&#10;class PantherShuriken(Projectile):&#10;    &quot;&quot;&quot;&#10;    팬서 암살자 보스의 단검 투사체&#10;    날아가는 동안은 ThrowingDagger0.png를 표시하고,&#10;    소멸 시에는 ThrowingDagger1~4 애니메이션을 재생합니다.&#10;    &quot;&quot;&quot;&#10;    flying_image = None&#10;    dissolve_images = []&#10;&#10;    def __init__(self, x, y, target_x, target_y, speed=400, from_player=False, damage=15, scale=1.2):&#10;        &quot;&quot;&quot;&#10;        PantherShuriken 초기화&#10;&#10;        Args:&#10;            x, y: 시작 위치&#10;            target_x, target_y: 목표 위치&#10;            speed: 투사체 속도&#10;            from_player: 플레이어가 발사했는지 여부&#10;            damage: 투사체 피해량&#10;            scale: 이미지 크기 배율&#10;        &quot;&quot;&quot;&#10;        super().__init__(x, y, target_x, target_y, speed, from_player)&#10;&#10;        # 투사체 속성&#10;        self.damage = damage&#10;        self.scale = scale&#10;        self.collision_width = int(13 * scale)&#10;        self.collision_height = int(41 * scale) // 2&#10;&#10;        # 회전 각도 계산 (원본 이미지가 위쪽을 바라봄, +y 방향 기준)&#10;        # math.atan2를 사용하여 방향 벡터로부터 각도 계산&#10;        import math&#10;        self.rotation_angle = math.atan2(self.dy, self.dx) + math.radians(-90) # 라디안 단위&#10;&#10;        # 상태 관리 변수&#10;        self.is_dissolving = False  # 소멸 애니메이션 재생 중인지&#10;        self.dissolve_frame = 0  # 현재 소멸 애니메이션 프레임&#10;        self.dissolve_timer = 0.0  # 소멸 애니메이션 타이머&#10;        self.dissolve_frame_duration = 0.08  # 각 소멸 프레임당 0.08초&#10;&#10;        # 이미지 로드 (클래스 레벨에서 한 번만)&#10;        if PantherShuriken.flying_image is None or not PantherShuriken.dissolve_images:&#10;            try:&#10;                # 비행 중 이미지 (ThrowingDagger0.png)&#10;                flying_img_path = 'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/FX/ThrowingDagger0.png'&#10;                PantherShuriken.flying_image = p2.load_image(flying_img_path)&#10;                print(f'[PantherShuriken] 비행 이미지 로드 완료: {flying_img_path}')&#10;&#10;                # 소멸 애니메이션 이미지 (ThrowingDagger1.png ~ ThrowingDagger4.png)&#10;                PantherShuriken.dissolve_images = []&#10;                for i in range(1, 5):  # 1, 2, 3, 4&#10;                    dissolve_img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/FX/ThrowingDagger{i}.png'&#10;                    PantherShuriken.dissolve_images.append(p2.load_image(dissolve_img_path))&#10;                print(f'[PantherShuriken] 소멸 애니메이션 이미지 로드 완료: {len(PantherShuriken.dissolve_images)}개 프레임')&#10;            except FileNotFoundError as e:&#10;                print(f'\033[91m[PantherShuriken] 이미지 로드 실패: {e}\033[0m')&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;단검 업데이트&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 소멸 애니메이션 중이면 애니메이션만 업데이트&#10;        if self.is_dissolving:&#10;            self.dissolve_timer += dt&#10;            if self.dissolve_timer &gt;= self.dissolve_frame_duration:&#10;                self.dissolve_timer -= self.dissolve_frame_duration&#10;                self.dissolve_frame += 1&#10;&#10;                # 모든 소멸 프레임을 다 재생했으면 제거&#10;                if self.dissolve_frame &gt;= len(PantherShuriken.dissolve_images):&#10;                    return False&#10;&#10;            return True&#10;&#10;        # 일반 비행 로직&#10;        self.x += self.dx * self.speed * dt&#10;        self.y += self.dy * self.speed * dt&#10;&#10;        # 화면 밖으로 나가면 소멸 애니메이션 시작&#10;        if (self.x &lt; -1000 or self.x &gt; 5000 or&#10;            self.y &lt; -1000 or self.y &gt; 5000):&#10;            self.start_dissolve()&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;단검 드로잉 (회전 적용)&quot;&quot;&quot;&#10;        # 소멸 애니메이션 중이면 소멸 이미지 그리기 (회전 적용)&#10;        if self.is_dissolving:&#10;            if (PantherShuriken.dissolve_images and&#10;                self.dissolve_frame &lt; len(PantherShuriken.dissolve_images)):&#10;                img = PantherShuriken.dissolve_images[self.dissolve_frame]&#10;                if img:&#10;                    # 회전을 적용하여 그리기&#10;                    img.rotate_draw(self.rotation_angle, draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;        else:&#10;            # 비행 중이면 비행 이미지 그리기 (회전 적용)&#10;            if PantherShuriken.flying_image:&#10;                img = PantherShuriken.flying_image&#10;                # 회전을 적용하여 그리기&#10;                img.rotate_draw(self.rotation_angle, draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;            else:&#10;                # 디버그 렌더링 (이미지 없을 때)&#10;                size = int(10 * self.scale)&#10;                p2.draw_rectangle(&#10;                    draw_x - size, draw_y - size,&#10;                    draw_x + size, draw_y + size&#10;                )&#10;&#10;        # DEBUG: 충돌 박스 그리기 (필요 시 주석 해제)&#10;        Left = draw_x - self.collision_width / 2&#10;        Right = draw_x + self.collision_width / 2&#10;        Bottom = draw_y - self.collision_height / 2&#10;        Top = draw_y + self.collision_height / 2&#10;        p2.draw_rectangle(Left, Bottom, Right, Top, r=0, g=255, b=0)&#10;&#10;    def on_hit(self):&#10;        &quot;&quot;&quot;투사체가 타겟에 명중했을 때 호출 - 소멸 애니메이션 시작&quot;&quot;&quot;&#10;        self.start_dissolve()&#10;&#10;    def start_dissolve(self):&#10;        &quot;&quot;&quot;소멸 애니메이션 시작&quot;&quot;&quot;&#10;        if not self.is_dissolving:&#10;            self.is_dissolving = True&#10;            self.dissolve_frame = 0&#10;            self.dissolve_timer = 0.0&#10;&#10;    def get_collision_box(self):&#10;        &quot;&quot;&quot;충돌 박스 반환&quot;&quot;&quot;&#10;        # 소멸 중일 때는 충돌 판정 없음&#10;        if self.is_dissolving:&#10;            return (0, 0)&#10;        return (self.collision_width, self.collision_height)&#10;&#10;&#10;class Clone:&#10;    &quot;&quot;&quot;&#10;    분신 객체 - 시각 효과 전용&#10;&#10;    주의: play_mode의 entities 레이어에서 정상 작동하려면&#10;          일부 더미 속성/메서드가 필요합니다.&#10;    &quot;&quot;&quot;&#10;    def __init__(self, start_x, start_y, target_x, target_y, images, scale_factor):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            start_x, start_y: 시작 위치 (본체 위치)&#10;            target_x, target_y: 목표 위치 (이동할 위치)&#10;            images: 애니메이션에 사용할 이미지 딕셔너리 {'throw_1st': [...], 'throw_2nd': [...], 'move': [...], 'die': [...]}&#10;            scale_factor: 본체의 스케일 팩터&#10;        &quot;&quot;&quot;&#10;        print(f&quot;[Clone.__init__] 분신 생성 시작 - 시작: ({start_x:.0f}, {start_y:.0f}), 목표: ({target_x:.0f}, {target_y:.0f})&quot;)&#10;&#10;        self.start_x = start_x&#10;        self.start_y = start_y&#10;        self.x = start_x&#10;        self.y = start_y&#10;        self.target_x = target_x&#10;        self.target_y = target_y&#10;        self.images = images&#10;        self.scale_factor = scale_factor  # 본체와 동일한 스케일 사용&#10;&#10;        # 이미지 딕셔너리 검증&#10;        print(f&quot;[Clone.__init__] 이미지 딕셔너리 키: {list(images.keys())}&quot;)&#10;        for key, img_list in images.items():&#10;            print(f&quot;[Clone.__init__] {key}: {len(img_list)}개 이미지&quot;)&#10;            if len(img_list) == 0:&#10;                print(f&quot;[Clone.__init__] 경고: {key} 이미지 리스트가 비어있음!&quot;)&#10;&#10;        # 이동 관련&#10;        self.move_duration = 1.5  # 이동 시간 (1.5초로 변경)&#10;        self.move_timer = 0.0&#10;        self.is_moving = True&#10;&#10;        # 잔상 효과&#10;        self.afterimage_alpha = 1.0  # 시작 위치의 잔상 투명도&#10;        self.afterimage_fade_duration = 0.5  # 잔상 사라지는 시간&#10;&#10;        # 애니메이션&#10;        self.current_animation = 'move'&#10;        self.frame = 0&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.1  # 프레임당 시간&#10;&#10;        # 사라지는 애니메이션 관련&#10;        self.is_dying = False  # 사라지는 애니메이션 재생 중 플래그&#10;        self.die_frame = 0  # Die 애니메이션 현재 프레임&#10;        self.die_frame_duration = 0.08  # Die 애니메이션 프레임당 시간&#10;        self.die_animation_frames = 11  # Die 애니메이션 프레임 수 (0~10)&#10;&#10;        # 제거 플래그 (entities에서 자동 제거되도록)&#10;        self.to_be_removed = False&#10;&#10;        print(f&quot;[Clone.__init__] 분신 생성 완료!&quot;)&#10;&#10;        # play_mode 호환성을 위한 더미 속성 추가&#10;        self.mark_for_removal = False  # play_mode의 제거 플래그&#10;        self.hp = 1  # 더미 체력 (충돌 검사에서 필요할 수 있음)&#10;        self.is_dead = False  # 더미 사망 플래그&#10;&#10;        # 디버깅: 생성 직후 첫 업데이트 강제 호출 테스트&#10;        print(f&quot;[Clone.__init__] 테스트: 생성 직후 update() 호출 가능 여부 확인&quot;)&#10;        try:&#10;            # update()를 호출하지는 않고, 대신 필수 속성들이 모두 있는지만 확인&#10;            assert hasattr(self, 'x'), &quot;x 속성 누락!&quot;&#10;            assert hasattr(self, 'y'), &quot;y 속성 누락!&quot;&#10;            assert hasattr(self, 'images'), &quot;images 속성 누락!&quot;&#10;            assert hasattr(self, 'update'), &quot;update 메서드 누락!&quot;&#10;            assert hasattr(self, 'draw'), &quot;draw 메서드 누락!&quot;&#10;            print(f&quot;[Clone.__init__] ✓ 필수 속성/메서드 검증 완료&quot;)&#10;        except AssertionError as e:&#10;            print(f&quot;\033[91m[Clone.__init__] ✗ 속성 검증 실패: {e}\033[0m&quot;)&#10;&#10;    def start_dying(self):&#10;        &quot;&quot;&quot;&#10;        분신 사라지는 애니메이션 시작&#10;        외부에서 이 메서드를 호출하여 분신을 제거 시작&#10;        &quot;&quot;&quot;&#10;        if not self.is_dying:&#10;            print(f&quot;[Clone.start_dying] 분신 사라지는 애니메이션 시작 - 위치: ({self.x:.0f}, {self.y:.0f})&quot;)&#10;            self.is_dying = True&#10;            self.die_frame = 0&#10;            self.frame_timer = 0.0&#10;            self.current_animation = 'die'&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;분신 업데이트 (play_mode에서 파라미터 없이 호출됨)&quot;&quot;&quot;&#10;        try:&#10;            # 첫 업데이트에만 로그 출력&#10;            if not hasattr(self, '_update_logged'):&#10;                print(f&quot;[Clone.update] 첫 업데이트 - 위치: ({self.x:.0f}, {self.y:.0f}), is_moving: {self.is_moving}&quot;)&#10;                self._update_logged = True&#10;&#10;            # dt는 내부에서 가져오기&#10;            dt = framework.get_delta_time()&#10;&#10;            # 사라지는 애니메이션 재생 중&#10;            if self.is_dying:&#10;                self.frame_timer += dt&#10;                if self.frame_timer &gt;= self.die_frame_duration:&#10;                    self.frame_timer = 0.0&#10;                    self.die_frame += 1&#10;                    &#10;                    # Die 애니메이션 완료 시 제거 플래그 설정&#10;                    if self.die_frame &gt;= self.die_animation_frames:&#10;                        print(f&quot;[Clone.update] Die 애니메이션 완료 - 제거 플래그 설정&quot;)&#10;                        self.mark_for_removal = True&#10;                        self.to_be_removed = True&#10;                        return True  # 제거 대기&#10;                &#10;                return True  # 애니메이션 재생 중&#10;&#10;            # 일반 동작 (이동 및 투척 애니메이션)&#10;            if self.is_moving:&#10;                self.move_timer += dt&#10;                progress = min(1.0, self.move_timer / self.move_duration)&#10;&#10;                # 부드러운 이동 (easeOutCubic)&#10;                ease_progress = 1 - pow(1 - progress, 3)&#10;                self.x = self.start_x + (self.target_x - self.start_x) * ease_progress&#10;                self.y = self.start_y + (self.target_y - self.start_y) * ease_progress&#10;&#10;                # 잔상 투명도 감소&#10;                self.afterimage_alpha = max(0.0, 1.0 - (self.move_timer / self.afterimage_fade_duration))&#10;&#10;                if progress &gt;= 1.0:&#10;                    self.is_moving = False&#10;                    self.current_animation = 'throw_1st'  # 이동 완료 후 투척 준비&#10;                    self.frame = 0&#10;                    print(f&quot;[Clone.update] 이동 완료! 위치: ({self.x:.0f}, {self.y:.0f})&quot;)&#10;&#10;            # 프레임 애니메이션&#10;            self.frame_timer += dt&#10;            if self.frame_timer &gt;= self.frame_duration:&#10;                self.frame_timer = 0.0&#10;&#10;                # 현재 애니메이션에 따라 프레임 업데이트&#10;                if self.current_animation in self.images:&#10;                    img_list = self.images[self.current_animation]&#10;&#10;                    if self.current_animation == 'move':&#10;                        # Move 애니메이션은 반복 재생&#10;                        if len(img_list) &gt; 0:&#10;                            self.frame = (self.frame + 1) % len(img_list)&#10;                    elif self.current_animation in ['whirlwind']:&#10;                        # Whirlwind 애니메이션은 반복 재생&#10;                        if len(img_list) &gt; 0:&#10;                            self.frame = (self.frame + 1) % len(img_list)&#10;                    elif self.current_animation in ['throw_1st', 'throw_2nd', 'withdraw']:&#10;                        # 투척 및 Withdraw 애니메이션은 한 번만 재생&#10;                        if len(img_list) &gt; 0 and self.frame &lt; len(img_list) - 1:&#10;                            self.frame += 1&#10;                else:&#10;                    print(f&quot;[Clone.update] 경고: {self.current_animation} 이미지가 없음!&quot;)&#10;&#10;            # update 메서드는 True를 반환해야 entities에서 유지됨&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Clone.update] 오류 발생: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            return True  # 오류가 나도 객체는 유지&#10;&#10;    def switch_animation(self, animation_type):&#10;        &quot;&quot;&quot;&#10;        애니메이션 변경&#10;        Args:&#10;            animation_type: 'move', 'whirlwind', 'withdraw', 'throw_1st', 'throw_2nd', 'die'&#10;        &quot;&quot;&quot;&#10;        try:&#10;            print(f&quot;[Clone.switch_animation] {self.current_animation} -&gt; {animation_type}&quot;)&#10;            self.current_animation = animation_type&#10;            self.frame = 0&#10;            self.frame_timer = 0.0&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Clone.switch_animation] 오류: {e}\033[0m&quot;)&#10;&#10;    def switch_throw_animation(self, throw_type):&#10;        &quot;&quot;&quot;투척 애니메이션 변경 (1st &lt;-&gt; 2nd) - 하위 호환성 유지&quot;&quot;&quot;&#10;        self.switch_animation(throw_type)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        분신 그리기&#10;        Args:&#10;            draw_x, draw_y: 카메라가 적용된 화면 좌표&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # 디버그: 첫 프레임에만 로그 출력&#10;            if not hasattr(self, '_draw_logged'):&#10;                print(f&quot;[Clone.draw] 첫 그리기 - 화면좌표: ({draw_x:.0f}, {draw_y:.0f}), 월드좌표: ({self.x:.0f}, {self.y:.0f})&quot;)&#10;                print(f&quot;[Clone.draw] 애니메이션: {self.current_animation}, 프레임: {self.frame}&quot;)&#10;                print(f&quot;[Clone.draw] 이미지 개수: {len(self.images.get(self.current_animation, []))}&quot;)&#10;                self._draw_logged = True&#10;&#10;            # Die 애니메이션 재생 중&#10;            if self.is_dying and 'die' in self.images:&#10;                die_img_list = self.images['die']&#10;                if len(die_img_list) &gt; 0 and 0 &lt;= self.die_frame &lt; len(die_img_list):&#10;                    die_img = die_img_list[self.die_frame]&#10;                    die_img.draw(&#10;                        draw_x, draw_y,&#10;                        die_img.w * self.scale_factor,&#10;                        die_img.h * self.scale_factor&#10;                    )&#10;                return  # Die 애니메이션 중에는 다른 것 그리지 않음&#10;&#10;            # 일반 애니메이션 (move, whirlwind, withdraw, throw_1st, throw_2nd)&#10;            if self.current_animation in self.images:&#10;                img_list = self.images[self.current_animation]&#10;                if len(img_list) == 0:&#10;                    print(f&quot;[Clone.draw] 경고: {self.current_animation} 이미지 리스트가 비어있음!&quot;)&#10;                    return&#10;&#10;                if 0 &lt;= self.frame &lt; len(img_list):&#10;                    current_img = img_list[self.frame]&#10;&#10;                    # 현재 위치에 분신 그리기 (카메라 좌표 이미 적용됨)&#10;                    current_img.draw(&#10;                        draw_x, draw_y,&#10;                        current_img.w * self.scale_factor,&#10;                        current_img.h * self.scale_factor&#10;                    )&#10;&#10;                    # 이동 중일 때 잔상 효과 (시작 위치)&#10;                    if self.is_moving and self.afterimage_alpha &gt; 0.0:&#10;                        # 잔상 위치도 카메라 좌표로 변환 필요&#10;                        # play_mode의 camera를 통해 변환&#10;                        from game_logic import play_mode&#10;                        if play_mode.camera is not None:&#10;                            afterimage_draw_x, afterimage_draw_y = play_mode.camera.apply(self.start_x, self.start_y)&#10;                        else:&#10;                            afterimage_draw_x, afterimage_draw_y = self.start_x, self.start_y&#10;&#10;                        current_img.opacify(self.afterimage_alpha)&#10;                        current_img.draw(&#10;                            afterimage_draw_x, afterimage_draw_y,&#10;                            current_img.w * self.scale_factor,&#10;                            current_img.h * self.scale_factor&#10;                        )&#10;                        current_img.opacify(1.0)  # 원래대로 복구&#10;                else:&#10;                    print(f&quot;[Clone.draw] 경고: 프레임 인덱스 범위 초과 - frame={self.frame}, max={len(img_list)-1}&quot;)&#10;            else:&#10;                print(f&quot;[Clone.draw] 경고: {self.current_animation} 키가 이미지 딕셔너리에 없음!&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Clone.draw] 오류 발생: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/player.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/player.py" />
              <option name="originalContent" value="# 패키지 내부 모듈을 직접 실행할 경우 친절한 안내 후 종료&#10;if __name__ == &quot;__main__&quot; and (__package__ is None or __package__ == &quot;&quot;):&#10;    import sys&#10;    print(&quot;이 모듈은 game_logic 패키지 내부 모듈입니다. 프로젝트 루트에서 main.py를 실행하세요.&quot;)&#10;    sys.exit(1)&#10;&#10;import ctypes&#10;import os&#10;import random&#10;import time&#10;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width, draw_rectangle&#10;from sdl2 import (SDL_KEYDOWN, SDL_KEYUP, SDLK_a, SDLK_d, SDLK_w, SDLK_s, SDLK_TAB, SDLK_SPACE, SDL_GetMouseState,&#10;                   SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT)&#10;&#10;from .equipment import EquipmentManager, Sword, Shield&#10;from .state_machine import StateMachine&#10;import game_framework as framework&#10;# 인벤토리 데이터 모델 import&#10;from .inventory import InventoryData, seed_debug_inventory&#10;from .stats import PlayerStats, StatModifier&#10;from .damage_indicator import DamageIndicator&#10;&#10;def Akey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_a&#10;def Akey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_a&#10;def Dkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_d&#10;def Dkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_d&#10;def Wkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_w&#10;def Wkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_w&#10;def Skey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_s&#10;def Skey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_s&#10;&#10;# 스페이스바 입력 검사용 predicate&#10;def Space_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_SPACE&#10;&#10;# 커스텀 이벤트 정의&#10;def move_event(e):&#10;    return e[0] == 'MOVE'&#10;&#10;def stop_event(e):&#10;    return e[0] == 'STOP'&#10;&#10;# 대시 이벤트 정의&#10;def dash_event(e):&#10;    return e[0] == 'DASH'&#10;&#10;def dash_end_event(e):&#10;    return e[0] == 'DASH_END'&#10;&#10;# Tab 키 입력 검사용 predicate (StateMachine 매핑용)&#10;def Tab_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_TAB&#10;&#10;class Run:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix, path):&#10;            files = sorted([f for f in os.listdir(path)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(path, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#10;&#10;        # 파티클 리소스 로드&#10;        particle_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Run_Dust')&#10;        self.particle_frames = load_seq('RunDust_Ver2_', particle_folder)&#10;        self.particle_spawn_timer = 0.0&#10;        self.particle_spawn_interval = 0.15 # 파티클 생성 간격&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Move frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.06&#10;        self.moving_speed = 300 # 초당 픽셀&#10;&#10;    def enter(self, e):&#10;        # 파티클 타이머만 초기화&#10;        self.particle_spawn_timer = 0.0&#10;&#10;    def exit(self, e):&#10;        # 파티클을 제거하지 않고 그대로 둠&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 플레이어 애니메이션 및 위치 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;        # 현재 스탯 기반 이동 속도 사용&#10;        moving_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else self.moving_speed&#10;        dir_magnitude = (self.player.dir[0] ** 2 + self.player.dir[1] ** 2) ** 0.5&#10;        if dir_magnitude &gt; 0:&#10;            norm_dir_x = self.player.dir[0] / dir_magnitude&#10;            norm_dir_y = self.player.dir[1] / dir_magnitude&#10;            new_x = self.player.x + norm_dir_x * moving_speed * dt&#10;            new_y = self.player.y + norm_dir_y * moving_speed * dt&#10;&#10;            # 맵 경계 체크 (카메라/월드 좌표 기반)&#10;            # lobby_mode에서 맵 크기를 가져와 경계 체크&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                # 배경 오브젝트에서 맵 크기 계산&#10;                if world['bg']:&#10;                    bg = world['bg'][0]&#10;                    map_width = bg.image.w * bg.scale&#10;                    map_height = bg.image.h * bg.scale&#10;                    # 맵의 중심이 (0, 0)이므로 경계는 ±map_width/2, ±map_height/2&#10;                    map_left = -map_width / 2&#10;                    map_right = map_width / 2&#10;                    map_bottom = -map_height / 2&#10;                    map_top = map_height / 2&#10;&#10;                    # 플레이어가 맵 경계를 벗어나지 않도록 제한&#10;                    if new_x &lt; map_left:&#10;                        new_x = map_left&#10;                    elif new_x &gt; map_right:&#10;                        new_x = map_right&#10;                    if new_y &lt; map_bottom:&#10;                        new_y = map_bottom&#10;                    elif new_y &gt; map_top:&#10;                        new_y = map_top&#10;            except Exception:&#10;                # 맵 정보를 가져올 수 없으면 화면 경계로 폴백&#10;                if new_x &gt; get_canvas_width():&#10;                    new_x = get_canvas_width()&#10;                elif new_x &lt; 0:&#10;                    new_x = 0&#10;                if new_y &gt; get_canvas_height():&#10;                    new_y = get_canvas_height()&#10;                elif new_y &lt; 0:&#10;                    new_y = 0&#10;&#10;            # 벽 충돌 체크 (플레이어 크기 32x48)&#10;            collided = False&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                for wall in world['walls']:&#10;                    if wall.check_collision(new_x - 32//2, new_y - 48//2, 32, 48):&#10;                        collided = True&#10;                        break&#10;            except Exception:&#10;                pass&#10;            if not collided:&#10;                self.player.x = new_x&#10;                self.player.y = new_y&#10;&#10;&#10;        # 파티클 생성&#10;        self.particle_spawn_timer += dt&#10;        if self.particle_spawn_timer &gt;= self.particle_spawn_interval:&#10;            self.particle_spawn_timer -= self.particle_spawn_interval&#10;            # 플레이어 발밑에 파티클 생성 (월드 좌표 사용)&#10;            # y 오프셋을 줄여서 발 위치에 더 가깝게 배치&#10;            particle_x = self.player.x + random.uniform(-10, 10)&#10;            particle_y = self.player.y - 20 + random.uniform(-5, 5)  # -40에서 -20으로 조정&#10;            new_particle = VFX_Run_Particle(particle_x, particle_y, self.particle_frames, 0.05, 2.0)&#10;            self.player.particles.append(new_particle)&#10;&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;&#10;        # camera 가져오기 - play_mode 우선, lobby_mode로 폴백&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            print(f&quot;\033[91m[player Idle] 카메라 가져오기 실패\033[0m&quot;)&#10;&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;class Dash:&#10;    &quot;&quot;&quot;대시 상태: 스페이스바로 활성화, 빠른 속도로 짧은 거리 이동&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix, path):&#10;            files = sorted([f for f in os.listdir(path)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(path, f)) for f in files]&#10;&#10;        # 대시용 애니메이션 프레임 (Run과 동일한 프레임 사용)&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Dash frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.03  # Run보다 2배 빠른 애니메이션&#10;&#10;        # 대시 설정&#10;        self.dash_duration = 0.15  # 대시 지속 시간 (0.15초)&#10;        self.dash_timer = 0.0  # 대시 경과 시간&#10;        self.dash_speed_multiplier = 4  # Run 속도의 4배&#10;&#10;        # 대시 방향 저장 (enter에서 설정)&#10;        self.dash_direction = [1, 0]  # 기본값: 오른쪽&#10;        self.return_to_idle = False  # Idle로 복귀할지 Run으로 복귀할지&#10;&#10;        # 잔상 이펙트 타이머&#10;        self.trail_timer = 0.0  # 잔상 생성 타이머&#10;        self.trail_interval = 0.04  # 잔상 생성 간격&#10;&#10;    def enter(self, e):&#10;        &quot;&quot;&quot;대시 상태 진입&quot;&quot;&quot;&#10;        # 대시 타이머 초기화&#10;        self.dash_timer = 0.0&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;&#10;        # 잔상 타이머 초기화&#10;        self.trail_timer = 0.0&#10;&#10;        # 무적 시간 활성화 (0.15초)&#10;        self.player.invincible = True&#10;        self.player.invincible_timer = 0.15&#10;        print(f&quot;[Dash] 무적 시간 활성화 (0.15초)&quot;)&#10;&#10;        # 대시 방향 결정&#10;        # Run 상태에서 왔으면 현재 이동 방향으로 대시&#10;        # Idle 상태에서 왔으면 오른쪽(face_dir)으로 대시&#10;        if self.player.dir[0] != 0 or self.player.dir[1] != 0:&#10;            # 이동 중이었으면 그 방향으로 대시&#10;            self.dash_direction = self.player.dir.copy()&#10;            self.return_to_idle = False&#10;            print(f&quot;[Dash] Run에서 대시 시작 - 방향: ({self.dash_direction[0]}, {self.dash_direction[1]})&quot;)&#10;        else:&#10;            # 정지 상태였으면 face_dir 방향으로 대시&#10;            self.dash_direction = [self.player.face_dir, 0]&#10;            self.return_to_idle = True&#10;            print(f&quot;[Dash] Idle에서 대시 시작 - 방향: 오른쪽({self.player.face_dir})&quot;)&#10;&#10;    def exit(self, e):&#10;        &quot;&quot;&quot;대시 상태 종료&quot;&quot;&quot;&#10;        print(f&quot;[Dash] 대시 종료 - {'Idle' if self.return_to_idle else 'Run'}로 복귀&quot;)&#10;        pass&#10;&#10;    def do(self):&#10;        &quot;&quot;&quot;대시 업데이트: 빠른 속도로 이동하고 시간이 지나면 종료&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 대시 타이머 업데이트&#10;        self.dash_timer += dt&#10;&#10;        # 잔상 타이머 업데이트 및 생성&#10;        self.trail_timer += dt&#10;        if self.trail_timer &gt;= self.trail_interval:&#10;            self.trail_timer -= self.trail_interval&#10;            # 잔상 이펙트 생성&#10;            self._create_trail_effect()&#10;&#10;        # 애니메이션 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;        # 대시 이동 처리&#10;        # 현재 스탯 기반 이동 속도 사용&#10;        base_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else 300&#10;        dash_speed = base_speed * self.dash_speed_multiplier&#10;&#10;        # 방향 정규화&#10;        dir_magnitude = (self.dash_direction[0] ** 2 + self.dash_direction[1] ** 2) ** 0.5&#10;        if dir_magnitude &gt; 0:&#10;            norm_dir_x = self.dash_direction[0] / dir_magnitude&#10;            norm_dir_y = self.dash_direction[1] / dir_magnitude&#10;            new_x = self.player.x + norm_dir_x * dash_speed * dt&#10;            new_y = self.player.y + norm_dir_y * dash_speed * dt&#10;&#10;            # 맵 경계 체크 및 벽 충돌 체크 (Run과 동일한 로직)&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                if world['bg']:&#10;                    bg = world['bg'][0]&#10;                    map_width = bg.image.w * bg.scale&#10;                    map_height = bg.image.h * bg.scale&#10;                    map_left = -map_width / 2&#10;                    map_right = map_width / 2&#10;                    map_bottom = -map_height / 2&#10;                    map_top = map_height / 2&#10;&#10;                    if new_x &lt; map_left:&#10;                        new_x = map_left&#10;                    elif new_x &gt; map_right:&#10;                        new_x = map_right&#10;                    if new_y &lt; map_bottom:&#10;                        new_y = map_bottom&#10;                    elif new_y &gt; map_top:&#10;                        new_y = map_top&#10;            except Exception:&#10;                if new_x &gt; get_canvas_width():&#10;                    new_x = get_canvas_width()&#10;                elif new_x &lt; 0:&#10;                    new_x = 0&#10;                if new_y &gt; get_canvas_height():&#10;                    new_y = get_canvas_height()&#10;                elif new_y &lt; 0:&#10;                    new_y = 0&#10;&#10;            # 벽 충돌 체크&#10;            collided = False&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                for wall in world['walls']:&#10;                    if wall.check_collision(new_x - 32//2, new_y - 48//2, 32, 48):&#10;                        collided = True&#10;                        break&#10;            except Exception:&#10;                pass&#10;&#10;            if not collided:&#10;                self.player.x = new_x&#10;                self.player.y = new_y&#10;&#10;        # 대시 지속 시간이 끝나면 상태 전환&#10;        if self.dash_timer &gt;= self.dash_duration:&#10;            # DASH_END 이벤트 발생&#10;            self.player.state_machine.handle_state_event(('DASH_END', None))&#10;&#10;    def _create_trail_effect(self):&#10;        &quot;&quot;&quot;대시 잔상 이펙트를 생성하여 world의 effects_back 레이어에 추가&quot;&quot;&quot;&#10;        try:&#10;            # vfx 모듈에서 DashTrailEffect import&#10;            from .vfx import DashTrailEffect&#10;&#10;            # 현재 플레이어 위치에 잔상 생성&#10;            trail = DashTrailEffect(&#10;                x=self.player.x,&#10;                y=self.player.y,&#10;                face_dir=self.player.face_dir,&#10;                scale=self.player.scale_factor&#10;            )&#10;&#10;            # world의 effects_back 레이어에 추가&#10;            if hasattr(self.player, 'world') and self.player.world:&#10;                if 'effects_back' in self.player.world:&#10;                    self.player.world['effects_back'].append(trail)&#10;                    print(f&quot;[Dash] 잔상 이펙트 생성 at ({self.player.x:.1f}, {self.player.y:.1f})&quot;)&#10;                else:&#10;                    print(f&quot;\033[93m[Dash] world에 effects_back 레이어가 없습니다\033[0m&quot;)&#10;            else:&#10;                print(f&quot;\033[93m[Dash] player.world가 설정되지 않았습니다\033[0m&quot;)&#10;        except Exception as ex:&#10;            print(f&quot;\033[91m[Dash] 잔상 이펙트 생성 실패: {ex}\033[0m&quot;)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;대시 상태 그리기 (Run과 동일한 스타일)&quot;&quot;&quot;&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;&#10;        # camera 가져오기&#10;        camera = None&#10;        try:&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            pass&#10;&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip, draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip, draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip, draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip, draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;class Idle:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix):&#10;            files = sorted([f for f in os.listdir(folder)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(folder, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Idle_Lower')&#10;        self.upper_frames = load_seq('Player_Adventurer_Idle_Upper')&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Idle frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.12&#10;&#10;    def enter(self, e):&#10;        self.player.dir = [0, 0]&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.frame_time_acc += dt&#10;        while self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;&#10;        # camera 가져오기 - play_mode 우선, lobby_mode로 폴백&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            print(f&quot;\033[91m[player Idle] 카메라 가져오기 실패\033[0m&quot;)&#10;&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;&#10;class Inventory:&#10;    &quot;&quot;&quot;인벤토리 상태: enter에서 이미지 로드, draw에서 중앙 오른쪽에 표시 (시뮬레이션 정지 없음)&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.image = None&#10;        self.scale = 1.0&#10;        self.prev_state = None  # 이전 상태 저장용&#10;&#10;    def enter(self, e):&#10;        # 현재 상태를 이전 상태로 저장 (복귀용)&#10;        self.prev_state = self.player.state_machine.cur_state&#10;&#10;        # 이미지 지연 로드(오버레이에서도 사용 가능하도록 유지하되, 여기서는 그리지 않음)&#10;        if self.image is None:&#10;            img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Inventory', 'InventoryBase_New1.png')&#10;            try:&#10;                self.image = load_image(img_path)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load inventory image: {img_path}, {ex}\033[0m&quot;)&#10;                self.image = None&#10;&#10;        # 인벤토리 표시 플래그만 설정 (이동은 유지)&#10;        self.player.inventory_open = True&#10;&#10;    def exit(self, e):&#10;        # 표시 플래그만 해제&#10;        self.player.inventory_open = False&#10;&#10;    def do(self):&#10;        # 현재 키 상태에 따라 Idle/Run의 do를 동적으로 실행&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.do()&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 현재 키 상태에 따라 Idle/Run의 draw를 먼저 실행 (플레이어 표시)&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.draw(draw_x, draw_y)&#10;        # 인벤토리 이미지를 화면 오른쪽에 표시 (카메라 스크롤 영향 없음)&#10;        # if self.image:&#10;        #     canvas_w = get_canvas_width()&#10;        #     canvas_h = get_canvas_height()&#10;        #     inv_x = canvas_w - self.image.w * self.scale // 2 - 20&#10;        #     inv_y = canvas_h // 2&#10;        #     self.image.draw(inv_x, inv_y, self.image.w * self.scale, self.image.h * self.scale)&#10;        pass&#10;&#10;class Death:&#10;    &quot;&quot;&quot;플레이어 사망 상태&quot;&quot;&quot;&#10;    image = None&#10;    hit_fx_images = None  # PlayerHitFX 이미지들&#10;    heart_hit_images = None  # HeartHit 이미지들&#10;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.world = getattr(player, 'world', None)  # play_mode에서 할당된 world 참조&#10;&#10;        if Death.image is None:&#10;            try:&#10;                Death.image = load_image('resources/Texture_organize/Player_character/Adventurer/Player_Adventurer_Down00.png')&#10;                print(f&quot;[Player Death] Loaded Down00 image&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] Failed to load image: {e}\033[0m&quot;)&#10;                Death.image = None&#10;&#10;        # PlayerHitFX 이미지 로드 (1 ~ 9)&#10;        if Death.hit_fx_images is None:&#10;            Death.hit_fx_images = []&#10;            try:&#10;                for i in range(1, 10):  # PlayerHitFX01 ~ PlayerHitFX09&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Die_Animation', f'PlayerHitFX0{i}.png')&#10;                    img = load_image(img_path)&#10;                    Death.hit_fx_images.append(img)&#10;                print(f&quot;[Player Death] PlayerHitFX 이미지 로드 완료: {len(Death.hit_fx_images)}개&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] PlayerHitFX 이미지 로드 실패: {e}\033[0m&quot;)&#10;                Death.hit_fx_images = []&#10;&#10;        # HeartHit 이미지 로드 (0 ~ 8)&#10;        if Death.heart_hit_images is None:&#10;            Death.heart_hit_images = []&#10;            try:&#10;                for i in range(9):  # HeartHit0_0 ~ HeartHit8_0&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Hit_verdict', f'HeartHit{i}_0.png')&#10;                    img = load_image(img_path)&#10;                    Death.heart_hit_images.append(img)&#10;                print(f&quot;[Player Death] HeartHit 이미지 로드 완료: {len(Death.heart_hit_images)}개&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] HeartHit 이미지 로드 실패: {e}\033[0m&quot;)&#10;                Death.heart_hit_images = []&#10;&#10;        self.death_timer = 0.0&#10;        self.death_conversion = 2.0  # 2초 후 변환&#10;        self.death_duration = 6.0  # 6초 후 종료&#10;        self.game_over_conversion_triggered = False&#10;        self.game_over_triggered = False&#10;&#10;        # 넉백 관련 변수 (강한 넉백)&#10;        self.knockback_dx = 0&#10;        self.knockback_dy = 0&#10;        self.knockback_speed = 400  # 강한 넉백&#10;        self.knockback_duration = 0.5  # 0.5초 동안&#10;        self.knockback_timer = 0.0&#10;&#10;        # 애니메이션 관련 변수&#10;        self.hit_fx_frame = 0&#10;        self.hit_fx_time = 0.0&#10;        self.hit_fx_duration = 0.08  # 각 프레임당 0.08초&#10;&#10;        self.heart_hit_frame = 0&#10;        self.heart_hit_time = 0.0&#10;        self.heart_hit_duration = 0.1  # 각 프레임당 0.1초&#10;&#10;        # 사망 위치 저장 (이동 제거, 죽은 자리에서 유지)&#10;        self.death_x = 0&#10;        self.death_y = 0&#10;&#10;        # 사망 모드용 배경 이미지 클래스&#10;        class BGimage:&#10;            &quot;&quot;&quot;사망 모드용 배경 이미지 클래스&quot;&quot;&quot;&#10;&#10;            def __init__(self, image_path):&#10;                try:&#10;                    self.image = load_image(image_path)&#10;                except Exception as e:&#10;                    print(f&quot;[Defeat Mode BG] 이미지 로드 실패: {e}&quot;)&#10;                    self.image = None&#10;&#10;                self.alpha = 0.0 # 투명도 초기값&#10;&#10;            def do(self):&#10;                pass&#10;&#10;            def update(self):&#10;                # 점진적으로 투명도 증가 / 3초 동안 완전 불투명&#10;                if self.alpha &lt; 1.0:&#10;                    self.alpha += framework.get_delta_time() / 3.0 * 2  # 3초에 걸쳐 1.0 도달&#10;                    if self.alpha &gt; 1.0:&#10;                        self.alpha = 1.0&#10;&#10;            def draw(self):&#10;                if self.image:&#10;                    canvas_w = get_canvas_width()&#10;                    canvas_h = get_canvas_height()&#10;                    self.image.opacify(self.alpha)&#10;                    self.image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)&#10;                    self.image.opacify(1.0)&#10;&#10;        # 배경 이미지 인스턴스 생성&#10;        self.BG = BGimage('resources/Texture_organize/UI/Stage_Loading/BlackBG.png')&#10;&#10;    def enter(self, e):&#10;        self.death_timer = 0.0&#10;        self.game_over_triggered = False&#10;        self.knockback_timer = 0.0&#10;&#10;        # 애니메이션 초기화&#10;        self.hit_fx_frame = 0&#10;        self.hit_fx_time = 0.0&#10;        self.heart_hit_frame = 0&#10;        self.heart_hit_time = 0.0&#10;&#10;        # 사망 위치 저장 (현재 월드 좌표 그대로 유지)&#10;        self.death_x = self.player.x&#10;        self.death_y = self.player.y&#10;&#10;        # 플레이어 무장 해제&#10;        self.player.equipment_manager.unequip_all()&#10;&#10;        # 넉백 방향 계산&#10;        if e and len(e) &gt; 1 and e[1] is not None:&#10;            attacker = e[1]&#10;            attacker_x = attacker.x if hasattr(attacker, 'x') else self.player.x&#10;            attacker_y = attacker.y if hasattr(attacker, 'y') else self.player.y&#10;&#10;            if hasattr(attacker, 'owner') and attacker.owner:&#10;                attacker_x = attacker.owner.x&#10;                attacker_y = attacker.owner.y&#10;&#10;            import math&#10;            dx = self.player.x - attacker_x&#10;            dy = self.player.y - attacker_y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            if distance &gt; 0:&#10;                self.knockback_dx = dx / distance&#10;                self.knockback_dy = dy / distance&#10;            else:&#10;                self.knockback_dx = 1.0&#10;                self.knockback_dy = 0.0&#10;        else:&#10;            self.knockback_dx = 1.0&#10;            self.knockback_dy = 0.0&#10;&#10;        print(f&quot;[Player Death State] 사망 상태 시작 (6초 후 defeat_mode로 전환) - 넉백 적용&quot;)&#10;        print(f&quot;[Player Death State] 사망 위치: ({self.death_x:.1f}, {self.death_y:.1f})&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.death_timer += dt&#10;&#10;        # 넉백 효과 적용 (사망 초기 0.5초만, 이후엔 그 자리에 고정)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            # 부드러운 감속&#10;            current_speed = self.knockback_speed * (1.0 - progress) ** 1.5&#10;            self.player.x += self.knockback_dx * current_speed * dt&#10;            self.player.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;        # 넉백 끝난 후에는 위치 고정 (중앙 이동 로직 제거)&#10;&#10;        # PlayerHitFX 애니메이션 업데이트&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#10;            self.hit_fx_time += dt&#10;            if self.hit_fx_time &gt;= self.hit_fx_duration:&#10;                self.hit_fx_time -= self.hit_fx_duration&#10;                self.hit_fx_frame += 1&#10;&#10;        # HeartHit 애니메이션 업데이트&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#10;            self.heart_hit_time += dt&#10;            if self.heart_hit_time &gt;= self.heart_hit_duration:&#10;                self.heart_hit_time -= self.heart_hit_duration&#10;                self.heart_hit_frame += 1&#10;&#10;        # 2초 후 배경 어둡게 시작 (extra_bg 레이어에 배경 추가)&#10;        if self.death_timer &gt;= self.death_conversion and not self.game_over_conversion_triggered:&#10;            self.game_over_conversion_triggered = True&#10;            print(f&quot;[Player Death State] 2초 경과, 배경 어둡게 시작&quot;)&#10;            from .play_mode import world&#10;            # 배경을 extra_bg 레이어에 추가하여 점진적으로 어둡게&#10;            world['extra_bg'].append(self.BG)&#10;            # 플레이어를 extras 레이어로 이동 (UI보다 아래, 배경보다 위에 그려지도록)&#10;            world['extras'].append(self.player)&#10;            if self.player in self.world['entities']:&#10;                world['entities'].remove(self.player)&#10;&#10;        # 6초 후 defeat_mode로 전환&#10;        if self.death_timer &gt;= self.death_duration and not self.game_over_triggered:&#10;            self.game_over_triggered = True&#10;            print(f&quot;[Player Death State] 6초 경과, 패배 모드로 전환&quot;)&#10;            import game_framework&#10;            from . import defeat_mode, play_mode&#10;            # play_mode의 경과 시간을 가져와서 defeat_mode로 전달&#10;            survival_time = getattr(play_mode, 'elapsed_time', 0.0)&#10;            print(f&quot;[Player Death State] 생존 시간: {survival_time:.2f}초&quot;)&#10;            game_framework.change_state(defeat_mode, self.player, survival_time)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 플레이어 사망 이미지 (바닥에 누운 모습)&#10;        # draw_x, draw_y는 이미 카메라가 적용된 화면 좌표이므로 그대로 사용&#10;        if Death.image is not None:&#10;            Death.image.draw(draw_x, draw_y,&#10;                           Death.image.w * self.player.scale_factor,&#10;                           Death.image.h * self.player.scale_factor)&#10;&#10;        # PlayerHitFX 이펙트 (플레이어 위치에 크게)&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#10;            hit_fx_img = Death.hit_fx_images[self.hit_fx_frame]&#10;            scale = 3.0&#10;            hit_fx_img.draw(&#10;                draw_x,&#10;                draw_y,&#10;                hit_fx_img.w * scale,&#10;                hit_fx_img.h * scale&#10;            )&#10;&#10;        # HeartHit 이펙트 (플레이어 위치 기준)&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#10;            heart_hit_img = Death.heart_hit_images[self.heart_hit_frame]&#10;            scale = 3.0&#10;            heart_hit_img.draw(&#10;                draw_x,&#10;                draw_y,&#10;                heart_hit_img.w * scale,&#10;                heart_hit_img.h * scale&#10;            )&#10;&#10;&#10;# 사망 이벤트 predicate&#10;def die(e):&#10;    return e[0] == 'DIE'&#10;&#10;&#10;class Player:&#10;    def __init__(self):&#10;        self.x = get_canvas_width() // 2&#10;        self.y = get_canvas_height() // 2&#10;        self.death_x = self.x&#10;        self.death_y = self.y&#10;        self.frame = 0&#10;        self.dir = [0, 0]  # x, y 방향 벡터&#10;        self.face_dir = 1&#10;        self.scale_factor = 3.0&#10;        self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;        self.moving = False # 이동 상태 플래그&#10;        self.particles = [] # 파티클 리스트를 Player로 이동&#10;        self.attack_effects = [] # 공격 이펙트 리스트&#10;        self.dash_stack_max = 3 # 대시 최대 스택&#10;        self.dash_stack = self.dash_stack_max # 대시 스택 초기화&#10;        self.dash_recharge_time = 3.0 # 대시 재충전 시간(초당 1회 충전)&#10;        self.dash_recharge_timer = 0.0 # 대시 재충전 타이머&#10;&#10;        # 플레이어 히트박스 변수&#10;        self.collision_width = 15 * self.scale_factor&#10;        self.collision_height = 15 * self.scale_factor&#10;&#10;        # 무적시간 관련 변수&#10;        self.invincible = False  # 무적 상태인지&#10;        self.invincible_timer = 0.0  # 무적 시간 타이머&#10;        self.invincible_duration = 0.3  # 무적 시간 지속 시간 (0.3초)&#10;&#10;        # 넉백 관련 변수 (방패 방어 시 사용)&#10;        self.knockback_dx = 0.0&#10;        self.knockback_dy = 0.0&#10;        self.knockback_speed = 0.0&#10;        self.knockback_duration = 0.0&#10;        self.knockback_timer = 0.0&#10;&#10;        # 방패 깨짐 상태 변수&#10;        self.shield_broken = False  # 방패가 깨졌는지 여부&#10;&#10;        # 아이템별 개별 쿨타임 관리 시스템&#10;        # key: item.id (아이템 고유 ID), value: 남은 쿨타임 시간(초)&#10;        self.item_cooldowns = {}  # 각 아이템의 남은 쿨타임을 저장&#10;&#10;        # 인벤토리 데이터 생성 및 디버그 아이템 채우기&#10;        self.inventory = InventoryData(cols=6, rows=5)&#10;        try:&#10;            seed_debug_inventory(self.inventory)&#10;        except Exception as ex:&#10;            print('[Player] 디버그 인벤토리 시드 실패:', ex)&#10;&#10;        # 스탯 시스템&#10;        self.stats = PlayerStats()&#10;        # 인벤토리 패시브 적용&#10;        try:&#10;            self.rebuild_inventory_passives()&#10;        except Exception as ex:&#10;            print('[Player] 패시브 재구성 실패:', ex)&#10;&#10;        # 장비 매니저 초기화&#10;        self.equipment_manager = EquipmentManager(self)&#10;&#10;        # 기본 무기 장착 (Tier1 검과 방패)&#10;        sword_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Sword_Tier1.png')&#10;        shield_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Shield_Tier1.png')&#10;&#10;        self.sword = Sword(self, sword_path, scale=3.0)&#10;        self.shield = Shield(self, shield_path, scale=3.0)&#10;&#10;        self.equipment_manager.equip(self.sword)&#10;        self.equipment_manager.equip(self.shield)&#10;&#10;        # 상태 정의&#10;        self.IDLE = Idle(self)&#10;        self.RUN = Run(self)&#10;        self.DASH = Dash(self)  # 대시 상태 추가&#10;        self.INVENTORY = Inventory(self)&#10;        self.DEATH = Death(self)&#10;&#10;        # 전투 플래그(전투중엔 인벤토리 안 염)&#10;        self.in_combat = False&#10;        self.inventory_open = False&#10;&#10;        # 상태 전환에 대한 매핑&#10;        self.state_machine = StateMachine(&#10;            self.IDLE,&#10;            {&#10;                self.IDLE: {move_event: self.RUN, dash_event: self.DASH, Tab_down: self.INVENTORY, die: self.DEATH},&#10;                self.RUN: {stop_event: self.IDLE, dash_event: self.DASH, Tab_down: self.INVENTORY, die: self.DEATH},&#10;                self.DASH: {dash_end_event: None, die: self.DEATH},  # DASH_END에서 이전 상태로 복귀 (None = 동적 처리)&#10;                self.INVENTORY: {Tab_down: None, die: self.DEATH},&#10;                self.DEATH: {},  # 사망 상태에서는 전환 없음&#10;            }&#10;        )&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 이동 전 위치 저장 (벽 충돌 시 롤백용)&#10;        prev_x = self.x&#10;        prev_y = self.y&#10;&#10;        # 넉백 효과 적용 (방패 방어 시)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            current_speed = self.knockback_speed * (1.0 - progress)&#10;            self.x += self.knockback_dx * current_speed * dt&#10;            self.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;&#10;        # 무적시간 업데이트&#10;        if self.invincible:&#10;            self.invincible_timer -= dt&#10;            if self.invincible_timer &lt;= 0:&#10;                self.invincible = False&#10;                self.invincible_timer = 0.0&#10;&#10;        # 대시 재충전 업데이트&#10;        if self.dash_stack &lt; self.dash_stack_max:&#10;            self.dash_recharge_timer += dt&#10;            if self.dash_recharge_timer &gt;= self.dash_recharge_time:&#10;                self.dash_stack += 1&#10;                self.dash_recharge_timer -= self.dash_recharge_time&#10;                print(f'\033[92m[Player] 대시 스택 충전: {self.dash_stack}/{self.dash_stack_max}\033[0m')&#10;&#10;        # 아이템별 개별 쿨타임 업데이트&#10;        # item_cooldowns 딕셔너리의 각 아이템 ID에 대해 쿨타임 감소&#10;        for item_id in list(self.item_cooldowns.keys()):&#10;            self.item_cooldowns[item_id] -= dt&#10;            if self.item_cooldowns[item_id] &lt;= 0:&#10;                # 쿨타임이 끝나면 딕셔너리에서 제거&#10;                del self.item_cooldowns[item_id]&#10;                print(f'\033[92m[Player] 아이템 사용 가능: {item_id} (쿨타임 종료)\033[0m')&#10;&#10;        self.state_machine.update()&#10;&#10;        # 벽 충돌 검사 (world 참조가 있는 경우)&#10;        if hasattr(self, 'world') and self.world and 'walls' in self.world:&#10;            # 플레이어 히트박스 (중심 기준)&#10;            player_w = 32  # 플레이어 너비 (필요시 조정)&#10;            player_h = 32  # 플레이어 높이 (필요시 조정)&#10;            player_left = self.x - player_w / 2&#10;            player_right = self.x + player_w / 2&#10;            player_bottom = self.y - player_h / 2&#10;            player_top = self.y + player_h / 2&#10;&#10;            # 모든 벽과 충돌 검사&#10;            collision_detected = False&#10;            for wall in self.world['walls']:&#10;                if hasattr(wall, 'check_collision'):&#10;                    # 벽의 히트박스 (중심 기준)&#10;                    wall_left = wall.x - wall.w / 2&#10;                    wall_right = wall.x + wall.w / 2&#10;                    wall_bottom = wall.y - wall.h / 2&#10;                    wall_top = wall.y + wall.h / 2&#10;&#10;                    # AABB 충돌 검사&#10;                    if (player_right &gt; wall_left and player_left &lt; wall_right and&#10;                        player_top &gt; wall_bottom and player_bottom &lt; wall_top):&#10;                        collision_detected = True&#10;                        break&#10;&#10;            # 충돌이 감지되면 이전 위치로 롤백&#10;            if collision_detected:&#10;                self.x = prev_x&#10;                self.y = prev_y&#10;                # 디버그 출력 (필요시 주석 해제)&#10;                # print(f&quot;[Player] 벽 충돌 감지! 위치 롤백: ({self.x:.1f}, {self.y:.1f})&quot;)&#10;&#10;        # 스탯 버프 업데이트(소비형 지속시간 관리)&#10;        if hasattr(self, 'stats'):&#10;            old_mana = self.stats.get('mana')&#10;            self.stats.update()&#10;            new_mana = self.stats.get('mana')&#10;&#10;            # 마나가 0에서 최대로 회복되면 방패 복구&#10;            if hasattr(self, 'shield_broken') and self.shield_broken:&#10;                if new_mana &gt;= 50:&#10;                    self.shield_broken = False&#10;                    print(f'\033[92m[Player] 방패 복구됨 (마나 회복)\033[0m')&#10;                else:&#10;                    # 마나가 아직 최대가 아니면 복구 불가&#10;                    pass&#10;&#10;        # 파티클 업데이트 (상태와 무관하게 항상 실행)&#10;        for p in self.particles:&#10;            p.update()&#10;        self.particles = [p for p in self.particles if p.life &gt; 0]&#10;&#10;        # 공격 이펙트 업데이트&#10;        for effect in self.attack_effects:&#10;            effect.update()&#10;        self.attack_effects = [e for e in self.attack_effects if e.life &gt; 0]&#10;&#10;        # 장비 업데이트&#10;        self.equipment_manager.update()&#10;&#10;    # 인벤토리 패시브 재적용&#10;    def rebuild_inventory_passives(self):&#10;        prefix = 'passive:'&#10;        self.stats.clear_by_prefix(prefix)&#10;        # 모든 슬롯 순회&#10;        try:&#10;            for r in range(self.inventory.rows):&#10;                for c in range(self.inventory.cols):&#10;                    slot = self.inventory.get_slot(r, c)&#10;                    if slot.is_empty():&#10;                        continue&#10;                    item = slot.item&#10;                    if getattr(item, 'passive', None):&#10;                        # 수량만큼 배수 적용(스택형 패시브 고려)&#10;                        qty = max(1, slot.quantity)&#10;                        values = {k: v * qty for k, v in item.passive.items()}&#10;                        mod_id = f'{prefix}{item.id}:{r},{c}'&#10;                        self.stats.add_modifier(StatModifier(mod_id, values, duration=None))&#10;        except Exception as ex:&#10;            print(f&quot;\033[91m[Player] 패시브 적용 중 오류: {ex}\033[0m&quot;)&#10;&#10;    # 소비형 아이템 사용 처리&#10;    def consume_item_at(self, r: int, c: int):&#10;        try:&#10;            slot = self.inventory.get_slot(r, c)&#10;        except Exception as ex:&#10;            print('[Player] 소비 실패: 잘못된 슬롯', ex)&#10;            return False&#10;&#10;        if slot.is_empty() or not getattr(slot.item, 'consumable', None):&#10;            return False&#10;&#10;        item = slot.item&#10;&#10;        # 아이템별 개별 쿨타임 체크&#10;        if item.id in self.item_cooldowns:&#10;            remaining_time = self.item_cooldowns[item.id]&#10;            print(f'\033[93m[Player] {item.name} 쿨타임 중! (남은 시간: {remaining_time:.1f}초)\033[0m')&#10;            return False&#10;&#10;        # 소비형 스탯 적용&#10;        values = dict(item.consumable)&#10;        duration = item.consume_duration&#10;        &#10;        # health와 mana는 즉시 회복 (최대값 제한)&#10;        instant_stats = {}&#10;        modifier_stats = {}&#10;        &#10;        for key, value in values.items():&#10;            if key == 'health':&#10;                # 현재 체력에 회복량을 더하되 최대 체력을 넘지 않도록&#10;                current_health = self.stats.base.get('health', 0.0)&#10;                max_health = self.stats.get('max_health')&#10;                new_health = min(max_health, current_health + value)&#10;                self.stats.base['health'] = new_health&#10;                instant_stats[key] = value&#10;                print(f'[Player] 체력 회복: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})')&#10;            elif key == 'mana':&#10;                # 현재 마나에 회복량을 더하되 최대 마나를 넘지 않도록&#10;                current_mana = self.stats.base.get('mana', 0.0)&#10;                max_mana = self.stats.get('max_mana')&#10;                new_mana = min(max_mana, current_mana + value)&#10;                self.stats.base['mana'] = new_mana&#10;                instant_stats[key] = value&#10;                print(f'[Player] 마나 회복: {current_mana:.1f} -&gt; {new_mana:.1f} (최대: {max_mana:.1f})')&#10;            else:&#10;                # 다른 스탯은 일시적 버프로 적용&#10;                modifier_stats[key] = value&#10;        &#10;        # 일시적 버프가 있는 경우에만 modifier 추가&#10;        if modifier_stats:&#10;            mod_id = f'consumable:{item.id}:{r},{c}:{int(time.time()*1000)%100000}'&#10;            self.stats.add_modifier(StatModifier(mod_id, modifier_stats, duration=duration))&#10;&#10;        # 1개 소모&#10;        self.inventory.remove_from(r, c, 1)&#10;&#10;        # 아이템별 쿨타임 시작 (아이템에 cooldown 속성이 있는 경우)&#10;        if hasattr(item, 'cooldown') and item.cooldown is not None and item.cooldown &gt; 0:&#10;            self.item_cooldowns[item.id] = item.cooldown&#10;            print(f'\033[93m[Player] {item.name} 사용! 쿨타임 시작 ({item.cooldown}초)\033[0m')&#10;        else:&#10;            print(f'\033[93m[Player] {item.name} 사용! (쿨타임 없음)\033[0m')&#10;&#10;        # 아이템의 이펙트 재생(있다면)&#10;        vfx_fn = (getattr(item, 'on_consume_vfx', None)&#10;                  or getattr(item, '_play_consume_vfx', None)&#10;                  or getattr(item, 'consume_effect', None))&#10;        if callable(vfx_fn):&#10;            try:&#10;                # prefer self.world (assigned by play_mode) so VFX are appended to the correct world dict&#10;                vfx_world = getattr(self, 'world', None)&#10;                # debug log&#10;                try:&#10;                    print(f&quot;[Player] triggering vfx for {getattr(item, 'name', item.id if hasattr(item,'id') else 'Unknown')} world={'set' if vfx_world is not None else 'None'})&quot;)&#10;                except Exception:&#10;                    pass&#10;                vfx_fn(self, world=vfx_world, x=getattr(self, 'x', None), y=getattr(self, 'y', None))&#10;            except Exception as ex:&#10;                print(f'[Player] 아이템 소비 이펙트 오류 ({item.name}):', ex)&#10;&#10;        # 패시브 재적용(수량 변화로 인한 패시브 변경 가능성 고려)&#10;        self.rebuild_inventory_passives()&#10;        print(f&quot;[Player] 소비: {item.name} -&gt; {values} ({duration}s)&quot;)&#10;        return True&#10;&#10;    # 신규: 입력 처리 - 상태머신과 장비 매니저로 이벤트 전달, 이동 벡터 관리&#10;    def handle_event(self, event):&#10;        try:&#10;            from sdl2 import SDL_KEYDOWN, SDL_KEYUP, SDLK_w, SDLK_a, SDLK_s, SDLK_d, SDLK_SPACE&#10;        except Exception:&#10;            SDL_KEYDOWN = SDL_KEYUP = None&#10;            SDLK_w = SDLK_a = SDLK_s = SDLK_d = SDLK_SPACE = None&#10;&#10;        # 1) 스페이스바 입력 처리 - 대시 실행&#10;        try:&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN and event.key == SDLK_SPACE:&#10;                # 대시 스택이 있고, Dash 상태가 아닐 때만 대시 가능&#10;                if self.dash_stack &gt; 0 and not isinstance(self.state_machine.cur_state, Dash):&#10;                    # 대시 스택 소모&#10;                    self.dash_stack -= 1&#10;                    print(f'\033[96m[Player] 대시 사용! 남은 스택: {self.dash_stack}/{self.dash_stack_max}\033[0m')&#10;                    # 대시 재충전 타이머 초기화&#10;                    self.dash_recharge_timer = 0.0&#10;                    # DASH 이벤트 발생&#10;                    if hasattr(self, 'state_machine'):&#10;                        self.state_machine.handle_state_event(('DASH', None))&#10;                elif self.dash_stack &lt;= 0:&#10;                    print(f'\033[93m[Player] 대시 스택 부족! ({self.dash_stack}/{self.dash_stack_max})\033[0m')&#10;        except Exception as ex:&#10;            print('[Player] 스페이스바 입력 처리 오류:', ex)&#10;&#10;        # 2) 장비 매니저에 항상 전달(매니저 내부에서 인벤토리 오픈시 무시 처리)&#10;        try:&#10;            if hasattr(self, 'equipment_manager') and hasattr(self.equipment_manager, 'handle_event'):&#10;                self.equipment_manager.handle_event(event)&#10;        except Exception as ex:&#10;            print('[Player] equipment_manager.handle_event 오류:', ex)&#10;&#10;        # 3) 상태머신으로 원본 입력 이벤트 전달(Tab 매핑 등 predicates가 처리)&#10;        try:&#10;            if hasattr(self, 'state_machine') and hasattr(self.state_machine, 'handle_state_event'):&#10;                self.state_machine.handle_state_event(('INPUT', event))&#10;        except Exception as ex:&#10;            print('[Player] state_machine 입력 이벤트 처리 오류:', ex)&#10;&#10;        # 4) WASD 이동 상태 관리 -&gt; MOVE/STOP 이벤트 생성&#10;        moved_before = any(self.keys_down.values())&#10;        try:&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = True&#10;                    self.dir[1] = 1&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = True&#10;                    self.dir[1] = -1&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = True&#10;                    self.dir[0] = -1&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = True&#10;                    self.dir[0] = 1&#10;            elif SDL_KEYUP is not None and event.type == SDL_KEYUP:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;&#10;        except Exception as ex:&#10;            print('[Player] 이동 입력 처리 오류:', ex)&#10;&#10;        moved_after = any(self.keys_down.values())&#10;        try:&#10;            if not moved_before and moved_after:&#10;                # 시작 이동&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('MOVE', None))&#10;            elif moved_before and not moved_after:&#10;                # 이동 종료&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('STOP', None))&#10;        except Exception as ex:&#10;            print('[Player] MOVE/STOP 이벤트 처리 오류:', ex)&#10;&#10;    # 신규: 렌더링 - 장비/플레이어/이펙트 순서대로 그리기&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표이므로 그대로 사용&#10;&#10;        # 디버그 로그 - 카메라 정보 포함&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except:&#10;            print(f'\033[93m[Player] 카메라 정보 가져오기 실패 (디버그 로그 생략)\033[0m')&#10;&#10;        # if camera is not None:&#10;        #     print(f'[Player] draw at screen ({draw_x:.1f}, {draw_y:.1f}), '&#10;        #           f'world ({self.x:.1f}, {self.y:.1f}), '&#10;        #           f'camera ({camera.x:.1f}, {camera.y:.1f})')&#10;        # else:&#10;        #     print(f'[Player] draw at ({draw_x:.1f}, {draw_y:.1f}), world ({self.x:.1f}, {self.y:.1f}) (NO CAMERA)')&#10;&#10;        # 1) 장비(뒤쪽) 그리기&#10;        if hasattr(self, 'equipment_manager'):&#10;            self.equipment_manager.draw_back(draw_x, draw_y)&#10;&#10;        # 2) 현재 상태 스프라이트(Idle/Run/Inventory)&#10;        try:&#10;            if hasattr(self, 'state_machine'):&#10;                if self.state_machine.current_state is not self.DEATH:&#10;                    self.death_x, self.death_y = draw_x, draw_y&#10;                self.state_machine.draw(draw_x, draw_y)&#10;        except Exception as ex:&#10;            print(f'\033[91m[Player] 상태머신 그리기 오류 발생 : {ex}\033[0m')&#10;&#10;        # 3) 장비(앞쪽) 그리기&#10;        if hasattr(self, 'equipment_manager'):&#10;            self.equipment_manager.draw_front(draw_x, draw_y)&#10;&#10;        # 4) 파티클/공격 이펙트 (카메라 적용)&#10;        try:&#10;            # 위에서 이미 가져온 camera 사용&#10;            for p in getattr(self, 'particles', []):&#10;                if hasattr(p, 'draw'):&#10;                    if camera is not None:&#10;                        particle_draw_x, particle_draw_y = camera.apply(p.x, p.y)&#10;                        p.draw(particle_draw_x, particle_draw_y)&#10;                    else:&#10;                        p.draw(p.x, p.y)&#10;            for e in getattr(self, 'attack_effects', []):&#10;                if hasattr(e, 'draw'):&#10;                    if camera is not None:&#10;                        effect_draw_x, effect_draw_y = camera.apply(e.x, e.y)&#10;                        e.draw(effect_draw_x, effect_draw_y)&#10;                    else:&#10;                        e.draw(e.x, e.y)&#10;        except Exception:&#10;            print(f'\033[91m[Player] 파티클/이펙트 그리기 오류 발생 : {ex}\033[0m')&#10;&#10;        # 화면에 표시되는 히트박스 (카메라 적용된 좌표 사용)&#10;        # player_left = draw_x - self.collision_width / 2&#10;        # player_right = draw_x + self.collision_width / 2&#10;        # player_bottom = draw_y - self.collision_height / 2&#10;        # player_top = draw_y + self.collision_height / 2&#10;        # draw_rectangle(player_left, player_bottom, player_right, player_top)&#10;&#10;    def check_collision_with_projectile(self, projectile):&#10;        &quot;&quot;&quot;몬스터 발사체와의 충돌 감지&#10;&#10;        Args:&#10;            projectile: Projectile을 상속받은 발사체 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 먼저 방패로 방어할 수 있는지 체크&#10;        if hasattr(self, 'shield') and self.shield:&#10;            if self.shield.check_projectile_block(projectile):&#10;                # 방패로 막았으면 투사체를 제거하고 충돌 처리 종료&#10;                return True&#10;&#10;        # 무적 상태이면 충돌 무시&#10;        if hasattr(self, 'invincible') and self.invincible:&#10;            return False&#10;&#10;        # 발사체 크기 (Projectile의 get_collision_box 메서드 사용)&#10;        if hasattr(projectile, 'get_collision_box'):&#10;            projectile_width, projectile_height = projectile.get_collision_box()&#10;        else:&#10;            projectile_width = 30&#10;            projectile_height = 30&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        player_left = self.x - self.collision_width / 2&#10;        player_right = self.x + self.collision_width / 2&#10;        player_bottom = self.y - self.collision_height / 2&#10;        player_top = self.y + self.collision_height / 2&#10;&#10;        proj_left = projectile.x - projectile_width / 2&#10;        proj_right = projectile.x + projectile_width / 2&#10;        proj_bottom = projectile.y - projectile_height / 2&#10;        proj_top = projectile.y + projectile_height / 2&#10;&#10;        # 충돌 검사&#10;        if (player_left &lt; proj_right and player_right &gt; proj_left and&#10;            player_bottom &lt; proj_top and player_top &gt; proj_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(projectile)&#10;            return True&#10;&#10;        return False&#10;&#10;    def check_collision_with_effect(self, effect):&#10;        &quot;&quot;&quot;몬스터 공격 이펙트와의 충돌 감지 (CatThiefSwingEffect 등)&#10;&#10;        Args:&#10;            effect: 공격 이펙트 객체 (get_collision_box 메서드를 가진 이펙트)&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 먼저 방패로 방어할 수 있는지 체크&#10;        if hasattr(self, 'shield') and self.shield:&#10;            # 방패의 방향과 이펙트 위치를 고려하여 방어 판정&#10;            if hasattr(self.shield, 'check_effect_block'):&#10;                if self.shield.check_effect_block(effect):&#10;                    # 방패로 막았으면 충돌 처리 종료&#10;                    print(f&quot;[Player] 방패로 {effect.__class__.__name__} 방어!&quot;)&#10;                    return True&#10;&#10;        # 무적 상태이면 충돌 무시&#10;        if hasattr(self, 'invincible') and self.invincible:&#10;            return False&#10;&#10;        # 이펙트 크기 (get_collision_box 메서드 사용)&#10;        if hasattr(effect, 'get_collision_box'):&#10;            effect_width, effect_height = effect.get_collision_box()&#10;        else:&#10;            # 기본값&#10;            effect_width = 100&#10;            effect_height = 100&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        player_left = self.x - self.collision_width / 2&#10;        player_right = self.x + self.collision_width / 2&#10;        player_bottom = self.y - self.collision_height / 2&#10;        player_top = self.y + self.collision_height / 2&#10;&#10;        effect_left = effect.x - effect_width / 2&#10;        effect_right = effect.x + effect_width / 2&#10;        effect_bottom = effect.y - effect_height / 2&#10;        effect_top = effect.y + effect_height / 2&#10;&#10;        # 충돌 검사&#10;        if (player_left &lt; effect_right and player_right &gt; effect_left and&#10;            player_bottom &lt; effect_top and player_top &gt; effect_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(effect)&#10;            return True&#10;&#10;        return False&#10;&#10;    def on_hit(self, attacker):&#10;        &quot;&quot;&quot;피격 시 호출되는 메서드&#10;&#10;        Args:&#10;            attacker: 공격한 객체 (투사체, 이펙트 등)&#10;        &quot;&quot;&quot;&#10;        # 무적 상태라면 무시&#10;        if self.invincible:&#10;            print(f&quot;[Player] 무적 상태로 피격 무시 (남은 무적시간: {self.invincible_timer:.2f}초)&quot;)&#10;            return&#10;&#10;        # 사망 상태면 무시&#10;        if isinstance(self.state_machine.cur_state, Death):&#10;            return&#10;&#10;        # 무적시간 활성화&#10;        self.invincible = True&#10;        self.invincible_timer = self.invincible_duration&#10;&#10;        # 데미지 계산&#10;        damage = 0&#10;        if hasattr(attacker, 'damage'):&#10;            damage = attacker.damage&#10;        elif hasattr(attacker, 'owner') and hasattr(attacker.owner, 'stats'):&#10;            # 공격자의 스탯에서 데미지 가져오기&#10;            damage = attacker.owner.stats.get('attack_damage')&#10;        else:&#10;            damage = 10.0  # 기본 데미지&#10;&#10;        # 방어력 적산&#10;        defense = self.stats.get('defense') if hasattr(self, 'stats') else 0&#10;        final_damage = max(1.0, damage - defense)&#10;&#10;        # 넉백 효과 적용 (공격자로부터 밀려나는 방향)&#10;        import math&#10;        knockback_distance = 100.0  # 넉백 거리&#10;        knockback_duration = 0.3  # 넉백 지속 시간 (초)&#10;&#10;        # 공격자의 위치 파악&#10;        attacker_x = attacker.x if hasattr(attacker, 'x') else self.x&#10;        attacker_y = attacker.y if hasattr(attacker, 'y') else self.y&#10;&#10;        # 넉백 방향 계산 (공격자 -&gt; 플레이어 방향)&#10;        dx = self.x - attacker_x&#10;        dy = self.y - attacker_y&#10;        distance = math.sqrt(dx * dx + dy * dy)&#10;&#10;        if distance &gt; 0:&#10;            # 정규화된 방향 벡터&#10;            self.knockback_dx = dx / distance&#10;            self.knockback_dy = dy / distance&#10;        else:&#10;            # 공격자와 위치가 같으면 랜덤 방향&#10;            angle = random.uniform(0, 2 * math.pi)&#10;            self.knockback_dx = math.cos(angle)&#10;            self.knockback_dy = math.sin(angle)&#10;&#10;        self.knockback_speed = knockback_distance / knockback_duration&#10;        self.knockback_duration = knockback_duration&#10;        self.knockback_timer = 0.0&#10;&#10;        # 스텟 업데이트 - 체력 감소, 마나 감소 등&#10;        if hasattr(self, 'stats'):&#10;            current_health = self.stats.get('health')&#10;            max_health = self.stats.get('max_health')&#10;            new_health = max(0, current_health - final_damage)&#10;            self.stats.set_base('health', new_health)&#10;&#10;            # 피격 정보 출력&#10;            attacker_name = attacker.__class__.__name__&#10;            DebugPrint = True&#10;            if DebugPrint:&#10;                print(f&quot;\n{'='*60}&quot;)&#10;                print(f&quot;[Player 피격]&quot;)&#10;                print(f&quot;  공격자: {attacker_name}&quot;)&#10;                print(f&quot;  원본 데미지: {damage:.1f}&quot;)&#10;                print(f&quot;  방어력: {defense:.1f}&quot;)&#10;                print(f&quot;  최종 데미지: {final_damage:.1f}&quot;)&#10;                print(f&quot;  체력 변화: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})&quot;)&#10;                print(f&quot;  체력 비율: {(new_health/max_health)*100:.1f}%&quot;)&#10;                print(f&quot;  무적시간: {self.invincible_duration}초 활성화&quot;)&#10;                print(f&quot;  넉백: 거리 {knockback_distance:.1f}px, 지속시간 {knockback_duration:.2f}초&quot;)&#10;&#10;            # 체력이 0 이하면 사망 상태로 전환&#10;            if new_health &lt;= 0:&#10;                print(f&quot;  &gt;&gt;&gt; Player 체력 0 - 사망 상태로 전환&quot;)&#10;                print(f&quot;{'='*60}\n&quot;)&#10;                self.state_machine.handle_state_event(('DIE', attacker))&#10;                return  # 사망 시 이펙트 생성하지 않음&#10;            else:&#10;                print(f&quot;{'='*60}\n&quot;)&#10;        else:&#10;            attacker_name = attacker.__class__.__name__&#10;            print(f&quot;[Player] 피격당함! 공격자: {attacker_name} (스탯 시스템 없음)&quot;)&#10;&#10;        # 피격 이펙트 재생 - Wound Particle 생성 (4개)&#10;        for i in range(4):&#10;            # 랜덤한 방향으로 파티클 발사&#10;            angle = random.uniform(0, 2 * math.pi)&#10;            speed = random.uniform(80, 150)  # 속도 랜덤&#10;            vx = math.cos(angle) * speed&#10;            vy = math.sin(angle) * speed + random.uniform(50, 100) # 위쪽으로 약간 더 많이&#10;&#10;            # 플레이어 위치에서 약간 랜덤한 오프셋&#10;            offset_x = random.uniform(-10, 10)&#10;            offset_y = random.uniform(-10, 10)&#10;&#10;            wound_particle = VFX_Wound_Particle(&#10;                self.x + offset_x,&#10;                self.y + offset_y,&#10;                vx, vy,&#10;                scale=3.0&#10;            )&#10;            self.particles.append(wound_particle)&#10;&#10;        print(f&quot;[Player] 피격 이펙트 생성 완료 (Wound Particle x4)&quot;)&#10;&#10;        # 데미지 인디케이터 생성&#10;        try:&#10;            if hasattr(self, 'world') and self.world and 'effects_front' in self.world:&#10;                dmg_indicator = DamageIndicator(&#10;                    x=self.x,&#10;                    y=self.y,&#10;                    damage=final_damage,&#10;                    font_size=20&#10;                )&#10;                self.world['effects_front'].append(dmg_indicator)&#10;                print(f&quot;[Player] 데미지 인디케이터 생성: {final_damage:.1f} 데미지&quot;)&#10;        except Exception as ex:&#10;            print(f'\033[91m[Player] 데미지 인디케이터 생성 실패: {ex}\033[0m')&#10;            pass&#10;&#10;        # TODO: 추후 추가 가능&#10;        # - 피격 사운드&#10;&#10;    def on_death(self):&#10;        &quot;&quot;&quot;사망 처리 - 상태 머신을 통해 Death 상태로 전환&quot;&quot;&quot;&#10;        print(&quot;[Player] on_death 호출 - Death 상태로 전환&quot;)&#10;        self.state_machine.handle_state_event(('DIE', None))&#10;&#10;class VFX_Run_Particle:&#10;    def __init__(self, x, y, frames, frame_duration, scale):&#10;        self.x, self.y = x, y&#10;        self.frames = frames&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = frame_duration&#10;        self.scale_factor = scale&#10;        self.life = len(frames) * frame_duration&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt; 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.frames)&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.draw(draw_x, draw_y, image.w * self.scale_factor, image.h * self.scale_factor)&#10;&#10;&#10;class VFX_Wound_Particle:&#10;    &quot;&quot;&quot;피격 시 출혈 파티클 이펙트 (개별 이미지 파일 사용)&quot;&quot;&quot;&#10;    _frames = None  # 클래스 변수로 이미지 프레임 공유&#10;&#10;    def __init__(self, x, y, vx, vy, scale=3.0):&#10;        # 이미지 프레임 로드 (최초 1회만)&#10;        if VFX_Wound_Particle._frames is None:&#10;            VFX_Wound_Particle._frames = []&#10;            wound_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Wound_Particle')&#10;            try:&#10;                for i in range(5):  # WoundParticle_0 ~ WoundParticle_4&#10;                    img_path = os.path.join(wound_folder, f'WoundParticle_{i}.png')&#10;                    frame = load_image(img_path)&#10;                    VFX_Wound_Particle._frames.append(frame)&#10;                print(f&quot;[WoundParticle] 이미지 로드 완료: {len(VFX_Wound_Particle._frames)}개 프레임&quot;)&#10;            except Exception as ex:&#10;                print(f&quot;[WoundParticle] 이미지 로드 실패: {ex}&quot;)&#10;                VFX_Wound_Particle._frames = []&#10;&#10;        self.x = x&#10;        self.y = y&#10;        self.vx = vx  # x 방향 속도&#10;        self.vy = vy  # y 방향 속도&#10;        self.scale_factor = scale&#10;&#10;        # 애니메이션 설정&#10;        self.total_frames = 5  # 총 프레임 수&#10;        self.current_frame = 0&#10;        self.frame_duration = 0.08  # 각 프레임당 0.08초&#10;        self.frame_time_acc = 0.0&#10;        self.life = self.total_frames * self.frame_duration  # 총 수명&#10;&#10;        # 중력 효과&#10;        self.gravity = 200.0  # 픽셀/초^2&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 수명 감소&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False&#10;&#10;        # 물리 업데이트&#10;        self.x += self.vx * dt&#10;        self.y += self.vy * dt&#10;        self.vy -= self.gravity * dt  # 중력 적용&#10;&#10;        # 애니메이션 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.current_frame += 1&#10;            if self.current_frame &gt;= self.total_frames:&#10;                self.current_frame = self.total_frames - 1  # 마지막 프레임 유지&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if not VFX_Wound_Particle._frames or len(VFX_Wound_Particle._frames) == 0:&#10;            return&#10;&#10;        if self.current_frame &lt; len(VFX_Wound_Particle._frames):&#10;            image = VFX_Wound_Particle._frames[self.current_frame]&#10;            image.draw(&#10;                draw_x, draw_y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;&#10;&#10;# VFX 전역 배율 설정: 전체 이펙트 크기와 거리(범위)를 일괄 조정&#10;VFX_GLOBAL_SCALE_MULT = 0.7   # 이펙트 크기 0.7배&#10;VFX_GLOBAL_RANGE_MULT = 0.8   # 이펙트 거리 0.8배&#10;&#10;class VFX_Tier1_Sword_Swing:&#10;    &quot;&quot;&quot;검 공격 이펙트 VFX&quot;&quot;&quot;&#10;    def __init__(self, x, y, angle, flip, scale=4.5, range_factor=60, variant=1, owner=None):&#10;        import math&#10;&#10;        # 공격자 정보 저장&#10;        self.owner = owner&#10;&#10;        # 데미지 설정 (owner의 스탯에서 가져오거나 기본값 사용)&#10;        if owner and hasattr(owner, 'stats'):&#10;            self.damage = owner.stats.get('attack_damage')&#10;        else:&#10;            self.damage = 20.0  # 기본 데미지&#10;&#10;        # 전역 배율을 적용한 range_factor/scale 사용&#10;        range_factor = range_factor * VFX_GLOBAL_RANGE_MULT&#10;        scale = scale * VFX_GLOBAL_SCALE_MULT&#10;&#10;        # 받은 위치에서 angle 방향으로 range_factor만큼 떨어진 위치 계산&#10;        temp_x = range_factor * math.cos(angle)&#10;        temp_y = range_factor * math.sin(angle)&#10;&#10;        self.x = x + temp_x&#10;        self.y = y + temp_y&#10;&#10;        # 각도 조정: 마우스가 오른쪽(0도~90도, 270도~360도)일 때 -90도, 왼쪽일 때 +90도&#10;        angle_deg = math.degrees(angle) % 360&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽&#10;            self.angle = angle + math.radians(90)&#10;        else:  # 오른쪽&#10;            self.angle = angle - math.radians(90)&#10;&#10;        self.flip = flip&#10;        self.scale_factor = scale&#10;&#10;        # 이펙트 이미지 로드&#10;        fx_folder = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Swing_FX')&#10;        if variant == 1:&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;        elif variant == 2:&#10;            # 콤보 전용 스프라이트&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_1.png'))&#10;            ]&#10;        elif variant == 3:&#10;            # Heavy swing (3스테이지) - 여러 프레임&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_1.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_2.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_3.png'))&#10;            ]&#10;        else:&#10;            # 안전망: 기본으로 variant 1 사용&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.05  # 각 프레임당 0.05초&#10;        self.life = len(self.frames) * self.frame_duration  # 총 수명&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame += 1&#10;            if self.frame &gt;= len(self.frames):&#10;                self.frame = len(self.frames) - 1  # 마지막 프레임 유지&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.clip_composite_draw(&#10;                0, 0, image.w, image.h,&#10;                self.angle, self.flip,&#10;                draw_x, draw_y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;" />
              <option name="updatedContent" value="# 패키지 내부 모듈을 직접 실행할 경우 친절한 안내 후 종료&#13;&#10;if __name__ == &quot;__main__&quot; and (__package__ is None or __package__ == &quot;&quot;):&#13;&#10;    import sys&#13;&#10;    print(&quot;이 모듈은 game_logic 패키지 내부 모듈입니다. 프로젝트 루트에서 main.py를 실행하세요.&quot;)&#13;&#10;    sys.exit(1)&#13;&#10;&#13;&#10;import ctypes&#13;&#10;import os&#13;&#10;import random&#13;&#10;import time&#13;&#10;&#13;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width, draw_rectangle&#13;&#10;from sdl2 import (SDL_KEYDOWN, SDL_KEYUP, SDLK_a, SDLK_d, SDLK_w, SDLK_s, SDLK_TAB, SDLK_SPACE, SDL_GetMouseState,&#13;&#10;                   SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT)&#13;&#10;&#13;&#10;from .equipment import EquipmentManager, Sword, Shield&#13;&#10;from .state_machine import StateMachine&#13;&#10;import game_framework as framework&#13;&#10;# 인벤토리 데이터 모델 import&#13;&#10;from .inventory import InventoryData, seed_debug_inventory&#13;&#10;from .stats import PlayerStats, StatModifier&#13;&#10;from .damage_indicator import DamageIndicator&#13;&#10;&#13;&#10;def Akey_down(e):&#13;&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_a&#13;&#10;def Akey_up(e):&#13;&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_a&#13;&#10;def Dkey_down(e):&#13;&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_d&#13;&#10;def Dkey_up(e):&#13;&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_d&#13;&#10;def Wkey_down(e):&#13;&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_w&#13;&#10;def Wkey_up(e):&#13;&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_w&#13;&#10;def Skey_down(e):&#13;&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_s&#13;&#10;def Skey_up(e):&#13;&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_s&#13;&#10;&#13;&#10;# 스페이스바 입력 검사용 predicate&#13;&#10;def Space_down(e):&#13;&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_SPACE&#13;&#10;&#13;&#10;# 커스텀 이벤트 정의&#13;&#10;def move_event(e):&#13;&#10;    return e[0] == 'MOVE'&#13;&#10;&#13;&#10;def stop_event(e):&#13;&#10;    return e[0] == 'STOP'&#13;&#10;&#13;&#10;# 대시 이벤트 정의&#13;&#10;def dash_event(e):&#13;&#10;    return e[0] == 'DASH'&#13;&#10;&#13;&#10;def dash_end_event(e):&#13;&#10;    return e[0] == 'DASH_END'&#13;&#10;&#13;&#10;# Tab 키 입력 검사용 predicate (StateMachine 매핑용)&#13;&#10;def Tab_down(e):&#13;&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_TAB&#13;&#10;&#13;&#10;class Run:&#13;&#10;    def __init__(self, player):&#13;&#10;        self.player = player&#13;&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#13;&#10;&#13;&#10;        def load_seq(prefix, path):&#13;&#10;            files = sorted([f for f in os.listdir(path)&#13;&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#13;&#10;            return [load_image(os.path.join(path, f)) for f in files]&#13;&#10;&#13;&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#13;&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#13;&#10;&#13;&#10;        # 파티클 리소스 로드&#13;&#10;        particle_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Run_Dust')&#13;&#10;        self.particle_frames = load_seq('RunDust_Ver2_', particle_folder)&#13;&#10;        self.particle_spawn_timer = 0.0&#13;&#10;        self.particle_spawn_interval = 0.15 # 파티클 생성 간격&#13;&#10;&#13;&#10;        if not self.lower_frames or not self.upper_frames:&#13;&#10;            raise RuntimeError(f'Move frames not found in {folder}')&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.frame_time_acc = 0.0&#13;&#10;        self.frame_duration = 0.06&#13;&#10;        self.moving_speed = 300 # 초당 픽셀&#13;&#10;&#13;&#10;    def enter(self, e):&#13;&#10;        # 파티클 타이머만 초기화&#13;&#10;        self.particle_spawn_timer = 0.0&#13;&#10;&#13;&#10;    def exit(self, e):&#13;&#10;        # 파티클을 제거하지 않고 그대로 둠&#13;&#10;        pass&#13;&#10;&#13;&#10;    def do(self):&#13;&#10;        dt = framework.get_delta_time()&#13;&#10;&#13;&#10;        # 플레이어 애니메이션 및 위치 업데이트&#13;&#10;        self.frame_time_acc += dt&#13;&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#13;&#10;            self.frame_time_acc -= self.frame_duration&#13;&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#13;&#10;&#13;&#10;        # 현재 스탯 기반 이동 속도 사용&#13;&#10;        moving_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else self.moving_speed&#13;&#10;        dir_magnitude = (self.player.dir[0] ** 2 + self.player.dir[1] ** 2) ** 0.5&#13;&#10;        if dir_magnitude &gt; 0:&#13;&#10;            norm_dir_x = self.player.dir[0] / dir_magnitude&#13;&#10;            norm_dir_y = self.player.dir[1] / dir_magnitude&#13;&#10;            new_x = self.player.x + norm_dir_x * moving_speed * dt&#13;&#10;            new_y = self.player.y + norm_dir_y * moving_speed * dt&#13;&#10;&#13;&#10;            # 맵 경계 체크 (카메라/월드 좌표 기반)&#13;&#10;            # lobby_mode에서 맵 크기를 가져와 경계 체크&#13;&#10;            try:&#13;&#10;                from game_logic.lobby_mode import world&#13;&#10;                # 배경 오브젝트에서 맵 크기 계산&#13;&#10;                if world['bg']:&#13;&#10;                    bg = world['bg'][0]&#13;&#10;                    map_width = bg.image.w * bg.scale&#13;&#10;                    map_height = bg.image.h * bg.scale&#13;&#10;                    # 맵의 중심이 (0, 0)이므로 경계는 ±map_width/2, ±map_height/2&#13;&#10;                    map_left = -map_width / 2&#13;&#10;                    map_right = map_width / 2&#13;&#10;                    map_bottom = -map_height / 2&#13;&#10;                    map_top = map_height / 2&#13;&#10;&#13;&#10;                    # 플레이어가 맵 경계를 벗어나지 않도록 제한&#13;&#10;                    if new_x &lt; map_left:&#13;&#10;                        new_x = map_left&#13;&#10;                    elif new_x &gt; map_right:&#13;&#10;                        new_x = map_right&#13;&#10;                    if new_y &lt; map_bottom:&#13;&#10;                        new_y = map_bottom&#13;&#10;                    elif new_y &gt; map_top:&#13;&#10;                        new_y = map_top&#13;&#10;            except Exception:&#13;&#10;                # 맵 정보를 가져올 수 없으면 화면 경계로 폴백&#13;&#10;                if new_x &gt; get_canvas_width():&#13;&#10;                    new_x = get_canvas_width()&#13;&#10;                elif new_x &lt; 0:&#13;&#10;                    new_x = 0&#13;&#10;                if new_y &gt; get_canvas_height():&#13;&#10;                    new_y = get_canvas_height()&#13;&#10;                elif new_y &lt; 0:&#13;&#10;                    new_y = 0&#13;&#10;&#13;&#10;            # 벽 충돌 체크 (플레이어 크기 32x48)&#13;&#10;            collided = False&#13;&#10;            try:&#13;&#10;                from game_logic.lobby_mode import world&#13;&#10;                for wall in world['walls']:&#13;&#10;                    if wall.check_collision(new_x - 32//2, new_y - 48//2, 32, 48):&#13;&#10;                        collided = True&#13;&#10;                        break&#13;&#10;            except Exception:&#13;&#10;                pass&#13;&#10;            if not collided:&#13;&#10;                self.player.x = new_x&#13;&#10;                self.player.y = new_y&#13;&#10;&#13;&#10;&#13;&#10;        # 파티클 생성&#13;&#10;        self.particle_spawn_timer += dt&#13;&#10;        if self.particle_spawn_timer &gt;= self.particle_spawn_interval:&#13;&#10;            self.particle_spawn_timer -= self.particle_spawn_interval&#13;&#10;            # 플레이어 발밑에 파티클 생성 (월드 좌표 사용)&#13;&#10;            # y 오프셋을 줄여서 발 위치에 더 가깝게 배치&#13;&#10;            particle_x = self.player.x + random.uniform(-10, 10)&#13;&#10;            particle_y = self.player.y - 20 + random.uniform(-5, 5)  # -40에서 -20으로 조정&#13;&#10;            new_particle = VFX_Run_Particle(particle_x, particle_y, self.particle_frames, 0.05, 2.0)&#13;&#10;            self.player.particles.append(new_particle)&#13;&#10;&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        # 마우스 위치 읽기&#13;&#10;        mx = ctypes.c_int(0)&#13;&#10;        my = ctypes.c_int(0)&#13;&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#13;&#10;        canvas_w = get_canvas_width()&#13;&#10;        canvas_h = get_canvas_height()&#13;&#10;&#13;&#10;        # camera 가져오기 - play_mode 우선, lobby_mode로 폴백&#13;&#10;        camera = None&#13;&#10;        try:&#13;&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#13;&#10;            import game_logic.play_mode as play&#13;&#10;            camera = getattr(play, 'camera', None)&#13;&#10;&#13;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#13;&#10;            if camera is None:&#13;&#10;                import game_logic.lobby_mode as lobby&#13;&#10;                camera = getattr(lobby, 'camera', None)&#13;&#10;        except Exception:&#13;&#10;            print(f&quot;\033[91m[player Idle] 카메라 가져오기 실패\033[0m&quot;)&#13;&#10;&#13;&#10;        # 마우스 좌표를 월드 좌표로 변환&#13;&#10;        if camera is not None:&#13;&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#13;&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#13;&#10;        else:&#13;&#10;            mouse_game_x = mx.value&#13;&#10;            mouse_game_y = canvas_h - my.value&#13;&#10;&#13;&#10;        # 마우스 x좌표 기준 face_dir 결정&#13;&#10;        if mouse_game_x &lt; self.player.x:&#13;&#10;            self.player.face_dir = -1&#13;&#10;        else:&#13;&#10;            self.player.face_dir = 1&#13;&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#13;&#10;        lower = self.lower_frames[self.frame]&#13;&#10;        upper = self.upper_frames[self.frame]&#13;&#10;        lw, lh = lower.w, lower.h&#13;&#10;        uw, uh = upper.w, upper.h&#13;&#10;&#13;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#13;&#10;        if mouse_game_y &gt; self.player.y:&#13;&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#13;&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#13;&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#13;&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#13;&#10;        else:&#13;&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#13;&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#13;&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#13;&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#13;&#10;&#13;&#10;class Dash:&#13;&#10;    &quot;&quot;&quot;대시 상태: 스페이스바로 활성화, 빠른 속도로 짧은 거리 이동&quot;&quot;&quot;&#13;&#10;    def __init__(self, player):&#13;&#10;        self.player = player&#13;&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#13;&#10;&#13;&#10;        def load_seq(prefix, path):&#13;&#10;            files = sorted([f for f in os.listdir(path)&#13;&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#13;&#10;            return [load_image(os.path.join(path, f)) for f in files]&#13;&#10;&#13;&#10;        # 대시용 애니메이션 프레임 (Run과 동일한 프레임 사용)&#13;&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#13;&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#13;&#10;&#13;&#10;        if not self.lower_frames or not self.upper_frames:&#13;&#10;            raise RuntimeError(f'Dash frames not found in {folder}')&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.frame_time_acc = 0.0&#13;&#10;        self.frame_duration = 0.03  # Run보다 2배 빠른 애니메이션&#13;&#10;&#13;&#10;        # 대시 설정&#13;&#10;        self.dash_duration = 0.15  # 대시 지속 시간 (0.15초)&#13;&#10;        self.dash_timer = 0.0  # 대시 경과 시간&#13;&#10;        self.dash_speed_multiplier = 4  # Run 속도의 4배&#13;&#10;&#13;&#10;        # 대시 방향 저장 (enter에서 설정)&#13;&#10;        self.dash_direction = [1, 0]  # 기본값: 오른쪽&#13;&#10;        self.return_to_idle = False  # Idle로 복귀할지 Run으로 복귀할지&#13;&#10;&#13;&#10;        # 잔상 이펙트 타이머&#13;&#10;        self.trail_timer = 0.0  # 잔상 생성 타이머&#13;&#10;        self.trail_interval = 0.04  # 잔상 생성 간격&#13;&#10;&#13;&#10;    def enter(self, e):&#13;&#10;        &quot;&quot;&quot;대시 상태 진입&quot;&quot;&quot;&#13;&#10;        # 대시 타이머 초기화&#13;&#10;        self.dash_timer = 0.0&#13;&#10;        self.frame = 0&#13;&#10;        self.frame_time_acc = 0.0&#13;&#10;&#13;&#10;        # 잔상 타이머 초기화&#13;&#10;        self.trail_timer = 0.0&#13;&#10;&#13;&#10;        # 무적 시간 활성화 (0.15초)&#13;&#10;        self.player.invincible = True&#13;&#10;        self.player.invincible_timer = 0.15&#13;&#10;        print(f&quot;[Dash] 무적 시간 활성화 (0.15초)&quot;)&#13;&#10;&#13;&#10;        # 대시 방향 결정&#13;&#10;        # Run 상태에서 왔으면 현재 이동 방향으로 대시&#13;&#10;        # Idle 상태에서 왔으면 오른쪽(face_dir)으로 대시&#13;&#10;        if self.player.dir[0] != 0 or self.player.dir[1] != 0:&#13;&#10;            # 이동 중이었으면 그 방향으로 대시&#13;&#10;            self.dash_direction = self.player.dir.copy()&#13;&#10;            self.return_to_idle = False&#13;&#10;            print(f&quot;[Dash] Run에서 대시 시작 - 방향: ({self.dash_direction[0]}, {self.dash_direction[1]})&quot;)&#13;&#10;        else:&#13;&#10;            # 정지 상태였으면 face_dir 방향으로 대시&#13;&#10;            self.dash_direction = [self.player.face_dir, 0]&#13;&#10;            self.return_to_idle = True&#13;&#10;            print(f&quot;[Dash] Idle에서 대시 시작 - 방향: 오른쪽({self.player.face_dir})&quot;)&#13;&#10;&#13;&#10;    def exit(self, e):&#13;&#10;        &quot;&quot;&quot;대시 상태 종료&quot;&quot;&quot;&#13;&#10;        print(f&quot;[Dash] 대시 종료 - {'Idle' if self.return_to_idle else 'Run'}로 복귀&quot;)&#13;&#10;        pass&#13;&#10;&#13;&#10;    def do(self):&#13;&#10;        &quot;&quot;&quot;대시 업데이트: 빠른 속도로 이동하고 시간이 지나면 종료&quot;&quot;&quot;&#13;&#10;        dt = framework.get_delta_time()&#13;&#10;&#13;&#10;        # 대시 타이머 업데이트&#13;&#10;        self.dash_timer += dt&#13;&#10;&#13;&#10;        # 잔상 타이머 업데이트 및 생성&#13;&#10;        self.trail_timer += dt&#13;&#10;        if self.trail_timer &gt;= self.trail_interval:&#13;&#10;            self.trail_timer -= self.trail_interval&#13;&#10;            # 잔상 이펙트 생성&#13;&#10;            self._create_trail_effect()&#13;&#10;&#13;&#10;        # 애니메이션 업데이트&#13;&#10;        self.frame_time_acc += dt&#13;&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#13;&#10;            self.frame_time_acc -= self.frame_duration&#13;&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#13;&#10;&#13;&#10;        # 대시 이동 처리&#13;&#10;        # 현재 스탯 기반 이동 속도 사용&#13;&#10;        base_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else 300&#13;&#10;        dash_speed = base_speed * self.dash_speed_multiplier&#13;&#10;&#13;&#10;        # 방향 정규화&#13;&#10;        dir_magnitude = (self.dash_direction[0] ** 2 + self.dash_direction[1] ** 2) ** 0.5&#13;&#10;        if dir_magnitude &gt; 0:&#13;&#10;            norm_dir_x = self.dash_direction[0] / dir_magnitude&#13;&#10;            norm_dir_y = self.dash_direction[1] / dir_magnitude&#13;&#10;            new_x = self.player.x + norm_dir_x * dash_speed * dt&#13;&#10;            new_y = self.player.y + norm_dir_y * dash_speed * dt&#13;&#10;&#13;&#10;            # 맵 경계 체크 및 벽 충돌 체크 (Run과 동일한 로직)&#13;&#10;            try:&#13;&#10;                from game_logic.lobby_mode import world&#13;&#10;                if world['bg']:&#13;&#10;                    bg = world['bg'][0]&#13;&#10;                    map_width = bg.image.w * bg.scale&#13;&#10;                    map_height = bg.image.h * bg.scale&#13;&#10;                    map_left = -map_width / 2&#13;&#10;                    map_right = map_width / 2&#13;&#10;                    map_bottom = -map_height / 2&#13;&#10;                    map_top = map_height / 2&#13;&#10;&#13;&#10;                    if new_x &lt; map_left:&#13;&#10;                        new_x = map_left&#13;&#10;                    elif new_x &gt; map_right:&#13;&#10;                        new_x = map_right&#13;&#10;                    if new_y &lt; map_bottom:&#13;&#10;                        new_y = map_bottom&#13;&#10;                    elif new_y &gt; map_top:&#13;&#10;                        new_y = map_top&#13;&#10;            except Exception:&#13;&#10;                if new_x &gt; get_canvas_width():&#13;&#10;                    new_x = get_canvas_width()&#13;&#10;                elif new_x &lt; 0:&#13;&#10;                    new_x = 0&#13;&#10;                if new_y &gt; get_canvas_height():&#13;&#10;                    new_y = get_canvas_height()&#13;&#10;                elif new_y &lt; 0:&#13;&#10;                    new_y = 0&#13;&#10;&#13;&#10;            # 벽 충돌 체크&#13;&#10;            collided = False&#13;&#10;            try:&#13;&#10;                from game_logic.lobby_mode import world&#13;&#10;                for wall in world['walls']:&#13;&#10;                    if wall.check_collision(new_x - 32//2, new_y - 48//2, 32, 48):&#13;&#10;                        collided = True&#13;&#10;                        break&#13;&#10;            except Exception:&#13;&#10;                pass&#13;&#10;&#13;&#10;            if not collided:&#13;&#10;                self.player.x = new_x&#13;&#10;                self.player.y = new_y&#13;&#10;&#13;&#10;        # 대시 지속 시간이 끝나면 상태 전환&#13;&#10;        if self.dash_timer &gt;= self.dash_duration:&#13;&#10;            # DASH_END 이벤트 발생&#13;&#10;            self.player.state_machine.handle_state_event(('DASH_END', None))&#13;&#10;&#13;&#10;    def _create_trail_effect(self):&#13;&#10;        &quot;&quot;&quot;대시 잔상 이펙트를 생성하여 world의 effects_back 레이어에 추가&quot;&quot;&quot;&#13;&#10;        try:&#13;&#10;            # vfx 모듈에서 DashTrailEffect import&#13;&#10;            from .vfx import DashTrailEffect&#13;&#10;&#13;&#10;            # 현재 플레이어 위치에 잔상 생성&#13;&#10;            trail = DashTrailEffect(&#13;&#10;                x=self.player.x,&#13;&#10;                y=self.player.y,&#13;&#10;                face_dir=self.player.face_dir,&#13;&#10;                scale=self.player.scale_factor&#13;&#10;            )&#13;&#10;&#13;&#10;            # world의 effects_back 레이어에 추가&#13;&#10;            if hasattr(self.player, 'world') and self.player.world:&#13;&#10;                if 'effects_back' in self.player.world:&#13;&#10;                    self.player.world['effects_back'].append(trail)&#13;&#10;                    print(f&quot;[Dash] 잔상 이펙트 생성 at ({self.player.x:.1f}, {self.player.y:.1f})&quot;)&#13;&#10;                else:&#13;&#10;                    print(f&quot;\033[93m[Dash] world에 effects_back 레이어가 없습니다\033[0m&quot;)&#13;&#10;            else:&#13;&#10;                print(f&quot;\033[93m[Dash] player.world가 설정되지 않았습니다\033[0m&quot;)&#13;&#10;        except Exception as ex:&#13;&#10;            print(f&quot;\033[91m[Dash] 잔상 이펙트 생성 실패: {ex}\033[0m&quot;)&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;대시 상태 그리기 (Run과 동일한 스타일)&quot;&quot;&quot;&#13;&#10;        # 마우스 위치 읽기&#13;&#10;        mx = ctypes.c_int(0)&#13;&#10;        my = ctypes.c_int(0)&#13;&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#13;&#10;        canvas_w = get_canvas_width()&#13;&#10;        canvas_h = get_canvas_height()&#13;&#10;&#13;&#10;        # camera 가져오기&#13;&#10;        camera = None&#13;&#10;        try:&#13;&#10;            import game_logic.play_mode as play&#13;&#10;            camera = getattr(play, 'camera', None)&#13;&#10;            if camera is None:&#13;&#10;                import game_logic.lobby_mode as lobby&#13;&#10;                camera = getattr(lobby, 'camera', None)&#13;&#10;        except Exception:&#13;&#10;            pass&#13;&#10;&#13;&#10;        # 마우스 좌표를 월드 좌표로 변환&#13;&#10;        if camera is not None:&#13;&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#13;&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#13;&#10;        else:&#13;&#10;            mouse_game_x = mx.value&#13;&#10;            mouse_game_y = canvas_h - my.value&#13;&#10;&#13;&#10;        # 마우스 x좌표 기준 face_dir 결정&#13;&#10;        if mouse_game_x &lt; self.player.x:&#13;&#10;            self.player.face_dir = -1&#13;&#10;        else:&#13;&#10;            self.player.face_dir = 1&#13;&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#13;&#10;&#13;&#10;        lower = self.lower_frames[self.frame]&#13;&#10;        upper = self.upper_frames[self.frame]&#13;&#10;        lw, lh = lower.w, lower.h&#13;&#10;        uw, uh = upper.w, upper.h&#13;&#10;&#13;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#13;&#10;        if mouse_game_y &gt; self.player.y:&#13;&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip, draw_x, draw_y,&#13;&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#13;&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip, draw_x, draw_y,&#13;&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#13;&#10;        else:&#13;&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip, draw_x, draw_y,&#13;&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#13;&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip, draw_x, draw_y,&#13;&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#13;&#10;&#13;&#10;class Idle:&#13;&#10;    def __init__(self, player):&#13;&#10;        self.player = player&#13;&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#13;&#10;&#13;&#10;        def load_seq(prefix):&#13;&#10;            files = sorted([f for f in os.listdir(folder)&#13;&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#13;&#10;            return [load_image(os.path.join(folder, f)) for f in files]&#13;&#10;&#13;&#10;        self.lower_frames = load_seq('Player_Adventurer_Idle_Lower')&#13;&#10;        self.upper_frames = load_seq('Player_Adventurer_Idle_Upper')&#13;&#10;&#13;&#10;        if not self.lower_frames or not self.upper_frames:&#13;&#10;            raise RuntimeError(f'Idle frames not found in {folder}')&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.frame_time_acc = 0.0&#13;&#10;        self.frame_duration = 0.12&#13;&#10;&#13;&#10;    def enter(self, e):&#13;&#10;        self.player.dir = [0, 0]&#13;&#10;&#13;&#10;    def exit(self, e):&#13;&#10;        pass&#13;&#10;&#13;&#10;    def do(self):&#13;&#10;        dt = framework.get_delta_time()&#13;&#10;&#13;&#10;        self.frame_time_acc += dt&#13;&#10;        while self.frame_time_acc &gt;= self.frame_duration:&#13;&#10;            self.frame_time_acc -= self.frame_duration&#13;&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        # 마우스 위치 읽기&#13;&#10;        mx = ctypes.c_int(0)&#13;&#10;        my = ctypes.c_int(0)&#13;&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#13;&#10;        canvas_w = get_canvas_width()&#13;&#10;        canvas_h = get_canvas_height()&#13;&#10;&#13;&#10;        # camera 가져오기 - play_mode 우선, lobby_mode로 폴백&#13;&#10;        camera = None&#13;&#10;        try:&#13;&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#13;&#10;            import game_logic.play_mode as play&#13;&#10;            camera = getattr(play, 'camera', None)&#13;&#10;&#13;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#13;&#10;            if camera is None:&#13;&#10;                import game_logic.lobby_mode as lobby&#13;&#10;                camera = getattr(lobby, 'camera', None)&#13;&#10;        except Exception:&#13;&#10;            print(f&quot;\033[91m[player Idle] 카메라 가져오기 실패\033[0m&quot;)&#13;&#10;&#13;&#10;        # 마우스 좌표를 월드 좌표로 변환&#13;&#10;        if camera is not None:&#13;&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#13;&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#13;&#10;        else:&#13;&#10;            mouse_game_x = mx.value&#13;&#10;            mouse_game_y = canvas_h - my.value&#13;&#10;&#13;&#10;        # 마우스 x좌표 기준 face_dir 결정&#13;&#10;        if mouse_game_x &lt; self.player.x:&#13;&#10;            self.player.face_dir = -1&#13;&#10;        else:&#13;&#10;            self.player.face_dir = 1&#13;&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#13;&#10;        lower = self.lower_frames[self.frame]&#13;&#10;        upper = self.upper_frames[self.frame]&#13;&#10;        lw, lh = lower.w, lower.h&#13;&#10;        uw, uh = upper.w, upper.h&#13;&#10;&#13;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#13;&#10;        if mouse_game_y &gt; self.player.y:&#13;&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#13;&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#13;&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#13;&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#13;&#10;        else:&#13;&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#13;&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#13;&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#13;&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#13;&#10;&#13;&#10;&#13;&#10;class Inventory:&#13;&#10;    &quot;&quot;&quot;인벤토리 상태: enter에서 이미지 로드, draw에서 중앙 오른쪽에 표시 (시뮬레이션 정지 없음)&quot;&quot;&quot;&#13;&#10;    def __init__(self, player):&#13;&#10;        self.player = player&#13;&#10;        self.image = None&#13;&#10;        self.scale = 1.0&#13;&#10;        self.prev_state = None  # 이전 상태 저장용&#13;&#10;&#13;&#10;    def enter(self, e):&#13;&#10;        # 현재 상태를 이전 상태로 저장 (복귀용)&#13;&#10;        self.prev_state = self.player.state_machine.cur_state&#13;&#10;&#13;&#10;        # 이미지 지연 로드(오버레이에서도 사용 가능하도록 유지하되, 여기서는 그리지 않음)&#13;&#10;        if self.image is None:&#13;&#10;            img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Inventory', 'InventoryBase_New1.png')&#13;&#10;            try:&#13;&#10;                self.image = load_image(img_path)&#13;&#10;            except Exception as ex:&#13;&#10;                print(f&quot;\033[91mFailed to load inventory image: {img_path}, {ex}\033[0m&quot;)&#13;&#10;                self.image = None&#13;&#10;&#13;&#10;        # 인벤토리 표시 플래그만 설정 (이동은 유지)&#13;&#10;        self.player.inventory_open = True&#13;&#10;&#13;&#10;    def exit(self, e):&#13;&#10;        # 표시 플래그만 해제&#13;&#10;        self.player.inventory_open = False&#13;&#10;&#13;&#10;    def do(self):&#13;&#10;        # 현재 키 상태에 따라 Idle/Run의 do를 동적으로 실행&#13;&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#13;&#10;        active_state.do()&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        # 현재 키 상태에 따라 Idle/Run의 draw를 먼저 실행 (플레이어 표시)&#13;&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#13;&#10;        active_state.draw(draw_x, draw_y)&#13;&#10;        # 인벤토리 이미지를 화면 오른쪽에 표시 (카메라 스크롤 영향 없음)&#13;&#10;        # if self.image:&#13;&#10;        #     canvas_w = get_canvas_width()&#13;&#10;        #     canvas_h = get_canvas_height()&#13;&#10;        #     inv_x = canvas_w - self.image.w * self.scale // 2 - 20&#13;&#10;        #     inv_y = canvas_h // 2&#13;&#10;        #     self.image.draw(inv_x, inv_y, self.image.w * self.scale, self.image.h * self.scale)&#13;&#10;        pass&#13;&#10;&#13;&#10;class Death:&#13;&#10;    &quot;&quot;&quot;플레이어 사망 상태&quot;&quot;&quot;&#13;&#10;    image = None&#13;&#10;    hit_fx_images = None  # PlayerHitFX 이미지들&#13;&#10;    heart_hit_images = None  # HeartHit 이미지들&#13;&#10;&#13;&#10;    def __init__(self, player):&#13;&#10;        self.player = player&#13;&#10;        self.world = getattr(player, 'world', None)  # play_mode에서 할당된 world 참조&#13;&#10;&#13;&#10;        if Death.image is None:&#13;&#10;            try:&#13;&#10;                Death.image = load_image('resources/Texture_organize/Player_character/Adventurer/Player_Adventurer_Down00.png')&#13;&#10;                print(f&quot;[Player Death] Loaded Down00 image&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[Player Death] Failed to load image: {e}\033[0m&quot;)&#13;&#10;                Death.image = None&#13;&#10;&#13;&#10;        # PlayerHitFX 이미지 로드 (1 ~ 9)&#13;&#10;        if Death.hit_fx_images is None:&#13;&#10;            Death.hit_fx_images = []&#13;&#10;            try:&#13;&#10;                for i in range(1, 10):  # PlayerHitFX01 ~ PlayerHitFX09&#13;&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Die_Animation', f'PlayerHitFX0{i}.png')&#13;&#10;                    img = load_image(img_path)&#13;&#10;                    Death.hit_fx_images.append(img)&#13;&#10;                print(f&quot;[Player Death] PlayerHitFX 이미지 로드 완료: {len(Death.hit_fx_images)}개&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[Player Death] PlayerHitFX 이미지 로드 실패: {e}\033[0m&quot;)&#13;&#10;                Death.hit_fx_images = []&#13;&#10;&#13;&#10;        # HeartHit 이미지 로드 (0 ~ 8)&#13;&#10;        if Death.heart_hit_images is None:&#13;&#10;            Death.heart_hit_images = []&#13;&#10;            try:&#13;&#10;                for i in range(9):  # HeartHit0_0 ~ HeartHit8_0&#13;&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Hit_verdict', f'HeartHit{i}_0.png')&#13;&#10;                    img = load_image(img_path)&#13;&#10;                    Death.heart_hit_images.append(img)&#13;&#10;                print(f&quot;[Player Death] HeartHit 이미지 로드 완료: {len(Death.heart_hit_images)}개&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[Player Death] HeartHit 이미지 로드 실패: {e}\033[0m&quot;)&#13;&#10;                Death.heart_hit_images = []&#13;&#10;&#13;&#10;        self.death_timer = 0.0&#13;&#10;        self.death_conversion = 2.0  # 2초 후 변환&#13;&#10;        self.death_duration = 6.0  # 6초 후 종료&#13;&#10;        self.game_over_conversion_triggered = False&#13;&#10;        self.game_over_triggered = False&#13;&#10;&#13;&#10;        # 넉백 관련 변수 (강한 넉백)&#13;&#10;        self.knockback_dx = 0&#13;&#10;        self.knockback_dy = 0&#13;&#10;        self.knockback_speed = 400  # 강한 넉백&#13;&#10;        self.knockback_duration = 0.5  # 0.5초 동안&#13;&#10;        self.knockback_timer = 0.0&#13;&#10;&#13;&#10;        # 애니메이션 관련 변수&#13;&#10;        self.hit_fx_frame = 0&#13;&#10;        self.hit_fx_time = 0.0&#13;&#10;        self.hit_fx_duration = 0.08  # 각 프레임당 0.08초&#13;&#10;&#13;&#10;        self.heart_hit_frame = 0&#13;&#10;        self.heart_hit_time = 0.0&#13;&#10;        self.heart_hit_duration = 0.1  # 각 프레임당 0.1초&#13;&#10;&#13;&#10;        # 사망 위치 저장 (이동 제거, 죽은 자리에서 유지)&#13;&#10;        self.death_x = 0&#13;&#10;        self.death_y = 0&#13;&#10;&#13;&#10;        # 사망 모드용 배경 이미지 클래스&#13;&#10;        class BGimage:&#13;&#10;            &quot;&quot;&quot;사망 모드용 배경 이미지 클래스&quot;&quot;&quot;&#13;&#10;&#13;&#10;            def __init__(self, image_path):&#13;&#10;                try:&#13;&#10;                    self.image = load_image(image_path)&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;[Defeat Mode BG] 이미지 로드 실패: {e}&quot;)&#13;&#10;                    self.image = None&#13;&#10;&#13;&#10;                self.alpha = 0.0 # 투명도 초기값&#13;&#10;&#13;&#10;            def do(self):&#13;&#10;                pass&#13;&#10;&#13;&#10;            def update(self):&#13;&#10;                # 점진적으로 투명도 증가 / 3초 동안 완전 불투명&#13;&#10;                if self.alpha &lt; 1.0:&#13;&#10;                    self.alpha += framework.get_delta_time() / 3.0 * 2  # 3초에 걸쳐 1.0 도달&#13;&#10;                    if self.alpha &gt; 1.0:&#13;&#10;                        self.alpha = 1.0&#13;&#10;&#13;&#10;            def draw(self):&#13;&#10;                if self.image:&#13;&#10;                    canvas_w = get_canvas_width()&#13;&#10;                    canvas_h = get_canvas_height()&#13;&#10;                    self.image.opacify(self.alpha)&#13;&#10;                    self.image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)&#13;&#10;                    self.image.opacify(1.0)&#13;&#10;&#13;&#10;        # 배경 이미지 인스턴스 생성&#13;&#10;        self.BG = BGimage('resources/Texture_organize/UI/Stage_Loading/BlackBG.png')&#13;&#10;&#13;&#10;    def enter(self, e):&#13;&#10;        self.death_timer = 0.0&#13;&#10;        self.game_over_triggered = False&#13;&#10;        self.knockback_timer = 0.0&#13;&#10;&#13;&#10;        # 애니메이션 초기화&#13;&#10;        self.hit_fx_frame = 0&#13;&#10;        self.hit_fx_time = 0.0&#13;&#10;        self.heart_hit_frame = 0&#13;&#10;        self.heart_hit_time = 0.0&#13;&#10;&#13;&#10;        # 사망 위치 저장 (현재 월드 좌표 그대로 유지)&#13;&#10;        self.death_x = self.player.x&#13;&#10;        self.death_y = self.player.y&#13;&#10;&#13;&#10;        # 플레이어 무장 해제&#13;&#10;        self.player.equipment_manager.unequip_all()&#13;&#10;&#13;&#10;        # 넉백 방향 계산&#13;&#10;        if e and len(e) &gt; 1 and e[1] is not None:&#13;&#10;            attacker = e[1]&#13;&#10;            attacker_x = attacker.x if hasattr(attacker, 'x') else self.player.x&#13;&#10;            attacker_y = attacker.y if hasattr(attacker, 'y') else self.player.y&#13;&#10;&#13;&#10;            if hasattr(attacker, 'owner') and attacker.owner:&#13;&#10;                attacker_x = attacker.owner.x&#13;&#10;                attacker_y = attacker.owner.y&#13;&#10;&#13;&#10;            import math&#13;&#10;            dx = self.player.x - attacker_x&#13;&#10;            dy = self.player.y - attacker_y&#13;&#10;            distance = math.sqrt(dx**2 + dy**2)&#13;&#10;&#13;&#10;            if distance &gt; 0:&#13;&#10;                self.knockback_dx = dx / distance&#13;&#10;                self.knockback_dy = dy / distance&#13;&#10;            else:&#13;&#10;                self.knockback_dx = 1.0&#13;&#10;                self.knockback_dy = 0.0&#13;&#10;        else:&#13;&#10;            self.knockback_dx = 1.0&#13;&#10;            self.knockback_dy = 0.0&#13;&#10;&#13;&#10;        print(f&quot;[Player Death State] 사망 상태 시작 (6초 후 defeat_mode로 전환) - 넉백 적용&quot;)&#13;&#10;        print(f&quot;[Player Death State] 사망 위치: ({self.death_x:.1f}, {self.death_y:.1f})&quot;)&#13;&#10;&#13;&#10;    def exit(self, e):&#13;&#10;        pass&#13;&#10;&#13;&#10;    def do(self):&#13;&#10;        dt = framework.get_delta_time()&#13;&#10;&#13;&#10;        self.death_timer += dt&#13;&#10;&#13;&#10;        # 넉백 효과 적용 (사망 초기 0.5초만, 이후엔 그 자리에 고정)&#13;&#10;        if self.knockback_timer &lt; self.knockback_duration:&#13;&#10;            progress = self.knockback_timer / self.knockback_duration&#13;&#10;            # 부드러운 감속&#13;&#10;            current_speed = self.knockback_speed * (1.0 - progress) ** 1.5&#13;&#10;            self.player.x += self.knockback_dx * current_speed * dt&#13;&#10;            self.player.y += self.knockback_dy * current_speed * dt&#13;&#10;            self.knockback_timer += dt&#13;&#10;        # 넉백 끝난 후에는 위치 고정 (중앙 이동 로직 제거)&#13;&#10;&#13;&#10;        # PlayerHitFX 애니메이션 업데이트&#13;&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#13;&#10;            self.hit_fx_time += dt&#13;&#10;            if self.hit_fx_time &gt;= self.hit_fx_duration:&#13;&#10;                self.hit_fx_time -= self.hit_fx_duration&#13;&#10;                self.hit_fx_frame += 1&#13;&#10;&#13;&#10;        # HeartHit 애니메이션 업데이트&#13;&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#13;&#10;            self.heart_hit_time += dt&#13;&#10;            if self.heart_hit_time &gt;= self.heart_hit_duration:&#13;&#10;                self.heart_hit_time -= self.heart_hit_duration&#13;&#10;                self.heart_hit_frame += 1&#13;&#10;&#13;&#10;        # 2초 후 배경 어둡게 시작 (extra_bg 레이어에 배경 추가)&#13;&#10;        if self.death_timer &gt;= self.death_conversion and not self.game_over_conversion_triggered:&#13;&#10;            self.game_over_conversion_triggered = True&#13;&#10;            print(f&quot;[Player Death State] 2초 경과, 배경 어둡게 시작&quot;)&#13;&#10;            from .play_mode import world&#13;&#10;            # 배경을 extra_bg 레이어에 추가하여 점진적으로 어둡게&#13;&#10;            world['extra_bg'].append(self.BG)&#13;&#10;            # 플레이어를 extras 레이어로 이동 (UI보다 아래, 배경보다 위에 그려지도록)&#13;&#10;            world['extras'].append(self.player)&#13;&#10;            if self.player in self.world['entities']:&#13;&#10;                world['entities'].remove(self.player)&#13;&#10;&#13;&#10;        # 6초 후 defeat_mode로 전환&#13;&#10;        if self.death_timer &gt;= self.death_duration and not self.game_over_triggered:&#13;&#10;            self.game_over_triggered = True&#13;&#10;            print(f&quot;[Player Death State] 6초 경과, 패배 모드로 전환&quot;)&#13;&#10;            import game_framework&#13;&#10;            from . import defeat_mode, play_mode&#13;&#10;            # play_mode의 경과 시간을 가져와서 defeat_mode로 전달&#13;&#10;            survival_time = getattr(play_mode, 'elapsed_time', 0.0)&#13;&#10;            print(f&quot;[Player Death State] 생존 시간: {survival_time:.2f}초&quot;)&#13;&#10;            game_framework.change_state(defeat_mode, self.player, survival_time)&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        # 플레이어 사망 이미지 (바닥에 누운 모습)&#13;&#10;        # draw_x, draw_y는 이미 카메라가 적용된 화면 좌표이므로 그대로 사용&#13;&#10;        if Death.image is not None:&#13;&#10;            Death.image.draw(draw_x, draw_y,&#13;&#10;                           Death.image.w * self.player.scale_factor,&#13;&#10;                           Death.image.h * self.player.scale_factor)&#13;&#10;&#13;&#10;        # PlayerHitFX 이펙트 (플레이어 위치에 크게)&#13;&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#13;&#10;            hit_fx_img = Death.hit_fx_images[self.hit_fx_frame]&#13;&#10;            scale = 3.0&#13;&#10;            hit_fx_img.draw(&#13;&#10;                draw_x,&#13;&#10;                draw_y,&#13;&#10;                hit_fx_img.w * scale,&#13;&#10;                hit_fx_img.h * scale&#13;&#10;            )&#13;&#10;&#13;&#10;        # HeartHit 이펙트 (플레이어 위치 기준)&#13;&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#13;&#10;            heart_hit_img = Death.heart_hit_images[self.heart_hit_frame]&#13;&#10;            scale = 3.0&#13;&#10;            heart_hit_img.draw(&#13;&#10;                draw_x,&#13;&#10;                draw_y,&#13;&#10;                heart_hit_img.w * scale,&#13;&#10;                heart_hit_img.h * scale&#13;&#10;            )&#13;&#10;&#13;&#10;&#13;&#10;# 사망 이벤트 predicate&#13;&#10;def die(e):&#13;&#10;    return e[0] == 'DIE'&#13;&#10;&#13;&#10;&#13;&#10;class Player:&#13;&#10;    def __init__(self):&#13;&#10;        self.x = get_canvas_width() // 2&#13;&#10;        self.y = get_canvas_height() // 2&#13;&#10;        self.death_x = self.x&#13;&#10;        self.death_y = self.y&#13;&#10;        self.frame = 0&#13;&#10;        self.dir = [0, 0]  # x, y 방향 벡터&#13;&#10;        self.face_dir = 1&#13;&#10;        self.scale_factor = 3.0&#13;&#10;        self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#13;&#10;        self.moving = False # 이동 상태 플래그&#13;&#10;        self.particles = [] # 파티클 리스트를 Player로 이동&#13;&#10;        self.attack_effects = [] # 공격 이펙트 리스트&#13;&#10;        self.dash_stack_max = 3 # 대시 최대 스택&#13;&#10;        self.dash_stack = self.dash_stack_max # 대시 스택 초기화&#13;&#10;        self.dash_recharge_time = 3.0 # 대시 재충전 시간(초당 1회 충전)&#13;&#10;        self.dash_recharge_timer = 0.0 # 대시 재충전 타이머&#13;&#10;&#13;&#10;        # 플레이어 히트박스 변수&#13;&#10;        self.collision_width = 15 * self.scale_factor&#13;&#10;        self.collision_height = 15 * self.scale_factor&#13;&#10;&#13;&#10;        # 무적시간 관련 변수&#13;&#10;        self.invincible = False  # 무적 상태인지&#13;&#10;        self.invincible_timer = 0.0  # 무적 시간 타이머&#13;&#10;        self.invincible_duration = 0.3  # 무적 시간 지속 시간 (0.3초)&#13;&#10;&#13;&#10;        # 넉백 관련 변수 (방패 방어 시 사용)&#13;&#10;        self.knockback_dx = 0.0&#13;&#10;        self.knockback_dy = 0.0&#13;&#10;        self.knockback_speed = 0.0&#13;&#10;        self.knockback_duration = 0.0&#13;&#10;        self.knockback_timer = 0.0&#13;&#10;&#13;&#10;        # 방패 깨짐 상태 변수&#13;&#10;        self.shield_broken = False  # 방패가 깨졌는지 여부&#13;&#10;&#13;&#10;        # 아이템별 개별 쿨타임 관리 시스템&#13;&#10;        # key: item.id (아이템 고유 ID), value: 남은 쿨타임 시간(초)&#13;&#10;        self.item_cooldowns = {}  # 각 아이템의 남은 쿨타임을 저장&#13;&#10;&#13;&#10;        # 인벤토리 데이터 생성 및 디버그 아이템 채우기&#13;&#10;        self.inventory = InventoryData(cols=6, rows=5)&#13;&#10;        try:&#13;&#10;            seed_debug_inventory(self.inventory)&#13;&#10;        except Exception as ex:&#13;&#10;            print('[Player] 디버그 인벤토리 시드 실패:', ex)&#13;&#10;&#13;&#10;        # 스탯 시스템&#13;&#10;        self.stats = PlayerStats()&#13;&#10;        # 인벤토리 패시브 적용&#13;&#10;        try:&#13;&#10;            self.rebuild_inventory_passives()&#13;&#10;        except Exception as ex:&#13;&#10;            print('[Player] 패시브 재구성 실패:', ex)&#13;&#10;&#13;&#10;        # 장비 매니저 초기화&#13;&#10;        self.equipment_manager = EquipmentManager(self)&#13;&#10;&#13;&#10;        # 기본 무기 장착 (Tier1 검과 방패)&#13;&#10;        sword_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Sword_Tier1.png')&#13;&#10;        shield_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Shield_Tier1.png')&#13;&#10;&#13;&#10;        self.sword = Sword(self, sword_path, scale=3.0)&#13;&#10;        self.shield = Shield(self, shield_path, scale=3.0)&#13;&#10;&#13;&#10;        self.equipment_manager.equip(self.sword)&#13;&#10;        self.equipment_manager.equip(self.shield)&#13;&#10;&#13;&#10;        # 상태 정의&#13;&#10;        self.IDLE = Idle(self)&#13;&#10;        self.RUN = Run(self)&#13;&#10;        self.DASH = Dash(self)  # 대시 상태 추가&#13;&#10;        self.INVENTORY = Inventory(self)&#13;&#10;        self.DEATH = Death(self)&#13;&#10;&#13;&#10;        # 전투 플래그(전투중엔 인벤토리 안 염)&#13;&#10;        self.in_combat = False&#13;&#10;        self.inventory_open = False&#13;&#10;&#13;&#10;        # 상태 전환에 대한 매핑&#13;&#10;        self.state_machine = StateMachine(&#13;&#10;            self.IDLE,&#13;&#10;            {&#13;&#10;                self.IDLE: {move_event: self.RUN, dash_event: self.DASH, Tab_down: self.INVENTORY, die: self.DEATH},&#13;&#10;                self.RUN: {stop_event: self.IDLE, dash_event: self.DASH, Tab_down: self.INVENTORY, die: self.DEATH},&#13;&#10;                self.DASH: {dash_end_event: None, die: self.DEATH},  # DASH_END에서 이전 상태로 복귀 (None = 동적 처리)&#13;&#10;                self.INVENTORY: {Tab_down: None, die: self.DEATH},&#13;&#10;                self.DEATH: {},  # 사망 상태에서는 전환 없음&#13;&#10;            }&#13;&#10;        )&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        dt = framework.get_delta_time()&#13;&#10;&#13;&#10;        # 이동 전 위치 저장 (벽 충돌 시 롤백용)&#13;&#10;        prev_x = self.x&#13;&#10;        prev_y = self.y&#13;&#10;&#13;&#10;        # 넉백 효과 적용 (방패 방어 시)&#13;&#10;        if self.knockback_timer &lt; self.knockback_duration:&#13;&#10;            progress = self.knockback_timer / self.knockback_duration&#13;&#10;            current_speed = self.knockback_speed * (1.0 - progress)&#13;&#10;            self.x += self.knockback_dx * current_speed * dt&#13;&#10;            self.y += self.knockback_dy * current_speed * dt&#13;&#10;            self.knockback_timer += dt&#13;&#10;&#13;&#10;        # 무적시간 업데이트&#13;&#10;        if self.invincible:&#13;&#10;            self.invincible_timer -= dt&#13;&#10;            if self.invincible_timer &lt;= 0:&#13;&#10;                self.invincible = False&#13;&#10;                self.invincible_timer = 0.0&#13;&#10;&#13;&#10;        # 대시 재충전 업데이트&#13;&#10;        if self.dash_stack &lt; self.dash_stack_max:&#13;&#10;            self.dash_recharge_timer += dt&#13;&#10;            if self.dash_recharge_timer &gt;= self.dash_recharge_time:&#13;&#10;                self.dash_stack += 1&#13;&#10;                self.dash_recharge_timer -= self.dash_recharge_time&#13;&#10;                print(f'\033[92m[Player] 대시 스택 충전: {self.dash_stack}/{self.dash_stack_max}\033[0m')&#13;&#10;&#13;&#10;        # 아이템별 개별 쿨타임 업데이트&#13;&#10;        # item_cooldowns 딕셔너리의 각 아이템 ID에 대해 쿨타임 감소&#13;&#10;        for item_id in list(self.item_cooldowns.keys()):&#13;&#10;            self.item_cooldowns[item_id] -= dt&#13;&#10;            if self.item_cooldowns[item_id] &lt;= 0:&#13;&#10;                # 쿨타임이 끝나면 딕셔너리에서 제거&#13;&#10;                del self.item_cooldowns[item_id]&#13;&#10;                print(f'\033[92m[Player] 아이템 사용 가능: {item_id} (쿨타임 종료)\033[0m')&#13;&#10;&#13;&#10;        self.state_machine.update()&#13;&#10;&#13;&#10;        # 벽 충돌 검사 (world 참조가 있는 경우)&#13;&#10;        if hasattr(self, 'world') and self.world and 'walls' in self.world:&#13;&#10;            # 플레이어 히트박스 (중심 기준)&#13;&#10;            player_w = 32  # 플레이어 너비 (필요시 조정)&#13;&#10;            player_h = 32  # 플레이어 높이 (필요시 조정)&#13;&#10;            player_left = self.x - player_w / 2&#13;&#10;            player_right = self.x + player_w / 2&#13;&#10;            player_bottom = self.y - player_h / 2&#13;&#10;            player_top = self.y + player_h / 2&#13;&#10;&#13;&#10;            # 모든 벽과 충돌 검사&#13;&#10;            collision_detected = False&#13;&#10;            for wall in self.world['walls']:&#13;&#10;                if hasattr(wall, 'check_collision'):&#13;&#10;                    # 벽의 히트박스 (중심 기준)&#13;&#10;                    wall_left = wall.x - wall.w / 2&#13;&#10;                    wall_right = wall.x + wall.w / 2&#13;&#10;                    wall_bottom = wall.y - wall.h / 2&#13;&#10;                    wall_top = wall.y + wall.h / 2&#13;&#10;&#13;&#10;                    # AABB 충돌 검사&#13;&#10;                    if (player_right &gt; wall_left and player_left &lt; wall_right and&#13;&#10;                        player_top &gt; wall_bottom and player_bottom &lt; wall_top):&#13;&#10;                        collision_detected = True&#13;&#10;                        break&#13;&#10;&#13;&#10;            # 충돌이 감지되면 이전 위치로 롤백&#13;&#10;            if collision_detected:&#13;&#10;                self.x = prev_x&#13;&#10;                self.y = prev_y&#13;&#10;                # 디버그 출력 (필요시 주석 해제)&#13;&#10;                # print(f&quot;[Player] 벽 충돌 감지! 위치 롤백: ({self.x:.1f}, {self.y:.1f})&quot;)&#13;&#10;&#13;&#10;        # 스탯 버프 업데이트(소비형 지속시간 관리)&#13;&#10;        if hasattr(self, 'stats'):&#13;&#10;            old_mana = self.stats.get('mana')&#13;&#10;            self.stats.update()&#13;&#10;            new_mana = self.stats.get('mana')&#13;&#10;&#13;&#10;            # 마나가 0에서 최대로 회복되면 방패 복구&#13;&#10;            if hasattr(self, 'shield_broken') and self.shield_broken:&#13;&#10;                if new_mana &gt;= 50:&#13;&#10;                    self.shield_broken = False&#13;&#10;                    print(f'\033[92m[Player] 방패 복구됨 (마나 회복)\033[0m')&#13;&#10;                else:&#13;&#10;                    # 마나가 아직 최대가 아니면 복구 불가&#13;&#10;                    pass&#13;&#10;&#13;&#10;        # 파티클 업데이트 (상태와 무관하게 항상 실행)&#13;&#10;        for p in self.particles:&#13;&#10;            p.update()&#13;&#10;        self.particles = [p for p in self.particles if p.life &gt; 0]&#13;&#10;&#13;&#10;        # 공격 이펙트 업데이트&#13;&#10;        for effect in self.attack_effects:&#13;&#10;            effect.update()&#13;&#10;        self.attack_effects = [e for e in self.attack_effects if e.life &gt; 0]&#13;&#10;&#13;&#10;        # 장비 업데이트&#13;&#10;        self.equipment_manager.update()&#13;&#10;&#13;&#10;    # 인벤토리 패시브 재적용&#13;&#10;    def rebuild_inventory_passives(self):&#13;&#10;        prefix = 'passive:'&#13;&#10;        self.stats.clear_by_prefix(prefix)&#13;&#10;        # 모든 슬롯 순회&#13;&#10;        try:&#13;&#10;            for r in range(self.inventory.rows):&#13;&#10;                for c in range(self.inventory.cols):&#13;&#10;                    slot = self.inventory.get_slot(r, c)&#13;&#10;                    if slot.is_empty():&#13;&#10;                        continue&#13;&#10;                    item = slot.item&#13;&#10;                    if getattr(item, 'passive', None):&#13;&#10;                        # 수량만큼 배수 적용(스택형 패시브 고려)&#13;&#10;                        qty = max(1, slot.quantity)&#13;&#10;                        values = {k: v * qty for k, v in item.passive.items()}&#13;&#10;                        mod_id = f'{prefix}{item.id}:{r},{c}'&#13;&#10;                        self.stats.add_modifier(StatModifier(mod_id, values, duration=None))&#13;&#10;        except Exception as ex:&#13;&#10;            print(f&quot;\033[91m[Player] 패시브 적용 중 오류: {ex}\033[0m&quot;)&#13;&#10;&#13;&#10;    # 소비형 아이템 사용 처리&#13;&#10;    def consume_item_at(self, r: int, c: int):&#13;&#10;        try:&#13;&#10;            slot = self.inventory.get_slot(r, c)&#13;&#10;        except Exception as ex:&#13;&#10;            print('[Player] 소비 실패: 잘못된 슬롯', ex)&#13;&#10;            return False&#13;&#10;&#13;&#10;        if slot.is_empty() or not getattr(slot.item, 'consumable', None):&#13;&#10;            return False&#13;&#10;&#13;&#10;        item = slot.item&#13;&#10;&#13;&#10;        # 아이템별 개별 쿨타임 체크&#13;&#10;        if item.id in self.item_cooldowns:&#13;&#10;            remaining_time = self.item_cooldowns[item.id]&#13;&#10;            print(f'\033[93m[Player] {item.name} 쿨타임 중! (남은 시간: {remaining_time:.1f}초)\033[0m')&#13;&#10;            return False&#13;&#10;&#13;&#10;        # 소비형 스탯 적용&#13;&#10;        values = dict(item.consumable)&#13;&#10;        duration = item.consume_duration&#13;&#10;        &#13;&#10;        # health와 mana는 즉시 회복 (최대값 제한)&#13;&#10;        instant_stats = {}&#13;&#10;        modifier_stats = {}&#13;&#10;        &#13;&#10;        for key, value in values.items():&#13;&#10;            if key == 'health':&#13;&#10;                # 현재 체력에 회복량을 더하되 최대 체력을 넘지 않도록&#13;&#10;                current_health = self.stats.base.get('health', 0.0)&#13;&#10;                max_health = self.stats.get('max_health')&#13;&#10;                new_health = min(max_health, current_health + value)&#13;&#10;                self.stats.base['health'] = new_health&#13;&#10;                instant_stats[key] = value&#13;&#10;                print(f'[Player] 체력 회복: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})')&#13;&#10;            elif key == 'mana':&#13;&#10;                # 현재 마나에 회복량을 더하되 최대 마나를 넘지 않도록&#13;&#10;                current_mana = self.stats.base.get('mana', 0.0)&#13;&#10;                max_mana = self.stats.get('max_mana')&#13;&#10;                new_mana = min(max_mana, current_mana + value)&#13;&#10;                self.stats.base['mana'] = new_mana&#13;&#10;                instant_stats[key] = value&#13;&#10;                print(f'[Player] 마나 회복: {current_mana:.1f} -&gt; {new_mana:.1f} (최대: {max_mana:.1f})')&#13;&#10;            else:&#13;&#10;                # 다른 스탯은 일시적 버프로 적용&#13;&#10;                modifier_stats[key] = value&#13;&#10;        &#13;&#10;        # 일시적 버프가 있는 경우에만 modifier 추가&#13;&#10;        if modifier_stats:&#13;&#10;            mod_id = f'consumable:{item.id}:{r},{c}:{int(time.time()*1000)%100000}'&#13;&#10;            self.stats.add_modifier(StatModifier(mod_id, modifier_stats, duration=duration))&#13;&#10;&#13;&#10;        # 1개 소모&#13;&#10;        self.inventory.remove_from(r, c, 1)&#13;&#10;&#13;&#10;        # 아이템별 쿨타임 시작 (아이템에 cooldown 속성이 있는 경우)&#13;&#10;        if hasattr(item, 'cooldown') and item.cooldown is not None and item.cooldown &gt; 0:&#13;&#10;            self.item_cooldowns[item.id] = item.cooldown&#13;&#10;            print(f'\033[93m[Player] {item.name} 사용! 쿨타임 시작 ({item.cooldown}초)\033[0m')&#13;&#10;        else:&#13;&#10;            print(f'\033[93m[Player] {item.name} 사용! (쿨타임 없음)\033[0m')&#13;&#10;&#13;&#10;        # 아이템의 이펙트 재생(있다면)&#13;&#10;        vfx_fn = (getattr(item, 'on_consume_vfx', None)&#13;&#10;                  or getattr(item, '_play_consume_vfx', None)&#13;&#10;                  or getattr(item, 'consume_effect', None))&#13;&#10;        if callable(vfx_fn):&#13;&#10;            try:&#13;&#10;                # prefer self.world (assigned by play_mode) so VFX are appended to the correct world dict&#13;&#10;                vfx_world = getattr(self, 'world', None)&#13;&#10;                # debug log&#13;&#10;                try:&#13;&#10;                    print(f&quot;[Player] triggering vfx for {getattr(item, 'name', item.id if hasattr(item,'id') else 'Unknown')} world={'set' if vfx_world is not None else 'None'})&quot;)&#13;&#10;                except Exception:&#13;&#10;                    pass&#13;&#10;                vfx_fn(self, world=vfx_world, x=getattr(self, 'x', None), y=getattr(self, 'y', None))&#13;&#10;            except Exception as ex:&#13;&#10;                print(f'[Player] 아이템 소비 이펙트 오류 ({item.name}):', ex)&#13;&#10;&#13;&#10;        # 패시브 재적용(수량 변화로 인한 패시브 변경 가능성 고려)&#13;&#10;        self.rebuild_inventory_passives()&#13;&#10;        print(f&quot;[Player] 소비: {item.name} -&gt; {values} ({duration}s)&quot;)&#13;&#10;        return True&#13;&#10;&#13;&#10;    # 신규: 입력 처리 - 상태머신과 장비 매니저로 이벤트 전달, 이동 벡터 관리&#13;&#10;    def handle_event(self, event):&#13;&#10;        try:&#13;&#10;            from sdl2 import SDL_KEYDOWN, SDL_KEYUP, SDLK_w, SDLK_a, SDLK_s, SDLK_d, SDLK_SPACE&#13;&#10;        except Exception:&#13;&#10;            SDL_KEYDOWN = SDL_KEYUP = None&#13;&#10;            SDLK_w = SDLK_a = SDLK_s = SDLK_d = SDLK_SPACE = None&#13;&#10;&#13;&#10;        # 1) 스페이스바 입력 처리 - 대시 실행&#13;&#10;        try:&#13;&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN and event.key == SDLK_SPACE:&#13;&#10;                # 대시 스택이 있고, Dash 상태가 아닐 때만 대시 가능&#13;&#10;                if self.dash_stack &gt; 0 and not isinstance(self.state_machine.cur_state, Dash):&#13;&#10;                    # 대시 스택 소모&#13;&#10;                    self.dash_stack -= 1&#13;&#10;                    print(f'\033[96m[Player] 대시 사용! 남은 스택: {self.dash_stack}/{self.dash_stack_max}\033[0m')&#13;&#10;                    # 대시 재충전 타이머 초기화&#13;&#10;                    self.dash_recharge_timer = 0.0&#13;&#10;                    # DASH 이벤트 발생&#13;&#10;                    if hasattr(self, 'state_machine'):&#13;&#10;                        self.state_machine.handle_state_event(('DASH', None))&#13;&#10;                elif self.dash_stack &lt;= 0:&#13;&#10;                    print(f'\033[93m[Player] 대시 스택 부족! ({self.dash_stack}/{self.dash_stack_max})\033[0m')&#13;&#10;        except Exception as ex:&#13;&#10;            print('[Player] 스페이스바 입력 처리 오류:', ex)&#13;&#10;&#13;&#10;        # 2) 장비 매니저에 항상 전달(매니저 내부에서 인벤토리 오픈시 무시 처리)&#13;&#10;        try:&#13;&#10;            if hasattr(self, 'equipment_manager') and hasattr(self.equipment_manager, 'handle_event'):&#13;&#10;                self.equipment_manager.handle_event(event)&#13;&#10;        except Exception as ex:&#13;&#10;            print('[Player] equipment_manager.handle_event 오류:', ex)&#13;&#10;&#13;&#10;        # 3) 상태머신으로 원본 입력 이벤트 전달(Tab 매핑 등 predicates가 처리)&#13;&#10;        try:&#13;&#10;            if hasattr(self, 'state_machine') and hasattr(self.state_machine, 'handle_state_event'):&#13;&#10;                self.state_machine.handle_state_event(('INPUT', event))&#13;&#10;        except Exception as ex:&#13;&#10;            print('[Player] state_machine 입력 이벤트 처리 오류:', ex)&#13;&#10;&#13;&#10;        # 4) WASD 이동 상태 관리 -&gt; MOVE/STOP 이벤트 생성&#13;&#10;        moved_before = any(self.keys_down.values())&#13;&#10;        try:&#13;&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN:&#13;&#10;                if event.key == SDLK_w:&#13;&#10;                    self.keys_down['w'] = True&#13;&#10;                    self.dir[1] = 1&#13;&#10;                elif event.key == SDLK_s:&#13;&#10;                    self.keys_down['s'] = True&#13;&#10;                    self.dir[1] = -1&#13;&#10;                elif event.key == SDLK_a:&#13;&#10;                    self.keys_down['a'] = True&#13;&#10;                    self.dir[0] = -1&#13;&#10;                elif event.key == SDLK_d:&#13;&#10;                    self.keys_down['d'] = True&#13;&#10;                    self.dir[0] = 1&#13;&#10;            elif SDL_KEYUP is not None and event.type == SDL_KEYUP:&#13;&#10;                if event.key == SDLK_w:&#13;&#10;                    self.keys_down['w'] = False&#13;&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#13;&#10;                elif event.key == SDLK_s:&#13;&#10;                    self.keys_down['s'] = False&#13;&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#13;&#10;                elif event.key == SDLK_a:&#13;&#10;                    self.keys_down['a'] = False&#13;&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#13;&#10;                elif event.key == SDLK_d:&#13;&#10;                    self.keys_down['d'] = False&#13;&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#13;&#10;&#13;&#10;        except Exception as ex:&#13;&#10;            print('[Player] 이동 입력 처리 오류:', ex)&#13;&#10;&#13;&#10;        moved_after = any(self.keys_down.values())&#13;&#10;        try:&#13;&#10;            if not moved_before and moved_after:&#13;&#10;                # 시작 이동&#13;&#10;                if hasattr(self, 'state_machine'):&#13;&#10;                    self.state_machine.handle_state_event(('MOVE', None))&#13;&#10;            elif moved_before and not moved_after:&#13;&#10;                # 이동 종료&#13;&#10;                if hasattr(self, 'state_machine'):&#13;&#10;                    self.state_machine.handle_state_event(('STOP', None))&#13;&#10;        except Exception as ex:&#13;&#10;            print('[Player] MOVE/STOP 이벤트 처리 오류:', ex)&#13;&#10;&#13;&#10;    # 신규: 렌더링 - 장비/플레이어/이펙트 순서대로 그리기&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표이므로 그대로 사용&#13;&#10;&#13;&#10;        # 디버그 로그 - 카메라 정보 포함&#13;&#10;        camera = None&#13;&#10;        try:&#13;&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#13;&#10;            import game_logic.play_mode as play&#13;&#10;            camera = getattr(play, 'camera', None)&#13;&#10;&#13;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#13;&#10;            if camera is None:&#13;&#10;                import game_logic.lobby_mode as lobby&#13;&#10;                camera = getattr(lobby, 'camera', None)&#13;&#10;        except:&#13;&#10;            print(f'\033[93m[Player] 카메라 정보 가져오기 실패 (디버그 로그 생략)\033[0m')&#13;&#10;&#13;&#10;        # if camera is not None:&#13;&#10;        #     print(f'[Player] draw at screen ({draw_x:.1f}, {draw_y:.1f}), '&#13;&#10;        #           f'world ({self.x:.1f}, {self.y:.1f}), '&#13;&#10;        #           f'camera ({camera.x:.1f}, {camera.y:.1f})')&#13;&#10;        # else:&#13;&#10;        #     print(f'[Player] draw at ({draw_x:.1f}, {draw_y:.1f}), world ({self.x:.1f}, {self.y:.1f}) (NO CAMERA)')&#13;&#10;&#13;&#10;        # 1) 장비(뒤쪽) 그리기&#13;&#10;        if hasattr(self, 'equipment_manager'):&#13;&#10;            self.equipment_manager.draw_back(draw_x, draw_y)&#13;&#10;&#13;&#10;        # 2) 현재 상태 스프라이트(Idle/Run/Inventory)&#13;&#10;        try:&#13;&#10;            if hasattr(self, 'state_machine'):&#13;&#10;                if self.state_machine.current_state is not self.DEATH:&#13;&#10;                    self.death_x, self.death_y = draw_x, draw_y&#13;&#10;                self.state_machine.draw(draw_x, draw_y)&#13;&#10;        except Exception as ex:&#13;&#10;            print(f'\033[91m[Player] 상태머신 그리기 오류 발생 : {ex}\033[0m')&#13;&#10;&#13;&#10;        # 3) 장비(앞쪽) 그리기&#13;&#10;        if hasattr(self, 'equipment_manager'):&#13;&#10;            self.equipment_manager.draw_front(draw_x, draw_y)&#13;&#10;&#13;&#10;        # 4) 파티클/공격 이펙트 (카메라 적용)&#13;&#10;        try:&#13;&#10;            # 위에서 이미 가져온 camera 사용&#13;&#10;            for p in getattr(self, 'particles', []):&#13;&#10;                if hasattr(p, 'draw'):&#13;&#10;                    if camera is not None:&#13;&#10;                        particle_draw_x, particle_draw_y = camera.apply(p.x, p.y)&#13;&#10;                        p.draw(particle_draw_x, particle_draw_y)&#13;&#10;                    else:&#13;&#10;                        p.draw(p.x, p.y)&#13;&#10;            for e in getattr(self, 'attack_effects', []):&#13;&#10;                if hasattr(e, 'draw'):&#13;&#10;                    if camera is not None:&#13;&#10;                        effect_draw_x, effect_draw_y = camera.apply(e.x, e.y)&#13;&#10;                        e.draw(effect_draw_x, effect_draw_y)&#13;&#10;                    else:&#13;&#10;                        e.draw(e.x, e.y)&#13;&#10;        except Exception:&#13;&#10;            print(f'\033[91m[Player] 파티클/이펙트 그리기 오류 발생 : {ex}\033[0m')&#13;&#10;&#13;&#10;        # 화면에 표시되는 히트박스 (카메라 적용된 좌표 사용)&#13;&#10;        # player_left = draw_x - self.collision_width / 2&#13;&#10;        # player_right = draw_x + self.collision_width / 2&#13;&#10;        # player_bottom = draw_y - self.collision_height / 2&#13;&#10;        # player_top = draw_y + self.collision_height / 2&#13;&#10;        # draw_rectangle(player_left, player_bottom, player_right, player_top)&#13;&#10;&#13;&#10;    def check_collision_with_projectile(self, projectile):&#13;&#10;        &quot;&quot;&quot;몬스터 발사체와의 충돌 감지&#13;&#10;&#13;&#10;        Args:&#13;&#10;            projectile: Projectile을 상속받은 발사체 객체&#13;&#10;&#13;&#10;        Returns:&#13;&#10;            bool: 충돌 여부&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # 먼저 방패로 방어할 수 있는지 체크&#13;&#10;        if hasattr(self, 'shield') and self.shield:&#13;&#10;            if self.shield.check_projectile_block(projectile):&#13;&#10;                # 방패로 막았으면 투사체를 제거하고 충돌 처리 종료&#13;&#10;                return True&#13;&#10;&#13;&#10;        # 무적 상태이면 충돌 무시&#13;&#10;        if hasattr(self, 'invincible') and self.invincible:&#13;&#10;            return False&#13;&#10;&#13;&#10;        # 발사체 크기 (Projectile의 get_collision_box 메서드 사용)&#13;&#10;        if hasattr(projectile, 'get_collision_box'):&#13;&#10;            projectile_width, projectile_height = projectile.get_collision_box()&#13;&#10;        else:&#13;&#10;            projectile_width = 30&#13;&#10;            projectile_height = 30&#13;&#10;&#13;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#13;&#10;        player_left = self.x - self.collision_width / 2&#13;&#10;        player_right = self.x + self.collision_width / 2&#13;&#10;        player_bottom = self.y - self.collision_height / 2&#13;&#10;        player_top = self.y + self.collision_height / 2&#13;&#10;&#13;&#10;        proj_left = projectile.x - projectile_width / 2&#13;&#10;        proj_right = projectile.x + projectile_width / 2&#13;&#10;        proj_bottom = projectile.y - projectile_height / 2&#13;&#10;        proj_top = projectile.y + projectile_height / 2&#13;&#10;&#13;&#10;        # 충돌 검사&#13;&#10;        if (player_left &lt; proj_right and player_right &gt; proj_left and&#13;&#10;            player_bottom &lt; proj_top and player_top &gt; proj_bottom):&#13;&#10;            # 충돌 시 피격 처리&#13;&#10;            self.on_hit(projectile)&#13;&#10;            return True&#13;&#10;&#13;&#10;        return False&#13;&#10;&#13;&#10;    def check_collision_with_effect(self, effect):&#13;&#10;        &quot;&quot;&quot;몬스터 공격 이펙트와의 충돌 감지 (CatThiefSwingEffect 등)&#13;&#10;&#13;&#10;        Args:&#13;&#10;            effect: 공격 이펙트 객체 (get_collision_box 메서드를 가진 이펙트)&#13;&#10;&#13;&#10;        Returns:&#13;&#10;            bool: 충돌 여부&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # 먼저 방패로 방어할 수 있는지 체크&#13;&#10;        if hasattr(self, 'shield') and self.shield:&#13;&#10;            # 방패의 방향과 이펙트 위치를 고려하여 방어 판정&#13;&#10;            if hasattr(self.shield, 'check_effect_block'):&#13;&#10;                if self.shield.check_effect_block(effect):&#13;&#10;                    # 방패로 막았으면 충돌 처리 종료&#13;&#10;                    print(f&quot;[Player] 방패로 {effect.__class__.__name__} 방어!&quot;)&#13;&#10;                    return True&#13;&#10;&#13;&#10;        # 무적 상태이면 충돌 무시&#13;&#10;        if hasattr(self, 'invincible') and self.invincible:&#13;&#10;            return False&#13;&#10;&#13;&#10;        # 이펙트 크기 (get_collision_box 메서드 사용)&#13;&#10;        if hasattr(effect, 'get_collision_box'):&#13;&#10;            effect_width, effect_height = effect.get_collision_box()&#13;&#10;        else:&#13;&#10;            # 기본값&#13;&#10;            effect_width = 100&#13;&#10;            effect_height = 100&#13;&#10;&#13;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#13;&#10;        player_left = self.x - self.collision_width / 2&#13;&#10;        player_right = self.x + self.collision_width / 2&#13;&#10;        player_bottom = self.y - self.collision_height / 2&#13;&#10;        player_top = self.y + self.collision_height / 2&#13;&#10;&#13;&#10;        effect_left = effect.x - effect_width / 2&#13;&#10;        effect_right = effect.x + effect_width / 2&#13;&#10;        effect_bottom = effect.y - effect_height / 2&#13;&#10;        effect_top = effect.y + effect_height / 2&#13;&#10;&#13;&#10;        # 충돌 검사&#13;&#10;        if (player_left &lt; effect_right and player_right &gt; effect_left and&#13;&#10;            player_bottom &lt; effect_top and player_top &gt; effect_bottom):&#13;&#10;            # 충돌 시 피격 처리&#13;&#10;            self.on_hit(effect)&#13;&#10;            return True&#13;&#10;&#13;&#10;        return False&#13;&#10;&#13;&#10;    def on_hit(self, attacker):&#13;&#10;        &quot;&quot;&quot;피격 시 호출되는 메서드&#13;&#10;&#13;&#10;        Args:&#13;&#10;            attacker: 공격한 객체 (투사체, 이펙트 등)&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # 무적 상태라면 무시&#13;&#10;        if self.invincible:&#13;&#10;            print(f&quot;[Player] 무적 상태로 피격 무시 (남은 무적시간: {self.invincible_timer:.2f}초)&quot;)&#13;&#10;            return&#13;&#10;&#13;&#10;        # 사망 상태면 무시&#13;&#10;        if isinstance(self.state_machine.cur_state, Death):&#13;&#10;            return&#13;&#10;&#13;&#10;        # 무적시간 활성화&#13;&#10;        self.invincible = True&#13;&#10;        self.invincible_timer = self.invincible_duration&#13;&#10;&#13;&#10;        # 데미지 계산&#13;&#10;        damage = 0&#13;&#10;        if hasattr(attacker, 'damage'):&#13;&#10;            damage = attacker.damage&#13;&#10;        elif hasattr(attacker, 'owner') and hasattr(attacker.owner, 'stats'):&#13;&#10;            # 공격자의 스탯에서 데미지 가져오기&#13;&#10;            damage = attacker.owner.stats.get('attack_damage')&#13;&#10;        else:&#13;&#10;            damage = 10.0  # 기본 데미지&#13;&#10;&#13;&#10;        # 방어력 적산&#13;&#10;        defense = self.stats.get('defense') if hasattr(self, 'stats') else 0&#13;&#10;        final_damage = max(1.0, damage - defense)&#13;&#10;&#13;&#10;        # 넉백 효과 적용 (공격자로부터 밀려나는 방향)&#13;&#10;        import math&#13;&#10;        knockback_distance = 100.0  # 넉백 거리&#13;&#10;        knockback_duration = 0.3  # 넉백 지속 시간 (초)&#13;&#10;&#13;&#10;        # 공격자의 위치 파악&#13;&#10;        attacker_x = attacker.x if hasattr(attacker, 'x') else self.x&#13;&#10;        attacker_y = attacker.y if hasattr(attacker, 'y') else self.y&#13;&#10;&#13;&#10;        # 넉백 방향 계산 (공격자 -&gt; 플레이어 방향)&#13;&#10;        dx = self.x - attacker_x&#13;&#10;        dy = self.y - attacker_y&#13;&#10;        distance = math.sqrt(dx * dx + dy * dy)&#13;&#10;&#13;&#10;        if distance &gt; 0:&#13;&#10;            # 정규화된 방향 벡터&#13;&#10;            self.knockback_dx = dx / distance&#13;&#10;            self.knockback_dy = dy / distance&#13;&#10;        else:&#13;&#10;            # 공격자와 위치가 같으면 랜덤 방향&#13;&#10;            angle = random.uniform(0, 2 * math.pi)&#13;&#10;            self.knockback_dx = math.cos(angle)&#13;&#10;            self.knockback_dy = math.sin(angle)&#13;&#10;&#13;&#10;        self.knockback_speed = knockback_distance / knockback_duration&#13;&#10;        self.knockback_duration = knockback_duration&#13;&#10;        self.knockback_timer = 0.0&#13;&#10;&#13;&#10;        # 스텟 업데이트 - 체력 감소, 마나 감소 등&#13;&#10;        if hasattr(self, 'stats'):&#13;&#10;            current_health = self.stats.get('health')&#13;&#10;            max_health = self.stats.get('max_health')&#13;&#10;            new_health = max(0, current_health - final_damage)&#13;&#10;            self.stats.set_base('health', new_health)&#13;&#10;&#13;&#10;            # 피격 정보 출력&#13;&#10;            attacker_name = attacker.__class__.__name__&#13;&#10;            DebugPrint = True&#13;&#10;            if DebugPrint:&#13;&#10;                print(f&quot;\n{'='*60}&quot;)&#13;&#10;                print(f&quot;[Player 피격]&quot;)&#13;&#10;                print(f&quot;  공격자: {attacker_name}&quot;)&#13;&#10;                print(f&quot;  원본 데미지: {damage:.1f}&quot;)&#13;&#10;                print(f&quot;  방어력: {defense:.1f}&quot;)&#13;&#10;                print(f&quot;  최종 데미지: {final_damage:.1f}&quot;)&#13;&#10;                print(f&quot;  체력 변화: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})&quot;)&#13;&#10;                print(f&quot;  체력 비율: {(new_health/max_health)*100:.1f}%&quot;)&#13;&#10;                print(f&quot;  무적시간: {self.invincible_duration}초 활성화&quot;)&#13;&#10;                print(f&quot;  넉백: 거리 {knockback_distance:.1f}px, 지속시간 {knockback_duration:.2f}초&quot;)&#13;&#10;&#13;&#10;            # 체력이 0 이하면 사망 상태로 전환&#13;&#10;            if new_health &lt;= 0:&#13;&#10;                print(f&quot;  &gt;&gt;&gt; Player 체력 0 - 사망 상태로 전환&quot;)&#13;&#10;                print(f&quot;{'='*60}\n&quot;)&#13;&#10;                self.state_machine.handle_state_event(('DIE', attacker))&#13;&#10;                return  # 사망 시 이펙트 생성하지 않음&#13;&#10;            else:&#13;&#10;                print(f&quot;{'='*60}\n&quot;)&#13;&#10;        else:&#13;&#10;            attacker_name = attacker.__class__.__name__&#13;&#10;            print(f&quot;[Player] 피격당함! 공격자: {attacker_name} (스탯 시스템 없음)&quot;)&#13;&#10;&#13;&#10;        # 피격 이펙트 재생 - Wound Particle 생성 (4개)&#13;&#10;        for i in range(4):&#13;&#10;            # 랜덤한 방향으로 파티클 발사&#13;&#10;            angle = random.uniform(0, 2 * math.pi)&#13;&#10;            speed = random.uniform(80, 150)  # 속도 랜덤&#13;&#10;            vx = math.cos(angle) * speed&#13;&#10;            vy = math.sin(angle) * speed + random.uniform(50, 100) # 위쪽으로 약간 더 많이&#13;&#10;&#13;&#10;            # 플레이어 위치에서 약간 랜덤한 오프셋&#13;&#10;            offset_x = random.uniform(-10, 10)&#13;&#10;            offset_y = random.uniform(-10, 10)&#13;&#10;&#13;&#10;            wound_particle = VFX_Wound_Particle(&#13;&#10;                self.x + offset_x,&#13;&#10;                self.y + offset_y,&#13;&#10;                vx, vy,&#13;&#10;                scale=3.0&#13;&#10;            )&#13;&#10;            self.particles.append(wound_particle)&#13;&#10;&#13;&#10;        print(f&quot;[Player] 피격 이펙트 생성 완료 (Wound Particle x4)&quot;)&#13;&#10;&#13;&#10;        # 데미지 인디케이터 생성&#13;&#10;        try:&#13;&#10;            if hasattr(self, 'world') and self.world and 'effects_front' in self.world:&#13;&#10;                dmg_indicator = DamageIndicator(&#13;&#10;                    x=self.x,&#13;&#10;                    y=self.y,&#13;&#10;                    damage=final_damage,&#13;&#10;                    font_size=20&#13;&#10;                )&#13;&#10;                self.world['effects_front'].append(dmg_indicator)&#13;&#10;                print(f&quot;[Player] 데미지 인디케이터 생성: {final_damage:.1f} 데미지&quot;)&#13;&#10;        except Exception as ex:&#13;&#10;            print(f'\033[91m[Player] 데미지 인디케이터 생성 실패: {ex}\033[0m')&#13;&#10;            pass&#13;&#10;&#13;&#10;        # TODO: 추후 추가 가능&#13;&#10;        # - 피격 사운드&#13;&#10;&#13;&#10;    def on_death(self):&#13;&#10;        &quot;&quot;&quot;사망 처리 - 상태 머신을 통해 Death 상태로 전환&quot;&quot;&quot;&#13;&#10;        print(&quot;[Player] on_death 호출 - Death 상태로 전환&quot;)&#13;&#10;        self.state_machine.handle_state_event(('DIE', None))&#13;&#10;&#13;&#10;class VFX_Run_Particle:&#13;&#10;    def __init__(self, x, y, frames, frame_duration, scale):&#13;&#10;        self.x, self.y = x, y&#13;&#10;        self.frames = frames&#13;&#10;        self.frame = 0&#13;&#10;        self.frame_time_acc = 0.0&#13;&#10;        self.frame_duration = frame_duration&#13;&#10;        self.scale_factor = scale&#13;&#10;        self.life = len(frames) * frame_duration&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        dt = framework.get_delta_time()&#13;&#10;        self.life -= dt&#13;&#10;        if self.life &lt; 0:&#13;&#10;            return False  # 수명이 다하면 False 반환&#13;&#10;&#13;&#10;        self.frame_time_acc += dt&#13;&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#13;&#10;            self.frame_time_acc -= self.frame_duration&#13;&#10;            self.frame = (self.frame + 1) % len(self.frames)&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#13;&#10;        if self.frame &lt; len(self.frames):&#13;&#10;            image = self.frames[self.frame]&#13;&#10;            image.draw(draw_x, draw_y, image.w * self.scale_factor, image.h * self.scale_factor)&#13;&#10;&#13;&#10;&#13;&#10;class VFX_Wound_Particle:&#13;&#10;    &quot;&quot;&quot;피격 시 출혈 파티클 이펙트 (개별 이미지 파일 사용)&quot;&quot;&quot;&#13;&#10;    _frames = None  # 클래스 변수로 이미지 프레임 공유&#13;&#10;&#13;&#10;    def __init__(self, x, y, vx, vy, scale=3.0):&#13;&#10;        # 이미지 프레임 로드 (최초 1회만)&#13;&#10;        if VFX_Wound_Particle._frames is None:&#13;&#10;            VFX_Wound_Particle._frames = []&#13;&#10;            wound_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Wound_Particle')&#13;&#10;            try:&#13;&#10;                for i in range(5):  # WoundParticle_0 ~ WoundParticle_4&#13;&#10;                    img_path = os.path.join(wound_folder, f'WoundParticle_{i}.png')&#13;&#10;                    frame = load_image(img_path)&#13;&#10;                    VFX_Wound_Particle._frames.append(frame)&#13;&#10;                print(f&quot;[WoundParticle] 이미지 로드 완료: {len(VFX_Wound_Particle._frames)}개 프레임&quot;)&#13;&#10;            except Exception as ex:&#13;&#10;                print(f&quot;[WoundParticle] 이미지 로드 실패: {ex}&quot;)&#13;&#10;                VFX_Wound_Particle._frames = []&#13;&#10;&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.vx = vx  # x 방향 속도&#13;&#10;        self.vy = vy  # y 방향 속도&#13;&#10;        self.scale_factor = scale&#13;&#10;&#13;&#10;        # 애니메이션 설정&#13;&#10;        self.total_frames = 5  # 총 프레임 수&#13;&#10;        self.current_frame = 0&#13;&#10;        self.frame_duration = 0.08  # 각 프레임당 0.08초&#13;&#10;        self.frame_time_acc = 0.0&#13;&#10;        self.life = self.total_frames * self.frame_duration  # 총 수명&#13;&#10;&#13;&#10;        # 중력 효과&#13;&#10;        self.gravity = 200.0  # 픽셀/초^2&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        dt = framework.get_delta_time()&#13;&#10;&#13;&#10;        # 수명 감소&#13;&#10;        self.life -= dt&#13;&#10;        if self.life &lt;= 0:&#13;&#10;            return False&#13;&#10;&#13;&#10;        # 물리 업데이트&#13;&#10;        self.x += self.vx * dt&#13;&#10;        self.y += self.vy * dt&#13;&#10;        self.vy -= self.gravity * dt  # 중력 적용&#13;&#10;&#13;&#10;        # 애니메이션 업데이트&#13;&#10;        self.frame_time_acc += dt&#13;&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#13;&#10;            self.frame_time_acc -= self.frame_duration&#13;&#10;            self.current_frame += 1&#13;&#10;            if self.current_frame &gt;= self.total_frames:&#13;&#10;                self.current_frame = self.total_frames - 1  # 마지막 프레임 유지&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#13;&#10;        if not VFX_Wound_Particle._frames or len(VFX_Wound_Particle._frames) == 0:&#13;&#10;            return&#13;&#10;&#13;&#10;        if self.current_frame &lt; len(VFX_Wound_Particle._frames):&#13;&#10;            image = VFX_Wound_Particle._frames[self.current_frame]&#13;&#10;            image.draw(&#13;&#10;                draw_x, draw_y,&#13;&#10;                image.w * self.scale_factor,&#13;&#10;                image.h * self.scale_factor&#13;&#10;            )&#13;&#10;&#13;&#10;&#13;&#10;# VFX 전역 배율 설정: 전체 이펙트 크기와 거리(범위)를 일괄 조정&#13;&#10;VFX_GLOBAL_SCALE_MULT = 0.7   # 이펙트 크기 0.7배&#13;&#10;VFX_GLOBAL_RANGE_MULT = 0.8   # 이펙트 거리 0.8배&#13;&#10;&#13;&#10;class VFX_Tier1_Sword_Swing:&#13;&#10;    &quot;&quot;&quot;검 공격 이펙트 VFX&quot;&quot;&quot;&#13;&#10;    def __init__(self, x, y, angle, flip, scale=4.5, range_factor=60, variant=1, owner=None):&#13;&#10;        import math&#13;&#10;&#13;&#10;        # 공격자 정보 저장&#13;&#10;        self.owner = owner&#13;&#10;&#13;&#10;        # 데미지 설정 (owner의 스탯에서 가져오거나 기본값 사용)&#13;&#10;        if owner and hasattr(owner, 'stats'):&#13;&#10;            self.damage = owner.stats.get('attack_damage')&#13;&#10;        else:&#13;&#10;            self.damage = 20.0  # 기본 데미지&#13;&#10;&#13;&#10;        # 전역 배율을 적용한 range_factor/scale 사용&#13;&#10;        range_factor = range_factor * VFX_GLOBAL_RANGE_MULT&#13;&#10;        scale = scale * VFX_GLOBAL_SCALE_MULT&#13;&#10;&#13;&#10;        # 받은 위치에서 angle 방향으로 range_factor만큼 떨어진 위치 계산&#13;&#10;        temp_x = range_factor * math.cos(angle)&#13;&#10;        temp_y = range_factor * math.sin(angle)&#13;&#10;&#13;&#10;        self.x = x + temp_x&#13;&#10;        self.y = y + temp_y&#13;&#10;&#13;&#10;        # 각도 조정: 마우스가 오른쪽(0도~90도, 270도~360도)일 때 -90도, 왼쪽일 때 +90도&#13;&#10;        angle_deg = math.degrees(angle) % 360&#13;&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽&#13;&#10;            self.angle = angle + math.radians(90)&#13;&#10;        else:  # 오른쪽&#13;&#10;            self.angle = angle - math.radians(90)&#13;&#10;&#13;&#10;        self.flip = flip&#13;&#10;        self.scale_factor = scale&#13;&#10;&#13;&#10;        # 이펙트 이미지 로드&#13;&#10;        fx_folder = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Swing_FX')&#13;&#10;        if variant == 1:&#13;&#10;            self.frames = [&#13;&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#13;&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#13;&#10;            ]&#13;&#10;        elif variant == 2:&#13;&#10;            # 콤보 전용 스프라이트&#13;&#10;            self.frames = [&#13;&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_0.png')),&#13;&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_1.png'))&#13;&#10;            ]&#13;&#10;        elif variant == 3:&#13;&#10;            # Heavy swing (3스테이지) - 여러 프레임&#13;&#10;            self.frames = [&#13;&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_0.png')),&#13;&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_1.png')),&#13;&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_2.png')),&#13;&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_3.png'))&#13;&#10;            ]&#13;&#10;        else:&#13;&#10;            # 안전망: 기본으로 variant 1 사용&#13;&#10;            self.frames = [&#13;&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#13;&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#13;&#10;            ]&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.frame_time_acc = 0.0&#13;&#10;        self.frame_duration = 0.05  # 각 프레임당 0.05초&#13;&#10;        self.life = len(self.frames) * self.frame_duration  # 총 수명&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        dt = framework.get_delta_time()&#13;&#10;        self.life -= dt&#13;&#10;        if self.life &lt;= 0:&#13;&#10;            return False  # 수명이 다하면 False 반환&#13;&#10;&#13;&#10;        self.frame_time_acc += dt&#13;&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#13;&#10;            self.frame_time_acc -= self.frame_duration&#13;&#10;            self.frame += 1&#13;&#10;            if self.frame &gt;= len(self.frames):&#13;&#10;                self.frame = len(self.frames) - 1  # 마지막 프레임 유지&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#13;&#10;        if self.frame &lt; len(self.frames):&#13;&#10;            image = self.frames[self.frame]&#13;&#10;            image.clip_composite_draw(&#13;&#10;                0, 0, image.w, image.h,&#13;&#10;                self.angle, self.flip,&#13;&#10;                draw_x, draw_y,&#13;&#10;                image.w * self.scale_factor,&#13;&#10;                image.h * self.scale_factor&#13;&#10;            )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/state_machine.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/state_machine.py" />
              <option name="originalContent" value="from .event_to_string import event_to_string&#10;import game_framework&#10;from .inventory import InventoryData&#10;&#10;&#10;class StateMachine:&#10;    def __init__(self, start_state, rules):&#10;        self.cur_state = start_state&#10;        self.rules = rules&#10;        self.cur_state.enter(('START', None))&#10;&#10;    def update(self):&#10;        self.cur_state.do()&#10;&#10;    def draw(self, draw_x = None, draw_y = None):&#10;        self.cur_state.draw(draw_x, draw_y)&#10;&#10;    def current_state(self):&#10;        return self.cur_state&#10;&#10;    def set_state(self, state):&#10;        self.cur_state = state&#10;&#10;    def handle_state_event(self, state_event):&#10;        processed_event = False&#10;        for check_event in self.rules[self.cur_state].keys():&#10;            if check_event(state_event):&#10;                next_state = self.rules[self.cur_state][check_event]&#10;&#10;                # 특수 처리: INVENTORY 상태에서 Tab_down이면 prev_state로 복귀&#10;                if next_state is None and hasattr(self.cur_state, 'prev_state') and self.cur_state.prev_state is not None:&#10;                    next_state = self.cur_state.prev_state&#10;&#10;                # 특수 처리: DASH 상태에서 DASH_END이면 return_to_idle에 따라 IDLE 또는 RUN으로 복귀&#10;                if next_state is None and hasattr(self.cur_state, 'return_to_idle'):&#10;                    # Dash의 return_to_idle 플래그 확인&#10;                    if self.cur_state.return_to_idle:&#10;                        # Idle로 복귀&#10;                        next_state = self.cur_state.player.IDLE&#10;                    else:&#10;                        # Run으로 복귀&#10;                        next_state = self.cur_state.player.RUN&#10;&#10;                self.cur_state.exit(state_event)&#10;                next_state.enter(state_event)&#10;&#10;                print(f'{self.cur_state.__class__.__name__}'&#10;                      f' ======{event_to_string(state_event)}======&gt; '&#10;                      f'{next_state.__class__.__name__}')&#10;                self.cur_state = next_state&#10;                processed_event = True&#10;                return&#10;        if not processed_event:&#10;            event_str = event_to_string(state_event)&#10;            es = event_str.upper() if isinstance(event_str, str) else ''&#10;            is_mouse_motion = ('MOUSE' in es and 'MOTION' in es) or ('MOUSEMOTION' in es)&#10;            if not is_mouse_motion:&#10;                # print('Refused Event:', self.cur_state.__class__.__name__, 'Input : ', event_to_string(state_event))&#10;                pass&#10;" />
              <option name="updatedContent" value="from .event_to_string import event_to_string&#13;&#10;import game_framework&#13;&#10;from .inventory import InventoryData&#13;&#10;&#13;&#10;&#13;&#10;class StateMachine:&#13;&#10;    def __init__(self, start_state, rules):&#13;&#10;        self.cur_state = start_state&#13;&#10;        self.rules = rules&#13;&#10;        self.cur_state.enter(('START', None))&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        self.cur_state.do()&#13;&#10;&#13;&#10;    def draw(self, draw_x = None, draw_y = None):&#13;&#10;        self.cur_state.draw(draw_x, draw_y)&#13;&#10;&#13;&#10;    def current_state(self):&#13;&#10;        return self.cur_state&#13;&#10;&#13;&#10;    def set_state(self, state):&#13;&#10;        self.cur_state = state&#13;&#10;&#13;&#10;    def handle_state_event(self, state_event):&#13;&#10;        processed_event = False&#13;&#10;        for check_event in self.rules[self.cur_state].keys():&#13;&#10;            if check_event(state_event):&#13;&#10;                next_state = self.rules[self.cur_state][check_event]&#13;&#10;&#13;&#10;                # 특수 처리: INVENTORY 상태에서 Tab_down이면 prev_state로 복귀&#13;&#10;                if next_state is None and hasattr(self.cur_state, 'prev_state') and self.cur_state.prev_state is not None:&#13;&#10;                    next_state = self.cur_state.prev_state&#13;&#10;&#13;&#10;                # 특수 처리: DASH 상태에서 DASH_END이면 return_to_idle에 따라 IDLE 또는 RUN으로 복귀&#13;&#10;                if next_state is None and hasattr(self.cur_state, 'return_to_idle'):&#13;&#10;                    # Dash의 return_to_idle 플래그 확인&#13;&#10;                    if self.cur_state.return_to_idle:&#13;&#10;                        # Idle로 복귀&#13;&#10;                        next_state = self.cur_state.player.IDLE&#13;&#10;                    else:&#13;&#10;                        # Run으로 복귀&#13;&#10;                        next_state = self.cur_state.player.RUN&#13;&#10;&#13;&#10;                self.cur_state.exit(state_event)&#13;&#10;                next_state.enter(state_event)&#13;&#10;&#13;&#10;                print(f'{self.cur_state.__class__.__name__}'&#13;&#10;                      f' ======{event_to_string(state_event)}======&gt; '&#13;&#10;                      f'{next_state.__class__.__name__}')&#13;&#10;                self.cur_state = next_state&#13;&#10;                processed_event = True&#13;&#10;                return&#13;&#10;        if not processed_event:&#13;&#10;            event_str = event_to_string(state_event)&#13;&#10;            es = event_str.upper() if isinstance(event_str, str) else ''&#13;&#10;            is_mouse_motion = ('MOUSE' in es and 'MOTION' in es) or ('MOUSEMOTION' in es)&#13;&#10;            if not is_mouse_motion:&#13;&#10;                # print('Refused Event:', self.cur_state.__class__.__name__, 'Input : ', event_to_string(state_event))&#13;&#10;                pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/vfx.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/vfx.py" />
              <option name="originalContent" value="import os&#10;from pico2d import load_image&#10;import pico2d as p2&#10;import game_framework&#10;&#10;class AnimatedVFX:&#10;    &quot;&quot;&quot;간단한 프레임 애니메이션 VFX 엔티티&#10;    - folder: 폴더 경로 (예: resources/Texture_organize/VFX/Potion_Common)&#10;    - prefix: 파일명 접두사 (예: 'Potion_Back_FX')&#10;    - frames: 프레임 수&#10;    - frame_time: 각 프레임 지속 시간&#10;    - x,y: 위치&#10;    - scale: 크기 배율&#10;    &quot;&quot;&quot;&#10;    def __init__(self, folder, prefix, frames, frame_time, x, y, scale=1.0, life=None):&#10;        self.folder = folder&#10;        self.prefix = prefix&#10;        self.frames_count = frames&#10;        self.frame_time = frame_time&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;        self.images = []&#10;        self.frame = 0&#10;        self.acc = 0.0&#10;        self.life = life if life is not None else frames * frame_time&#10;        self._load_frames()&#10;&#10;    def _load_frames(self):&#10;        self.images = []&#10;        for i in range(self.frames_count):&#10;            name1 = f&quot;{self.prefix}{i:02d}.png&quot;&#10;            path = os.path.join(self.folder, name1)&#10;            try:&#10;                img = load_image(path)&#10;                self.images.append(img)&#10;            except Exception:&#10;                # 로드 실패하면 다음 프레임도 시도하지만 중단&#10;                print(f'\033[91m[AnimatedVFX] Failed to load frame: {path}\033[0m')&#10;                break&#10;        # fallback: 만약 아무 프레임도 로드되지 않으면 try single file without index&#10;        if not self.images:&#10;            single = os.path.join(self.folder, f&quot;{self.prefix}.png&quot;)&#10;            try:&#10;                img = load_image(single)&#10;                self.images.append(img)&#10;            except Exception:&#10;                print(f'\033[91m[AnimatedVFX] Failed to load single image: {single}\033[0m')&#10;        # adjust frames_count to actual loaded&#10;        self.frames_count = len(self.images)&#10;&#10;    def update(self, dt=None):&#10;        # dt None이면 framework에서 값을 가져옴 (main.update_world가 인자로 주지 않으므로)&#10;        if dt is None:&#10;            dt = game_framework.get_delta_time()&#10;        if self.life &lt;= 0:&#10;            return False&#10;        self.life -= dt&#10;        if self.frames_count == 0:&#10;            return self.life &gt; 0&#10;        self.acc += dt&#10;        while self.acc &gt;= self.frame_time and self.frame &lt; self.frames_count - 1:&#10;            self.acc -= self.frame_time&#10;            self.frame += 1&#10;        return self.life &gt; 0&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if self.images and 0 &lt;= self.frame &lt; len(self.images):&#10;            img = self.images[self.frame]&#10;            img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;&#10;&#10;class GuardFX:&#10;    &quot;&quot;&quot;방패 방어 성공 시 표시되는 이펙트&quot;&quot;&quot;&#10;    images = None&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if GuardFX.images is None:&#10;            GuardFX.images = []&#10;            try:&#10;                for i in range(5):  # GuardFX1_0.png ~ GuardFX1_4.png&#10;                    img = p2.load_image(f'resources/Texture_organize/Weapon/SwordANDShield/Guard_FX/GuardFX1_{i}.png')&#10;                    GuardFX.images.append(img)&#10;                print(f&quot;[GuardFX] Loaded {len(GuardFX.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[GuardFX] Failed to load images: {e}\033[0m&quot;)&#10;                GuardFX.images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 20  # 빠르게 재생 (20 FPS)&#10;        self.finished = False&#10;&#10;        print(f&quot;[GuardFX] 생성됨 at world({int(x)}, {int(y)}), 총 프레임: {len(GuardFX.images) if GuardFX.images else 0}&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#10;        if self.finished:&#10;            return False&#10;&#10;        dt = game_framework.get_delta_time()&#10;        self.animation_time += dt&#10;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            self.frame += 1&#10;            self.animation_time = 0&#10;&#10;            # 애니메이션이 끝나면 제거&#10;            if GuardFX.images and self.frame &gt;= len(GuardFX.images):&#10;                self.finished = True&#10;                return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        이펙트 그리기&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if not GuardFX.images or len(GuardFX.images) == 0:&#10;            print(&quot;[GuardFX] 이미지가 없음!&quot;)&#10;            return&#10;&#10;        if self.finished:&#10;            return&#10;&#10;        frame_idx = min(self.frame, len(GuardFX.images) - 1)&#10;        try:&#10;            # 카메라가 적용된 좌표(draw_x, draw_y)를 사용하여 그리기&#10;            GuardFX.images[frame_idx].draw(&#10;                draw_x, draw_y,&#10;                GuardFX.images[frame_idx].w * self.scale,&#10;                GuardFX.images[frame_idx].h * self.scale&#10;            )&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[GuardFX] draw 에러: {e}\033[0m&quot;)&#10;&#10;&#10;class ShieldCrashEffect:&#10;    &quot;&quot;&quot;방패가 깨질 때 표시되는 이펙트 (Crash_Blue)&quot;&quot;&quot;&#10;    front_images = None&#10;    back_images = None&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if ShieldCrashEffect.front_images is None:&#10;            ShieldCrashEffect.front_images = []&#10;            try:&#10;                for i in range(11):  # Crash_Blue_Front_FX00 ~ FX10 (0~10)&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Front_FX0{i}.png')&#10;                    ShieldCrashEffect.front_images.append(img)&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.front_images)} front images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load front images: {e}\033[0m&quot;)&#10;                ShieldCrashEffect.front_images = []&#10;&#10;        if ShieldCrashEffect.back_images is None:&#10;            ShieldCrashEffect.back_images = []&#10;            try:&#10;                for i in range(3, 9):  # Crash_Blue_Back_FX03 ~ FX08 (3~8)&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Back_FX0{i}.png')&#10;                    ShieldCrashEffect.back_images.append(img)&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.back_images)} back images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load back images: {e}\033[0m&quot;)&#10;                ShieldCrashEffect.back_images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 20  # 빠른 애니메이션 (20 FPS)&#10;        self.finished = False&#10;&#10;        print(f&quot;[ShieldCrashEffect] 생성됨 at world({int(x)}, {int(y)})&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#10;        if self.finished:&#10;            return False&#10;&#10;        dt = game_framework.get_delta_time()&#10;        self.animation_time += dt&#10;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            self.frame += 1&#10;            self.animation_time = 0&#10;&#10;            # Front 이미지 기준으로 애니메이션이 끝나면 제거&#10;            if ShieldCrashEffect.front_images and self.frame &gt;= len(ShieldCrashEffect.front_images):&#10;                self.finished = True&#10;                return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        이펙트 그리기 (Front와 Back을 레이어링)&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if self.finished:&#10;            return&#10;&#10;        # Front 이미지 그리기 (0~10 프레임)&#10;        if ShieldCrashEffect.front_images and self.frame &lt; len(ShieldCrashEffect.front_images):&#10;            try:&#10;                ShieldCrashEffect.front_images[self.frame].draw(&#10;                    draw_x, draw_y,&#10;                    ShieldCrashEffect.front_images[self.frame].w * self.scale,&#10;                    ShieldCrashEffect.front_images[self.frame].h * self.scale&#10;                )&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] front draw 에러: {e}\033[0m&quot;)&#10;&#10;        # Back 이미지 그리기 (Front 프레임 3부터 시작)&#10;        # Front frame 3 = Back index 0 (Back_FX03)&#10;        # Front frame 4 = Back index 1 (Back_FX04) ...&#10;        if self.frame &gt;= 3:&#10;            back_index = self.frame - 3&#10;            if ShieldCrashEffect.back_images and back_index &lt; len(ShieldCrashEffect.back_images):&#10;                try:&#10;                    ShieldCrashEffect.back_images[back_index].draw(&#10;                        draw_x, draw_y,&#10;                        ShieldCrashEffect.back_images[back_index].w * self.scale,&#10;                        ShieldCrashEffect.back_images[back_index].h * self.scale&#10;                    )&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[ShieldCrashEffect] back draw 에러: {e}\033[0m&quot;)&#10;&#10;&#10;class DashTrailEffect:&#10;    &quot;&quot;&quot;대시 시 남는 잔상 이펙트 - 0.3초간 알파값이 1에서 0으로 페이드아웃&quot;&quot;&quot;&#10;    trail_image = None  # 클래스 변수로 이미지 한 번만 로드&#10;&#10;    def __init__(self, x, y, face_dir, scale=3.0):&#10;        &quot;&quot;&quot;&#10;        대시 잔상 이펙트 생성&#10;        &#10;        Args:&#10;            x: 월드 X 좌표&#10;            y: 월드 Y 좌표&#10;            face_dir: 플레이어의 방향 (1: 오른쪽, -1: 왼쪽)&#10;            scale: 이미지 크기 배율&#10;        &quot;&quot;&quot;&#10;        self.x = x&#10;        self.y = y&#10;        self.face_dir = face_dir&#10;        self.scale = scale&#10;        &#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if DashTrailEffect.trail_image is None:&#10;            try:&#10;                img_path = os.path.join('resources', 'Texture_organize', 'Player_character', 'PlayerDashTrailFx0.png')&#10;                DashTrailEffect.trail_image = load_image(img_path)&#10;                print(f&quot;[DashTrailEffect] 이미지 로드 성공: {img_path}&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[DashTrailEffect] 이미지 로드 실패: {e}\033[0m&quot;)&#10;                DashTrailEffect.trail_image = None&#10;        &#10;        # 페이드아웃 설정&#10;        self.fade_duration = 0.3  # 0.3초간 페이드아웃&#10;        self.elapsed_time = 0.0&#10;        self.alpha = 1.0  # 초기 알파값 1.0 (완전 불투명)&#10;    &#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        이펙트 업데이트 - 알파값을 시간에 따라 감소&#10;        &#10;        Returns:&#10;            bool: True면 계속 유지, False면 제거&#10;        &quot;&quot;&quot;&#10;        dt = game_framework.get_delta_time()&#10;        self.elapsed_time += dt&#10;        &#10;        # 알파값 계산 (1.0 -&gt; 0.0으로 선형 감소)&#10;        if self.elapsed_time &lt; self.fade_duration:&#10;            self.alpha = 1.0 - (self.elapsed_time / self.fade_duration)&#10;        else:&#10;            self.alpha = 0.0&#10;            return False  # 알파값이 0이 되면 제거&#10;        &#10;        return True&#10;    &#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        잔상 이펙트 그리기&#10;        &#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if not DashTrailEffect.trail_image:&#10;            return&#10;        &#10;        # 알파값이 0이면 그리지 않음&#10;        if self.alpha &lt;= 0:&#10;            return&#10;        &#10;        # 방향에 따라 flip 설정&#10;        flip = '' if self.face_dir == 1 else 'h'&#10;        &#10;        # 알파값 설정하여 그리기&#10;        DashTrailEffect.trail_image.opacify(self.alpha)&#10;        DashTrailEffect.trail_image.clip_composite_draw(&#10;            0, 0, &#10;            DashTrailEffect.trail_image.w, &#10;            DashTrailEffect.trail_image.h,&#10;            0, flip,&#10;            draw_x, draw_y,&#10;            DashTrailEffect.trail_image.w * self.scale,&#10;            DashTrailEffect.trail_image.h * self.scale&#10;        )&#10;        # 알파값 복원 (다른 이미지에 영향 주지 않도록)&#10;        DashTrailEffect.trail_image.opacify(1.0)" />
              <option name="updatedContent" value="import os&#13;&#10;from pico2d import load_image&#13;&#10;import pico2d as p2&#13;&#10;import game_framework&#13;&#10;&#13;&#10;class AnimatedVFX:&#13;&#10;    &quot;&quot;&quot;간단한 프레임 애니메이션 VFX 엔티티&#13;&#10;    - folder: 폴더 경로 (예: resources/Texture_organize/VFX/Potion_Common)&#13;&#10;    - prefix: 파일명 접두사 (예: 'Potion_Back_FX')&#13;&#10;    - frames: 프레임 수&#13;&#10;    - frame_time: 각 프레임 지속 시간&#13;&#10;    - x,y: 위치&#13;&#10;    - scale: 크기 배율&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    def __init__(self, folder, prefix, frames, frame_time, x, y, scale=1.0, life=None):&#13;&#10;        self.folder = folder&#13;&#10;        self.prefix = prefix&#13;&#10;        self.frames_count = frames&#13;&#10;        self.frame_time = frame_time&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;        self.images = []&#13;&#10;        self.frame = 0&#13;&#10;        self.acc = 0.0&#13;&#10;        self.life = life if life is not None else frames * frame_time&#13;&#10;        self._load_frames()&#13;&#10;&#13;&#10;    def _load_frames(self):&#13;&#10;        self.images = []&#13;&#10;        for i in range(self.frames_count):&#13;&#10;            name1 = f&quot;{self.prefix}{i:02d}.png&quot;&#13;&#10;            path = os.path.join(self.folder, name1)&#13;&#10;            try:&#13;&#10;                img = load_image(path)&#13;&#10;                self.images.append(img)&#13;&#10;            except Exception:&#13;&#10;                # 로드 실패하면 다음 프레임도 시도하지만 중단&#13;&#10;                print(f'\033[91m[AnimatedVFX] Failed to load frame: {path}\033[0m')&#13;&#10;                break&#13;&#10;        # fallback: 만약 아무 프레임도 로드되지 않으면 try single file without index&#13;&#10;        if not self.images:&#13;&#10;            single = os.path.join(self.folder, f&quot;{self.prefix}.png&quot;)&#13;&#10;            try:&#13;&#10;                img = load_image(single)&#13;&#10;                self.images.append(img)&#13;&#10;            except Exception:&#13;&#10;                print(f'\033[91m[AnimatedVFX] Failed to load single image: {single}\033[0m')&#13;&#10;        # adjust frames_count to actual loaded&#13;&#10;        self.frames_count = len(self.images)&#13;&#10;&#13;&#10;    def update(self, dt=None):&#13;&#10;        # dt None이면 framework에서 값을 가져옴 (main.update_world가 인자로 주지 않으므로)&#13;&#10;        if dt is None:&#13;&#10;            dt = game_framework.get_delta_time()&#13;&#10;        if self.life &lt;= 0:&#13;&#10;            return False&#13;&#10;        self.life -= dt&#13;&#10;        if self.frames_count == 0:&#13;&#10;            return self.life &gt; 0&#13;&#10;        self.acc += dt&#13;&#10;        while self.acc &gt;= self.frame_time and self.frame &lt; self.frames_count - 1:&#13;&#10;            self.acc -= self.frame_time&#13;&#10;            self.frame += 1&#13;&#10;        return self.life &gt; 0&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        if self.images and 0 &lt;= self.frame &lt; len(self.images):&#13;&#10;            img = self.images[self.frame]&#13;&#10;            img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#13;&#10;&#13;&#10;&#13;&#10;class GuardFX:&#13;&#10;    &quot;&quot;&quot;방패 방어 성공 시 표시되는 이펙트&quot;&quot;&quot;&#13;&#10;    images = None&#13;&#10;&#13;&#10;    def __init__(self, x, y, scale=3.0):&#13;&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;&#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if GuardFX.images is None:&#13;&#10;            GuardFX.images = []&#13;&#10;            try:&#13;&#10;                for i in range(5):  # GuardFX1_0.png ~ GuardFX1_4.png&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/Weapon/SwordANDShield/Guard_FX/GuardFX1_{i}.png')&#13;&#10;                    GuardFX.images.append(img)&#13;&#10;                print(f&quot;[GuardFX] Loaded {len(GuardFX.images)} images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[GuardFX] Failed to load images: {e}\033[0m&quot;)&#13;&#10;                GuardFX.images = []&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.animation_time = 0&#13;&#10;        self.animation_speed = 20  # 빠르게 재생 (20 FPS)&#13;&#10;        self.finished = False&#13;&#10;&#13;&#10;        print(f&quot;[GuardFX] 생성됨 at world({int(x)}, {int(y)}), 총 프레임: {len(GuardFX.images) if GuardFX.images else 0}&quot;)&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return False&#13;&#10;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.animation_time += dt&#13;&#10;&#13;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;            self.frame += 1&#13;&#10;            self.animation_time = 0&#13;&#10;&#13;&#10;            # 애니메이션이 끝나면 제거&#13;&#10;            if GuardFX.images and self.frame &gt;= len(GuardFX.images):&#13;&#10;                self.finished = True&#13;&#10;                return False&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 그리기&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not GuardFX.images or len(GuardFX.images) == 0:&#13;&#10;            print(&quot;[GuardFX] 이미지가 없음!&quot;)&#13;&#10;            return&#13;&#10;&#13;&#10;        if self.finished:&#13;&#10;            return&#13;&#10;&#13;&#10;        frame_idx = min(self.frame, len(GuardFX.images) - 1)&#13;&#10;        try:&#13;&#10;            # 카메라가 적용된 좌표(draw_x, draw_y)를 사용하여 그리기&#13;&#10;            GuardFX.images[frame_idx].draw(&#13;&#10;                draw_x, draw_y,&#13;&#10;                GuardFX.images[frame_idx].w * self.scale,&#13;&#10;                GuardFX.images[frame_idx].h * self.scale&#13;&#10;            )&#13;&#10;        except Exception as e:&#13;&#10;            print(f&quot;\033[91m[GuardFX] draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;class ShieldCrashEffect:&#13;&#10;    &quot;&quot;&quot;방패가 깨질 때 표시되는 이펙트 (Crash_Blue)&quot;&quot;&quot;&#13;&#10;    front_images = None&#13;&#10;    back_images = None&#13;&#10;&#13;&#10;    def __init__(self, x, y, scale=3.0):&#13;&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;&#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if ShieldCrashEffect.front_images is None:&#13;&#10;            ShieldCrashEffect.front_images = []&#13;&#10;            try:&#13;&#10;                for i in range(11):  # Crash_Blue_Front_FX00 ~ FX10 (0~10)&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Front_FX0{i}.png')&#13;&#10;                    ShieldCrashEffect.front_images.append(img)&#13;&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.front_images)} front images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load front images: {e}\033[0m&quot;)&#13;&#10;                ShieldCrashEffect.front_images = []&#13;&#10;&#13;&#10;        if ShieldCrashEffect.back_images is None:&#13;&#10;            ShieldCrashEffect.back_images = []&#13;&#10;            try:&#13;&#10;                for i in range(3, 9):  # Crash_Blue_Back_FX03 ~ FX08 (3~8)&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Back_FX0{i}.png')&#13;&#10;                    ShieldCrashEffect.back_images.append(img)&#13;&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.back_images)} back images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load back images: {e}\033[0m&quot;)&#13;&#10;                ShieldCrashEffect.back_images = []&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.animation_time = 0&#13;&#10;        self.animation_speed = 20  # 빠른 애니메이션 (20 FPS)&#13;&#10;        self.finished = False&#13;&#10;&#13;&#10;        print(f&quot;[ShieldCrashEffect] 생성됨 at world({int(x)}, {int(y)})&quot;)&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return False&#13;&#10;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.animation_time += dt&#13;&#10;&#13;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;            self.frame += 1&#13;&#10;            self.animation_time = 0&#13;&#10;&#13;&#10;            # Front 이미지 기준으로 애니메이션이 끝나면 제거&#13;&#10;            if ShieldCrashEffect.front_images and self.frame &gt;= len(ShieldCrashEffect.front_images):&#13;&#10;                self.finished = True&#13;&#10;                return False&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 그리기 (Front와 Back을 레이어링)&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return&#13;&#10;&#13;&#10;        # Front 이미지 그리기 (0~10 프레임)&#13;&#10;        if ShieldCrashEffect.front_images and self.frame &lt; len(ShieldCrashEffect.front_images):&#13;&#10;            try:&#13;&#10;                ShieldCrashEffect.front_images[self.frame].draw(&#13;&#10;                    draw_x, draw_y,&#13;&#10;                    ShieldCrashEffect.front_images[self.frame].w * self.scale,&#13;&#10;                    ShieldCrashEffect.front_images[self.frame].h * self.scale&#13;&#10;                )&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] front draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;        # Back 이미지 그리기 (Front 프레임 3부터 시작)&#13;&#10;        # Front frame 3 = Back index 0 (Back_FX03)&#13;&#10;        # Front frame 4 = Back index 1 (Back_FX04) ...&#13;&#10;        if self.frame &gt;= 3:&#13;&#10;            back_index = self.frame - 3&#13;&#10;            if ShieldCrashEffect.back_images and back_index &lt; len(ShieldCrashEffect.back_images):&#13;&#10;                try:&#13;&#10;                    ShieldCrashEffect.back_images[back_index].draw(&#13;&#10;                        draw_x, draw_y,&#13;&#10;                        ShieldCrashEffect.back_images[back_index].w * self.scale,&#13;&#10;                        ShieldCrashEffect.back_images[back_index].h * self.scale&#13;&#10;                    )&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91m[ShieldCrashEffect] back draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;class DashTrailEffect:&#13;&#10;    &quot;&quot;&quot;대시 시 남는 잔상 이펙트 - 0.3초간 알파값이 1에서 0으로 페이드아웃&quot;&quot;&quot;&#13;&#10;    trail_image = None  # 클래스 변수로 이미지 한 번만 로드&#13;&#10;&#13;&#10;    def __init__(self, x, y, face_dir, scale=3.0):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        대시 잔상 이펙트 생성&#13;&#10;        &#13;&#10;        Args:&#13;&#10;            x: 월드 X 좌표&#13;&#10;            y: 월드 Y 좌표&#13;&#10;            face_dir: 플레이어의 방향 (1: 오른쪽, -1: 왼쪽)&#13;&#10;            scale: 이미지 크기 배율&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.face_dir = face_dir&#13;&#10;        self.scale = scale&#13;&#10;        &#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if DashTrailEffect.trail_image is None:&#13;&#10;            try:&#13;&#10;                img_path = os.path.join('resources', 'Texture_organize', 'Player_character', 'PlayerDashTrailFx0.png')&#13;&#10;                DashTrailEffect.trail_image = load_image(img_path)&#13;&#10;                print(f&quot;[DashTrailEffect] 이미지 로드 성공: {img_path}&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[DashTrailEffect] 이미지 로드 실패: {e}\033[0m&quot;)&#13;&#10;                DashTrailEffect.trail_image = None&#13;&#10;        &#13;&#10;        # 페이드아웃 설정&#13;&#10;        self.fade_duration = 0.3  # 0.3초간 페이드아웃&#13;&#10;        self.elapsed_time = 0.0&#13;&#10;        self.alpha = 1.0  # 초기 알파값 1.0 (완전 불투명)&#13;&#10;    &#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 업데이트 - 알파값을 시간에 따라 감소&#13;&#10;        &#13;&#10;        Returns:&#13;&#10;            bool: True면 계속 유지, False면 제거&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.elapsed_time += dt&#13;&#10;        &#13;&#10;        # 알파값 계산 (1.0 -&gt; 0.0으로 선형 감소)&#13;&#10;        if self.elapsed_time &lt; self.fade_duration:&#13;&#10;            self.alpha = 1.0 - (self.elapsed_time / self.fade_duration)&#13;&#10;        else:&#13;&#10;            self.alpha = 0.0&#13;&#10;            return False  # 알파값이 0이 되면 제거&#13;&#10;        &#13;&#10;        return True&#13;&#10;    &#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        잔상 이펙트 그리기&#13;&#10;        &#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not DashTrailEffect.trail_image:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # 알파값이 0이면 그리지 않음&#13;&#10;        if self.alpha &lt;= 0:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # 방향에 따라 flip 설정&#13;&#10;        flip = '' if self.face_dir == 1 else 'h'&#13;&#10;        &#13;&#10;        # 알파값 설정하여 그리기&#13;&#10;        DashTrailEffect.trail_image.opacify(self.alpha)&#13;&#10;        DashTrailEffect.trail_image.clip_composite_draw(&#13;&#10;            0, 0, &#13;&#10;            DashTrailEffect.trail_image.w, &#13;&#10;            DashTrailEffect.trail_image.h,&#13;&#10;            0, flip,&#13;&#10;            draw_x, draw_y,&#13;&#10;            DashTrailEffect.trail_image.w * self.scale,&#13;&#10;            DashTrailEffect.trail_image.h * self.scale&#13;&#10;        )&#13;&#10;        # 알파값 복원 (다른 이미지에 영향 주지 않도록)&#13;&#10;        DashTrailEffect.trail_image.opacify(1.0)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>