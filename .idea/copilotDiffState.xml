<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game_logic/cursor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/cursor.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False&#10;" />
              <option name="updatedContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/play_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/play_mode.py" />
              <option name="originalContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#10;# minimal, compatible with existing game_logic modules&#10;import pico2d as p2&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#10;from PIL import Image&#10;&#10;import game_framework&#10;from .player import Player&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar, DashBar&#10;from .cursor import Cursor&#10;from .loading_screen import LoadingScreen&#10;from . import defeat_mode, victory_mode&#10;# 사용할 스테이지 모듈들을 import 합니다.&#10;from .stages import stage_1, stage_2&#10;&#10;# world layers: keep same keys as original main.py&#10;world = {&#10;    'ground': [],&#10;    'upper_ground': [],&#10;    'walls': [],&#10;    'effects_back': [],&#10;    'entities': [],&#10;    'effects_front': [],&#10;    'ui': [],&#10;    'extra_bg': [],&#10;    'extras': [],&#10;    'cursor': []&#10;}&#10;world['bg'] = world['ground']&#10;&#10;# 스테이지 관리&#10;# stages = [stage_1, stage_2]&#10;stages = [stage_1]&#10;current_stage_index = 0&#10;is_stage_cleared = False&#10;&#10;# 로딩 화면 관리&#10;loading_screen = None&#10;is_loading = False&#10;next_stage_to_load = None&#10;&#10;# 경과 시간 추적 (play_mode 진입 후 경과 시간)&#10;elapsed_time = 0.0&#10;&#10;# 승리 페이드인 효과 관련 변수&#10;is_fading_to_victory = False  # 승리 페이드인 진행 중 플래그&#10;victory_fade_elapsed = 0.0    # 페이드인 경과 시간&#10;victory_fade_duration = 3.0   # 페이드인 지속 시간 (3초)&#10;victory_fade_image = None     # 페이드인 이미지&#10;&#10;&#10;class Camera:&#10;    &quot;&quot;&quot;&#10;    플레이어를 부드럽게 따라가는 카메라 클래스&#10;    맵의 경계를 넘지 않도록 제한하며, 화면 중앙을 (0,0)으로 하는 좌표계 사용&#10;    &quot;&quot;&quot;&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#10;        &quot;&quot;&quot;&#10;        카메라 초기화&#10;        Args:&#10;            target: 카메라가 따라갈 대상 (일반적으로 플레이어)&#10;            map_width: 맵의 전체 너비&#10;            map_height: 맵의 전체 높이&#10;            screen_width: 화면 너비&#10;            screen_height: 화면 높이&#10;        &quot;&quot;&quot;&#10;        self.target = target&#10;        self.x = target.x&#10;        self.y = target.y&#10;        self.map_width = map_width&#10;        self.map_height = map_height&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1, 낮을수록 부드럽고 느림)&#10;&#10;        # 맵 오프셋 (배경의 중심점, calculate_background_bounds에서 설정)&#10;        self.map_offset_x = 0&#10;        self.map_offset_y = 0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        카메라 위치 업데이트 - 타겟을 부드럽게 따라가며 맵 경계 내로 제한&#10;        &quot;&quot;&quot;&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP - Linear Interpolation)&#10;        target_x = self.target.x&#10;        target_y = self.target.y&#10;        self.x += (target_x - self.x) * self.smooth&#10;        self.y += (target_y - self.y) * self.smooth&#10;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#10;        min_x = -self.map_width/2&#10;        max_x = self.map_width/2&#10;        min_y = -self.map_height/2&#10;        max_y = self.map_height/2&#10;&#10;        self.x = max(min_x, min(self.x, max_x))&#10;        self.y = max(min_y, min(self.y, max_y))&#10;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#10;        if self.map_width &lt;= self.screen_width:&#10;            self.x = 0&#10;        if self.map_height &lt;= self.screen_height:&#10;            self.y = 0&#10;&#10;    def apply(self, obj_x, obj_y):&#10;        &quot;&quot;&quot;&#10;        카메라 위치에 따라 오브젝트의 화면 좌표 계산&#10;        Args:&#10;            obj_x: 오브젝트의 월드 x 좌표 (맵 중심 기준)&#10;            obj_y: 오브젝트의 월드 y 좌표 (맵 중심 기준)&#10;        Returns:&#10;            tuple: (draw_x, draw_y) - 화면에 그릴 좌표&#10;        &quot;&quot;&quot;&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#10;&#10;&#10;# Camera 객체를 전역으로 선언&#10;camera = None&#10;&#10;&#10;def calculate_background_bounds():&#10;    &quot;&quot;&quot;&#10;    ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#10;&#10;    Returns:&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#10;    &quot;&quot;&quot;&#10;    min_x = float('inf')&#10;    max_x = float('-inf')&#10;    min_y = float('inf')&#10;    max_y = float('-inf')&#10;&#10;    # ground 레이어의 모든 객체를 순회&#10;    for obj in world['ground']:&#10;        # 객체가 x, y, image 속성을 가지고 있는지 확인&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image'):&#10;            # 객체의 중심 좌표&#10;            obj_x = obj.x&#10;            obj_y = obj.y&#10;&#10;            # 이미지 크기 계산 (scale 속성이 있으면 적용)&#10;            scale = getattr(obj, 'scale', 1.0)&#10;            img_width = obj.image.w * scale&#10;            img_height = obj.image.h * scale&#10;&#10;            # 객체의 경계 계산 (중심 기준이므로 절반씩)&#10;            obj_left = obj_x - img_width / 2&#10;            obj_right = obj_x + img_width / 2&#10;            obj_bottom = obj_y - img_height / 2&#10;            obj_top = obj_y + img_height / 2&#10;&#10;            # 최소/최대 값 업데이트&#10;            min_x = min(min_x, obj_left)&#10;            max_x = max(max_x, obj_right)&#10;            min_y = min(min_y, obj_bottom)&#10;            max_y = max(max_y, obj_top)&#10;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환 (1280x720 화면 기준)&#10;    if min_x == float('inf') or max_x == float('-inf'):&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#10;        return (-640, 640, -360, 360)&#10;&#10;    print(f&quot;[play_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#10;    return (min_x, max_x, min_y, max_y)&#10;&#10;&#10;def change_stage(next_stage_index):&#10;    &quot;&quot;&quot;다음 스테이지로 변경하는 함수&quot;&quot;&quot;&#10;    global current_stage_index, loading_screen, is_loading, next_stage_to_load, is_fading_to_victory, victory_fade_elapsed, victory_fade_image&#10;&#10;    # 다음 스테이지 인덱스 확인&#10;    if next_stage_index &gt;= len(stages):&#10;        # 모든 스테이지 클리어 시 페이드인 효과 시작&#10;        print(&quot;All stages cleared! Starting fade-in effect...&quot;)&#10;        is_fading_to_victory = True&#10;        victory_fade_elapsed = 0.0&#10;&#10;        # 플레이어를 entities에서 extras 레이어로 즉시 이동&#10;        player = world.get('player')&#10;        if player and player in world['entities']:&#10;            world['entities'].remove(player)&#10;            world['extras'].append(player)&#10;            print(&quot;[change_stage] 플레이어를 extras 레이어로 이동&quot;)&#10;&#10;        # 페이드인 이미지 로드&#10;        try:&#10;            victory_fade_image = p2.load_image('resources/Texture_organize/IDK_2/Square.png')&#10;            print(&quot;[change_stage] 승리 페이드인 이미지 로드 성공&quot;)&#10;        except Exception as ex:&#10;            print(f'\033[91m[change_stage] 승리 페이드인 이미지 로드 실패: {ex}\033[0m')&#10;            victory_fade_image = None&#10;&#10;        return&#10;&#10;    # 로딩 화면 시작 - 스테이지 모듈의 LOADING_SCREEN_INFO 사용&#10;    next_stage_module = stages[next_stage_index]&#10;    loading_info = getattr(next_stage_module, 'LOADING_SCREEN_INFO', None)&#10;&#10;    if loading_info:&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1} 로딩 화면 시작&quot;)&#10;        loading_screen = LoadingScreen(loading_info)&#10;        is_loading = True&#10;        next_stage_to_load = next_stage_index&#10;    else:&#10;        # LOADING_SCREEN_INFO가 없으면 로딩 화면 없이 바로 전환&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1}에 로딩 화면 정보 없음, 즉시 전환&quot;)&#10;        next_stage_to_load = next_stage_index&#10;        _complete_stage_change()&#10;&#10;&#10;class PlayModeWall:&#10;    &quot;&quot;&quot;플레이 모드에서 사용하는 벽 클래스 (투명 영역 감지용)&quot;&quot;&quot;&#10;    def __init__(self, x, y, w, h):&#10;        &quot;&quot;&quot;&#10;        벽 초기화&#10;        Args:&#10;            x: 벽의 월드 x 좌표 (맵 중심 기준)&#10;            y: 벽의 월드 y 좌표 (맵 중심 기준)&#10;            w: 벽의 너비&#10;            h: 벽의 높이&#10;        &quot;&quot;&quot;&#10;        self.x = x&#10;        self.y = y&#10;        self.w = w&#10;        self.h = h&#10;&#10;    def check_collision(self, px, py, pw, ph):&#10;        &quot;&quot;&quot;&#10;        플레이어와 벽의 충돌 검사&#10;        Args:&#10;            px: 플레이어 x 좌표&#10;            py: 플레이어 y 좌표&#10;            pw: 플레이어 너비&#10;            ph: 플레이어 높이&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        return (self.x &lt; px + pw and self.x + self.w &gt; px and&#10;                self.y &lt; py + ph and self.y + self.h &gt; py)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;벽은 업데이트가 필요 없음&quot;&quot;&quot;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        벽 디버깅용 그리기 (필요시 주석 해제)&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 x 좌표&#10;            draw_y: 카메라가 적용된 화면 y 좌표&#10;        &quot;&quot;&quot;&#10;        # 디버깅용: 벽을 빨간색으로 표시 (벽 위치 확인용)&#10;        # p2.draw_rectangle(draw_x - self.w/2, draw_y - self.h/2,&#10;        #                   draw_x + self.w/2, draw_y + self.h/2)&#10;        pass&#10;&#10;&#10;def generate_walls_from_png(png_path, block_size=8, map_x=0, map_y=0, map_scale=1.0):&#10;    &quot;&quot;&quot;&#10;    PNG 이미지의 투명 영역을 감지하여 벽 블록 생성&#10;    Args:&#10;        png_path: PNG 이미지 경로&#10;        block_size: 벽 블록의 기본 크기 (픽셀 단위, 스케일 적용 전)&#10;        map_x: 맵의 월드 x 좌표 (중심 기준)&#10;        map_y: 맵의 월드 y 좌표 (중심 기준)&#10;        map_scale: 맵의 스케일&#10;    Returns:&#10;        list: 생성된 PlayModeWall 객체 리스트&#10;    &quot;&quot;&quot;&#10;    print(f&quot;[generate_walls_from_png] 시작: {png_path}&quot;)&#10;    print(f&quot;  - block_size={block_size}, map_x={map_x}, map_y={map_y}, map_scale={map_scale}&quot;)&#10;&#10;    try:&#10;        img = Image.open(png_path).convert('RGBA')&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[generate_walls_from_png] 이미지 열기 실패: {ex}\033[0m&quot;)&#10;        return []&#10;&#10;    width, height = img.size&#10;    walls = []&#10;    pixels = img.load()&#10;    transparent_count = 0&#10;&#10;    # 맵 이미지의 좌상단 기준 좌표 계산 (맵 중심 기준)&#10;    map_left = map_x - (width * map_scale) / 2&#10;    map_bottom = map_y - (height * map_scale) / 2&#10;&#10;    print(f&quot;  - 이미지 크기: {width}x{height}&quot;)&#10;    print(f&quot;  - 맵 좌하단 좌표: ({map_left:.1f}, {map_bottom:.1f})&quot;)&#10;&#10;    # 이미지를 블록 단위로 순회&#10;    for y in range(0, height, block_size):&#10;        for x in range(0, width, block_size):&#10;            is_transparent = False&#10;            # 블록 내부의 픽셀들을 검사&#10;            for dy in range(block_size):&#10;                for dx in range(block_size):&#10;                    if x + dx &lt; width and y + dy &lt; height:&#10;                        _, _, _, alpha = pixels[x + dx, y + dy]&#10;                        if alpha == 0:  # 완전 투명&#10;                            is_transparent = True&#10;                            transparent_count += 1&#10;                            break&#10;                if is_transparent:&#10;                    break&#10;&#10;            # 투명 블록이면 벽 생성&#10;            if is_transparent:&#10;                # 이미지 좌표를 월드 좌표로 변환&#10;                # 이미지 좌표계: 좌상단 (0,0), 우하단 (width, height)&#10;                # 월드 좌표계: 맵 중심 (0,0)&#10;                wall_x_img = x&#10;                wall_y_img = height - y - block_size  # Y축 반전 (이미지는 위에서 아래로, 월드는 아래에서 위로)&#10;&#10;                # 월드 좌표로 변환&#10;                wall_x_world = map_left + wall_x_img * map_scale + (block_size * map_scale) / 2&#10;                wall_y_world = map_bottom + wall_y_img * map_scale + (block_size * map_scale) / 2&#10;&#10;                walls.append(PlayModeWall(&#10;                    wall_x_world,&#10;                    wall_y_world,&#10;                    block_size * map_scale,&#10;                    block_size * map_scale&#10;                ))&#10;&#10;    print(f&quot;  - 투명 픽셀 수: {transparent_count}, 생성된 벽 수: {len(walls)}&quot;)&#10;    return walls&#10;&#10;&#10;def _complete_stage_change():&#10;    &quot;&quot;&quot;로딩이 완료된 후 실제 스테이지 전환을 수행&quot;&quot;&quot;&#10;    global current_stage_index, world, is_stage_cleared, loading_screen, is_loading, next_stage_to_load, camera&#10;&#10;    print(f&quot;[_complete_stage_change] 스테이지 {next_stage_to_load + 1} 로드 시작&quot;)&#10;&#10;    # 현재 스테이지의 몬스터, 배경 등 제거 (플레이어는 유지)&#10;    player = world.get('player')&#10;    world['entities'] = [player] if player else []&#10;    world['bg'].clear()&#10;    world['walls'].clear()  # 벽도 초기화&#10;    # 다른 레이어도 필요에 따라 초기화&#10;    world['effects_back'].clear()&#10;    world['effects_front'].clear()&#10;&#10;    # 다음 스테이지 인덱스로 변경&#10;    current_stage_index = next_stage_to_load&#10;&#10;    # 새 스테이지 로드&#10;    stages[current_stage_index].load(world)&#10;&#10;    # 스테이지 맵에서 벽 생성 (ground 레이어의 첫 번째 객체가 맵이라고 가정)&#10;    try:&#10;        if world['ground'] and len(world['ground']) &gt; 0:&#10;            stage_map = world['ground'][1]&#10;            if hasattr(stage_map, 'image') and hasattr(stage_map, 'x') and hasattr(stage_map, 'y'):&#10;                # 맵 이미지의 경로 가져오기 (StageMap 객체에서)&#10;                next_stage_module = stages[current_stage_index]&#10;                stage_data = getattr(next_stage_module, 'stage_data', None)&#10;&#10;                if stage_data and 'stage_map' in stage_data:&#10;                    map_image_path = stage_data['stage_map']['image']&#10;                    map_scale = getattr(stage_map, 'scale', 1.0)&#10;&#10;                    print(f&quot;[_complete_stage_change] 맵 이미지에서 벽 생성 중...&quot;)&#10;                    wall_blocks = generate_walls_from_png(&#10;                        map_image_path,&#10;                        block_size=8,&#10;                        map_x=stage_map.x,&#10;                        map_y=stage_map.y,&#10;                        map_scale=map_scale&#10;                    )&#10;&#10;                    for wall in wall_blocks:&#10;                        world['walls'].append(wall)&#10;&#10;                    print(f&quot;[_complete_stage_change] {len(wall_blocks)}개의 벽 생성 완료&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[_complete_stage_change] 벽 생성 실패: {ex}\033[0m&quot;)&#10;&#10;    # 플레이어 위치 설정 (스테이지에 PLAYER_START_POSITION이 있으면 사용)&#10;    if player:&#10;        next_stage_module = stages[current_stage_index]&#10;        player_start_pos = getattr(next_stage_module, 'PLAYER_START_POSITION', None)&#10;&#10;        if player_start_pos:&#10;            # 플레이어 위치를 새 스테이지 시작 위치로 설정&#10;            new_x = player_start_pos['x']&#10;            new_y = player_start_pos['y']&#10;            player.x = new_x&#10;            player.y = new_y&#10;            print(f&quot;[_complete_stage_change] 플레이어 위치 설정: ({player.x}, {player.y})&quot;)&#10;        else:&#10;            print(f&quot;[_complete_stage_change] 플레이어 시작 위치 정보 없음, 현재 위치 유지&quot;)&#10;    else:&#10;        print(f'\033[91m[_complete_stage_change] 플레이어 객체 없음\033[0m')&#10;&#10;    # 카메라 초기화 또는 업데이트&#10;    try:&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;        map_width = max_x - min_x&#10;        map_height = max_y - min_y&#10;&#10;        screen_width = p2.get_canvas_width()&#10;        screen_height = p2.get_canvas_height()&#10;&#10;        # 카메라가 없으면 새로 생성 (첫 스테이지)&#10;        if camera is None and player:&#10;            print(f&quot;[_complete_stage_change] 카메라 생성 중...&quot;)&#10;            camera = Camera(player, map_width, map_height, screen_width, screen_height)&#10;            camera.map_offset_x = (min_x + max_x) / 2&#10;            camera.map_offset_y = (min_y + max_y) / 2&#10;            # 카메라를 플레이어 위치로 즉시 동기화&#10;            camera.x = player.x&#10;            camera.y = player.y&#10;            print(f&quot;[_complete_stage_change] 카메라 생성 완료: ({camera.x}, {camera.y})&quot;)&#10;        # 카메라가 이미 있으면 맵 크기만 업데이트&#10;        elif camera is not None:&#10;            camera.map_width = map_width&#10;            camera.map_height = map_height&#10;            camera.map_offset_x = (min_x + max_x) / 2&#10;            camera.map_offset_y = (min_y + max_y) / 2&#10;            # 카메라를 플레이어 위치로 즉시 동기화&#10;            if player:&#10;                camera.x = player.x&#10;                camera.y = player.y&#10;            print(f&quot;[_complete_stage_change] 카메라 업데이트 완료: 맵 크기 {map_width:.1f}x{map_height:.1f}&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[_complete_stage_change] 카메라 초기화/업데이트 실패: {ex}\033[0m&quot;)&#10;&#10;    is_stage_cleared = False&#10;&#10;    # 로딩 화면 종료&#10;    loading_screen = None&#10;    is_loading = False&#10;    next_stage_to_load = None&#10;&#10;    print(f&quot;[_complete_stage_change] Changed to Stage {current_stage_index + 1}&quot;)&#10;&#10;def enter(player=None):&#10;    global world, current_stage_index, is_stage_cleared, loading_screen, is_loading, next_stage_to_load, elapsed_time&#10;    print(&quot;[play_mode] Starting enter()...&quot;)&#10;&#10;    # 경과 시간 초기화&#10;    elapsed_time = 0.0&#10;&#10;    # clear existing&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(f'\033[91m[play_mode] Failed to clear world layer: {k}\033[0m')&#10;&#10;    print(&quot;[play_mode] Creating player...&quot;)&#10;    # create player (use fallback if heavy Player init fails)&#10;    try:&#10;        if player == None:&#10;            player = Player()&#10;        print(&quot;[play_mode] Player created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[play_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#10;        from .inventory import InventoryData, seed_debug_inventory&#10;&#10;        class _FallbackPlayer:&#10;            def __init__(self):&#10;                self.x = 0  # 맵 중심 기준 좌표&#10;                self.y = 0&#10;                self.face_dir = 1&#10;                self.scale_factor = 1.0&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;                self.particles = []&#10;                self.attack_effects = []&#10;                self.inventory = InventoryData(cols=6, rows=5)&#10;                try:&#10;                    seed_debug_inventory(self.inventory)&#10;                except Exception:&#10;                    pass&#10;                self.inventory_open = False&#10;&#10;            def update(self):&#10;                return True&#10;&#10;            def rebuild_inventory_passives(self):&#10;                return&#10;&#10;            def consume_item_at(self, r, c):&#10;                return False&#10;&#10;        player = _FallbackPlayer()&#10;&#10;    print(&quot;[play_mode] Attaching world reference to player...&quot;)&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#10;    try:&#10;        player.world = world&#10;    except Exception:&#10;        pass&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#10;    world['entities'].append(player)&#10;&#10;    print(&quot;[play_mode] Creating inventory overlay...&quot;)&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#10;    try:&#10;        inv = InventoryOverlay(player, world)&#10;        print(&quot;[play_mode] InventoryOverlay created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] InventoryOverlay init failed, creating minimal stub:', ex)&#10;&#10;        class _InvStub:&#10;            def __init__(self, player, world=None):&#10;                self.player = player&#10;                self.world = world&#10;                self.dragging = False&#10;                self.drag_from = None&#10;                self.drag_icon = None&#10;                self.drag_qty = 0&#10;            def handle_event(self, e):&#10;                return&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        inv = _InvStub(player, world)&#10;    world['ui'].append(inv)&#10;&#10;    print(&quot;[play_mode] Creating health bar...&quot;)&#10;    # health bar UI 생성&#10;    try:&#10;        health_bar = HealthBar(player)&#10;        print(&quot;[play_mode] HealthBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] HealthBar init failed, using stub:', ex)&#10;&#10;        class _HealthBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        health_bar = _HealthBarStub(player)&#10;    world['ui'].append(health_bar)&#10;&#10;    print(&quot;[play_mode] Creating mana bar...&quot;)&#10;    # mana bar UI 생성&#10;    try:&#10;        mana_bar = ManaBar(player)&#10;        print(&quot;[play_mode] ManaBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] ManaBar init failed, using stub:', ex)&#10;&#10;        class _ManaBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        mana_bar = _ManaBarStub(player)&#10;    world['ui'].append(mana_bar)&#10;&#10;    print(&quot;[play_mode] Creating dash bar...&quot;)&#10;    # dash bar UI 생성&#10;    try:&#10;        dash_bar = DashBar(player)&#10;        print(&quot;[play_mode] DashBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] DashBar init failed, using stub:', ex)&#10;&#10;        class _DashBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        dash_bar = _DashBarStub(player)&#10;    world['ui'].append(dash_bar)&#10;&#10;    print(&quot;[play_mode] Creating cursor...&quot;)&#10;    # cursor on top (safe fallback)&#10;    try:&#10;        cursor = Cursor(player)&#10;        print(&quot;[play_mode] Cursor created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] Cursor init failed, using stub cursor:', ex)&#10;&#10;        class _CursorStub:&#10;            def __init__(self, player=None):&#10;                self.player = player&#10;                self.x = 0&#10;                self.y = 0&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;            def handle_event(self, e):&#10;                return&#10;&#10;        cursor = _CursorStub(player)&#10;    world['cursor'].append(cursor)&#10;&#10;    # expose world to __main__ for legacy code that looks up main.world&#10;    try:&#10;        import sys&#10;        main_mod = sys.modules.get('__main__')&#10;        if main_mod is not None:&#10;            setattr(main_mod, 'world', world)&#10;    except Exception:&#10;        pass&#10;&#10;    print(&quot;[play_mode] Starting first stage with loading screen...&quot;)&#10;    # 첫 번째 스테이지를 로딩 화면과 함께 시작&#10;    current_stage_index = -1  # change_stage가 0으로 설정할 것임&#10;    is_stage_cleared = False&#10;&#10;    # change_stage 함수를 사용하여 로딩 화면과 함께 첫 스테이지 로드&#10;    change_stage(0)&#10;&#10;    print(f&quot;[play_mode] Entered play_mode, loading Stage 1 with loading screen&quot;)&#10;&#10;    # Camera 초기화는 _complete_stage_change에서 진행됨&#10;&#10;def exit():&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            pass&#10;&#10;&#10;def handle_events():&#10;    import game_framework as app_framework&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            app_framework.quit()&#10;            return&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#10;            app_framework.quit()&#10;            return&#10;&#10;        # 페이드인 중일 때는 플레이어 이동 이벤트만 무시하고 나머지는 처리&#10;        if is_fading_to_victory:&#10;            # extras 레이어의 플레이어는 이동 이벤트 무시 (하지만 다른 이벤트는 처리 가능)&#10;            # UI와 커서 이벤트는 처리 (인벤토리 조작 등)&#10;            for o in list(world['ui']):&#10;                try:&#10;                    if hasattr(o, 'handle_event'):&#10;                        o.handle_event(e)&#10;                except Exception:&#10;                    print(f'\033[91m[play_mode] handle_event error in ui {o.__class__.__name__}\033[0m')&#10;                    pass&#10;            for o in list(world['cursor']):&#10;                try:&#10;                    if hasattr(o, 'handle_event'):&#10;                        o.handle_event(e)&#10;                except Exception:&#10;                    print(f'\033[91m[play_mode] handle_event error in cursor {o.__class__.__name__}\033[0m')&#10;                    pass&#10;            # 페이드인 중에는 다음 이벤트로 넘어감 (entities와 extras의 이동 이벤트 무시)&#10;            continue&#10;&#10;        # 일반 게임 플레이 중에는 모든 이벤트 처리&#10;        # broadcast to entities -&gt; extras -&gt; ui -&gt; cursor&#10;        for o in list(world['entities']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in entity {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;        # extras 레이어의 객체들도 이벤트 처리&#10;        for o in list(world['extras']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in extras {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;        for o in list(world['ui']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in ui {o.__class__.__name__}\033[0m')&#10;                pass&#10;        for o in list(world['cursor']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in cursor {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;&#10;def update():&#10;    global is_stage_cleared, loading_screen, is_loading, camera, elapsed_time, is_fading_to_victory, victory_fade_elapsed&#10;&#10;    # 로딩 중이면 로딩 화면만 업데이트&#10;    if is_loading and loading_screen:&#10;        loading_screen.update()&#10;&#10;        # 로딩이 완료되었으면 실제 스테이지 전환&#10;        if loading_screen.is_complete:&#10;            _complete_stage_change()&#10;            print(f'[play_mode] 스테이지 {current_stage_index + 1} 로딩 완료, 전환 완료')&#10;&#10;        return  # 로딩 중에는 게임 로직 업데이트 안 함&#10;&#10;    # 승리 페이드인 중이면 페이드인 타이머만 업데이트&#10;    if is_fading_to_victory:&#10;        dt = game_framework.get_delta_time()&#10;        victory_fade_elapsed += dt&#10;&#10;        # 페이드인이 완료되면 victory_mode로 전환&#10;        if victory_fade_elapsed &gt;= victory_fade_duration:&#10;            print(&quot;[play_mode] 페이드인 완료, victory_mode로 전환&quot;)&#10;            player = world.get('player')&#10;            survival_time = elapsed_time&#10;            game_framework.change_state(victory_mode, player, survival_time)&#10;&#10;        return  # 페이드인 중에는 게임 로직 업데이트 안 함&#10;&#10;    # 경과 시간 누적 (로딩 중이 아닐 때만)&#10;    dt = game_framework.get_delta_time()&#10;    elapsed_time += dt&#10;&#10;    # 카메라 업데이트 추가&#10;    if camera is not None:&#10;        camera.update()&#10;&#10;    # 일반 게임 업데이트&#10;    for layer_name in ['bg', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']:&#10;        new_list = []&#10;        for o in list(world[layer_name]):&#10;            try:&#10;                if hasattr(o, 'update'):&#10;                    alive = o.update()&#10;                    if alive is False:&#10;                        continue&#10;&#10;                # mark_for_removal 플래그 확인&#10;                if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#10;                    print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#10;                    continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#10;&#10;                new_list.append(o)&#10;            except Exception:&#10;                try:&#10;                    new_list.append(o)&#10;                except Exception:&#10;                    pass&#10;        world[layer_name][:] = new_list&#10;&#10;    # 충돌 검사 시스템&#10;    from .projectile import Projectile&#10;    from .monsters.cat_theif import CatThiefSwingEffect  # CatThiefSwingEffect import 추가&#10;    from .monsters.panther_assassin import PantherBladeSwingEffect  # PantherBladeSwingEffect import 추가&#10;    from .monsters.Boss_Logic.panther_assassin_3pattern import PantherCombo1SwingEffect&#10;    from .monsters.Boss_Logic.panther_assassin_3pattern import PantherCombo2SwingEffect&#10;    player = world.get('player')&#10;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#10;    effects_to_remove = set()&#10;    projectiles_to_remove = set()&#10;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#10;    for effect in world['effects_front']:&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#10;            for entity in world['entities']:&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#10;                    if entity.check_collision_with_effect(effect):&#10;                        # 디버그: 충돌 정보 출력&#10;                        attacker_name = &quot;Player&quot;&#10;                        if hasattr(effect, 'owner'):&#10;                            attacker_name = effect.owner.__class__.__name__&#10;                        target_name = entity.__class__.__name__&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#10;                        pass&#10;&#10;    # 1-2. 몬스터 공격 이펙트와 플레이어 충돌 검사&#10;    # 피격 판정이 필요한 몬스터 공격 이펙트 클래스 리스트&#10;    MONSTER_ATTACK_EFFECT_TYPES = [&#10;        CatThiefSwingEffect,&#10;        PantherBladeSwingEffect,&#10;        PantherCombo1SwingEffect,&#10;        PantherCombo2SwingEffect,&#10;    ]&#10;&#10;    if player:&#10;        for effect in world['effects_front']:&#10;            # 몬스터 공격 이펙트 타입 체크&#10;            for effect_type in MONSTER_ATTACK_EFFECT_TYPES:&#10;                if isinstance(effect, effect_type):&#10;                    # 이미 맞춘 플레이어는 다시 체크하지 않음 (중복 타격 방지)&#10;                    if not effect.has_hit_player:&#10;                        # 먼저 방패로 방어할 수 있는지 체크&#10;                        shield_blocked = False&#10;                        if hasattr(player, 'shield') and player.shield:&#10;                            if hasattr(player.shield, 'check_effect_block'):&#10;                                if player.shield.check_effect_block(effect):&#10;                                    # 방패로 막았으면 막은 것으로 판별, 이펙트는 지우지 않음&#10;                                    effect.has_hit_player = True&#10;                                    shield_blocked = True&#10;                                    print(f&quot;[COLLISION] Player가 방패로 {effect.__class__.__name__} 방어!&quot;)&#10;&#10;                        # 방패로 막지 못했을 때만 플레이어와 충돌 검사&#10;                        if not shield_blocked:&#10;                            if hasattr(player, 'check_collision_with_effect'):&#10;                                if player.check_collision_with_effect(effect):&#10;                                    # 충돌 시 플레이어 타격 처리&#10;                                    effect.has_hit_player = True&#10;                                    # 디버그: 충돌 정보 출력&#10;                                    attacker_name = &quot;Unknown&quot;&#10;                                    if hasattr(effect, 'owner') and effect.owner:&#10;                                        attacker_name = effect.owner.__class__.__name__&#10;                                    print(f&quot;[COLLISION] {attacker_name} {effect.__class__.__name__} -&gt; Player 피격!&quot;)&#10;                    &#10;                    # 해당 타입으로 확인되면 다른 타입 체크는 불필요&#10;                    break&#10;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#10;    if player:&#10;        for projectile in world['effects_front']:&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#10;            if isinstance(projectile, Projectile):&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#10;                if not projectile.from_player:&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#10;                        if player.check_collision_with_projectile(projectile):&#10;                            # 디버그: 충돌 정보 출력&#10;                            attacker_name = &quot;Unknown&quot;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#10;                                attacker_name = projectile.owner.__class__.__name__&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#10;                            projectiles_to_remove.add(projectile)&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#10;                else:&#10;                    for entity in world['entities']:&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#10;                            if entity.check_collision_with_projectile(projectile):&#10;                                # 디버그: 충돌 정보 출력&#10;                                target_name = entity.__class__.__name__&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#10;                                projectiles_to_remove.add(projectile)&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#10;&#10;    # 충돌한 투사체 제거&#10;    if projectiles_to_remove:&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#10;&#10;    # 스테이지 클리어 조건 확인 (몬스터가 모두 제거되었는지)&#10;    # 'entities' 레이어에 플레이어만 남아있는지 확인합니다.&#10;    if not is_stage_cleared and len(world['entities']) == 1 and world.get('player') in world['entities']:&#10;        # 이전에 몬스터가 1마리 이상 있었는지 확인하는 조건이 필요할 수 있습니다.&#10;        # 여기서는 간단히 몬스터가 없으면 클리어로 간주합니다.&#10;        print(&quot;Stage cleared!&quot;)&#10;        is_stage_cleared = True # 중복 호출 방지&#10;        change_stage(current_stage_index + 1)&#10;&#10;&#10;def draw():&#10;    global camera, victory_fade_image, victory_fade_elapsed, victory_fade_duration&#10;    p2.clear_canvas()&#10;&#10;    # 로딩 중이면 로딩 화면만 그리기&#10;    if is_loading and loading_screen:&#10;        loading_screen.draw()&#10;    else:&#10;        # 일반 게임 화면 그리기&#10;        # 1. FixedBackground 먼저 그리기 (카메라 영향 없음)&#10;        from .background import FixedBackground&#10;        from .equipment import ShieldRangeEffect&#10;&#10;        for o in world['bg']:&#10;            if isinstance(o, FixedBackground):&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        o.draw()  # FixedBackground는 인자 없이 호출&#10;                except Exception as ex:&#10;                    print(f'\033[91m[play_mode] FixedBackground 그리기 오류: {ex}\033[0m')&#10;                    pass&#10;&#10;        # 2. 나머지 객체들은 카메라 좌표 적용하여 그리기&#10;        for layer_name in ['bg', 'walls', 'upper_ground', 'effects_back', 'entities', 'effects_front', 'extra_bg', 'extras']:&#10;            for o in world[layer_name]:&#10;                # FixedBackground는 이미 그렸으므로 스킵&#10;                if isinstance(o, FixedBackground):&#10;                    continue&#10;&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        # ShieldRangeEffect는 특별 처리 (플레이어 위치 기준)&#10;                        if isinstance(o, ShieldRangeEffect):&#10;                            if hasattr(o, 'player') and o.player:&#10;                                if camera is not None:&#10;                                    draw_x, draw_y = camera.apply(o.player.x, o.player.y)&#10;                                else:&#10;                                    draw_x, draw_y = o.player.x, o.player.y&#10;                                o.draw(draw_x, draw_y)&#10;                        # x, y 속성이 있는 객체는 카메라 좌표로 변환하여 그리기&#10;                        elif hasattr(o, 'x') and hasattr(o, 'y'):&#10;                            if camera is not None:&#10;                                draw_x, draw_y = camera.apply(o.x, o.y)&#10;                            else:&#10;                                draw_x, draw_y = o.x, o.y&#10;                            o.draw(draw_x, draw_y)&#10;                        else:&#10;                            # x, y 속성이 없는 객체는 그대로 그리기&#10;                            o.draw()&#10;                except Exception as ex:&#10;                    print(f'\033[91m[play_mode] {layer_name} 레이어의 {o.__class__.__name__} 그리기 오류: {ex}\033[0m')&#10;                    pass&#10;&#10;        # 3. UI와 커서는 카메라 적용하지 않음 (고정 UI)&#10;        for o in world['ui']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[play_mode] UI 레이어의 {o.__class__.__name__} 그리기 오류 : {ex}\033[0m')&#10;                pass&#10;&#10;        for o in world['cursor']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[play_mode] Cursor 레이어의 {o.__class__.__name__} 그리기 오류 : {ex}\033[0m')&#10;                pass&#10;&#10;        # 4. 승리 페이드인 효과 그리기 (기존 화면 위에 오버레이)&#10;        if is_fading_to_victory and victory_fade_image:&#10;            canvas_w = p2.get_canvas_width()&#10;            canvas_h = p2.get_canvas_height()&#10;&#10;            # 페이드인 진행률 계산 (0.0 ~ 1.0)&#10;            fade_progress = min(victory_fade_elapsed / victory_fade_duration, 1.0)&#10;&#10;            # 이미지 투명도 설정 및 그리기&#10;            victory_fade_image.opacify(fade_progress)&#10;            victory_fade_image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)&#10;&#10;    p2.update_canvas()&#10;" />
              <option name="updatedContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#10;# minimal, compatible with existing game_logic modules&#10;import pico2d as p2&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#10;from PIL import Image&#10;&#10;import game_framework&#10;from .player import Player&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar, DashBar&#10;from .cursor import Cursor&#10;from .loading_screen import LoadingScreen&#10;from . import defeat_mode, victory_mode&#10;# 사용할 스테이지 모듈들을 import 합니다.&#10;from .stages import stage_1, stage_2&#10;&#10;# world layers: keep same keys as original main.py&#10;world = {&#10;    'ground': [],&#10;    'upper_ground': [],&#10;    'walls': [],&#10;    'effects_back': [],&#10;    'entities': [],&#10;    'effects_front': [],&#10;    'ui': [],&#10;    'extra_bg': [],&#10;    'extras': [],&#10;    'cursor': []&#10;}&#10;world['bg'] = world['ground']&#10;&#10;# 스테이지 관리&#10;# stages = [stage_1, stage_2]&#10;stages = [stage_1]&#10;current_stage_index = 0&#10;is_stage_cleared = False&#10;&#10;# 로딩 화면 관리&#10;loading_screen = None&#10;is_loading = False&#10;next_stage_to_load = None&#10;&#10;# 경과 시간 추적 (play_mode 진입 후 경과 시간)&#10;elapsed_time = 0.0&#10;&#10;# 승리 페이드인 효과 관련 변수&#10;is_fading_to_victory = False  # 승리 페이드인 진행 중 플래그&#10;victory_fade_elapsed = 0.0    # 페이드인 경과 시간&#10;victory_fade_duration = 3.0   # 페이드인 지속 시간 (3초)&#10;victory_fade_image = None     # 페이드인 이미지&#10;&#10;&#10;class Camera:&#10;    &quot;&quot;&quot;&#10;    플레이어를 부드럽게 따라가는 카메라 클래스&#10;    맵의 경계를 넘지 않도록 제한하며, 화면 중앙을 (0,0)으로 하는 좌표계 사용&#10;    &quot;&quot;&quot;&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#10;        &quot;&quot;&quot;&#10;        카메라 초기화&#10;        Args:&#10;            target: 카메라가 따라갈 대상 (일반적으로 플레이어)&#10;            map_width: 맵의 전체 너비&#10;            map_height: 맵의 전체 높이&#10;            screen_width: 화면 너비&#10;            screen_height: 화면 높이&#10;        &quot;&quot;&quot;&#10;        self.target = target&#10;        self.x = target.x&#10;        self.y = target.y&#10;        self.map_width = map_width&#10;        self.map_height = map_height&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1, 낮을수록 부드럽고 느림)&#10;&#10;        # 맵 오프셋 (배경의 중심점, calculate_background_bounds에서 설정)&#10;        self.map_offset_x = 0&#10;        self.map_offset_y = 0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        카메라 위치 업데이트 - 타겟을 부드럽게 따라가며 맵 경계 내로 제한&#10;        &quot;&quot;&quot;&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP - Linear Interpolation)&#10;        target_x = self.target.x&#10;        target_y = self.target.y&#10;        self.x += (target_x - self.x) * self.smooth&#10;        self.y += (target_y - self.y) * self.smooth&#10;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#10;        min_x = -self.map_width/2&#10;        max_x = self.map_width/2&#10;        min_y = -self.map_height/2&#10;        max_y = self.map_height/2&#10;&#10;        self.x = max(min_x, min(self.x, max_x))&#10;        self.y = max(min_y, min(self.y, max_y))&#10;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#10;        if self.map_width &lt;= self.screen_width:&#10;            self.x = 0&#10;        if self.map_height &lt;= self.screen_height:&#10;            self.y = 0&#10;&#10;    def apply(self, obj_x, obj_y):&#10;        &quot;&quot;&quot;&#10;        카메라 위치에 따라 오브젝트의 화면 좌표 계산&#10;        Args:&#10;            obj_x: 오브젝트의 월드 x 좌표 (맵 중심 기준)&#10;            obj_y: 오브젝트의 월드 y 좌표 (맵 중심 기준)&#10;        Returns:&#10;            tuple: (draw_x, draw_y) - 화면에 그릴 좌표&#10;        &quot;&quot;&quot;&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#10;&#10;&#10;# Camera 객체를 전역으로 선언&#10;camera = None&#10;&#10;&#10;def calculate_background_bounds():&#10;    &quot;&quot;&quot;&#10;    ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#10;&#10;    Returns:&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#10;    &quot;&quot;&quot;&#10;    min_x = float('inf')&#10;    max_x = float('-inf')&#10;    min_y = float('inf')&#10;    max_y = float('-inf')&#10;&#10;    # ground 레이어의 모든 객체를 순회&#10;    for obj in world['ground']:&#10;        # 객체가 x, y, image 속성을 가지고 있는지 확인&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image'):&#10;            # 객체의 중심 좌표&#10;            obj_x = obj.x&#10;            obj_y = obj.y&#10;&#10;            # 이미지 크기 계산 (scale 속성이 있으면 적용)&#10;            scale = getattr(obj, 'scale', 1.0)&#10;            img_width = obj.image.w * scale&#10;            img_height = obj.image.h * scale&#10;&#10;            # 객체의 경계 계산 (중심 기준이므로 절반씩)&#10;            obj_left = obj_x - img_width / 2&#10;            obj_right = obj_x + img_width / 2&#10;            obj_bottom = obj_y - img_height / 2&#10;            obj_top = obj_y + img_height / 2&#10;&#10;            # 최소/최대 값 업데이트&#10;            min_x = min(min_x, obj_left)&#10;            max_x = max(max_x, obj_right)&#10;            min_y = min(min_y, obj_bottom)&#10;            max_y = max(max_y, obj_top)&#10;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환 (1280x720 화면 기준)&#10;    if min_x == float('inf') or max_x == float('-inf'):&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#10;        return (-640, 640, -360, 360)&#10;&#10;    print(f&quot;[play_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#10;    return (min_x, max_x, min_y, max_y)&#10;&#10;&#10;def change_stage(next_stage_index):&#10;    &quot;&quot;&quot;다음 스테이지로 변경하는 함수&quot;&quot;&quot;&#10;    global current_stage_index, loading_screen, is_loading, next_stage_to_load, is_fading_to_victory, victory_fade_elapsed, victory_fade_image&#10;&#10;    # 다음 스테이지 인덱스 확인&#10;    if next_stage_index &gt;= len(stages):&#10;        # 모든 스테이지 클리어 시 페이드인 효과 시작&#10;        print(&quot;All stages cleared! Starting fade-in effect...&quot;)&#10;        is_fading_to_victory = True&#10;        victory_fade_elapsed = 0.0&#10;&#10;        # 플레이어를 entities에서 extras 레이어로 즉시 이동&#10;        player = world.get('player')&#10;        if player and player in world['entities']:&#10;            world['entities'].remove(player)&#10;            world['extras'].append(player)&#10;            print(&quot;[change_stage] 플레이어를 extras 레이어로 이동&quot;)&#10;&#10;        # 페이드인 이미지 로드&#10;        try:&#10;            victory_fade_image = p2.load_image('resources/Texture_organize/IDK_2/Square.png')&#10;            print(&quot;[change_stage] 승리 페이드인 이미지 로드 성공&quot;)&#10;        except Exception as ex:&#10;            print(f'\033[91m[change_stage] 승리 페이드인 이미지 로드 실패: {ex}\033[0m')&#10;            victory_fade_image = None&#10;&#10;        return&#10;&#10;    # 로딩 화면 시작 - 스테이지 모듈의 LOADING_SCREEN_INFO 사용&#10;    next_stage_module = stages[next_stage_index]&#10;    loading_info = getattr(next_stage_module, 'LOADING_SCREEN_INFO', None)&#10;&#10;    if loading_info:&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1} 로딩 화면 시작&quot;)&#10;        loading_screen = LoadingScreen(loading_info)&#10;        is_loading = True&#10;        next_stage_to_load = next_stage_index&#10;    else:&#10;        # LOADING_SCREEN_INFO가 없으면 로딩 화면 없이 바로 전환&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1}에 로딩 화면 정보 없음, 즉시 전환&quot;)&#10;        next_stage_to_load = next_stage_index&#10;        _complete_stage_change()&#10;&#10;&#10;class PlayModeWall:&#10;    &quot;&quot;&quot;플레이 모드에서 사용하는 벽 클래스 (투명 영역 감지용)&quot;&quot;&quot;&#10;    def __init__(self, x, y, w, h):&#10;        &quot;&quot;&quot;&#10;        벽 초기화&#10;        Args:&#10;            x: 벽의 월드 x 좌표 (맵 중심 기준)&#10;            y: 벽의 월드 y 좌표 (맵 중심 기준)&#10;            w: 벽의 너비&#10;            h: 벽의 높이&#10;        &quot;&quot;&quot;&#10;        self.x = x&#10;        self.y = y&#10;        self.w = w&#10;        self.h = h&#10;&#10;    def check_collision(self, px, py, pw, ph):&#10;        &quot;&quot;&quot;&#10;        플레이어와 벽의 충돌 검사&#10;        Args:&#10;            px: 플레이어 x 좌표&#10;            py: 플레이어 y 좌표&#10;            pw: 플레이어 너비&#10;            ph: 플레이어 높이&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        return (self.x &lt; px + pw and self.x + self.w &gt; px and&#10;                self.y &lt; py + ph and self.y + self.h &gt; py)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;벽은 업데이트가 필요 없음&quot;&quot;&quot;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        벽 디버깅용 그리기 (필요시 주석 해제)&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 x 좌표&#10;            draw_y: 카메라가 적용된 화면 y 좌표&#10;        &quot;&quot;&quot;&#10;        # 디버깅용: 벽을 빨간색으로 표시 (벽 위치 확인용)&#10;        # p2.draw_rectangle(draw_x - self.w/2, draw_y - self.h/2,&#10;        #                   draw_x + self.w/2, draw_y + self.h/2)&#10;        pass&#10;&#10;&#10;def generate_walls_from_png(png_path, block_size=8, map_x=0, map_y=0, map_scale=1.0):&#10;    &quot;&quot;&quot;&#10;    PNG 이미지의 투명 영역을 감지하여 벽 블록 생성&#10;    Args:&#10;        png_path: PNG 이미지 경로&#10;        block_size: 벽 블록의 기본 크기 (픽셀 단위, 스케일 적용 전)&#10;        map_x: 맵의 월드 x 좌표 (중심 기준)&#10;        map_y: 맵의 월드 y 좌표 (중심 기준)&#10;        map_scale: 맵의 스케일&#10;    Returns:&#10;        list: 생성된 PlayModeWall 객체 리스트&#10;    &quot;&quot;&quot;&#10;    print(f&quot;[generate_walls_from_png] 시작: {png_path}&quot;)&#10;    print(f&quot;  - block_size={block_size}, map_x={map_x}, map_y={map_y}, map_scale={map_scale}&quot;)&#10;&#10;    try:&#10;        img = Image.open(png_path).convert('RGBA')&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[generate_walls_from_png] 이미지 열기 실패: {ex}\033[0m&quot;)&#10;        return []&#10;&#10;    width, height = img.size&#10;    walls = []&#10;    pixels = img.load()&#10;    transparent_count = 0&#10;&#10;    # 맵 이미지의 좌상단 기준 좌표 계산 (맵 중심 기준)&#10;    map_left = map_x - (width * map_scale) / 2&#10;    map_bottom = map_y - (height * map_scale) / 2&#10;&#10;    print(f&quot;  - 이미지 크기: {width}x{height}&quot;)&#10;    print(f&quot;  - 맵 좌하단 좌표: ({map_left:.1f}, {map_bottom:.1f})&quot;)&#10;&#10;    # 이미지를 블록 단위로 순회&#10;    for y in range(0, height, block_size):&#10;        for x in range(0, width, block_size):&#10;            is_transparent = False&#10;            # 블록 내부의 픽셀들을 검사&#10;            for dy in range(block_size):&#10;                for dx in range(block_size):&#10;                    if x + dx &lt; width and y + dy &lt; height:&#10;                        _, _, _, alpha = pixels[x + dx, y + dy]&#10;                        if alpha == 0:  # 완전 투명&#10;                            is_transparent = True&#10;                            transparent_count += 1&#10;                            break&#10;                if is_transparent:&#10;                    break&#10;&#10;            # 투명 블록이면 벽 생성&#10;            if is_transparent:&#10;                # 이미지 좌표를 월드 좌표로 변환&#10;                # 이미지 좌표계: 좌상단 (0,0), 우하단 (width, height)&#10;                # 월드 좌표계: 맵 중심 (0,0)&#10;                wall_x_img = x&#10;                wall_y_img = height - y - block_size  # Y축 반전 (이미지는 위에서 아래로, 월드는 아래에서 위로)&#10;&#10;                # 월드 좌표로 변환&#10;                wall_x_world = map_left + wall_x_img * map_scale + (block_size * map_scale) / 2&#10;                wall_y_world = map_bottom + wall_y_img * map_scale + (block_size * map_scale) / 2&#10;&#10;                walls.append(PlayModeWall(&#10;                    wall_x_world,&#10;                    wall_y_world,&#10;                    block_size * map_scale,&#10;                    block_size * map_scale&#10;                ))&#10;&#10;    print(f&quot;  - 투명 픽셀 수: {transparent_count}, 생성된 벽 수: {len(walls)}&quot;)&#10;    return walls&#10;&#10;&#10;def _complete_stage_change():&#10;    &quot;&quot;&quot;로딩이 완료된 후 실제 스테이지 전환을 수행&quot;&quot;&quot;&#10;    global current_stage_index, world, is_stage_cleared, loading_screen, is_loading, next_stage_to_load, camera&#10;&#10;    print(f&quot;[_complete_stage_change] 스테이지 {next_stage_to_load + 1} 로드 시작&quot;)&#10;&#10;    # 현재 스테이지의 몬스터, 배경 등 제거 (플레이어는 유지)&#10;    player = world.get('player')&#10;    world['entities'] = [player] if player else []&#10;    world['bg'].clear()&#10;    world['walls'].clear()  # 벽도 초기화&#10;    # 다른 레이어도 필요에 따라 초기화&#10;    world['effects_back'].clear()&#10;    world['effects_front'].clear()&#10;&#10;    # 다음 스테이지 인덱스로 변경&#10;    current_stage_index = next_stage_to_load&#10;&#10;    # 새 스테이지 로드&#10;    stages[current_stage_index].load(world)&#10;&#10;    # 스테이지 맵에서 벽 생성 (ground 레이어의 첫 번째 객체가 맵이라고 가정)&#10;    try:&#10;        if world['ground'] and len(world['ground']) &gt; 0:&#10;            stage_map = world['ground'][1]&#10;            if hasattr(stage_map, 'image') and hasattr(stage_map, 'x') and hasattr(stage_map, 'y'):&#10;                # 맵 이미지의 경로 가져오기 (StageMap 객체에서)&#10;                next_stage_module = stages[current_stage_index]&#10;                stage_data = getattr(next_stage_module, 'stage_data', None)&#10;&#10;                if stage_data and 'stage_map' in stage_data:&#10;                    map_image_path = stage_data['stage_map']['image']&#10;                    map_scale = getattr(stage_map, 'scale', 1.0)&#10;&#10;                    print(f&quot;[_complete_stage_change] 맵 이미지에서 벽 생성 중...&quot;)&#10;                    wall_blocks = generate_walls_from_png(&#10;                        map_image_path,&#10;                        block_size=8,&#10;                        map_x=stage_map.x,&#10;                        map_y=stage_map.y,&#10;                        map_scale=map_scale&#10;                    )&#10;&#10;                    for wall in wall_blocks:&#10;                        world['walls'].append(wall)&#10;&#10;                    print(f&quot;[_complete_stage_change] {len(wall_blocks)}개의 벽 생성 완료&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[_complete_stage_change] 벽 생성 실패: {ex}\033[0m&quot;)&#10;&#10;    # 플레이어 위치 설정 (스테이지에 PLAYER_START_POSITION이 있으면 사용)&#10;    if player:&#10;        next_stage_module = stages[current_stage_index]&#10;        player_start_pos = getattr(next_stage_module, 'PLAYER_START_POSITION', None)&#10;&#10;        if player_start_pos:&#10;            # 플레이어 위치를 새 스테이지 시작 위치로 설정&#10;            new_x = player_start_pos['x']&#10;            new_y = player_start_pos['y']&#10;            player.x = new_x&#10;            player.y = new_y&#10;            print(f&quot;[_complete_stage_change] 플레이어 위치 설정: ({player.x}, {player.y})&quot;)&#10;        else:&#10;            print(f&quot;[_complete_stage_change] 플레이어 시작 위치 정보 없음, 현재 위치 유지&quot;)&#10;    else:&#10;        print(f'\033[91m[_complete_stage_change] 플레이어 객체 없음\033[0m')&#10;&#10;    # 카메라 초기화 또는 업데이트&#10;    try:&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;        map_width = max_x - min_x&#10;        map_height = max_y - min_y&#10;&#10;        screen_width = p2.get_canvas_width()&#10;        screen_height = p2.get_canvas_height()&#10;&#10;        # 카메라가 없으면 새로 생성 (첫 스테이지)&#10;        if camera is None and player:&#10;            print(f&quot;[_complete_stage_change] 카메라 생성 중...&quot;)&#10;            camera = Camera(player, map_width, map_height, screen_width, screen_height)&#10;            camera.map_offset_x = (min_x + max_x) / 2&#10;            camera.map_offset_y = (min_y + max_y) / 2&#10;            # 카메라를 플레이어 위치로 즉시 동기화&#10;            camera.x = player.x&#10;            camera.y = player.y&#10;            print(f&quot;[_complete_stage_change] 카메라 생성 완료: ({camera.x}, {camera.y})&quot;)&#10;        # 카메라가 이미 있으면 맵 크기만 업데이트&#10;        elif camera is not None:&#10;            camera.map_width = map_width&#10;            camera.map_height = map_height&#10;            camera.map_offset_x = (min_x + max_x) / 2&#10;            camera.map_offset_y = (min_y + max_y) / 2&#10;            # 카메라를 플레이어 위치로 즉시 동기화&#10;            if player:&#10;                camera.x = player.x&#10;                camera.y = player.y&#10;            print(f&quot;[_complete_stage_change] 카메라 업데이트 완료: 맵 크기 {map_width:.1f}x{map_height:.1f}&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[_complete_stage_change] 카메라 초기화/업데이트 실패: {ex}\033[0m&quot;)&#10;&#10;    is_stage_cleared = False&#10;&#10;    # 로딩 화면 종료&#10;    loading_screen = None&#10;    is_loading = False&#10;    next_stage_to_load = None&#10;&#10;    print(f&quot;[_complete_stage_change] Changed to Stage {current_stage_index + 1}&quot;)&#10;&#10;def enter(player=None):&#10;    global world, current_stage_index, is_stage_cleared, loading_screen, is_loading, next_stage_to_load, elapsed_time&#10;    print(&quot;[play_mode] Starting enter()...&quot;)&#10;&#10;    # 경과 시간 초기화&#10;    elapsed_time = 0.0&#10;&#10;    # clear existing&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(f'\033[91m[play_mode] Failed to clear world layer: {k}\033[0m')&#10;&#10;    print(&quot;[play_mode] Creating player...&quot;)&#10;    # create player (use fallback if heavy Player init fails)&#10;    try:&#10;        if player == None:&#10;            player = Player()&#10;        print(&quot;[play_mode] Player created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[play_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#10;        from .inventory import InventoryData, seed_debug_inventory&#10;&#10;        class _FallbackPlayer:&#10;            def __init__(self):&#10;                self.x = 0  # 맵 중심 기준 좌표&#10;                self.y = 0&#10;                self.face_dir = 1&#10;                self.scale_factor = 1.0&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;                self.particles = []&#10;                self.attack_effects = []&#10;                self.inventory = InventoryData(cols=6, rows=5)&#10;                try:&#10;                    seed_debug_inventory(self.inventory)&#10;                except Exception:&#10;                    pass&#10;                self.inventory_open = False&#10;&#10;            def update(self):&#10;                return True&#10;&#10;            def rebuild_inventory_passives(self):&#10;                return&#10;&#10;            def consume_item_at(self, r, c):&#10;                return False&#10;&#10;        player = _FallbackPlayer()&#10;&#10;    print(&quot;[play_mode] Attaching world reference to player...&quot;)&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#10;    try:&#10;        player.world = world&#10;    except Exception:&#10;        pass&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#10;    world['entities'].append(player)&#10;&#10;    print(&quot;[play_mode] Creating inventory overlay...&quot;)&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#10;    try:&#10;        inv = InventoryOverlay(player, world)&#10;        print(&quot;[play_mode] InventoryOverlay created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] InventoryOverlay init failed, creating minimal stub:', ex)&#10;&#10;        class _InvStub:&#10;            def __init__(self, player, world=None):&#10;                self.player = player&#10;                self.world = world&#10;                self.dragging = False&#10;                self.drag_from = None&#10;                self.drag_icon = None&#10;                self.drag_qty = 0&#10;            def handle_event(self, e):&#10;                return&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        inv = _InvStub(player, world)&#10;    world['ui'].append(inv)&#10;&#10;    print(&quot;[play_mode] Creating health bar...&quot;)&#10;    # health bar UI 생성&#10;    try:&#10;        health_bar = HealthBar(player)&#10;        print(&quot;[play_mode] HealthBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] HealthBar init failed, using stub:', ex)&#10;&#10;        class _HealthBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        health_bar = _HealthBarStub(player)&#10;    world['ui'].append(health_bar)&#10;&#10;    print(&quot;[play_mode] Creating mana bar...&quot;)&#10;    # mana bar UI 생성&#10;    try:&#10;        mana_bar = ManaBar(player)&#10;        print(&quot;[play_mode] ManaBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] ManaBar init failed, using stub:', ex)&#10;&#10;        class _ManaBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        mana_bar = _ManaBarStub(player)&#10;    world['ui'].append(mana_bar)&#10;&#10;    print(&quot;[play_mode] Creating dash bar...&quot;)&#10;    # dash bar UI 생성&#10;    try:&#10;        dash_bar = DashBar(player)&#10;        print(&quot;[play_mode] DashBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] DashBar init failed, using stub:', ex)&#10;&#10;        class _DashBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        dash_bar = _DashBarStub(player)&#10;    world['ui'].append(dash_bar)&#10;&#10;    print(&quot;[play_mode] Creating cursor...&quot;)&#10;    # cursor on top (safe fallback)&#10;    try:&#10;        cursor = Cursor(player)&#10;        print(&quot;[play_mode] Cursor created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] Cursor init failed, using stub cursor:', ex)&#10;&#10;        class _CursorStub:&#10;            def __init__(self, player=None):&#10;                self.player = player&#10;                self.x = 0&#10;                self.y = 0&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;            def handle_event(self, e):&#10;                return&#10;&#10;        cursor = _CursorStub(player)&#10;    world['cursor'].append(cursor)&#10;&#10;    # expose world to __main__ for legacy code that looks up main.world&#10;    try:&#10;        import sys&#10;        main_mod = sys.modules.get('__main__')&#10;        if main_mod is not None:&#10;            setattr(main_mod, 'world', world)&#10;    except Exception:&#10;        pass&#10;&#10;    print(&quot;[play_mode] Starting first stage with loading screen...&quot;)&#10;    # 첫 번째 스테이지를 로딩 화면과 함께 시작&#10;    current_stage_index = -1  # change_stage가 0으로 설정할 것임&#10;    is_stage_cleared = False&#10;&#10;    # change_stage 함수를 사용하여 로딩 화면과 함께 첫 스테이지 로드&#10;    change_stage(0)&#10;&#10;    print(f&quot;[play_mode] Entered play_mode, loading Stage 1 with loading screen&quot;)&#10;&#10;    # Camera 초기화는 _complete_stage_change에서 진행됨&#10;&#10;def exit():&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            pass&#10;&#10;&#10;def handle_events():&#10;    import game_framework as app_framework&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            app_framework.quit()&#10;            return&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#10;            app_framework.quit()&#10;            return&#10;&#10;        # 페이드인 중일 때는 플레이어 이동 이벤트만 무시하고 나머지는 처리&#10;        if is_fading_to_victory:&#10;            # extras 레이어의 플레이어는 이동 이벤트 무시 (하지만 다른 이벤트는 처리 가능)&#10;            # UI와 커서 이벤트는 처리 (인벤토리 조작 등)&#10;            for o in list(world['ui']):&#10;                try:&#10;                    if hasattr(o, 'handle_event'):&#10;                        o.handle_event(e)&#10;                except Exception:&#10;                    print(f'\033[91m[play_mode] handle_event error in ui {o.__class__.__name__}\033[0m')&#10;                    pass&#10;            for o in list(world['cursor']):&#10;                try:&#10;                    if hasattr(o, 'handle_event'):&#10;                        o.handle_event(e)&#10;                except Exception:&#10;                    print(f'\033[91m[play_mode] handle_event error in cursor {o.__class__.__name__}\033[0m')&#10;                    pass&#10;            # 페이드인 중에는 다음 이벤트로 넘어감 (entities와 extras의 이동 이벤트 무시)&#10;            continue&#10;&#10;        # 일반 게임 플레이 중에는 모든 이벤트 처리&#10;        # broadcast to entities -&gt; extras -&gt; ui -&gt; cursor&#10;        for o in list(world['entities']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in entity {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;        # extras 레이어의 객체들도 이벤트 처리&#10;        for o in list(world['extras']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in extras {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;        for o in list(world['ui']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in ui {o.__class__.__name__}\033[0m')&#10;                pass&#10;        for o in list(world['cursor']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in cursor {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;&#10;def update():&#10;    global is_stage_cleared, loading_screen, is_loading, camera, elapsed_time, is_fading_to_victory, victory_fade_elapsed&#10;&#10;    # 로딩 중이면 로딩 화면만 업데이트&#10;    if is_loading and loading_screen:&#10;        loading_screen.update()&#10;&#10;        # 로딩이 완료되었으면 실제 스테이지 전환&#10;        if loading_screen.is_complete:&#10;            _complete_stage_change()&#10;            print(f'[play_mode] 스테이지 {current_stage_index + 1} 로딩 완료, 전환 완료')&#10;&#10;        return  # 로딩 중에는 게임 로직 업데이트 안 함&#10;&#10;    # 승리 페이드인 중이면 페이드인 타이머만 업데이트&#10;    if is_fading_to_victory:&#10;        dt = game_framework.get_delta_time()&#10;        victory_fade_elapsed += dt&#10;&#10;        # 페이드인이 완료되면 victory_mode로 전환&#10;        if victory_fade_elapsed &gt;= victory_fade_duration:&#10;            print(&quot;[play_mode] 페이드인 완료, victory_mode로 전환&quot;)&#10;            player = world.get('player')&#10;            survival_time = elapsed_time&#10;            game_framework.change_state(victory_mode, player, survival_time)&#10;&#10;        return  # 페이드인 중에는 게임 로직 업데이트 안 함&#10;&#10;    # 경과 시간 누적 (로딩 중이 아닐 때만)&#10;    dt = game_framework.get_delta_time()&#10;    elapsed_time += dt&#10;&#10;    # 카메라 업데이트 추가&#10;    if camera is not None:&#10;        camera.update()&#10;&#10;    # 일반 게임 업데이트&#10;    for layer_name in ['bg', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']:&#10;        new_list = []&#10;        for o in list(world[layer_name]):&#10;            try:&#10;                if hasattr(o, 'update'):&#10;                    alive = o.update()&#10;                    if alive is False:&#10;                        continue&#10;&#10;                # mark_for_removal 플래그 확인&#10;                if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#10;                    print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#10;                    continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#10;&#10;                new_list.append(o)&#10;            except Exception:&#10;                try:&#10;                    new_list.append(o)&#10;                except Exception:&#10;                    pass&#10;        world[layer_name][:] = new_list&#10;&#10;    # 충돌 검사 시스템&#10;    from .projectile import Projectile&#10;    from .monsters.cat_theif import CatThiefSwingEffect  # CatThiefSwingEffect import 추가&#10;    from .monsters.panther_assassin import PantherBladeSwingEffect  # PantherBladeSwingEffect import 추가&#10;    from .monsters.Boss_Logic.panther_assassin_3pattern import PantherCombo1SwingEffect&#10;    from .monsters.Boss_Logic.panther_assassin_3pattern import PantherCombo2SwingEffect&#10;    player = world.get('player')&#10;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#10;    effects_to_remove = set()&#10;    projectiles_to_remove = set()&#10;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#10;    for effect in world['effects_front']:&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#10;            for entity in world['entities']:&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#10;                    if entity.check_collision_with_effect(effect):&#10;                        # 디버그: 충돌 정보 출력&#10;                        attacker_name = &quot;Player&quot;&#10;                        if hasattr(effect, 'owner'):&#10;                            attacker_name = effect.owner.__class__.__name__&#10;                        target_name = entity.__class__.__name__&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#10;                        pass&#10;&#10;    # 1-2. 몬스터 공격 이펙트와 플레이어 충돌 검사&#10;    # 피격 판정이 필요한 몬스터 공격 이펙트 클래스 리스트&#10;    MONSTER_ATTACK_EFFECT_TYPES = [&#10;        CatThiefSwingEffect,&#10;        PantherBladeSwingEffect,&#10;        PantherCombo1SwingEffect,&#10;        PantherCombo2SwingEffect,&#10;    ]&#10;&#10;    if player:&#10;        for effect in world['effects_front']:&#10;            # 몬스터 공격 이펙트 타입 체크&#10;            for effect_type in MONSTER_ATTACK_EFFECT_TYPES:&#10;                if isinstance(effect, effect_type):&#10;                    # 이미 맞춘 플레이어는 다시 체크하지 않음 (중복 타격 방지)&#10;                    if not effect.has_hit_player:&#10;                        # 먼저 방패로 방어할 수 있는지 체크&#10;                        shield_blocked = False&#10;                        if hasattr(player, 'shield') and player.shield:&#10;                            if hasattr(player.shield, 'check_effect_block'):&#10;                                if player.shield.check_effect_block(effect):&#10;                                    # 방패로 막았으면 막은 것으로 판별, 이펙트는 지우지 않음&#10;                                    effect.has_hit_player = True&#10;                                    shield_blocked = True&#10;                                    print(f&quot;[COLLISION] Player가 방패로 {effect.__class__.__name__} 방어!&quot;)&#10;&#10;                        # 방패로 막지 못했을 때만 플레이어와 충돌 검사&#10;                        if not shield_blocked:&#10;                            if hasattr(player, 'check_collision_with_effect'):&#10;                                if player.check_collision_with_effect(effect):&#10;                                    # 충돌 시 플레이어 타격 처리&#10;                                    effect.has_hit_player = True&#10;                                    # 디버그: 충돌 정보 출력&#10;                                    attacker_name = &quot;Unknown&quot;&#10;                                    if hasattr(effect, 'owner') and effect.owner:&#10;                                        attacker_name = effect.owner.__class__.__name__&#10;                                    print(f&quot;[COLLISION] {attacker_name} {effect.__class__.__name__} -&gt; Player 피격!&quot;)&#10;                    &#10;                    # 해당 타입으로 확인되면 다른 타입 체크는 불필요&#10;                    break&#10;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#10;    if player:&#10;        for projectile in world['effects_front']:&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#10;            if isinstance(projectile, Projectile):&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#10;                if not projectile.from_player:&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#10;                        if player.check_collision_with_projectile(projectile):&#10;                            # 디버그: 충돌 정보 출력&#10;                            attacker_name = &quot;Unknown&quot;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#10;                                attacker_name = projectile.owner.__class__.__name__&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#10;                            projectiles_to_remove.add(projectile)&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#10;                else:&#10;                    for entity in world['entities']:&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#10;                            if entity.check_collision_with_projectile(projectile):&#10;                                # 디버그: 충돌 정보 출력&#10;                                target_name = entity.__class__.__name__&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#10;                                projectiles_to_remove.add(projectile)&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#10;&#10;    # 충돌한 투사체 제거&#10;    if projectiles_to_remove:&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#10;&#10;    # 스테이지 클리어 조건 확인 (몬스터가 모두 제거되었는지)&#10;    # 'entities' 레이어에 플레이어만 남아있는지 확인합니다.&#10;    if not is_stage_cleared and len(world['entities']) == 1 and world.get('player') in world['entities']:&#10;        # 이전에 몬스터가 1마리 이상 있었는지 확인하는 조건이 필요할 수 있습니다.&#10;        # 여기서는 간단히 몬스터가 없으면 클리어로 간주합니다.&#10;        print(&quot;Stage cleared!&quot;)&#10;        is_stage_cleared = True # 중복 호출 방지&#10;        change_stage(current_stage_index + 1)&#10;&#10;&#10;def draw():&#10;    global camera, victory_fade_image, victory_fade_elapsed, victory_fade_duration&#10;    p2.clear_canvas()&#10;&#10;    # 로딩 중이면 로딩 화면만 그리기&#10;    if is_loading and loading_screen:&#10;        loading_screen.draw()&#10;    else:&#10;        # 일반 게임 화면 그리기&#10;        # 1. FixedBackground 먼저 그리기 (카메라 영향 없음)&#10;        from .background import FixedBackground&#10;        from .equipment import ShieldRangeEffect&#10;&#10;        for o in world['bg']:&#10;            if isinstance(o, FixedBackground):&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        o.draw()  # FixedBackground는 인자 없이 호출&#10;                except Exception as ex:&#10;                    print(f'\033[91m[play_mode] FixedBackground 그리기 오류: {ex}\033[0m')&#10;                    pass&#10;&#10;        # 2. 나머지 객체들은 카메라 좌표 적용하여 그리기&#10;        for layer_name in ['bg', 'walls', 'upper_ground', 'effects_back', 'entities', 'effects_front', 'extra_bg', 'extras']:&#10;            for o in world[layer_name]:&#10;                # FixedBackground는 이미 그렸으므로 스킵&#10;                if isinstance(o, FixedBackground):&#10;                    continue&#10;&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        # ShieldRangeEffect는 특별 처리 (플레이어 위치 기준)&#10;                        if isinstance(o, ShieldRangeEffect):&#10;                            if hasattr(o, 'player') and o.player:&#10;                                if camera is not None:&#10;                                    draw_x, draw_y = camera.apply(o.player.x, o.player.y)&#10;                                else:&#10;                                    draw_x, draw_y = o.player.x, o.player.y&#10;                                o.draw(draw_x, draw_y)&#10;                        # x, y 속성이 있는 객체는 카메라 좌표로 변환하여 그리기&#10;                        elif hasattr(o, 'x') and hasattr(o, 'y'):&#10;                            if camera is not None:&#10;                                draw_x, draw_y = camera.apply(o.x, o.y)&#10;                            else:&#10;                                draw_x, draw_y = o.x, o.y&#10;                            o.draw(draw_x, draw_y)&#10;                        else:&#10;                            # x, y 속성이 없는 객체는 그대로 그리기&#10;                            o.draw()&#10;                except Exception as ex:&#10;                    print(f'\033[91m[play_mode] {layer_name} 레이어의 {o.__class__.__name__} 그리기 오류: {ex}\033[0m')&#10;                    pass&#10;&#10;        # 3. UI와 커서는 카메라 적용하지 않음 (고정 UI)&#10;        for o in world['ui']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[play_mode] UI 레이어의 {o.__class__.__name__} 그리기 오류 : {ex}\033[0m')&#10;                pass&#10;&#10;        for o in world['cursor']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[play_mode] Cursor 레이어의 {o.__class__.__name__} 그리기 오류 : {ex}\033[0m')&#10;                pass&#10;&#10;        # 4. 승리 페이드인 효과 그리기 (기존 화면 위에 오버레이)&#10;        if is_fading_to_victory and victory_fade_image:&#10;            canvas_w = p2.get_canvas_width()&#10;            canvas_h = p2.get_canvas_height()&#10;&#10;            # 페이드인 진행률 계산 (0.0 ~ 1.0)&#10;            fade_progress = min(victory_fade_elapsed / victory_fade_duration, 1.0)&#10;&#10;            # 이미지 투명도 설정 및 그리기&#10;            victory_fade_image.opacify(fade_progress)&#10;            victory_fade_image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)&#10;&#10;    p2.update_canvas()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/state_machine.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/state_machine.py" />
              <option name="originalContent" value="from .event_to_string import event_to_string&#10;import game_framework&#10;from .inventory import InventoryData&#10;&#10;&#10;class StateMachine:&#10;    def __init__(self, start_state, rules):&#10;        self.cur_state = start_state&#10;        self.rules = rules&#10;        self.cur_state.enter(('START', None))&#10;&#10;    def update(self):&#10;        self.cur_state.do()&#10;&#10;    def draw(self, draw_x = None, draw_y = None):&#10;        self.cur_state.draw(draw_x, draw_y)&#10;&#10;    def current_state(self):&#10;        return self.cur_state&#10;&#10;    def set_state(self, state):&#10;        self.cur_state = state&#10;&#10;    def handle_state_event(self, state_event):&#10;        processed_event = False&#10;        for check_event in self.rules[self.cur_state].keys():&#10;            if check_event(state_event):&#10;                next_state = self.rules[self.cur_state][check_event]&#10;&#10;                # 특수 처리: INVENTORY 상태에서 Tab_down이면 prev_state로 복귀&#10;                if next_state is None and hasattr(self.cur_state, 'prev_state') and self.cur_state.prev_state is not None:&#10;                    next_state = self.cur_state.prev_state&#10;&#10;                # 특수 처리: DASH 상태에서 DASH_END이면 return_to_idle에 따라 IDLE 또는 RUN으로 복귀&#10;                if next_state is None and hasattr(self.cur_state, 'return_to_idle'):&#10;                    # Dash의 return_to_idle 플래그 확인&#10;                    if self.cur_state.return_to_idle:&#10;                        # Idle로 복귀&#10;                        next_state = self.cur_state.player.IDLE&#10;                    else:&#10;                        # Run으로 복귀&#10;                        next_state = self.cur_state.player.RUN&#10;&#10;                self.cur_state.exit(state_event)&#10;                next_state.enter(state_event)&#10;&#10;                print(f'{self.cur_state.__class__.__name__}'&#10;                      f' ======{event_to_string(state_event)}======&gt; '&#10;                      f'{next_state.__class__.__name__}')&#10;                self.cur_state = next_state&#10;                processed_event = True&#10;                return&#10;        if not processed_event:&#10;            event_str = event_to_string(state_event)&#10;            es = event_str.upper() if isinstance(event_str, str) else ''&#10;            is_mouse_motion = ('MOUSE' in es and 'MOTION' in es) or ('MOUSEMOTION' in es)&#10;            if not is_mouse_motion:&#10;                # print('Refused Event:', self.cur_state.__class__.__name__, 'Input : ', event_to_string(state_event))&#10;                pass&#10;" />
              <option name="updatedContent" value="from .event_to_string import event_to_string&#13;&#10;import game_framework&#13;&#10;from .inventory import InventoryData&#13;&#10;&#13;&#10;&#13;&#10;class StateMachine:&#13;&#10;    def __init__(self, start_state, rules):&#13;&#10;        self.cur_state = start_state&#13;&#10;        self.rules = rules&#13;&#10;        self.cur_state.enter(('START', None))&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        self.cur_state.do()&#13;&#10;&#13;&#10;    def draw(self, draw_x = None, draw_y = None):&#13;&#10;        self.cur_state.draw(draw_x, draw_y)&#13;&#10;&#13;&#10;    def current_state(self):&#13;&#10;        return self.cur_state&#13;&#10;&#13;&#10;    def set_state(self, state):&#13;&#10;        self.cur_state = state&#13;&#10;&#13;&#10;    def handle_state_event(self, state_event):&#13;&#10;        processed_event = False&#13;&#10;        for check_event in self.rules[self.cur_state].keys():&#13;&#10;            if check_event(state_event):&#13;&#10;                next_state = self.rules[self.cur_state][check_event]&#13;&#10;&#13;&#10;                # 특수 처리: INVENTORY 상태에서 Tab_down이면 prev_state로 복귀&#13;&#10;                if next_state is None and hasattr(self.cur_state, 'prev_state') and self.cur_state.prev_state is not None:&#13;&#10;                    next_state = self.cur_state.prev_state&#13;&#10;&#13;&#10;                # 특수 처리: DASH 상태에서 DASH_END이면 return_to_idle에 따라 IDLE 또는 RUN으로 복귀&#13;&#10;                if next_state is None and hasattr(self.cur_state, 'return_to_idle'):&#13;&#10;                    # Dash의 return_to_idle 플래그 확인&#13;&#10;                    if self.cur_state.return_to_idle:&#13;&#10;                        # Idle로 복귀&#13;&#10;                        next_state = self.cur_state.player.IDLE&#13;&#10;                    else:&#13;&#10;                        # Run으로 복귀&#13;&#10;                        next_state = self.cur_state.player.RUN&#13;&#10;&#13;&#10;                self.cur_state.exit(state_event)&#13;&#10;                next_state.enter(state_event)&#13;&#10;&#13;&#10;                print(f'{self.cur_state.__class__.__name__}'&#13;&#10;                      f' ======{event_to_string(state_event)}======&gt; '&#13;&#10;                      f'{next_state.__class__.__name__}')&#13;&#10;                self.cur_state = next_state&#13;&#10;                processed_event = True&#13;&#10;                return&#13;&#10;        if not processed_event:&#13;&#10;            event_str = event_to_string(state_event)&#13;&#10;            es = event_str.upper() if isinstance(event_str, str) else ''&#13;&#10;            is_mouse_motion = ('MOUSE' in es and 'MOTION' in es) or ('MOUSEMOTION' in es)&#13;&#10;            if not is_mouse_motion:&#13;&#10;                # print('Refused Event:', self.cur_state.__class__.__name__, 'Input : ', event_to_string(state_event))&#13;&#10;                pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/vfx.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/vfx.py" />
              <option name="originalContent" value="import os&#10;from pico2d import load_image&#10;import pico2d as p2&#10;import game_framework&#10;&#10;class AnimatedVFX:&#10;    &quot;&quot;&quot;간단한 프레임 애니메이션 VFX 엔티티&#10;    - folder: 폴더 경로 (예: resources/Texture_organize/VFX/Potion_Common)&#10;    - prefix: 파일명 접두사 (예: 'Potion_Back_FX')&#10;    - frames: 프레임 수&#10;    - frame_time: 각 프레임 지속 시간&#10;    - x,y: 위치&#10;    - scale: 크기 배율&#10;    &quot;&quot;&quot;&#10;    def __init__(self, folder, prefix, frames, frame_time, x, y, scale=1.0, life=None):&#10;        self.folder = folder&#10;        self.prefix = prefix&#10;        self.frames_count = frames&#10;        self.frame_time = frame_time&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;        self.images = []&#10;        self.frame = 0&#10;        self.acc = 0.0&#10;        self.life = life if life is not None else frames * frame_time&#10;        self._load_frames()&#10;&#10;    def _load_frames(self):&#10;        self.images = []&#10;        for i in range(self.frames_count):&#10;            name1 = f&quot;{self.prefix}{i:02d}.png&quot;&#10;            path = os.path.join(self.folder, name1)&#10;            try:&#10;                img = load_image(path)&#10;                self.images.append(img)&#10;            except Exception:&#10;                # 로드 실패하면 다음 프레임도 시도하지만 중단&#10;                print(f'\033[91m[AnimatedVFX] Failed to load frame: {path}\033[0m')&#10;                break&#10;        # fallback: 만약 아무 프레임도 로드되지 않으면 try single file without index&#10;        if not self.images:&#10;            single = os.path.join(self.folder, f&quot;{self.prefix}.png&quot;)&#10;            try:&#10;                img = load_image(single)&#10;                self.images.append(img)&#10;            except Exception:&#10;                print(f'\033[91m[AnimatedVFX] Failed to load single image: {single}\033[0m')&#10;        # adjust frames_count to actual loaded&#10;        self.frames_count = len(self.images)&#10;&#10;    def update(self, dt=None):&#10;        # dt None이면 framework에서 값을 가져옴 (main.update_world가 인자로 주지 않으므로)&#10;        if dt is None:&#10;            dt = game_framework.get_delta_time()&#10;        if self.life &lt;= 0:&#10;            return False&#10;        self.life -= dt&#10;        if self.frames_count == 0:&#10;            return self.life &gt; 0&#10;        self.acc += dt&#10;        while self.acc &gt;= self.frame_time and self.frame &lt; self.frames_count - 1:&#10;            self.acc -= self.frame_time&#10;            self.frame += 1&#10;        return self.life &gt; 0&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if self.images and 0 &lt;= self.frame &lt; len(self.images):&#10;            img = self.images[self.frame]&#10;            img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;&#10;&#10;class GuardFX:&#10;    &quot;&quot;&quot;방패 방어 성공 시 표시되는 이펙트&quot;&quot;&quot;&#10;    images = None&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if GuardFX.images is None:&#10;            GuardFX.images = []&#10;            try:&#10;                for i in range(5):  # GuardFX1_0.png ~ GuardFX1_4.png&#10;                    img = p2.load_image(f'resources/Texture_organize/Weapon/SwordANDShield/Guard_FX/GuardFX1_{i}.png')&#10;                    GuardFX.images.append(img)&#10;                print(f&quot;[GuardFX] Loaded {len(GuardFX.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[GuardFX] Failed to load images: {e}\033[0m&quot;)&#10;                GuardFX.images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 20  # 빠르게 재생 (20 FPS)&#10;        self.finished = False&#10;&#10;        print(f&quot;[GuardFX] 생성됨 at world({int(x)}, {int(y)}), 총 프레임: {len(GuardFX.images) if GuardFX.images else 0}&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#10;        if self.finished:&#10;            return False&#10;&#10;        dt = game_framework.get_delta_time()&#10;        self.animation_time += dt&#10;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            self.frame += 1&#10;            self.animation_time = 0&#10;&#10;            # 애니메이션이 끝나면 제거&#10;            if GuardFX.images and self.frame &gt;= len(GuardFX.images):&#10;                self.finished = True&#10;                return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        이펙트 그리기&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if not GuardFX.images or len(GuardFX.images) == 0:&#10;            print(&quot;[GuardFX] 이미지가 없음!&quot;)&#10;            return&#10;&#10;        if self.finished:&#10;            return&#10;&#10;        frame_idx = min(self.frame, len(GuardFX.images) - 1)&#10;        try:&#10;            # 카메라가 적용된 좌표(draw_x, draw_y)를 사용하여 그리기&#10;            GuardFX.images[frame_idx].draw(&#10;                draw_x, draw_y,&#10;                GuardFX.images[frame_idx].w * self.scale,&#10;                GuardFX.images[frame_idx].h * self.scale&#10;            )&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[GuardFX] draw 에러: {e}\033[0m&quot;)&#10;&#10;&#10;class ShieldCrashEffect:&#10;    &quot;&quot;&quot;방패가 깨질 때 표시되는 이펙트 (Crash_Blue)&quot;&quot;&quot;&#10;    front_images = None&#10;    back_images = None&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if ShieldCrashEffect.front_images is None:&#10;            ShieldCrashEffect.front_images = []&#10;            try:&#10;                for i in range(11):  # Crash_Blue_Front_FX00 ~ FX10 (0~10)&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Front_FX0{i}.png')&#10;                    ShieldCrashEffect.front_images.append(img)&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.front_images)} front images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load front images: {e}\033[0m&quot;)&#10;                ShieldCrashEffect.front_images = []&#10;&#10;        if ShieldCrashEffect.back_images is None:&#10;            ShieldCrashEffect.back_images = []&#10;            try:&#10;                for i in range(3, 9):  # Crash_Blue_Back_FX03 ~ FX08 (3~8)&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Back_FX0{i}.png')&#10;                    ShieldCrashEffect.back_images.append(img)&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.back_images)} back images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load back images: {e}\033[0m&quot;)&#10;                ShieldCrashEffect.back_images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 20  # 빠른 애니메이션 (20 FPS)&#10;        self.finished = False&#10;&#10;        print(f&quot;[ShieldCrashEffect] 생성됨 at world({int(x)}, {int(y)})&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#10;        if self.finished:&#10;            return False&#10;&#10;        dt = game_framework.get_delta_time()&#10;        self.animation_time += dt&#10;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            self.frame += 1&#10;            self.animation_time = 0&#10;&#10;            # Front 이미지 기준으로 애니메이션이 끝나면 제거&#10;            if ShieldCrashEffect.front_images and self.frame &gt;= len(ShieldCrashEffect.front_images):&#10;                self.finished = True&#10;                return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        이펙트 그리기 (Front와 Back을 레이어링)&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if self.finished:&#10;            return&#10;&#10;        # Front 이미지 그리기 (0~10 프레임)&#10;        if ShieldCrashEffect.front_images and self.frame &lt; len(ShieldCrashEffect.front_images):&#10;            try:&#10;                ShieldCrashEffect.front_images[self.frame].draw(&#10;                    draw_x, draw_y,&#10;                    ShieldCrashEffect.front_images[self.frame].w * self.scale,&#10;                    ShieldCrashEffect.front_images[self.frame].h * self.scale&#10;                )&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] front draw 에러: {e}\033[0m&quot;)&#10;&#10;        # Back 이미지 그리기 (Front 프레임 3부터 시작)&#10;        # Front frame 3 = Back index 0 (Back_FX03)&#10;        # Front frame 4 = Back index 1 (Back_FX04) ...&#10;        if self.frame &gt;= 3:&#10;            back_index = self.frame - 3&#10;            if ShieldCrashEffect.back_images and back_index &lt; len(ShieldCrashEffect.back_images):&#10;                try:&#10;                    ShieldCrashEffect.back_images[back_index].draw(&#10;                        draw_x, draw_y,&#10;                        ShieldCrashEffect.back_images[back_index].w * self.scale,&#10;                        ShieldCrashEffect.back_images[back_index].h * self.scale&#10;                    )&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[ShieldCrashEffect] back draw 에러: {e}\033[0m&quot;)&#10;&#10;&#10;class DashTrailEffect:&#10;    &quot;&quot;&quot;대시 시 남는 잔상 이펙트 - 0.3초간 알파값이 1에서 0으로 페이드아웃&quot;&quot;&quot;&#10;    trail_image = None  # 클래스 변수로 이미지 한 번만 로드&#10;&#10;    def __init__(self, x, y, face_dir, scale=3.0):&#10;        &quot;&quot;&quot;&#10;        대시 잔상 이펙트 생성&#10;        &#10;        Args:&#10;            x: 월드 X 좌표&#10;            y: 월드 Y 좌표&#10;            face_dir: 플레이어의 방향 (1: 오른쪽, -1: 왼쪽)&#10;            scale: 이미지 크기 배율&#10;        &quot;&quot;&quot;&#10;        self.x = x&#10;        self.y = y&#10;        self.face_dir = face_dir&#10;        self.scale = scale&#10;        &#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if DashTrailEffect.trail_image is None:&#10;            try:&#10;                img_path = os.path.join('resources', 'Texture_organize', 'Player_character', 'PlayerDashTrailFx0.png')&#10;                DashTrailEffect.trail_image = load_image(img_path)&#10;                print(f&quot;[DashTrailEffect] 이미지 로드 성공: {img_path}&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[DashTrailEffect] 이미지 로드 실패: {e}\033[0m&quot;)&#10;                DashTrailEffect.trail_image = None&#10;        &#10;        # 페이드아웃 설정&#10;        self.fade_duration = 0.3  # 0.3초간 페이드아웃&#10;        self.elapsed_time = 0.0&#10;        self.alpha = 1.0  # 초기 알파값 1.0 (완전 불투명)&#10;    &#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        이펙트 업데이트 - 알파값을 시간에 따라 감소&#10;        &#10;        Returns:&#10;            bool: True면 계속 유지, False면 제거&#10;        &quot;&quot;&quot;&#10;        dt = game_framework.get_delta_time()&#10;        self.elapsed_time += dt&#10;        &#10;        # 알파값 계산 (1.0 -&gt; 0.0으로 선형 감소)&#10;        if self.elapsed_time &lt; self.fade_duration:&#10;            self.alpha = 1.0 - (self.elapsed_time / self.fade_duration)&#10;        else:&#10;            self.alpha = 0.0&#10;            return False  # 알파값이 0이 되면 제거&#10;        &#10;        return True&#10;    &#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        잔상 이펙트 그리기&#10;        &#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if not DashTrailEffect.trail_image:&#10;            return&#10;        &#10;        # 알파값이 0이면 그리지 않음&#10;        if self.alpha &lt;= 0:&#10;            return&#10;        &#10;        # 방향에 따라 flip 설정&#10;        flip = '' if self.face_dir == 1 else 'h'&#10;        &#10;        # 알파값 설정하여 그리기&#10;        DashTrailEffect.trail_image.opacify(self.alpha)&#10;        DashTrailEffect.trail_image.clip_composite_draw(&#10;            0, 0, &#10;            DashTrailEffect.trail_image.w, &#10;            DashTrailEffect.trail_image.h,&#10;            0, flip,&#10;            draw_x, draw_y,&#10;            DashTrailEffect.trail_image.w * self.scale,&#10;            DashTrailEffect.trail_image.h * self.scale&#10;        )&#10;        # 알파값 복원 (다른 이미지에 영향 주지 않도록)&#10;        DashTrailEffect.trail_image.opacify(1.0)" />
              <option name="updatedContent" value="import os&#13;&#10;from pico2d import load_image&#13;&#10;import pico2d as p2&#13;&#10;import game_framework&#13;&#10;&#13;&#10;class AnimatedVFX:&#13;&#10;    &quot;&quot;&quot;간단한 프레임 애니메이션 VFX 엔티티&#13;&#10;    - folder: 폴더 경로 (예: resources/Texture_organize/VFX/Potion_Common)&#13;&#10;    - prefix: 파일명 접두사 (예: 'Potion_Back_FX')&#13;&#10;    - frames: 프레임 수&#13;&#10;    - frame_time: 각 프레임 지속 시간&#13;&#10;    - x,y: 위치&#13;&#10;    - scale: 크기 배율&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    def __init__(self, folder, prefix, frames, frame_time, x, y, scale=1.0, life=None):&#13;&#10;        self.folder = folder&#13;&#10;        self.prefix = prefix&#13;&#10;        self.frames_count = frames&#13;&#10;        self.frame_time = frame_time&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;        self.images = []&#13;&#10;        self.frame = 0&#13;&#10;        self.acc = 0.0&#13;&#10;        self.life = life if life is not None else frames * frame_time&#13;&#10;        self._load_frames()&#13;&#10;&#13;&#10;    def _load_frames(self):&#13;&#10;        self.images = []&#13;&#10;        for i in range(self.frames_count):&#13;&#10;            name1 = f&quot;{self.prefix}{i:02d}.png&quot;&#13;&#10;            path = os.path.join(self.folder, name1)&#13;&#10;            try:&#13;&#10;                img = load_image(path)&#13;&#10;                self.images.append(img)&#13;&#10;            except Exception:&#13;&#10;                # 로드 실패하면 다음 프레임도 시도하지만 중단&#13;&#10;                print(f'\033[91m[AnimatedVFX] Failed to load frame: {path}\033[0m')&#13;&#10;                break&#13;&#10;        # fallback: 만약 아무 프레임도 로드되지 않으면 try single file without index&#13;&#10;        if not self.images:&#13;&#10;            single = os.path.join(self.folder, f&quot;{self.prefix}.png&quot;)&#13;&#10;            try:&#13;&#10;                img = load_image(single)&#13;&#10;                self.images.append(img)&#13;&#10;            except Exception:&#13;&#10;                print(f'\033[91m[AnimatedVFX] Failed to load single image: {single}\033[0m')&#13;&#10;        # adjust frames_count to actual loaded&#13;&#10;        self.frames_count = len(self.images)&#13;&#10;&#13;&#10;    def update(self, dt=None):&#13;&#10;        # dt None이면 framework에서 값을 가져옴 (main.update_world가 인자로 주지 않으므로)&#13;&#10;        if dt is None:&#13;&#10;            dt = game_framework.get_delta_time()&#13;&#10;        if self.life &lt;= 0:&#13;&#10;            return False&#13;&#10;        self.life -= dt&#13;&#10;        if self.frames_count == 0:&#13;&#10;            return self.life &gt; 0&#13;&#10;        self.acc += dt&#13;&#10;        while self.acc &gt;= self.frame_time and self.frame &lt; self.frames_count - 1:&#13;&#10;            self.acc -= self.frame_time&#13;&#10;            self.frame += 1&#13;&#10;        return self.life &gt; 0&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        if self.images and 0 &lt;= self.frame &lt; len(self.images):&#13;&#10;            img = self.images[self.frame]&#13;&#10;            img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#13;&#10;&#13;&#10;&#13;&#10;class GuardFX:&#13;&#10;    &quot;&quot;&quot;방패 방어 성공 시 표시되는 이펙트&quot;&quot;&quot;&#13;&#10;    images = None&#13;&#10;&#13;&#10;    def __init__(self, x, y, scale=3.0):&#13;&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;&#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if GuardFX.images is None:&#13;&#10;            GuardFX.images = []&#13;&#10;            try:&#13;&#10;                for i in range(5):  # GuardFX1_0.png ~ GuardFX1_4.png&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/Weapon/SwordANDShield/Guard_FX/GuardFX1_{i}.png')&#13;&#10;                    GuardFX.images.append(img)&#13;&#10;                print(f&quot;[GuardFX] Loaded {len(GuardFX.images)} images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[GuardFX] Failed to load images: {e}\033[0m&quot;)&#13;&#10;                GuardFX.images = []&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.animation_time = 0&#13;&#10;        self.animation_speed = 20  # 빠르게 재생 (20 FPS)&#13;&#10;        self.finished = False&#13;&#10;&#13;&#10;        print(f&quot;[GuardFX] 생성됨 at world({int(x)}, {int(y)}), 총 프레임: {len(GuardFX.images) if GuardFX.images else 0}&quot;)&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return False&#13;&#10;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.animation_time += dt&#13;&#10;&#13;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;            self.frame += 1&#13;&#10;            self.animation_time = 0&#13;&#10;&#13;&#10;            # 애니메이션이 끝나면 제거&#13;&#10;            if GuardFX.images and self.frame &gt;= len(GuardFX.images):&#13;&#10;                self.finished = True&#13;&#10;                return False&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 그리기&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not GuardFX.images or len(GuardFX.images) == 0:&#13;&#10;            print(&quot;[GuardFX] 이미지가 없음!&quot;)&#13;&#10;            return&#13;&#10;&#13;&#10;        if self.finished:&#13;&#10;            return&#13;&#10;&#13;&#10;        frame_idx = min(self.frame, len(GuardFX.images) - 1)&#13;&#10;        try:&#13;&#10;            # 카메라가 적용된 좌표(draw_x, draw_y)를 사용하여 그리기&#13;&#10;            GuardFX.images[frame_idx].draw(&#13;&#10;                draw_x, draw_y,&#13;&#10;                GuardFX.images[frame_idx].w * self.scale,&#13;&#10;                GuardFX.images[frame_idx].h * self.scale&#13;&#10;            )&#13;&#10;        except Exception as e:&#13;&#10;            print(f&quot;\033[91m[GuardFX] draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;class ShieldCrashEffect:&#13;&#10;    &quot;&quot;&quot;방패가 깨질 때 표시되는 이펙트 (Crash_Blue)&quot;&quot;&quot;&#13;&#10;    front_images = None&#13;&#10;    back_images = None&#13;&#10;&#13;&#10;    def __init__(self, x, y, scale=3.0):&#13;&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;&#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if ShieldCrashEffect.front_images is None:&#13;&#10;            ShieldCrashEffect.front_images = []&#13;&#10;            try:&#13;&#10;                for i in range(11):  # Crash_Blue_Front_FX00 ~ FX10 (0~10)&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Front_FX0{i}.png')&#13;&#10;                    ShieldCrashEffect.front_images.append(img)&#13;&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.front_images)} front images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load front images: {e}\033[0m&quot;)&#13;&#10;                ShieldCrashEffect.front_images = []&#13;&#10;&#13;&#10;        if ShieldCrashEffect.back_images is None:&#13;&#10;            ShieldCrashEffect.back_images = []&#13;&#10;            try:&#13;&#10;                for i in range(3, 9):  # Crash_Blue_Back_FX03 ~ FX08 (3~8)&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Back_FX0{i}.png')&#13;&#10;                    ShieldCrashEffect.back_images.append(img)&#13;&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.back_images)} back images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load back images: {e}\033[0m&quot;)&#13;&#10;                ShieldCrashEffect.back_images = []&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.animation_time = 0&#13;&#10;        self.animation_speed = 20  # 빠른 애니메이션 (20 FPS)&#13;&#10;        self.finished = False&#13;&#10;&#13;&#10;        print(f&quot;[ShieldCrashEffect] 생성됨 at world({int(x)}, {int(y)})&quot;)&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return False&#13;&#10;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.animation_time += dt&#13;&#10;&#13;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;            self.frame += 1&#13;&#10;            self.animation_time = 0&#13;&#10;&#13;&#10;            # Front 이미지 기준으로 애니메이션이 끝나면 제거&#13;&#10;            if ShieldCrashEffect.front_images and self.frame &gt;= len(ShieldCrashEffect.front_images):&#13;&#10;                self.finished = True&#13;&#10;                return False&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 그리기 (Front와 Back을 레이어링)&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return&#13;&#10;&#13;&#10;        # Front 이미지 그리기 (0~10 프레임)&#13;&#10;        if ShieldCrashEffect.front_images and self.frame &lt; len(ShieldCrashEffect.front_images):&#13;&#10;            try:&#13;&#10;                ShieldCrashEffect.front_images[self.frame].draw(&#13;&#10;                    draw_x, draw_y,&#13;&#10;                    ShieldCrashEffect.front_images[self.frame].w * self.scale,&#13;&#10;                    ShieldCrashEffect.front_images[self.frame].h * self.scale&#13;&#10;                )&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] front draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;        # Back 이미지 그리기 (Front 프레임 3부터 시작)&#13;&#10;        # Front frame 3 = Back index 0 (Back_FX03)&#13;&#10;        # Front frame 4 = Back index 1 (Back_FX04) ...&#13;&#10;        if self.frame &gt;= 3:&#13;&#10;            back_index = self.frame - 3&#13;&#10;            if ShieldCrashEffect.back_images and back_index &lt; len(ShieldCrashEffect.back_images):&#13;&#10;                try:&#13;&#10;                    ShieldCrashEffect.back_images[back_index].draw(&#13;&#10;                        draw_x, draw_y,&#13;&#10;                        ShieldCrashEffect.back_images[back_index].w * self.scale,&#13;&#10;                        ShieldCrashEffect.back_images[back_index].h * self.scale&#13;&#10;                    )&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91m[ShieldCrashEffect] back draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;class DashTrailEffect:&#13;&#10;    &quot;&quot;&quot;대시 시 남는 잔상 이펙트 - 0.3초간 알파값이 1에서 0으로 페이드아웃&quot;&quot;&quot;&#13;&#10;    trail_image = None  # 클래스 변수로 이미지 한 번만 로드&#13;&#10;&#13;&#10;    def __init__(self, x, y, face_dir, scale=3.0):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        대시 잔상 이펙트 생성&#13;&#10;        &#13;&#10;        Args:&#13;&#10;            x: 월드 X 좌표&#13;&#10;            y: 월드 Y 좌표&#13;&#10;            face_dir: 플레이어의 방향 (1: 오른쪽, -1: 왼쪽)&#13;&#10;            scale: 이미지 크기 배율&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.face_dir = face_dir&#13;&#10;        self.scale = scale&#13;&#10;        &#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if DashTrailEffect.trail_image is None:&#13;&#10;            try:&#13;&#10;                img_path = os.path.join('resources', 'Texture_organize', 'Player_character', 'PlayerDashTrailFx0.png')&#13;&#10;                DashTrailEffect.trail_image = load_image(img_path)&#13;&#10;                print(f&quot;[DashTrailEffect] 이미지 로드 성공: {img_path}&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[DashTrailEffect] 이미지 로드 실패: {e}\033[0m&quot;)&#13;&#10;                DashTrailEffect.trail_image = None&#13;&#10;        &#13;&#10;        # 페이드아웃 설정&#13;&#10;        self.fade_duration = 0.3  # 0.3초간 페이드아웃&#13;&#10;        self.elapsed_time = 0.0&#13;&#10;        self.alpha = 1.0  # 초기 알파값 1.0 (완전 불투명)&#13;&#10;    &#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 업데이트 - 알파값을 시간에 따라 감소&#13;&#10;        &#13;&#10;        Returns:&#13;&#10;            bool: True면 계속 유지, False면 제거&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.elapsed_time += dt&#13;&#10;        &#13;&#10;        # 알파값 계산 (1.0 -&gt; 0.0으로 선형 감소)&#13;&#10;        if self.elapsed_time &lt; self.fade_duration:&#13;&#10;            self.alpha = 1.0 - (self.elapsed_time / self.fade_duration)&#13;&#10;        else:&#13;&#10;            self.alpha = 0.0&#13;&#10;            return False  # 알파값이 0이 되면 제거&#13;&#10;        &#13;&#10;        return True&#13;&#10;    &#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        잔상 이펙트 그리기&#13;&#10;        &#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not DashTrailEffect.trail_image:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # 알파값이 0이면 그리지 않음&#13;&#10;        if self.alpha &lt;= 0:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # 방향에 따라 flip 설정&#13;&#10;        flip = '' if self.face_dir == 1 else 'h'&#13;&#10;        &#13;&#10;        # 알파값 설정하여 그리기&#13;&#10;        DashTrailEffect.trail_image.opacify(self.alpha)&#13;&#10;        DashTrailEffect.trail_image.clip_composite_draw(&#13;&#10;            0, 0, &#13;&#10;            DashTrailEffect.trail_image.w, &#13;&#10;            DashTrailEffect.trail_image.h,&#13;&#10;            0, flip,&#13;&#10;            draw_x, draw_y,&#13;&#10;            DashTrailEffect.trail_image.w * self.scale,&#13;&#10;            DashTrailEffect.trail_image.h * self.scale&#13;&#10;        )&#13;&#10;        # 알파값 복원 (다른 이미지에 영향 주지 않도록)&#13;&#10;        DashTrailEffect.trail_image.opacify(1.0)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>