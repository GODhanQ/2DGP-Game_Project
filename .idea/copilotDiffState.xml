<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game_logic/cursor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/cursor.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False&#10;" />
              <option name="updatedContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/state_machine.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/state_machine.py" />
              <option name="originalContent" value="from .event_to_string import event_to_string&#10;import game_framework&#10;from .inventory import InventoryData&#10;&#10;&#10;class StateMachine:&#10;    def __init__(self, start_state, rules):&#10;        self.cur_state = start_state&#10;        self.rules = rules&#10;        self.cur_state.enter(('START', None))&#10;&#10;    def update(self):&#10;        self.cur_state.do()&#10;&#10;    def draw(self, draw_x = None, draw_y = None):&#10;        self.cur_state.draw(draw_x, draw_y)&#10;&#10;    def current_state(self):&#10;        return self.cur_state&#10;&#10;    def set_state(self, state):&#10;        self.cur_state = state&#10;&#10;    def handle_state_event(self, state_event):&#10;        processed_event = False&#10;        for check_event in self.rules[self.cur_state].keys():&#10;            if check_event(state_event):&#10;                next_state = self.rules[self.cur_state][check_event]&#10;&#10;                # 특수 처리: INVENTORY 상태에서 Tab_down이면 prev_state로 복귀&#10;                if next_state is None and hasattr(self.cur_state, 'prev_state') and self.cur_state.prev_state is not None:&#10;                    next_state = self.cur_state.prev_state&#10;&#10;                # 특수 처리: DASH 상태에서 DASH_END이면 return_to_idle에 따라 IDLE 또는 RUN으로 복귀&#10;                if next_state is None and hasattr(self.cur_state, 'return_to_idle'):&#10;                    # Dash의 return_to_idle 플래그 확인&#10;                    if self.cur_state.return_to_idle:&#10;                        # Idle로 복귀&#10;                        next_state = self.cur_state.player.IDLE&#10;                    else:&#10;                        # Run으로 복귀&#10;                        next_state = self.cur_state.player.RUN&#10;&#10;                self.cur_state.exit(state_event)&#10;                next_state.enter(state_event)&#10;&#10;                print(f'{self.cur_state.__class__.__name__}'&#10;                      f' ======{event_to_string(state_event)}======&gt; '&#10;                      f'{next_state.__class__.__name__}')&#10;                self.cur_state = next_state&#10;                processed_event = True&#10;                return&#10;        if not processed_event:&#10;            event_str = event_to_string(state_event)&#10;            es = event_str.upper() if isinstance(event_str, str) else ''&#10;            is_mouse_motion = ('MOUSE' in es and 'MOTION' in es) or ('MOUSEMOTION' in es)&#10;            if not is_mouse_motion:&#10;                # print('Refused Event:', self.cur_state.__class__.__name__, 'Input : ', event_to_string(state_event))&#10;                pass&#10;" />
              <option name="updatedContent" value="from .event_to_string import event_to_string&#13;&#10;import game_framework&#13;&#10;from .inventory import InventoryData&#13;&#10;&#13;&#10;&#13;&#10;class StateMachine:&#13;&#10;    def __init__(self, start_state, rules):&#13;&#10;        self.cur_state = start_state&#13;&#10;        self.rules = rules&#13;&#10;        self.cur_state.enter(('START', None))&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        self.cur_state.do()&#13;&#10;&#13;&#10;    def draw(self, draw_x = None, draw_y = None):&#13;&#10;        self.cur_state.draw(draw_x, draw_y)&#13;&#10;&#13;&#10;    def current_state(self):&#13;&#10;        return self.cur_state&#13;&#10;&#13;&#10;    def set_state(self, state):&#13;&#10;        self.cur_state = state&#13;&#10;&#13;&#10;    def handle_state_event(self, state_event):&#13;&#10;        processed_event = False&#13;&#10;        for check_event in self.rules[self.cur_state].keys():&#13;&#10;            if check_event(state_event):&#13;&#10;                next_state = self.rules[self.cur_state][check_event]&#13;&#10;&#13;&#10;                # 특수 처리: INVENTORY 상태에서 Tab_down이면 prev_state로 복귀&#13;&#10;                if next_state is None and hasattr(self.cur_state, 'prev_state') and self.cur_state.prev_state is not None:&#13;&#10;                    next_state = self.cur_state.prev_state&#13;&#10;&#13;&#10;                # 특수 처리: DASH 상태에서 DASH_END이면 return_to_idle에 따라 IDLE 또는 RUN으로 복귀&#13;&#10;                if next_state is None and hasattr(self.cur_state, 'return_to_idle'):&#13;&#10;                    # Dash의 return_to_idle 플래그 확인&#13;&#10;                    if self.cur_state.return_to_idle:&#13;&#10;                        # Idle로 복귀&#13;&#10;                        next_state = self.cur_state.player.IDLE&#13;&#10;                    else:&#13;&#10;                        # Run으로 복귀&#13;&#10;                        next_state = self.cur_state.player.RUN&#13;&#10;&#13;&#10;                self.cur_state.exit(state_event)&#13;&#10;                next_state.enter(state_event)&#13;&#10;&#13;&#10;                print(f'{self.cur_state.__class__.__name__}'&#13;&#10;                      f' ======{event_to_string(state_event)}======&gt; '&#13;&#10;                      f'{next_state.__class__.__name__}')&#13;&#10;                self.cur_state = next_state&#13;&#10;                processed_event = True&#13;&#10;                return&#13;&#10;        if not processed_event:&#13;&#10;            event_str = event_to_string(state_event)&#13;&#10;            es = event_str.upper() if isinstance(event_str, str) else ''&#13;&#10;            is_mouse_motion = ('MOUSE' in es and 'MOTION' in es) or ('MOUSEMOTION' in es)&#13;&#10;            if not is_mouse_motion:&#13;&#10;                # print('Refused Event:', self.cur_state.__class__.__name__, 'Input : ', event_to_string(state_event))&#13;&#10;                pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/vfx.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/vfx.py" />
              <option name="originalContent" value="import os&#10;from pico2d import load_image&#10;import pico2d as p2&#10;import game_framework&#10;&#10;class AnimatedVFX:&#10;    &quot;&quot;&quot;간단한 프레임 애니메이션 VFX 엔티티&#10;    - folder: 폴더 경로 (예: resources/Texture_organize/VFX/Potion_Common)&#10;    - prefix: 파일명 접두사 (예: 'Potion_Back_FX')&#10;    - frames: 프레임 수&#10;    - frame_time: 각 프레임 지속 시간&#10;    - x,y: 위치&#10;    - scale: 크기 배율&#10;    &quot;&quot;&quot;&#10;    def __init__(self, folder, prefix, frames, frame_time, x, y, scale=1.0, life=None):&#10;        self.folder = folder&#10;        self.prefix = prefix&#10;        self.frames_count = frames&#10;        self.frame_time = frame_time&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;        self.images = []&#10;        self.frame = 0&#10;        self.acc = 0.0&#10;        self.life = life if life is not None else frames * frame_time&#10;        self._load_frames()&#10;&#10;    def _load_frames(self):&#10;        self.images = []&#10;        for i in range(self.frames_count):&#10;            name1 = f&quot;{self.prefix}{i:02d}.png&quot;&#10;            path = os.path.join(self.folder, name1)&#10;            try:&#10;                img = load_image(path)&#10;                self.images.append(img)&#10;            except Exception:&#10;                # 로드 실패하면 다음 프레임도 시도하지만 중단&#10;                print(f'\033[91m[AnimatedVFX] Failed to load frame: {path}\033[0m')&#10;                break&#10;        # fallback: 만약 아무 프레임도 로드되지 않으면 try single file without index&#10;        if not self.images:&#10;            single = os.path.join(self.folder, f&quot;{self.prefix}.png&quot;)&#10;            try:&#10;                img = load_image(single)&#10;                self.images.append(img)&#10;            except Exception:&#10;                print(f'\033[91m[AnimatedVFX] Failed to load single image: {single}\033[0m')&#10;        # adjust frames_count to actual loaded&#10;        self.frames_count = len(self.images)&#10;&#10;    def update(self, dt=None):&#10;        # dt None이면 framework에서 값을 가져옴 (main.update_world가 인자로 주지 않으므로)&#10;        if dt is None:&#10;            dt = game_framework.get_delta_time()&#10;        if self.life &lt;= 0:&#10;            return False&#10;        self.life -= dt&#10;        if self.frames_count == 0:&#10;            return self.life &gt; 0&#10;        self.acc += dt&#10;        while self.acc &gt;= self.frame_time and self.frame &lt; self.frames_count - 1:&#10;            self.acc -= self.frame_time&#10;            self.frame += 1&#10;        return self.life &gt; 0&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if self.images and 0 &lt;= self.frame &lt; len(self.images):&#10;            img = self.images[self.frame]&#10;            img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;&#10;&#10;class GuardFX:&#10;    &quot;&quot;&quot;방패 방어 성공 시 표시되는 이펙트&quot;&quot;&quot;&#10;    images = None&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if GuardFX.images is None:&#10;            GuardFX.images = []&#10;            try:&#10;                for i in range(5):  # GuardFX1_0.png ~ GuardFX1_4.png&#10;                    img = p2.load_image(f'resources/Texture_organize/Weapon/SwordANDShield/Guard_FX/GuardFX1_{i}.png')&#10;                    GuardFX.images.append(img)&#10;                print(f&quot;[GuardFX] Loaded {len(GuardFX.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[GuardFX] Failed to load images: {e}\033[0m&quot;)&#10;                GuardFX.images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 20  # 빠르게 재생 (20 FPS)&#10;        self.finished = False&#10;&#10;        print(f&quot;[GuardFX] 생성됨 at world({int(x)}, {int(y)}), 총 프레임: {len(GuardFX.images) if GuardFX.images else 0}&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#10;        if self.finished:&#10;            return False&#10;&#10;        dt = game_framework.get_delta_time()&#10;        self.animation_time += dt&#10;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            self.frame += 1&#10;            self.animation_time = 0&#10;&#10;            # 애니메이션이 끝나면 제거&#10;            if GuardFX.images and self.frame &gt;= len(GuardFX.images):&#10;                self.finished = True&#10;                return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        이펙트 그리기&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if not GuardFX.images or len(GuardFX.images) == 0:&#10;            print(&quot;[GuardFX] 이미지가 없음!&quot;)&#10;            return&#10;&#10;        if self.finished:&#10;            return&#10;&#10;        frame_idx = min(self.frame, len(GuardFX.images) - 1)&#10;        try:&#10;            # 카메라가 적용된 좌표(draw_x, draw_y)를 사용하여 그리기&#10;            GuardFX.images[frame_idx].draw(&#10;                draw_x, draw_y,&#10;                GuardFX.images[frame_idx].w * self.scale,&#10;                GuardFX.images[frame_idx].h * self.scale&#10;            )&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[GuardFX] draw 에러: {e}\033[0m&quot;)&#10;&#10;&#10;class ShieldCrashEffect:&#10;    &quot;&quot;&quot;방패가 깨질 때 표시되는 이펙트 (Crash_Blue)&quot;&quot;&quot;&#10;    front_images = None&#10;    back_images = None&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if ShieldCrashEffect.front_images is None:&#10;            ShieldCrashEffect.front_images = []&#10;            try:&#10;                for i in range(11):  # Crash_Blue_Front_FX00 ~ FX10 (0~10)&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Front_FX0{i}.png')&#10;                    ShieldCrashEffect.front_images.append(img)&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.front_images)} front images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load front images: {e}\033[0m&quot;)&#10;                ShieldCrashEffect.front_images = []&#10;&#10;        if ShieldCrashEffect.back_images is None:&#10;            ShieldCrashEffect.back_images = []&#10;            try:&#10;                for i in range(3, 9):  # Crash_Blue_Back_FX03 ~ FX08 (3~8)&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Back_FX0{i}.png')&#10;                    ShieldCrashEffect.back_images.append(img)&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.back_images)} back images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load back images: {e}\033[0m&quot;)&#10;                ShieldCrashEffect.back_images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 20  # 빠른 애니메이션 (20 FPS)&#10;        self.finished = False&#10;&#10;        print(f&quot;[ShieldCrashEffect] 생성됨 at world({int(x)}, {int(y)})&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#10;        if self.finished:&#10;            return False&#10;&#10;        dt = game_framework.get_delta_time()&#10;        self.animation_time += dt&#10;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            self.frame += 1&#10;            self.animation_time = 0&#10;&#10;            # Front 이미지 기준으로 애니메이션이 끝나면 제거&#10;            if ShieldCrashEffect.front_images and self.frame &gt;= len(ShieldCrashEffect.front_images):&#10;                self.finished = True&#10;                return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        이펙트 그리기 (Front와 Back을 레이어링)&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if self.finished:&#10;            return&#10;&#10;        # Front 이미지 그리기 (0~10 프레임)&#10;        if ShieldCrashEffect.front_images and self.frame &lt; len(ShieldCrashEffect.front_images):&#10;            try:&#10;                ShieldCrashEffect.front_images[self.frame].draw(&#10;                    draw_x, draw_y,&#10;                    ShieldCrashEffect.front_images[self.frame].w * self.scale,&#10;                    ShieldCrashEffect.front_images[self.frame].h * self.scale&#10;                )&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] front draw 에러: {e}\033[0m&quot;)&#10;&#10;        # Back 이미지 그리기 (Front 프레임 3부터 시작)&#10;        # Front frame 3 = Back index 0 (Back_FX03)&#10;        # Front frame 4 = Back index 1 (Back_FX04) ...&#10;        if self.frame &gt;= 3:&#10;            back_index = self.frame - 3&#10;            if ShieldCrashEffect.back_images and back_index &lt; len(ShieldCrashEffect.back_images):&#10;                try:&#10;                    ShieldCrashEffect.back_images[back_index].draw(&#10;                        draw_x, draw_y,&#10;                        ShieldCrashEffect.back_images[back_index].w * self.scale,&#10;                        ShieldCrashEffect.back_images[back_index].h * self.scale&#10;                    )&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[ShieldCrashEffect] back draw 에러: {e}\033[0m&quot;)&#10;&#10;&#10;class DashTrailEffect:&#10;    &quot;&quot;&quot;대시 시 남는 잔상 이펙트 - 0.3초간 알파값이 1에서 0으로 페이드아웃&quot;&quot;&quot;&#10;    trail_image = None  # 클래스 변수로 이미지 한 번만 로드&#10;&#10;    def __init__(self, x, y, face_dir, scale=3.0):&#10;        &quot;&quot;&quot;&#10;        대시 잔상 이펙트 생성&#10;        &#10;        Args:&#10;            x: 월드 X 좌표&#10;            y: 월드 Y 좌표&#10;            face_dir: 플레이어의 방향 (1: 오른쪽, -1: 왼쪽)&#10;            scale: 이미지 크기 배율&#10;        &quot;&quot;&quot;&#10;        self.x = x&#10;        self.y = y&#10;        self.face_dir = face_dir&#10;        self.scale = scale&#10;        &#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if DashTrailEffect.trail_image is None:&#10;            try:&#10;                img_path = os.path.join('resources', 'Texture_organize', 'Player_character', 'PlayerDashTrailFx0.png')&#10;                DashTrailEffect.trail_image = load_image(img_path)&#10;                print(f&quot;[DashTrailEffect] 이미지 로드 성공: {img_path}&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[DashTrailEffect] 이미지 로드 실패: {e}\033[0m&quot;)&#10;                DashTrailEffect.trail_image = None&#10;        &#10;        # 페이드아웃 설정&#10;        self.fade_duration = 0.3  # 0.3초간 페이드아웃&#10;        self.elapsed_time = 0.0&#10;        self.alpha = 1.0  # 초기 알파값 1.0 (완전 불투명)&#10;    &#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        이펙트 업데이트 - 알파값을 시간에 따라 감소&#10;        &#10;        Returns:&#10;            bool: True면 계속 유지, False면 제거&#10;        &quot;&quot;&quot;&#10;        dt = game_framework.get_delta_time()&#10;        self.elapsed_time += dt&#10;        &#10;        # 알파값 계산 (1.0 -&gt; 0.0으로 선형 감소)&#10;        if self.elapsed_time &lt; self.fade_duration:&#10;            self.alpha = 1.0 - (self.elapsed_time / self.fade_duration)&#10;        else:&#10;            self.alpha = 0.0&#10;            return False  # 알파값이 0이 되면 제거&#10;        &#10;        return True&#10;    &#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        잔상 이펙트 그리기&#10;        &#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if not DashTrailEffect.trail_image:&#10;            return&#10;        &#10;        # 알파값이 0이면 그리지 않음&#10;        if self.alpha &lt;= 0:&#10;            return&#10;        &#10;        # 방향에 따라 flip 설정&#10;        flip = '' if self.face_dir == 1 else 'h'&#10;        &#10;        # 알파값 설정하여 그리기&#10;        DashTrailEffect.trail_image.opacify(self.alpha)&#10;        DashTrailEffect.trail_image.clip_composite_draw(&#10;            0, 0, &#10;            DashTrailEffect.trail_image.w, &#10;            DashTrailEffect.trail_image.h,&#10;            0, flip,&#10;            draw_x, draw_y,&#10;            DashTrailEffect.trail_image.w * self.scale,&#10;            DashTrailEffect.trail_image.h * self.scale&#10;        )&#10;        # 알파값 복원 (다른 이미지에 영향 주지 않도록)&#10;        DashTrailEffect.trail_image.opacify(1.0)" />
              <option name="updatedContent" value="import os&#13;&#10;from pico2d import load_image&#13;&#10;import pico2d as p2&#13;&#10;import game_framework&#13;&#10;&#13;&#10;class AnimatedVFX:&#13;&#10;    &quot;&quot;&quot;간단한 프레임 애니메이션 VFX 엔티티&#13;&#10;    - folder: 폴더 경로 (예: resources/Texture_organize/VFX/Potion_Common)&#13;&#10;    - prefix: 파일명 접두사 (예: 'Potion_Back_FX')&#13;&#10;    - frames: 프레임 수&#13;&#10;    - frame_time: 각 프레임 지속 시간&#13;&#10;    - x,y: 위치&#13;&#10;    - scale: 크기 배율&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    def __init__(self, folder, prefix, frames, frame_time, x, y, scale=1.0, life=None):&#13;&#10;        self.folder = folder&#13;&#10;        self.prefix = prefix&#13;&#10;        self.frames_count = frames&#13;&#10;        self.frame_time = frame_time&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;        self.images = []&#13;&#10;        self.frame = 0&#13;&#10;        self.acc = 0.0&#13;&#10;        self.life = life if life is not None else frames * frame_time&#13;&#10;        self._load_frames()&#13;&#10;&#13;&#10;    def _load_frames(self):&#13;&#10;        self.images = []&#13;&#10;        for i in range(self.frames_count):&#13;&#10;            name1 = f&quot;{self.prefix}{i:02d}.png&quot;&#13;&#10;            path = os.path.join(self.folder, name1)&#13;&#10;            try:&#13;&#10;                img = load_image(path)&#13;&#10;                self.images.append(img)&#13;&#10;            except Exception:&#13;&#10;                # 로드 실패하면 다음 프레임도 시도하지만 중단&#13;&#10;                print(f'\033[91m[AnimatedVFX] Failed to load frame: {path}\033[0m')&#13;&#10;                break&#13;&#10;        # fallback: 만약 아무 프레임도 로드되지 않으면 try single file without index&#13;&#10;        if not self.images:&#13;&#10;            single = os.path.join(self.folder, f&quot;{self.prefix}.png&quot;)&#13;&#10;            try:&#13;&#10;                img = load_image(single)&#13;&#10;                self.images.append(img)&#13;&#10;            except Exception:&#13;&#10;                print(f'\033[91m[AnimatedVFX] Failed to load single image: {single}\033[0m')&#13;&#10;        # adjust frames_count to actual loaded&#13;&#10;        self.frames_count = len(self.images)&#13;&#10;&#13;&#10;    def update(self, dt=None):&#13;&#10;        # dt None이면 framework에서 값을 가져옴 (main.update_world가 인자로 주지 않으므로)&#13;&#10;        if dt is None:&#13;&#10;            dt = game_framework.get_delta_time()&#13;&#10;        if self.life &lt;= 0:&#13;&#10;            return False&#13;&#10;        self.life -= dt&#13;&#10;        if self.frames_count == 0:&#13;&#10;            return self.life &gt; 0&#13;&#10;        self.acc += dt&#13;&#10;        while self.acc &gt;= self.frame_time and self.frame &lt; self.frames_count - 1:&#13;&#10;            self.acc -= self.frame_time&#13;&#10;            self.frame += 1&#13;&#10;        return self.life &gt; 0&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        if self.images and 0 &lt;= self.frame &lt; len(self.images):&#13;&#10;            img = self.images[self.frame]&#13;&#10;            img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#13;&#10;&#13;&#10;&#13;&#10;class GuardFX:&#13;&#10;    &quot;&quot;&quot;방패 방어 성공 시 표시되는 이펙트&quot;&quot;&quot;&#13;&#10;    images = None&#13;&#10;&#13;&#10;    def __init__(self, x, y, scale=3.0):&#13;&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;&#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if GuardFX.images is None:&#13;&#10;            GuardFX.images = []&#13;&#10;            try:&#13;&#10;                for i in range(5):  # GuardFX1_0.png ~ GuardFX1_4.png&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/Weapon/SwordANDShield/Guard_FX/GuardFX1_{i}.png')&#13;&#10;                    GuardFX.images.append(img)&#13;&#10;                print(f&quot;[GuardFX] Loaded {len(GuardFX.images)} images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[GuardFX] Failed to load images: {e}\033[0m&quot;)&#13;&#10;                GuardFX.images = []&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.animation_time = 0&#13;&#10;        self.animation_speed = 20  # 빠르게 재생 (20 FPS)&#13;&#10;        self.finished = False&#13;&#10;&#13;&#10;        print(f&quot;[GuardFX] 생성됨 at world({int(x)}, {int(y)}), 총 프레임: {len(GuardFX.images) if GuardFX.images else 0}&quot;)&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return False&#13;&#10;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.animation_time += dt&#13;&#10;&#13;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;            self.frame += 1&#13;&#10;            self.animation_time = 0&#13;&#10;&#13;&#10;            # 애니메이션이 끝나면 제거&#13;&#10;            if GuardFX.images and self.frame &gt;= len(GuardFX.images):&#13;&#10;                self.finished = True&#13;&#10;                return False&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 그리기&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not GuardFX.images or len(GuardFX.images) == 0:&#13;&#10;            print(&quot;[GuardFX] 이미지가 없음!&quot;)&#13;&#10;            return&#13;&#10;&#13;&#10;        if self.finished:&#13;&#10;            return&#13;&#10;&#13;&#10;        frame_idx = min(self.frame, len(GuardFX.images) - 1)&#13;&#10;        try:&#13;&#10;            # 카메라가 적용된 좌표(draw_x, draw_y)를 사용하여 그리기&#13;&#10;            GuardFX.images[frame_idx].draw(&#13;&#10;                draw_x, draw_y,&#13;&#10;                GuardFX.images[frame_idx].w * self.scale,&#13;&#10;                GuardFX.images[frame_idx].h * self.scale&#13;&#10;            )&#13;&#10;        except Exception as e:&#13;&#10;            print(f&quot;\033[91m[GuardFX] draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;class ShieldCrashEffect:&#13;&#10;    &quot;&quot;&quot;방패가 깨질 때 표시되는 이펙트 (Crash_Blue)&quot;&quot;&quot;&#13;&#10;    front_images = None&#13;&#10;    back_images = None&#13;&#10;&#13;&#10;    def __init__(self, x, y, scale=3.0):&#13;&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;&#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if ShieldCrashEffect.front_images is None:&#13;&#10;            ShieldCrashEffect.front_images = []&#13;&#10;            try:&#13;&#10;                for i in range(11):  # Crash_Blue_Front_FX00 ~ FX10 (0~10)&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Front_FX0{i}.png')&#13;&#10;                    ShieldCrashEffect.front_images.append(img)&#13;&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.front_images)} front images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load front images: {e}\033[0m&quot;)&#13;&#10;                ShieldCrashEffect.front_images = []&#13;&#10;&#13;&#10;        if ShieldCrashEffect.back_images is None:&#13;&#10;            ShieldCrashEffect.back_images = []&#13;&#10;            try:&#13;&#10;                for i in range(3, 9):  # Crash_Blue_Back_FX03 ~ FX08 (3~8)&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Back_FX0{i}.png')&#13;&#10;                    ShieldCrashEffect.back_images.append(img)&#13;&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.back_images)} back images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load back images: {e}\033[0m&quot;)&#13;&#10;                ShieldCrashEffect.back_images = []&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.animation_time = 0&#13;&#10;        self.animation_speed = 20  # 빠른 애니메이션 (20 FPS)&#13;&#10;        self.finished = False&#13;&#10;&#13;&#10;        print(f&quot;[ShieldCrashEffect] 생성됨 at world({int(x)}, {int(y)})&quot;)&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return False&#13;&#10;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.animation_time += dt&#13;&#10;&#13;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;            self.frame += 1&#13;&#10;            self.animation_time = 0&#13;&#10;&#13;&#10;            # Front 이미지 기준으로 애니메이션이 끝나면 제거&#13;&#10;            if ShieldCrashEffect.front_images and self.frame &gt;= len(ShieldCrashEffect.front_images):&#13;&#10;                self.finished = True&#13;&#10;                return False&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 그리기 (Front와 Back을 레이어링)&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return&#13;&#10;&#13;&#10;        # Front 이미지 그리기 (0~10 프레임)&#13;&#10;        if ShieldCrashEffect.front_images and self.frame &lt; len(ShieldCrashEffect.front_images):&#13;&#10;            try:&#13;&#10;                ShieldCrashEffect.front_images[self.frame].draw(&#13;&#10;                    draw_x, draw_y,&#13;&#10;                    ShieldCrashEffect.front_images[self.frame].w * self.scale,&#13;&#10;                    ShieldCrashEffect.front_images[self.frame].h * self.scale&#13;&#10;                )&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] front draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;        # Back 이미지 그리기 (Front 프레임 3부터 시작)&#13;&#10;        # Front frame 3 = Back index 0 (Back_FX03)&#13;&#10;        # Front frame 4 = Back index 1 (Back_FX04) ...&#13;&#10;        if self.frame &gt;= 3:&#13;&#10;            back_index = self.frame - 3&#13;&#10;            if ShieldCrashEffect.back_images and back_index &lt; len(ShieldCrashEffect.back_images):&#13;&#10;                try:&#13;&#10;                    ShieldCrashEffect.back_images[back_index].draw(&#13;&#10;                        draw_x, draw_y,&#13;&#10;                        ShieldCrashEffect.back_images[back_index].w * self.scale,&#13;&#10;                        ShieldCrashEffect.back_images[back_index].h * self.scale&#13;&#10;                    )&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91m[ShieldCrashEffect] back draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;class DashTrailEffect:&#13;&#10;    &quot;&quot;&quot;대시 시 남는 잔상 이펙트 - 0.3초간 알파값이 1에서 0으로 페이드아웃&quot;&quot;&quot;&#13;&#10;    trail_image = None  # 클래스 변수로 이미지 한 번만 로드&#13;&#10;&#13;&#10;    def __init__(self, x, y, face_dir, scale=3.0):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        대시 잔상 이펙트 생성&#13;&#10;        &#13;&#10;        Args:&#13;&#10;            x: 월드 X 좌표&#13;&#10;            y: 월드 Y 좌표&#13;&#10;            face_dir: 플레이어의 방향 (1: 오른쪽, -1: 왼쪽)&#13;&#10;            scale: 이미지 크기 배율&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.face_dir = face_dir&#13;&#10;        self.scale = scale&#13;&#10;        &#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if DashTrailEffect.trail_image is None:&#13;&#10;            try:&#13;&#10;                img_path = os.path.join('resources', 'Texture_organize', 'Player_character', 'PlayerDashTrailFx0.png')&#13;&#10;                DashTrailEffect.trail_image = load_image(img_path)&#13;&#10;                print(f&quot;[DashTrailEffect] 이미지 로드 성공: {img_path}&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[DashTrailEffect] 이미지 로드 실패: {e}\033[0m&quot;)&#13;&#10;                DashTrailEffect.trail_image = None&#13;&#10;        &#13;&#10;        # 페이드아웃 설정&#13;&#10;        self.fade_duration = 0.3  # 0.3초간 페이드아웃&#13;&#10;        self.elapsed_time = 0.0&#13;&#10;        self.alpha = 1.0  # 초기 알파값 1.0 (완전 불투명)&#13;&#10;    &#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 업데이트 - 알파값을 시간에 따라 감소&#13;&#10;        &#13;&#10;        Returns:&#13;&#10;            bool: True면 계속 유지, False면 제거&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.elapsed_time += dt&#13;&#10;        &#13;&#10;        # 알파값 계산 (1.0 -&gt; 0.0으로 선형 감소)&#13;&#10;        if self.elapsed_time &lt; self.fade_duration:&#13;&#10;            self.alpha = 1.0 - (self.elapsed_time / self.fade_duration)&#13;&#10;        else:&#13;&#10;            self.alpha = 0.0&#13;&#10;            return False  # 알파값이 0이 되면 제거&#13;&#10;        &#13;&#10;        return True&#13;&#10;    &#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        잔상 이펙트 그리기&#13;&#10;        &#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not DashTrailEffect.trail_image:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # 알파값이 0이면 그리지 않음&#13;&#10;        if self.alpha &lt;= 0:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # 방향에 따라 flip 설정&#13;&#10;        flip = '' if self.face_dir == 1 else 'h'&#13;&#10;        &#13;&#10;        # 알파값 설정하여 그리기&#13;&#10;        DashTrailEffect.trail_image.opacify(self.alpha)&#13;&#10;        DashTrailEffect.trail_image.clip_composite_draw(&#13;&#10;            0, 0, &#13;&#10;            DashTrailEffect.trail_image.w, &#13;&#10;            DashTrailEffect.trail_image.h,&#13;&#10;            0, flip,&#13;&#10;            draw_x, draw_y,&#13;&#10;            DashTrailEffect.trail_image.w * self.scale,&#13;&#10;            DashTrailEffect.trail_image.h * self.scale&#13;&#10;        )&#13;&#10;        # 알파값 복원 (다른 이미지에 영향 주지 않도록)&#13;&#10;        DashTrailEffect.trail_image.opacify(1.0)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>