<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game_framework.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_framework.py" />
              <option name="originalContent" value="import time&#10;import game_logic.framework as gl_framework&#10;&#10;current_state = None&#10;_running = False&#10;&#10;&#10;def change_state(new_state, *args, **kwargs):&#10;    global current_state&#10;    # exit old state&#10;    try:&#10;        if current_state and hasattr(current_state, 'exit'):&#10;            current_state.exit()&#10;    except Exception:&#10;        print(f'\033[91m[game_framework] Exception during exit of state {current_state}\033[0m')&#10;&#10;    # change state&#10;    current_state = new_state&#10;    # enter new state (with args if provided)&#10;    run(current_state, *args, **kwargs)&#10;&#10;&#10;def run(start_state, *args, **kwargs):&#10;    &quot;&quot;&quot;Start the main loop with start_state (module-like object that exposes&#10;    enter/exit/handle_events/update/draw).&quot;&quot;&quot;&#10;    global current_state, _running&#10;    current_state = start_state&#10;    try:&#10;        if current_state and hasattr(current_state, 'enter'):&#10;            if args or kwargs:&#10;                current_state.enter(*args, **kwargs)&#10;            else:&#10;                current_state.enter()&#10;    except Exception as ex:&#10;        print(f'\033[91m[game_framework] Exception {ex} during enter of state {current_state}\033[0m')&#10;&#10;    _running = True&#10;    last_time = time.time()&#10;    try:&#10;        while _running:&#10;            now = time.time()&#10;            dt = now - last_time&#10;            last_time = now&#10;            # update global delta_time used by game_logic modules&#10;            try:&#10;                gl_framework.set_delta_time(dt)&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during set_delta_time() with dt={dt}\033[0m')&#10;&#10;            if current_state is None:&#10;                break&#10;&#10;            # event handling&#10;            try:&#10;                if hasattr(current_state, 'handle_events'):&#10;                    current_state.handle_events()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during handle_events() of state {current_state}\033[0m')&#10;                print(f'\033[91m[game_framework] Or Entering Next State with {current_state} handle_events()\033[0m')&#10;                print('\033[91m[game_framework]Continuing main loop...\033[0m')&#10;&#10;            # update&#10;            try:&#10;                if hasattr(current_state, 'update'):&#10;                    current_state.update()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during update() of state {current_state}\033[0m')&#10;&#10;            # draw&#10;            try:&#10;                if hasattr(current_state, 'draw'):&#10;                    current_state.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during draw() of state {current_state}\033[0m')&#10;&#10;            # small sleep to avoid 100% CPU (frame limiter is handled by resource loads)&#10;            time.sleep(gl_framework.frame_time if hasattr(gl_framework, 'frame_time') else 0.01)&#10;    finally:&#10;        try:&#10;            if current_state and hasattr(current_state, 'exit'):&#10;                current_state.exit()&#10;        except Exception as ex:&#10;            print(f'\033[91m[game_framework] Exception {ex} during exit() of state {current_state}\033[0m')&#10;&#10;&#10;def quit():&#10;    global _running&#10;    _running = False&#10;" />
              <option name="updatedContent" value="import time&#10;import game_logic.framework as gl_framework&#10;&#10;current_state = None&#10;_running = False&#10;&#10;&#10;def change_state(new_state, *args, **kwargs):&#10;    global current_state&#10;    # exit old state&#10;    try:&#10;        if current_state and hasattr(current_state, 'exit'):&#10;            current_state.exit()&#10;    except Exception:&#10;        print(f'\033[91m[game_framework] Exception during exit of state {current_state}\033[0m')&#10;&#10;    # change state&#10;    current_state = new_state&#10;    # enter new state (with args if provided)&#10;    run(current_state, *args, **kwargs)&#10;&#10;&#10;def run(start_state, *args, **kwargs):&#10;    &quot;&quot;&quot;Start the main loop with start_state (module-like object that exposes&#10;    enter/exit/handle_events/update/draw).&quot;&quot;&quot;&#10;    global current_state, _running&#10;    current_state = start_state&#10;    try:&#10;        if current_state and hasattr(current_state, 'enter'):&#10;            if args or kwargs:&#10;                current_state.enter(*args, **kwargs)&#10;            else:&#10;                current_state.enter()&#10;    except Exception as ex:&#10;        print(f'\033[91m[game_framework] Exception {ex} during enter of state {current_state}\033[0m')&#10;&#10;    _running = True&#10;    last_time = time.time()&#10;    try:&#10;        while _running:&#10;            now = time.time()&#10;            dt = now - last_time&#10;            last_time = now&#10;            # update global delta_time used by game_logic modules&#10;            try:&#10;                gl_framework.set_delta_time(dt)&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during set_delta_time() with dt={dt}\033[0m')&#10;&#10;            if current_state is None:&#10;                break&#10;&#10;            # event handling&#10;            try:&#10;                if hasattr(current_state, 'handle_events'):&#10;                    current_state.handle_events()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during handle_events() of state {current_state}\033[0m')&#10;                print(f'\033[91m[game_framework] Or Entering Next State with {current_state} handle_events()\033[0m')&#10;                print('\033[91m[game_framework]Continuing main loop...\033[0m')&#10;&#10;            # update&#10;            try:&#10;                if hasattr(current_state, 'update'):&#10;                    current_state.update()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during update() of state {current_state}\033[0m')&#10;&#10;            # draw&#10;            try:&#10;                if hasattr(current_state, 'draw'):&#10;                    current_state.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during draw() of state {current_state}\033[0m')&#10;&#10;            # small sleep to avoid 100% CPU (frame limiter is handled by resource loads)&#10;            time.sleep(gl_framework.frame_time if hasattr(gl_framework, 'frame_time') else 0.01)&#10;    finally:&#10;        try:&#10;            if current_state and hasattr(current_state, 'exit'):&#10;                current_state.exit()&#10;        except Exception as ex:&#10;            print(f'\033[91m[game_framework] Exception {ex} during exit() of state {current_state}\033[0m')&#10;&#10;&#10;def quit():&#10;    global _running&#10;    _running = False" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/cursor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/cursor.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;import math&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;from . import framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        if right_held and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;" />
              <option name="updatedContent" value="import ctypes&#13;&#10;import os&#13;&#10;import math&#13;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#13;&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#13;&#10;from . import framework&#13;&#10;&#13;&#10;class Cursor:&#13;&#10;    def __init__(self, player=None):&#13;&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#13;&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#13;&#10;        self.x, self.y = 0, 0&#13;&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#13;&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#13;&#10;&#13;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#13;&#10;        self.player = player&#13;&#10;        self.last_inventory_open = False&#13;&#10;&#13;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#13;&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#13;&#10;        self.inv_frames = []&#13;&#10;        for i in range(0, 7):&#13;&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#13;&#10;            try:&#13;&#10;                self.inv_frames.append(load_image(path))&#13;&#10;            except Exception as ex:&#13;&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#13;&#10;                self.inv_frames = []&#13;&#10;                break&#13;&#10;&#13;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#13;&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#13;&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#13;&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#13;&#10;        self.inv_anchor = (0.10, 0.90)&#13;&#10;&#13;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#13;&#10;        try:&#13;&#10;            self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#13;&#10;        except Exception as ex:&#13;&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#13;&#10;            self.shield_range_image = None&#13;&#10;        self.shield_range_scale = 4.0&#13;&#10;&#13;&#10;        # 애니메이션 상태&#13;&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#13;&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#13;&#10;        self.frame_timer = 0.0&#13;&#10;        self.frame_duration = 0.06    # 프레임당 시간&#13;&#10;        self.mouse_down = False&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        # 마우스 위치 갱신&#13;&#10;        mx = ctypes.c_int(0)&#13;&#10;        my = ctypes.c_int(0)&#13;&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#13;&#10;        canvas_h = get_canvas_height()&#13;&#10;        self.x = mx.value&#13;&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#13;&#10;&#13;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#13;&#10;&#13;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#13;&#10;        if inv_open != self.last_inventory_open:&#13;&#10;            self.anim_state = 'idle_up'&#13;&#10;            self.frame_idx = 6&#13;&#10;            self.frame_timer = 0.0&#13;&#10;            self.mouse_down = False&#13;&#10;            self.last_inventory_open = inv_open&#13;&#10;&#13;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#13;&#10;        if inv_open and self.inv_frames:&#13;&#10;            dt = framework.get_delta_time()&#13;&#10;            self.frame_timer += dt&#13;&#10;            if self.anim_state == 'down':&#13;&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#13;&#10;                if self.frame_timer &gt;= self.frame_duration:&#13;&#10;                    self.frame_timer -= self.frame_duration&#13;&#10;                    if self.frame_idx &lt; 1:&#13;&#10;                        self.frame_idx += 1&#13;&#10;                # 눌린 상태 유지 시 frame 1 고정&#13;&#10;                if self.mouse_down:&#13;&#10;                    self.frame_idx = max(self.frame_idx, 1)&#13;&#10;                else:&#13;&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#13;&#10;                    self.anim_state = 'up'&#13;&#10;                    self.frame_idx = 2&#13;&#10;                    self.frame_timer = 0.0&#13;&#10;            elif self.anim_state == 'up':&#13;&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#13;&#10;                if self.frame_timer &gt;= self.frame_duration:&#13;&#10;                    self.frame_timer -= self.frame_duration&#13;&#10;                    if self.frame_idx &lt; 6:&#13;&#10;                        self.frame_idx += 1&#13;&#10;                    if self.frame_idx &gt;= 6:&#13;&#10;                        self.anim_state = 'idle_up'&#13;&#10;                        self.frame_idx = 6&#13;&#10;            else:&#13;&#10;                # idle_up: 프레임 6 유지&#13;&#10;                self.frame_idx = 6&#13;&#10;&#13;&#10;    def draw(self, draw_x=None, draw_y=None):&#13;&#10;        if draw_x is None:&#13;&#10;            draw_x = self.x&#13;&#10;        if draw_y is None:&#13;&#10;            draw_y = self.y&#13;&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#13;&#10;        right_held = False&#13;&#10;        try:&#13;&#10;            mx = ctypes.c_int(0)&#13;&#10;            my = ctypes.c_int(0)&#13;&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#13;&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#13;&#10;            right_held = bool(state &amp; right_mask)&#13;&#10;        except Exception:&#13;&#10;            right_held = False&#13;&#10;&#13;&#10;        shield_block = False&#13;&#10;        draw_in_entity = False&#13;&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#13;&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#13;&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#13;&#10;&#13;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#13;&#10;        if right_held and self.shield_range_image is not None and not draw_in_entity:&#13;&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#13;&#10;            camera = None&#13;&#10;            try:&#13;&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#13;&#10;                import game_logic.play_mode as play&#13;&#10;                camera = getattr(play, 'camera', None)&#13;&#10;&#13;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#13;&#10;                if camera is None:&#13;&#10;                    import game_logic.lobby_mode as lobby&#13;&#10;                    camera = getattr(lobby, 'camera', None)&#13;&#10;            except Exception as ex:&#13;&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#13;&#10;                camera = None&#13;&#10;&#13;&#10;            # 마우스 화면 좌표 가져오기&#13;&#10;            mx2 = ctypes.c_int(0)&#13;&#10;            my2 = ctypes.c_int(0)&#13;&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#13;&#10;&#13;&#10;            canvas_h = get_canvas_height()&#13;&#10;            canvas_w = get_canvas_width()&#13;&#10;            mouse_screen_x = mx2.value&#13;&#10;            mouse_screen_y = canvas_h - my2.value&#13;&#10;&#13;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#13;&#10;            if camera is not None:&#13;&#10;                half_w = canvas_w // 2&#13;&#10;                half_h = canvas_h // 2&#13;&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#13;&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#13;&#10;            else:&#13;&#10;                mouse_world_x = mouse_screen_x&#13;&#10;                mouse_world_y = mouse_screen_y&#13;&#10;&#13;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#13;&#10;            dx = mouse_world_x - self.player.x&#13;&#10;            dy = mouse_world_y - self.player.y&#13;&#10;&#13;&#10;            # 각도 계산&#13;&#10;            angle = math.atan2(dy, dx)&#13;&#10;            base_offset = -math.pi / 2&#13;&#10;            theta = angle + base_offset&#13;&#10;&#13;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#13;&#10;            if camera is not None:&#13;&#10;                half_w = canvas_w // 2&#13;&#10;                half_h = canvas_h // 2&#13;&#10;                player_screen_x = self.player.x - camera.x + half_w&#13;&#10;                player_screen_y = self.player.y - camera.y + half_h&#13;&#10;            else:&#13;&#10;                player_screen_x = self.player.x&#13;&#10;                player_screen_y = self.player.y&#13;&#10;&#13;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#13;&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#13;&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#13;&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#13;&#10;&#13;&#10;            self.shield_range_image.clip_composite_draw(&#13;&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#13;&#10;                theta, '',&#13;&#10;                draw_x_shield, draw_y_shield,&#13;&#10;                self.shield_range_image.w * self.shield_range_scale,&#13;&#10;                self.shield_range_image.h * self.shield_range_scale&#13;&#10;            )&#13;&#10;            # 디버그 로그 - 카메라 정보 추가&#13;&#10;            # if camera is not None:&#13;&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#13;&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#13;&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#13;&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#13;&#10;            # else:&#13;&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#13;&#10;&#13;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#13;&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#13;&#10;            img = self.inv_frames[self.frame_idx]&#13;&#10;            w = img.w * self.scale_factor&#13;&#10;            h = img.h * self.scale_factor&#13;&#10;            ax, ay = self.inv_anchor&#13;&#10;            cx = self.x + (0.5 - ax) * w&#13;&#10;            cy = self.y + (0.5 - ay) * h&#13;&#10;            img.draw(cx, cy, w, h)&#13;&#10;        else:&#13;&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#13;&#10;&#13;&#10;    def handle_event(self, event):&#13;&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#13;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#13;&#10;        if not inv_open:&#13;&#10;            return&#13;&#10;        if not self.inv_frames:&#13;&#10;            return&#13;&#10;        # 마우스 좌클릭 이벤트 처리&#13;&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#13;&#10;            self.mouse_down = True&#13;&#10;            self.anim_state = 'down'&#13;&#10;            self.frame_idx = 0&#13;&#10;            self.frame_timer = 0.0&#13;&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#13;&#10;            self.mouse_down = False&#13;&#10;            # 업 애니메이션 시작 (2부터)&#13;&#10;            self.anim_state = 'up'&#13;&#10;            self.frame_idx = 2&#13;&#10;            self.frame_timer = 0.0" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/defeat_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/defeat_mode.py" />
              <option name="originalContent" value="import pico2d as p2&#10;from pico2d import draw_rectangle&#10;&#10;import game_framework&#10;&#10;# defeat_mode의 world 레이어 구조 (play_mode와 유사)&#10;world = {&#10;    'backgrounds': [],&#10;    'entities': [],  # player 등&#10;    'ui': [],&#10;}&#10;&#10;def enter(player):&#10;    &quot;&quot;&quot;패배 모드 진입. 기존 player 객체를 그대로 world에 보관.&quot;&quot;&quot;&#10;    print(&quot;[defeat_mode] enter() - player 객체 전달받음&quot;)&#10;    world['entities'].clear()&#10;    world['ui'].clear()&#10;    world['entities'].append(player)&#10;    player.x = p2.get_canvas_width() // 2&#10;    player.y = p2.get_canvas_height() // 2&#10;    BG = BGimage('resources/Texture_organize/UI/Stage_Loading/BlackBG.png')&#10;    world['backgrounds'].append(BG)&#10;&#10;&#10;&#10;def exit():&#10;    world['entities'].clear()&#10;    world['ui'].clear()&#10;&#10;def update():&#10;    # 필요시 player 등 업데이트&#10;    for layer in ['backgrounds', 'entities', 'ui']:&#10;        for o in world[layer]:&#10;            if hasattr(o, 'update'):&#10;                o.update()&#10;&#10;def draw():&#10;    try:&#10;        p2.clear_canvas()&#10;        # (원한다면 player 등 그리기)&#10;        for layer in ['backgrounds', 'entities', 'ui']:&#10;            for o in world[layer]:&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        o.draw()&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[defeat_mode] draw error in {layer}: {e}\033[0m&quot;)&#10;&#10;        # 화면 중앙에 &quot;패배&quot; 메시지 출력&#10;        canvas_w = p2.get_canvas_width()&#10;        canvas_h = p2.get_canvas_height()&#10;        center_x = canvas_w // 2&#10;        center_y = canvas_h // 1.25&#10;        # 폰트 로드 (한글 지원 폰트 우선)&#10;        try:&#10;            font = p2.load_font('resources/Fonts/pixelroborobo.otf', 80)&#10;        except Exception:&#10;            font = None&#10;        text = &quot;패배&quot;&#10;        font_size = 80&#10;        approx_width = int(len(text) * font_size * 1.0)&#10;&#10;        if font:&#10;            font.draw(center_x - approx_width // 2, center_y, text, (255, 80, 80))&#10;        else:&#10;            p2.draw_text(text, center_x - 40, center_y, (255, 80, 80))&#10;    except Exception as e:&#10;        print(f&quot;\033[91m[defeat_mode] draw() exception: {e}\033[0m&quot;)&#10;    p2.update_canvas()&#10;&#10;def handle_events():&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == p2.SDL_QUIT:&#10;            game_framework.quit()&#10;        elif e.type == p2.SDL_KEYDOWN:&#10;            if e.key == p2.SDLK_ESCAPE:&#10;                game_framework.quit()&#10;            # 필요시 엔터 등으로 타이틀로 복귀 등 추가 가능&#10;&#10;def pause():&#10;    pass&#10;&#10;def resume():&#10;    pass&#10;&#10;class BGimage:&#10;    &quot;&quot;&quot;패배 모드용 배경 이미지 클래스&quot;&quot;&quot;&#10;    def __init__(self, image_path):&#10;        try:&#10;            self.image = p2.load_image(image_path)&#10;        except Exception:&#10;            self.image = None&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def do(self):&#10;        pass&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_w = p2.get_canvas_width()&#10;            canvas_h = p2.get_canvas_height()&#10;            self.image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)" />
              <option name="updatedContent" value="import pico2d as p2&#10;from pico2d import draw_rectangle&#10;&#10;import game_framework&#10;&#10;# defeat_mode의 world 레이어 구조 (play_mode와 유사)&#10;world = {&#10;    'backgrounds': [],&#10;    'entities': [],  # player 등&#10;    'ui': [],&#10;}&#10;&#10;def enter(player):&#10;    &quot;&quot;&quot;패배 모드 진입. 기존 player 객체를 그대로 world에 보관.&quot;&quot;&quot;&#10;    print(&quot;[defeat_mode] enter() - player 객체 전달받음&quot;)&#10;    world['entities'].clear()&#10;    world['ui'].clear()&#10;    world['entities'].append(player)&#10;    player.x = p2.get_canvas_width() // 2&#10;    player.y = p2.get_canvas_height() // 2&#10;    BG = BGimage('resources/Texture_organize/UI/Stage_Loading/BlackBG.png')&#10;    world['backgrounds'].append(BG)&#10;&#10;&#10;&#10;def exit():&#10;    world['entities'].clear()&#10;    world['ui'].clear()&#10;&#10;def update():&#10;    # 필요시 player 등 업데이트&#10;    for layer in ['backgrounds', 'entities', 'ui']:&#10;        for o in world[layer]:&#10;            if hasattr(o, 'update'):&#10;                o.update()&#10;&#10;def draw():&#10;    try:&#10;        p2.clear_canvas()&#10;        # (원한다면 player 등 그리기)&#10;        for layer in ['backgrounds', 'entities', 'ui']:&#10;            for o in world[layer]:&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        o.draw()&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[defeat_mode] draw error in {layer}: {e}\033[0m&quot;)&#10;&#10;        # 화면 중앙에 &quot;패배&quot; 메시지 출력&#10;        canvas_w = p2.get_canvas_width()&#10;        canvas_h = p2.get_canvas_height()&#10;        center_x = canvas_w // 2&#10;        center_y = canvas_h // 1.25&#10;        # 폰트 로드 (한글 지원 폰트 우선)&#10;        try:&#10;            font = p2.load_font('resources/Fonts/pixelroborobo.otf', 80)&#10;        except Exception:&#10;            font = None&#10;        text = &quot;패배&quot;&#10;        font_size = 80&#10;        approx_width = int(len(text) * font_size * 1.0)&#10;&#10;        if font:&#10;            font.draw(center_x - approx_width // 2, center_y, text, (255, 80, 80))&#10;        else:&#10;            p2.draw_text(text, center_x - 40, center_y, (255, 80, 80))&#10;    except Exception as e:&#10;        print(f&quot;\033[91m[defeat_mode] draw() exception: {e}\033[0m&quot;)&#10;    p2.update_canvas()&#10;&#10;def handle_events():&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == p2.SDL_QUIT:&#10;            game_framework.quit()&#10;        elif e.type == p2.SDL_KEYDOWN:&#10;            if e.key == p2.SDLK_ESCAPE:&#10;                game_framework.quit()&#10;            # 필요시 엔터 등으로 타이틀로 복귀 등 추가 가능&#10;&#10;def pause():&#10;    pass&#10;&#10;def resume():&#10;    pass&#10;&#10;class BGimage:&#10;    &quot;&quot;&quot;패배 모드용 배경 이미지 클래스&quot;&quot;&quot;&#10;    def __init__(self, image_path):&#10;        try:&#10;            self.image = p2.load_image(image_path)&#10;        except Exception:&#10;            self.image = None&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def do(self):&#10;        pass&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_w = p2.get_canvas_width()&#10;            canvas_h = p2.get_canvas_height()&#10;            self.image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/equipment.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/equipment.py" />
              <option name="originalContent" value="import ctypes&#10;import math&#10;import os&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;from . import framework&#10;&#10;&#10;def get_mouse_world_position(player):&#10;    &quot;&quot;&quot;&#10;    마우스 화면 좌표를 월드 좌표로 변환하는 헬퍼 함수&#10;    카메라 스크롤을 고려하여 정확한 월드 좌표를 반환&#10;&#10;    Args:&#10;        player: 플레이어 객체 (world 참조를 통해 camera 접근)&#10;&#10;    Returns:&#10;        tuple: (world_x, world_y) 월드 좌표계에서의 마우스 위치&#10;    &quot;&quot;&quot;&#10;    # 마우스 화면 좌표 가져오기&#10;    mx = ctypes.c_int(0)&#10;    my = ctypes.c_int(0)&#10;    SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;&#10;    # pico2d 좌표계로 변환 (Y축 반전)&#10;    canvas_h = get_canvas_height()&#10;    canvas_w = get_canvas_width()&#10;    mouse_screen_x = mx.value&#10;    mouse_screen_y = canvas_h - my.value&#10;&#10;    # 카메라 오프셋 적용하여 월드 좌표로 변환&#10;    # play_mode와 lobby_mode 모두에서 카메라 가져오기&#10;    camera = None&#10;    try:&#10;        # 먼저 play_mode에서 카메라 가져오기 시도&#10;        import game_logic.play_mode as play&#10;        camera = getattr(play, 'camera', None)&#10;&#10;        # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;        if camera is None:&#10;            import game_logic.lobby_mode as lobby&#10;            camera = getattr(lobby, 'camera', None)&#10;    except Exception as ex:&#10;        # 카메라 가져오기 실패 시 None 유지&#10;        pass&#10;&#10;    if camera is not None:&#10;        # 화면 좌표 -&gt; 월드 좌표 변환&#10;        # camera.apply()의 역연산: world_pos = screen_pos - (screen_center - camera_pos)&#10;        half_w = canvas_w // 2&#10;        half_h = canvas_h // 2&#10;        world_x = mouse_screen_x - half_w + camera.x&#10;        world_y = mouse_screen_y - half_h + camera.y&#10;    else:&#10;        # 카메라가 없으면 화면 좌표 그대로 사용&#10;        world_x = mouse_screen_x&#10;        world_y = mouse_screen_y&#10;&#10;    return world_x, world_y&#10;&#10;&#10;# 방패 범위 이펙트 클래스&#10;class ShieldRangeEffect:&#10;    &quot;&quot;&quot;&#10;    방패 범위 표시 이펙트 - world['effects_front']에서 관리&#10;    우클릭으로 방패를 전개할 때 표시되는 범위 이펙트&#10;&#10;    주의: 이 클래스는 x, y 속성을 가지지 않습니다.&#10;    lobby_mode.py의 draw 루프에서 특별 처리가 필요합니다.&#10;    &quot;&quot;&quot;&#10;    _range_image = None  # 클래스 변수로 이미지 공유&#10;&#10;    def __init__(self, player, shield):&#10;        # 이미지 최초 1회만 로드 (클래스 변수 사용)&#10;        if ShieldRangeEffect._range_image is None:&#10;            range_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'shieldRange.png')&#10;            try:&#10;                ShieldRangeEffect._range_image = load_image(range_path)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load shield range image: {ex}\033[0m&quot;)&#10;                ShieldRangeEffect._range_image = None&#10;&#10;        self.player = player&#10;        self.shield = shield&#10;        self.range_scale = 4.0  # 방패 범위 이펙트 크기 조정&#10;&#10;        # x, y 속성 제거: 카메라 적용을 위해 플레이어 참조만 유지&#10;        # draw()에서 player의 카메라 적용된 좌표를 직접 받아서 사용&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        매 프레임마다 호출되어 이펙트 상태 업데이트&#10;        방패가 blocking 상태가 아니면 False를 반환하여 제거됨&#10;        &quot;&quot;&quot;&#10;        # 방패의 blocking 상태가 해제되면 이펙트도 제거&#10;        if not self.shield.blocking:&#10;            return False&#10;        # x, y 동기화 제거: player 참조만 유지&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        방패 범위 이펙트 그리기&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 플레이어의 화면 X 좌표&#10;            draw_y: 카메라가 적용된 플레이어의 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if ShieldRangeEffect._range_image is None:&#10;            return&#10;&#10;        # 방패 범위 각도 계산 (마우스 방향 기준, -90도 오프셋 적용)&#10;        base_offset = -math.pi / 2&#10;        theta = self.shield.range_angle + base_offset&#10;&#10;        # 카메라가 적용된 draw_x, draw_y를 기준으로 방패 범위 이펙트 그리기&#10;        ShieldRangeEffect._range_image.clip_composite_draw(&#10;            0, 0, ShieldRangeEffect._range_image.w, ShieldRangeEffect._range_image.h,&#10;            theta, '',&#10;            draw_x, draw_y,&#10;            ShieldRangeEffect._range_image.w * self.range_scale,&#10;            ShieldRangeEffect._range_image.h * self.range_scale&#10;        )&#10;&#10;&#10;class Weapon:&#10;    &quot;&quot;&quot;기본 무기 클래스&quot;&quot;&quot;&#10;    def __init__(self, player, weapon_type, image_path, render_layer='back', scale=3.0):&#10;        self.player = player&#10;        self.weapon_type = weapon_type  # 'sword', 'shield', 'wand' 등&#10;        self.render_layer = render_layer  # 'back' 또는 'front'&#10;        self.scale_factor = scale&#10;&#10;        # 이미지 로드&#10;        self.image = load_image(image_path)&#10;&#10;        # 무기 위치 오프셋 (플레이어 중심 기준)&#10;        self.offset_x = 20  # 기본 오프셋&#10;        self.offset_y = 0&#10;&#10;        # 회전 각도&#10;        self.angle = 0  # 라디안&#10;&#10;        # 공격 상태&#10;        self.is_attacking = False&#10;        self.attack_timer = 0.0&#10;        self.attack_duration = 0.3  # 실제 공격 애니메이션 시간&#10;        self.attack_recovery = 0.15  # 공격 후 딜레이 (후딜레이)&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery  # 총 공격 시간&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치를 기준으로 무기 각도 계산 (카메라 보정 적용)&quot;&quot;&quot;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#10;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;        dx = world_mouse_x - self.player.x&#10;        dy = world_mouse_y - self.player.y&#10;&#10;        # 각도 계산 (라디안)&#10;        self.angle = math.atan2(dy, dx)&#10;&#10;        # 공격 타이머 업데이트&#10;        if self.is_attacking:&#10;            dt = framework.get_delta_time()&#10;            self.attack_timer += dt&#10;            if self.attack_timer &gt;= self.total_attack_time:&#10;                self.is_attacking = False&#10;                self.attack_timer = 0.0&#10;&#10;    def attack(self):&#10;        &quot;&quot;&quot;공격 시작&quot;&quot;&quot;&#10;        if not self.is_attacking:&#10;            self.is_attacking = True&#10;            self.attack_timer = 0.0&#10;            print(f&quot;{self.weapon_type} 공격!&quot;)&#10;            return True&#10;        return False&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;무기를 회전시켜서 그리기&quot;&quot;&quot;&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        # 무기 위치 계산 (카메라 적용된 플레이어 위치 기준)&#10;        weapon_x = draw_x + self.offset_x * math.cos(self.angle)&#10;        weapon_y = draw_y + self.offset_y + self.offset_x * math.sin(self.angle)&#10;&#10;        # 좌우 반전 결정&#10;        flip = 'h' if self.player.face_dir == -1 else ''&#10;&#10;        # 회전된 무기 그리기&#10;        self.image.clip_composite_draw(&#10;            0, 0, self.image.w, self.image.h,&#10;            self.angle, flip,&#10;            weapon_x, weapon_y,&#10;            self.image.w * self.scale_factor,&#10;            self.image.h * self.scale_factor&#10;        )&#10;&#10;&#10;class Shield(Weapon):&#10;    &quot;&quot;&quot;방패 클래스 (항상 캐릭터 앞에 그려짐)&quot;&quot;&quot;&#10;    def __init__(self, player, image_path, scale=3.0):&#10;        super().__init__(player, 'shield', image_path, render_layer='front', scale=scale)&#10;        self.offset_x = -10  # 기본 X 오프셋(사용 안 함)&#10;        self.offset_y = -10  # Y 오프셋 유지&#10;&#10;        # 우클릭 방패 전개 상태&#10;        self.blocking = False&#10;        self.range_angle = 0.0&#10;&#10;        # 방패 범위 이펙트 참조 (world['effects_front']에서 관리)&#10;        self.range_effect = None&#10;&#10;        # 바라보는 방향으로 방패를 살짝 앞으로 이동시키는 오프셋(픽셀)&#10;        self.forward_offset = 18&#10;&#10;    def start_block(self):&#10;        self.blocking = True&#10;&#10;    def end_block(self):&#10;        self.blocking = False&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;방패: 우클릭 유지 시 각도를 커서 방향으로 갱신 (카메라 보정 적용)&quot;&quot;&quot;&#10;        # 인벤토리가 열려 있으면 방패 입력/전개 무시&#10;        if getattr(self.player, 'inventory_open', False):&#10;            self.blocking = False&#10;            if self.is_attacking:&#10;                dt = framework.get_delta_time()&#10;                self.attack_timer += dt&#10;                if self.attack_timer &gt;= self.attack_duration:&#10;                    self.is_attacking = False&#10;                    self.attack_timer = 0.0&#10;            return&#10;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#10;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;        dx = world_mouse_x - self.player.x&#10;        dy = world_mouse_y - self.player.y&#10;&#10;        # 방패 범위 각도 계산 (라디안)&#10;        self.range_angle = math.atan2(dy, dx)&#10;&#10;        # 이전 blocking 상태 저장&#10;        was_blocking = self.blocking&#10;&#10;        # 프레임별 우클릭 유지 여부를 직접 폴링하여 blocking 동기화 (이벤트 누락 대비)&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        try:&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            self.blocking = bool(state &amp; right_mask)&#10;        except Exception:&#10;            pass&#10;&#10;        # blocking 상태가 변경되었을 때 이펙트 생성/제거&#10;        if self.blocking and not was_blocking:&#10;            # blocking 시작: 이펙트 생성&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#10;                self.range_effect = ShieldRangeEffect(self.player, self)&#10;                self.player.world['effects_front'].append(self.range_effect)&#10;        elif not self.blocking and was_blocking:&#10;            # blocking 종료: 이펙트는 자동으로 제거됨 (update에서 False 반환)&#10;            self.range_effect = None&#10;&#10;        # 기존 공격 타이머 로직 유지(필요 시)&#10;        if self.is_attacking:&#10;            dt = framework.get_delta_time()&#10;            self.attack_timer += dt&#10;            if self.attack_timer &gt;= self.attack_duration:&#10;                self.is_attacking = False&#10;                self.attack_timer = 0.0&#10;&#10;    def attack(self):&#10;        &quot;&quot;&quot;방패는 막기 동작 (현재는 사용하지 않음)&quot;&quot;&quot;&#10;        if not self.is_attacking:&#10;            self.is_attacking = True&#10;            self.attack_timer = 0.0&#10;            print(f&quot;방패로 막기!&quot;)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;방패 본체 그리기 (범위 이미지는 world['effects_front']에서 관리)&quot;&quot;&quot;&#10;        # 방패 본체는 회전 없이 플레이어 앞에 고정&#10;        flip = 'h' if self.player.face_dir == -1 else ''&#10;        # 전개 중일 때만 앞으로 이동, 아니면 기존의 작은 좌우 오프셋 유지&#10;        if self.blocking:&#10;            local_offset_x = self.forward_offset if self.player.face_dir == 1 else -self.forward_offset&#10;        else:&#10;            local_offset_x = 10 if self.player.face_dir == -1 else -10&#10;&#10;        # 바라보는 방향에 따른 방패 로컬 오프셋 적용&#10;        weapon_x = draw_x + local_offset_x&#10;        weapon_y = draw_y + self.offset_y&#10;&#10;        self.image.clip_composite_draw(&#10;            0, 0, self.image.w, self.image.h,&#10;            0, flip,&#10;            weapon_x, weapon_y,&#10;            self.image.w * self.scale_factor,&#10;            self.image.h * self.scale_factor&#10;        )&#10;&#10;    def check_projectile_block(self, projectile):&#10;        &quot;&quot;&quot;투사체가 방패에 막혔는지 확인&#10;&#10;        Args:&#10;            projectile: 투사체 객체&#10;&#10;        Returns:&#10;            bool: 방패에 막혔으면 True, 아니면 False&#10;        &quot;&quot;&quot;&#10;        # 방패를 전개하지 않았으면 막을 수 없음&#10;        if not self.blocking:&#10;            return False&#10;&#10;        # print(f&quot;[Shield] 방패 전개 중, 투사체 충돌 체크 시작&quot;)&#10;&#10;        # 방패 중심 위치 계산&#10;        if self.blocking:&#10;            local_offset_x = self.forward_offset if self.player.face_dir == 1 else -self.forward_offset&#10;        else:&#10;            local_offset_x = 10 if self.player.face_dir == -1 else -10&#10;        shield_x = self.player.x + local_offset_x&#10;        shield_y = self.player.y + self.offset_y&#10;&#10;        # 방패 크기 (이미지 크기 * scale) - 충돌 범위를 매우 넓게&#10;        shield_width = self.image.w * self.scale_factor * 2.5  # 3배로 확대&#10;        shield_height = self.image.h * self.scale_factor * 2.5&#10;&#10;        # 투사체 크기&#10;        if hasattr(projectile, 'get_collision_box'):&#10;            proj_width, proj_height = projectile.get_collision_box()&#10;        else:&#10;            proj_width = 30&#10;            proj_height = 30&#10;&#10;        # AABB 충돌 감지&#10;        shield_left = shield_x - shield_width / 2&#10;        shield_right = shield_x + shield_width / 2&#10;        shield_bottom = shield_y - shield_height / 2&#10;        shield_top = shield_y + shield_height / 2&#10;&#10;        proj_left = projectile.x - proj_width / 2&#10;        proj_right = projectile.x + proj_width / 2&#10;        proj_bottom = projectile.y - proj_height / 2&#10;        proj_top = projectile.y + proj_height / 2&#10;&#10;        # 충돌 검사&#10;        if (shield_left &lt; proj_right and shield_right &gt; proj_left and&#10;            shield_bottom &lt; proj_top and shield_top &gt; proj_bottom):&#10;&#10;            print(f&quot;[Shield] AABB 충돌 감지!&quot;)&#10;&#10;            # 투사체가 플레이어 방향으로 날아오는지 확인&#10;            # 투사체에서 플레이어로 향하는 벡터 (투사체의 이동 방향과 유사)&#10;            proj_to_player_x = self.player.x - projectile.x&#10;            proj_to_player_y = self.player.y - projectile.y&#10;&#10;            # 투사체의 속도 벡터 확인 (투사체가 플레이어 쪽으로 오고 있는지)&#10;            if hasattr(projectile, 'dx') and hasattr(projectile, 'dy'):&#10;                # 투사체의 이동 방향과 플레이어 방향이 같은지 확인&#10;                dot_product = projectile.dx * proj_to_player_x + projectile.dy * proj_to_player_y&#10;                if dot_product &lt; 0:&#10;                    # 투사체가 플레이어에게서 멀어지고 있음 (이미 지나침)&#10;                    print(f&quot;[Shield] 투사체가 플레이어에게서 멀어지고 있음 - 방어 실패&quot;)&#10;                    return False&#10;&#10;            # 방어 이펙트 생성 (투사체 위치에 생성)&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#10;                try:&#10;                    from .guard_fx import GuardFX&#10;                    # 투사체(공격자) 위치에 이펙트 생성&#10;                    guard_fx = GuardFX(projectile.x, projectile.y, scale=self.scale_factor)&#10;                    self.player.world['effects_front'].append(guard_fx)&#10;                    print(f&quot;[Shield] 방어 이펙트 생성 완료 at ({int(projectile.x)}, {int(projectile.y)})&quot;)&#10;                except Exception as ex:&#10;                    print(f&quot;[Shield] 방어 이펙트 생성 실패: {ex}&quot;)&#10;&#10;            # 플레이어 넉백 (부드럽게)&#10;            knockback_strength = 100  # 픽셀 (초기 속도 기반)&#10;            distance = math.sqrt(proj_to_player_x**2 + proj_to_player_y**2)&#10;            if distance &gt; 0:&#10;                # 넉백 방향 계산 (투사체에서 멀어지는 방향)&#10;                self.player.knockback_dx = proj_to_player_x / distance&#10;                self.player.knockback_dy = proj_to_player_y / distance&#10;                # 넉백 속도 및 지속시간 설정&#10;                self.player.knockback_speed = knockback_strength&#10;                self.player.knockback_duration = 0.2  # 0.2초 동안 넉백&#10;                self.player.knockback_timer = 0.0  # 타이머 초기화&#10;                print(f&quot;[Shield] 방어 이펙트에 의한 넉백 발생: 방향=({self.player.knockback_dx:.2f}, {self.player.knockback_dy:.2f}), 속도={knockback_strength}&quot;)&#10;&#10;            return True&#10;&#10;        # print(f&quot;[Shield] 충돌 감지 안됨&quot;)&#10;        return False&#10;&#10;&#10;class Sword(Weapon):&#10;    &quot;&quot;&quot;검 클래스 (항상 캐릭터 뒤에 그려짐)&quot;&quot;&quot;&#10;    def __init__(self, player, image_path, scale=3.0):&#10;        super().__init__(player, 'sword', image_path, render_layer='back', scale=scale)&#10;        self.offset_x = 15  # 검은 좀 더 멀리&#10;        self.offset_y = 8 # 검의 기본 Y 오프셋&#10;&#10;        # 스테이지별(콤보) 시간 설정 (스테이지1 = 기본, 스테이지2 = 콤보)&#10;        self.stage = 1&#10;        # 기본(보정 전) 시간값 저장&#10;        self.stage1_attack_duration_base = 0.2  # 공격 모션 시간 (1스테이지)&#10;        self.stage1_attack_recovery_base = 0.3  # 후딜 (1스테이지)&#10;        self.stage2_attack_duration_base = 0.18  # 공격 모션 시간 (콤보)&#10;        self.stage2_attack_recovery_base = 0.35  # 후딜 (콤보)&#10;        self.stage3_attack_duration_base = 0.28  # 3스테이지 모션 시간&#10;        self.stage3_attack_recovery_base = 0.4   # 3스테이지 후딜&#10;&#10;        # 현재 활성화된 공격 시간 값 (초기값은 1스테이지 보정 적용)&#10;        self.attack_duration = self.stage1_attack_duration_base&#10;        self.attack_recovery = self.stage1_attack_recovery_base&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery&#10;&#10;        self.base_angle_offset = math.radians(25)  # 기본 각도 오프셋&#10;&#10;        # 공격 모션 관련 변수&#10;        self.attack_progress = 0.0  # 0.0 ~ 1.0&#10;        self.attack_angle_range = -math.radians(205)  # 0도 ~ 270도 회전 (검 자체 회전)&#10;        self.y_offset_down = -50  # progress 0.5까지 내려갈 y 오프셋&#10;&#10;        # 자전 및 공전 각도 범위 추가&#10;        self.rotation_angle_range = -math.radians(270)  # 자전: 0도 ~ 270도&#10;        self.orbit_angle_range = -math.radians(205)  # 공전: 0도 ~ 205도&#10;&#10;        # 콤보 관련 플래그&#10;        self.combo_queued = False  # 후딜 중에 콤보 입력이 들어왔는지&#10;&#10;    def _apply_speed(self, stage: int):&#10;        &quot;&quot;&quot;플레이어 stats.attack_speed로 해당 스테이지 시간값을 보정한다.&quot;&quot;&quot;&#10;        speed = 1.0&#10;        try:&#10;            if hasattr(self.player, 'stats'):&#10;                speed = max(0.1, float(self.player.stats.get('attack_speed')))&#10;        except Exception:&#10;            speed = 1.0&#10;        if stage == 1:&#10;            self.attack_duration = self.stage1_attack_duration_base / speed&#10;            self.attack_recovery = self.stage1_attack_recovery_base / speed&#10;        elif stage == 2:&#10;            self.attack_duration = self.stage2_attack_duration_base / speed&#10;            self.attack_recovery = self.stage2_attack_recovery_base / speed&#10;        elif stage == 3:&#10;            self.attack_duration = self.stage3_attack_duration_base / speed&#10;            self.attack_recovery = self.stage3_attack_recovery_base / speed&#10;        else:&#10;            pass&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치를 기준으로 무기 각도 계산 (카메라 보정 적용)&quot;&quot;&quot;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#10;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;        dx = world_mouse_x - self.player.x&#10;        dy = world_mouse_y - self.player.y&#10;&#10;        # 각도 계산 (라디안)&#10;        self.angle = math.atan2(dy, dx)&#10;&#10;        # 공격 타이머 업데이트&#10;        if self.is_attacking:&#10;            dt = framework.get_delta_time()&#10;            self.attack_timer += dt&#10;&#10;            # 공격 progress 계산 (0.0 ~ 1.0)&#10;            if self.attack_timer &lt; self.attack_duration:&#10;                self.attack_progress = self.attack_timer / self.attack_duration&#10;            else:&#10;                self.attack_progress = 1.0&#10;&#10;            # 스테이지별 종료 처리&#10;            if self.attack_timer &gt;= self.total_attack_time:&#10;                # 3스테이지 종료 처리&#10;                if self.stage == 3:&#10;                    self.is_attacking = False&#10;                    self.attack_timer = 0.0&#10;                    self.attack_progress = 0.0&#10;                    self.stage = 1&#10;                    # 기본 스테이지 시간 복원&#10;                    self.attack_duration = self.stage1_attack_duration_base&#10;                    self.attack_recovery = self.stage1_attack_recovery_base&#10;                    self.total_attack_time = self.attack_duration + self.attack_recovery&#10;                    self.combo_queued = False&#10;                # 2스테이지 종료 처리&#10;                elif self.stage == 2:&#10;                    self.is_attacking = False&#10;                    self.attack_timer = 0.0&#10;                    self.attack_progress = 0.0&#10;                    self.stage = 1&#10;                    self.attack_duration = self.stage1_attack_duration_base&#10;                    self.attack_recovery = self.stage1_attack_recovery_base&#10;                    self.total_attack_time = self.attack_duration + self.attack_recovery&#10;                    self.combo_queued = False&#10;                else:&#10;                    # 1스테이지 종료&#10;                    self.is_attacking = False&#10;                    self.attack_timer = 0.0&#10;                    self.attack_progress = 0.0&#10;                    self.combo_queued = False&#10;&#10;    def attack(self):&#10;        &quot;&quot;&quot;공격 시작&#10;&#10;        동작 요약:&#10;        - 비공격 중이면 1스테이지 공격 시작&#10;        - 공격 중(후딜 영역)에 클릭하면 즉시 2스테이지(콤보) 공격으로 전환&#10;        &quot;&quot;&quot;&#10;        # 비공격 상태에서 시작&#10;        if not self.is_attacking:&#10;            self.is_attacking = True&#10;            self.attack_timer = 0.0&#10;            self.attack_progress = 0.0&#10;            self.stage = 1&#10;            # 스탯 보정 적용&#10;            self._apply_speed(1)&#10;            print(f&quot;{self.weapon_type} 공격! (stage 1)&quot;)&#10;&#10;            # 공격 이펙트 생성&#10;            from .player import VFX_Tier1_Sword_Swing&#10;&#10;            angle_deg = math.degrees(self.angle) % 360&#10;            if 90 &lt; angle_deg &lt; 270:  # 왼쪽 영역&#10;                flip = 'vh'&#10;            else:&#10;                flip = 'h'&#10;&#10;            attack_vfx = VFX_Tier1_Sword_Swing(&#10;                self.player.x,&#10;                self.player.y,&#10;                self.angle,&#10;                flip,&#10;                scale=4.5,&#10;                range_factor=60,&#10;                variant=1,&#10;                owner=self.player&#10;            )&#10;            # world['effects_front']에 추가 (없으면 player에 추가)&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#10;                self.player.world['effects_front'].append(attack_vfx)&#10;            else:&#10;                self.player.attack_effects.append(attack_vfx)&#10;&#10;            return True&#10;&#10;        # 공격 중일 때: 후딜 중에 콤보 입력을 받아 단계별 전환&#10;        else:&#10;            # 1스테이지 후딜에서 클릭 -&gt; 2스테이지&#10;            if self.attack_timer &gt;= self.attack_duration and self.stage == 1:&#10;                # 즉시 콤보(2스테이지)로 전환&#10;                self.stage = 2&#10;                self.attack_timer = 0.0&#10;                self.attack_progress = 0.0&#10;                # 스탯 보정 적용&#10;                self._apply_speed(2)&#10;                self.combo_queued = True&#10;                print(f&quot;{self.weapon_type} 콤보! (stage 2)&quot;)&#10;&#10;                # 콤보용 이펙트 생성&#10;                from .player import VFX_Tier1_Sword_Swing&#10;&#10;                angle_deg = math.degrees(self.angle) % 360&#10;                flip = 'vh' if 90 &lt; angle_deg &lt; 270 else 'h'&#10;&#10;                attack_vfx = VFX_Tier1_Sword_Swing(&#10;                    self.player.x,&#10;                    self.player.y,&#10;                    self.angle,&#10;                    flip,&#10;                    scale=5.5,&#10;                    range_factor=70,&#10;                    variant=2&#10;                )&#10;                # world['effects_front']에 추가 (없으면 player에 추가)&#10;                if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#10;                    self.player.world['effects_front'].append(attack_vfx)&#10;                else:&#10;                    self.player.attack_effects.append(attack_vfx)&#10;&#10;                return True&#10;&#10;            # 2스테이지 후딜에서 클릭 -&gt; 3스테이지 (헤비 스윙)&#10;            if self.attack_timer &gt;= self.attack_duration and self.stage == 2:&#10;                self.stage = 3&#10;                self.attack_timer = 0.0&#10;                self.attack_progress = 0.0&#10;                # 스탯 보정 적용&#10;                self._apply_speed(3)&#10;                self.combo_queued = True&#10;                print(f&quot;{self.weapon_type} 헤비 스윙! (stage 3)&quot;)&#10;&#10;                # 3스테이지 전용 이펙트 생성 (variant=3)&#10;                from .player import VFX_Tier1_Sword_Swing&#10;&#10;                angle_deg = math.degrees(self.angle) % 360&#10;                flip = 'vh' if 90 &lt; angle_deg &lt; 270 else 'h'&#10;&#10;                attack_vfx = VFX_Tier1_Sword_Swing(&#10;                    self.player.x,&#10;                    self.player.y,&#10;                    self.angle,&#10;                    flip,&#10;                    scale=6.0,&#10;                    range_factor=90,&#10;                    variant=3,&#10;                    owner=self.player&#10;                )&#10;                # world['effects_front']에 추가 (없으면 player에 추가)&#10;                if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#10;                    self.player.world['effects_front'].append(attack_vfx)&#10;                else:&#10;                    self.player.attack_effects.append(attack_vfx)&#10;&#10;                return True&#10;&#10;            # 그 외(공격 중이지만 아직 공격 모션 중이거나 이미 최고 단계면 무시)&#10;            return False&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        검을 회전시켜서 그리기 - 검 자체를 중심으로 회전 + 캐릭터 중심으로 공전&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 플레이어의 화면 X 좌표&#10;            draw_y: 카메라가 적용된 플레이어의 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        # ========== 공격 모션에 따른 각도 및 오프셋 계산 ==========&#10;        sword_rotation = 0.0          # 검 자체의 회전 각도 (자전)&#10;        orbit_angle_offset = 0.0      # 캐릭터 중심 기준 공전 각도 오프셋&#10;        y_offset_modifier = 0.0       # Y축 위치 오프셋 (공격 시 아래로 내려감)&#10;&#10;        if self.is_attacking:&#10;            if self.attack_timer &lt; self.attack_duration:&#10;                # 공격 모션 중 (0 ~ attack_duration)&#10;                sword_rotation = self.rotation_angle_range * self.attack_progress  # 자전 각도&#10;                orbit_angle_offset = self.orbit_angle_range * self.attack_progress  # 공전 각도&#10;                # Y축 오프셋: 공격 시 검을 아래로 내림&#10;                y_offset_modifier = -3 * self.offset_y * self.attack_progress&#10;            else:&#10;                # 후딜레이 중 (attack_duration ~ total_attack_time)&#10;                sword_rotation = self.rotation_angle_range      # 자전 최대 각도 유지&#10;                orbit_angle_offset = self.orbit_angle_range    # 공전 최대 각도 유지&#10;                # Y축 오프셋: 후딜레이 동안 최대 아래 위치 유지&#10;                y_offset_modifier = -3 * self.offset_y&#10;&#10;        # ========== 2스테이지(콤보) 시 자전 방향 반전 ==========&#10;        # 콤보 공격 시 검이 반대 방향으로 회전하여 자연스러운 연계 공격 연출&#10;        invert_rotation = (getattr(self, 'stage', 1) == 2 and self.attack_timer &lt; self.attack_duration)&#10;        if invert_rotation:&#10;            sword_rotation = -sword_rotation&#10;&#10;        # ========== 검의 기본 각도 오프셋 ==========&#10;        base_offset = self.base_angle_offset&#10;&#10;        # ========== 마우스 위치에 따른 검의 방향 결정 ==========&#10;        angle_deg = math.degrees(self.angle) % 360&#10;&#10;        # 마우스가 왼쪽/오른쪽에 있는지에 따라 검의 위치와 반전 방향 결정&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽 영역&#10;            flip = 'v'  # 수직 반전&#10;            # 왼쪽: 공전 각도를 빼서 위치 계산&#10;            position_angle = self.angle - orbit_angle_offset&#10;            # 왼쪽: 자전 각도를 빼서 최종 각도 계산&#10;            final_angle = position_angle - sword_rotation&#10;        else:  # 오른쪽 영역&#10;            flip = ''&#10;            # 오른쪽: 공전 각도를 더해서 위치 계산&#10;            position_angle = self.angle + orbit_angle_offset&#10;            # 오른쪽: 자전 각도를 더해서 최종 각도 계산&#10;            final_angle = position_angle + sword_rotation&#10;&#10;        # ========== 검의 실제 화면 위치 계산 (카메라 적용 좌표 기준) ==========&#10;        # draw_x, draw_y는 이미 카메라가 적용된 화면 좌표이므로, 이를 기준으로 offset 적용&#10;        weapon_x = draw_x + self.offset_x * math.cos(position_angle)&#10;        weapon_y = draw_y + self.offset_y + self.offset_x * math.sin(position_angle) + y_offset_modifier&#10;&#10;        # ========== 검 이미지 그리기 ==========&#10;        self.image.clip_composite_draw(&#10;            0, 0, self.image.w, self.image.h,&#10;            final_angle + base_offset, flip,&#10;            weapon_x, weapon_y,&#10;            self.image.w * self.scale_factor,&#10;            self.image.h * self.scale_factor&#10;        )&#10;&#10;&#10;class EquipmentManager:&#10;    &quot;&quot;&quot;장비를 관리하는 매니저 클래스&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.back_equipment = []   # 캐릭터 뒤에 그려질 장비 (검 등)&#10;        self.front_equipment = []  # 캐릭터 앞에 그려질 장비 (방패 등)&#10;&#10;    def equip(self, equipment):&#10;        &quot;&quot;&quot;장비 장착&quot;&quot;&quot;&#10;        if equipment.render_layer == 'back':&#10;            self.back_equipment.append(equipment)&#10;        elif equipment.render_layer == 'front':&#10;            self.front_equipment.append(equipment)&#10;&#10;    def unequip(self, equipment):&#10;        &quot;&quot;&quot;장비 해제&quot;&quot;&quot;&#10;        if equipment in self.back_equipment:&#10;            self.back_equipment.remove(equipment)&#10;        if equipment in self.front_equipment:&#10;            self.front_equipment.remove(equipment)&#10;&#10;    def unequip_all(self):&#10;        &quot;&quot;&quot;모든 장비 해제&quot;&quot;&quot;&#10;        self.back_equipment.clear()&#10;        self.front_equipment.clear()&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;모든 장비 업데이트&quot;&quot;&quot;&#10;        for equipment in self.back_equipment + self.front_equipment:&#10;            equipment.update()&#10;&#10;    def handle_event(self, event):&#10;        &quot;&quot;&quot;장비 이벤트 처리 (좌클릭: 공격, 우클릭: 방패 전개 표시)&quot;&quot;&quot;&#10;        # 마우스 좌클릭 시 공격(검)&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            for equipment in self.back_equipment:&#10;                equipment.attack()&#10;&#10;        # 마우스 우클릭: 방패 범위 표시 시작/종료&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_RIGHT:&#10;            # 디버그: 우클릭 다운 수신&#10;            try:&#10;                print('[Shield] RIGHT DOWN')&#10;            except Exception:&#10;                pass&#10;            for equipment in self.front_equipment:&#10;                if isinstance(equipment, Shield):&#10;                    equipment.start_block()&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_RIGHT:&#10;            # 디버그: 우클릭 업 수신&#10;            try:&#10;                print('[Shield] RIGHT UP')&#10;            except Exception:&#10;                pass&#10;            for equipment in self.front_equipment:&#10;                if isinstance(equipment, Shield):&#10;                    equipment.end_block()&#10;&#10;    def draw_back(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;캐릭터 뒤에 그려질 장비들&quot;&quot;&quot;&#10;        for equipment in self.back_equipment:&#10;            equipment.draw(draw_x, draw_y)&#10;&#10;    def draw_front(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;캐릭터 앞에 그려질 장비들&quot;&quot;&quot;&#10;        for equipment in self.front_equipment:&#10;            equipment.draw(draw_x, draw_y)&#10;" />
              <option name="updatedContent" value="import ctypes&#13;&#10;import math&#13;&#10;import os&#13;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#13;&#10;from sdl2 import SDL_GetMouseState, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#13;&#10;from . import framework&#13;&#10;&#13;&#10;&#13;&#10;def get_mouse_world_position(player):&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    마우스 화면 좌표를 월드 좌표로 변환하는 헬퍼 함수&#13;&#10;    카메라 스크롤을 고려하여 정확한 월드 좌표를 반환&#13;&#10;&#13;&#10;    Args:&#13;&#10;        player: 플레이어 객체 (world 참조를 통해 camera 접근)&#13;&#10;&#13;&#10;    Returns:&#13;&#10;        tuple: (world_x, world_y) 월드 좌표계에서의 마우스 위치&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    # 마우스 화면 좌표 가져오기&#13;&#10;    mx = ctypes.c_int(0)&#13;&#10;    my = ctypes.c_int(0)&#13;&#10;    SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#13;&#10;&#13;&#10;    # pico2d 좌표계로 변환 (Y축 반전)&#13;&#10;    canvas_h = get_canvas_height()&#13;&#10;    canvas_w = get_canvas_width()&#13;&#10;    mouse_screen_x = mx.value&#13;&#10;    mouse_screen_y = canvas_h - my.value&#13;&#10;&#13;&#10;    # 카메라 오프셋 적용하여 월드 좌표로 변환&#13;&#10;    # play_mode와 lobby_mode 모두에서 카메라 가져오기&#13;&#10;    camera = None&#13;&#10;    try:&#13;&#10;        # 먼저 play_mode에서 카메라 가져오기 시도&#13;&#10;        import game_logic.play_mode as play&#13;&#10;        camera = getattr(play, 'camera', None)&#13;&#10;&#13;&#10;        # play_mode 카메라가 없으면 lobby_mode에서 시도&#13;&#10;        if camera is None:&#13;&#10;            import game_logic.lobby_mode as lobby&#13;&#10;            camera = getattr(lobby, 'camera', None)&#13;&#10;    except Exception as ex:&#13;&#10;        # 카메라 가져오기 실패 시 None 유지&#13;&#10;        pass&#13;&#10;&#13;&#10;    if camera is not None:&#13;&#10;        # 화면 좌표 -&gt; 월드 좌표 변환&#13;&#10;        # camera.apply()의 역연산: world_pos = screen_pos - (screen_center - camera_pos)&#13;&#10;        half_w = canvas_w // 2&#13;&#10;        half_h = canvas_h // 2&#13;&#10;        world_x = mouse_screen_x - half_w + camera.x&#13;&#10;        world_y = mouse_screen_y - half_h + camera.y&#13;&#10;    else:&#13;&#10;        # 카메라가 없으면 화면 좌표 그대로 사용&#13;&#10;        world_x = mouse_screen_x&#13;&#10;        world_y = mouse_screen_y&#13;&#10;&#13;&#10;    return world_x, world_y&#13;&#10;&#13;&#10;&#13;&#10;# 방패 범위 이펙트 클래스&#13;&#10;class ShieldRangeEffect:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    방패 범위 표시 이펙트 - world['effects_front']에서 관리&#13;&#10;    우클릭으로 방패를 전개할 때 표시되는 범위 이펙트&#13;&#10;&#13;&#10;    주의: 이 클래스는 x, y 속성을 가지지 않습니다.&#13;&#10;    lobby_mode.py의 draw 루프에서 특별 처리가 필요합니다.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    _range_image = None  # 클래스 변수로 이미지 공유&#13;&#10;&#13;&#10;    def __init__(self, player, shield):&#13;&#10;        # 이미지 최초 1회만 로드 (클래스 변수 사용)&#13;&#10;        if ShieldRangeEffect._range_image is None:&#13;&#10;            range_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'shieldRange.png')&#13;&#10;            try:&#13;&#10;                ShieldRangeEffect._range_image = load_image(range_path)&#13;&#10;            except Exception as ex:&#13;&#10;                print(f&quot;\033[91mFailed to load shield range image: {ex}\033[0m&quot;)&#13;&#10;                ShieldRangeEffect._range_image = None&#13;&#10;&#13;&#10;        self.player = player&#13;&#10;        self.shield = shield&#13;&#10;        self.range_scale = 4.0  # 방패 범위 이펙트 크기 조정&#13;&#10;&#13;&#10;        # x, y 속성 제거: 카메라 적용을 위해 플레이어 참조만 유지&#13;&#10;        # draw()에서 player의 카메라 적용된 좌표를 직접 받아서 사용&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        매 프레임마다 호출되어 이펙트 상태 업데이트&#13;&#10;        방패가 blocking 상태가 아니면 False를 반환하여 제거됨&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # 방패의 blocking 상태가 해제되면 이펙트도 제거&#13;&#10;        if not self.shield.blocking:&#13;&#10;            return False&#13;&#10;        # x, y 동기화 제거: player 참조만 유지&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        방패 범위 이펙트 그리기&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 플레이어의 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 플레이어의 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if ShieldRangeEffect._range_image is None:&#13;&#10;            return&#13;&#10;&#13;&#10;        # 방패 범위 각도 계산 (마우스 방향 기준, -90도 오프셋 적용)&#13;&#10;        base_offset = -math.pi / 2&#13;&#10;        theta = self.shield.range_angle + base_offset&#13;&#10;&#13;&#10;        # 카메라가 적용된 draw_x, draw_y를 기준으로 방패 범위 이펙트 그리기&#13;&#10;        ShieldRangeEffect._range_image.clip_composite_draw(&#13;&#10;            0, 0, ShieldRangeEffect._range_image.w, ShieldRangeEffect._range_image.h,&#13;&#10;            theta, '',&#13;&#10;            draw_x, draw_y,&#13;&#10;            ShieldRangeEffect._range_image.w * self.range_scale,&#13;&#10;            ShieldRangeEffect._range_image.h * self.range_scale&#13;&#10;        )&#13;&#10;&#13;&#10;&#13;&#10;class Weapon:&#13;&#10;    &quot;&quot;&quot;기본 무기 클래스&quot;&quot;&quot;&#13;&#10;    def __init__(self, player, weapon_type, image_path, render_layer='back', scale=3.0):&#13;&#10;        self.player = player&#13;&#10;        self.weapon_type = weapon_type  # 'sword', 'shield', 'wand' 등&#13;&#10;        self.render_layer = render_layer  # 'back' 또는 'front'&#13;&#10;        self.scale_factor = scale&#13;&#10;&#13;&#10;        # 이미지 로드&#13;&#10;        self.image = load_image(image_path)&#13;&#10;&#13;&#10;        # 무기 위치 오프셋 (플레이어 중심 기준)&#13;&#10;        self.offset_x = 20  # 기본 오프셋&#13;&#10;        self.offset_y = 0&#13;&#10;&#13;&#10;        # 회전 각도&#13;&#10;        self.angle = 0  # 라디안&#13;&#10;&#13;&#10;        # 공격 상태&#13;&#10;        self.is_attacking = False&#13;&#10;        self.attack_timer = 0.0&#13;&#10;        self.attack_duration = 0.3  # 실제 공격 애니메이션 시간&#13;&#10;        self.attack_recovery = 0.15  # 공격 후 딜레이 (후딜레이)&#13;&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery  # 총 공격 시간&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;마우스 위치를 기준으로 무기 각도 계산 (카메라 보정 적용)&quot;&quot;&quot;&#13;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#13;&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#13;&#10;&#13;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#13;&#10;        dx = world_mouse_x - self.player.x&#13;&#10;        dy = world_mouse_y - self.player.y&#13;&#10;&#13;&#10;        # 각도 계산 (라디안)&#13;&#10;        self.angle = math.atan2(dy, dx)&#13;&#10;&#13;&#10;        # 공격 타이머 업데이트&#13;&#10;        if self.is_attacking:&#13;&#10;            dt = framework.get_delta_time()&#13;&#10;            self.attack_timer += dt&#13;&#10;            if self.attack_timer &gt;= self.total_attack_time:&#13;&#10;                self.is_attacking = False&#13;&#10;                self.attack_timer = 0.0&#13;&#10;&#13;&#10;    def attack(self):&#13;&#10;        &quot;&quot;&quot;공격 시작&quot;&quot;&quot;&#13;&#10;        if not self.is_attacking:&#13;&#10;            self.is_attacking = True&#13;&#10;            self.attack_timer = 0.0&#13;&#10;            print(f&quot;{self.weapon_type} 공격!&quot;)&#13;&#10;            return True&#13;&#10;        return False&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;무기를 회전시켜서 그리기&quot;&quot;&quot;&#13;&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#13;&#10;        # 무기 위치 계산 (카메라 적용된 플레이어 위치 기준)&#13;&#10;        weapon_x = draw_x + self.offset_x * math.cos(self.angle)&#13;&#10;        weapon_y = draw_y + self.offset_y + self.offset_x * math.sin(self.angle)&#13;&#10;&#13;&#10;        # 좌우 반전 결정&#13;&#10;        flip = 'h' if self.player.face_dir == -1 else ''&#13;&#10;&#13;&#10;        # 회전된 무기 그리기&#13;&#10;        self.image.clip_composite_draw(&#13;&#10;            0, 0, self.image.w, self.image.h,&#13;&#10;            self.angle, flip,&#13;&#10;            weapon_x, weapon_y,&#13;&#10;            self.image.w * self.scale_factor,&#13;&#10;            self.image.h * self.scale_factor&#13;&#10;        )&#13;&#10;&#13;&#10;&#13;&#10;class Shield(Weapon):&#13;&#10;    &quot;&quot;&quot;방패 클래스 (항상 캐릭터 앞에 그려짐)&quot;&quot;&quot;&#13;&#10;    def __init__(self, player, image_path, scale=3.0):&#13;&#10;        super().__init__(player, 'shield', image_path, render_layer='front', scale=scale)&#13;&#10;        self.offset_x = -10  # 기본 X 오프셋(사용 안 함)&#13;&#10;        self.offset_y = -10  # Y 오프셋 유지&#13;&#10;&#13;&#10;        # 우클릭 방패 전개 상태&#13;&#10;        self.blocking = False&#13;&#10;        self.range_angle = 0.0&#13;&#10;&#13;&#10;        # 방패 범위 이펙트 참조 (world['effects_front']에서 관리)&#13;&#10;        self.range_effect = None&#13;&#10;&#13;&#10;        # 바라보는 방향으로 방패를 살짝 앞으로 이동시키는 오프셋(픽셀)&#13;&#10;        self.forward_offset = 18&#13;&#10;&#13;&#10;    def start_block(self):&#13;&#10;        self.blocking = True&#13;&#10;&#13;&#10;    def end_block(self):&#13;&#10;        self.blocking = False&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;방패: 우클릭 유지 시 각도를 커서 방향으로 갱신 (카메라 보정 적용)&quot;&quot;&quot;&#13;&#10;        # 인벤토리가 열려 있으면 방패 입력/전개 무시&#13;&#10;        if getattr(self.player, 'inventory_open', False):&#13;&#10;            self.blocking = False&#13;&#10;            if self.is_attacking:&#13;&#10;                dt = framework.get_delta_time()&#13;&#10;                self.attack_timer += dt&#13;&#10;                if self.attack_timer &gt;= self.attack_duration:&#13;&#10;                    self.is_attacking = False&#13;&#10;                    self.attack_timer = 0.0&#13;&#10;            return&#13;&#10;&#13;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#13;&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#13;&#10;&#13;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#13;&#10;        dx = world_mouse_x - self.player.x&#13;&#10;        dy = world_mouse_y - self.player.y&#13;&#10;&#13;&#10;        # 방패 범위 각도 계산 (라디안)&#13;&#10;        self.range_angle = math.atan2(dy, dx)&#13;&#10;&#13;&#10;        # 이전 blocking 상태 저장&#13;&#10;        was_blocking = self.blocking&#13;&#10;&#13;&#10;        # 프레임별 우클릭 유지 여부를 직접 폴링하여 blocking 동기화 (이벤트 누락 대비)&#13;&#10;        mx = ctypes.c_int(0)&#13;&#10;        my = ctypes.c_int(0)&#13;&#10;        state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#13;&#10;        try:&#13;&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#13;&#10;            self.blocking = bool(state &amp; right_mask)&#13;&#10;        except Exception:&#13;&#10;            pass&#13;&#10;&#13;&#10;        # blocking 상태가 변경되었을 때 이펙트 생성/제거&#13;&#10;        if self.blocking and not was_blocking:&#13;&#10;            # blocking 시작: 이펙트 생성&#13;&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#13;&#10;                self.range_effect = ShieldRangeEffect(self.player, self)&#13;&#10;                self.player.world['effects_front'].append(self.range_effect)&#13;&#10;        elif not self.blocking and was_blocking:&#13;&#10;            # blocking 종료: 이펙트는 자동으로 제거됨 (update에서 False 반환)&#13;&#10;            self.range_effect = None&#13;&#10;&#13;&#10;        # 기존 공격 타이머 로직 유지(필요 시)&#13;&#10;        if self.is_attacking:&#13;&#10;            dt = framework.get_delta_time()&#13;&#10;            self.attack_timer += dt&#13;&#10;            if self.attack_timer &gt;= self.attack_duration:&#13;&#10;                self.is_attacking = False&#13;&#10;                self.attack_timer = 0.0&#13;&#10;&#13;&#10;    def attack(self):&#13;&#10;        &quot;&quot;&quot;방패는 막기 동작 (현재는 사용하지 않음)&quot;&quot;&quot;&#13;&#10;        if not self.is_attacking:&#13;&#10;            self.is_attacking = True&#13;&#10;            self.attack_timer = 0.0&#13;&#10;            print(f&quot;방패로 막기!&quot;)&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;방패 본체 그리기 (범위 이미지는 world['effects_front']에서 관리)&quot;&quot;&quot;&#13;&#10;        # 방패 본체는 회전 없이 플레이어 앞에 고정&#13;&#10;        flip = 'h' if self.player.face_dir == -1 else ''&#13;&#10;        # 전개 중일 때만 앞으로 이동, 아니면 기존의 작은 좌우 오프셋 유지&#13;&#10;        if self.blocking:&#13;&#10;            local_offset_x = self.forward_offset if self.player.face_dir == 1 else -self.forward_offset&#13;&#10;        else:&#13;&#10;            local_offset_x = 10 if self.player.face_dir == -1 else -10&#13;&#10;&#13;&#10;        # 바라보는 방향에 따른 방패 로컬 오프셋 적용&#13;&#10;        weapon_x = draw_x + local_offset_x&#13;&#10;        weapon_y = draw_y + self.offset_y&#13;&#10;&#13;&#10;        self.image.clip_composite_draw(&#13;&#10;            0, 0, self.image.w, self.image.h,&#13;&#10;            0, flip,&#13;&#10;            weapon_x, weapon_y,&#13;&#10;            self.image.w * self.scale_factor,&#13;&#10;            self.image.h * self.scale_factor&#13;&#10;        )&#13;&#10;&#13;&#10;    def check_projectile_block(self, projectile):&#13;&#10;        &quot;&quot;&quot;투사체가 방패에 막혔는지 확인&#13;&#10;&#13;&#10;        Args:&#13;&#10;            projectile: 투사체 객체&#13;&#10;&#13;&#10;        Returns:&#13;&#10;            bool: 방패에 막혔으면 True, 아니면 False&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # 방패를 전개하지 않았으면 막을 수 없음&#13;&#10;        if not self.blocking:&#13;&#10;            return False&#13;&#10;&#13;&#10;        # print(f&quot;[Shield] 방패 전개 중, 투사체 충돌 체크 시작&quot;)&#13;&#10;&#13;&#10;        # 방패 중심 위치 계산&#13;&#10;        if self.blocking:&#13;&#10;            local_offset_x = self.forward_offset if self.player.face_dir == 1 else -self.forward_offset&#13;&#10;        else:&#13;&#10;            local_offset_x = 10 if self.player.face_dir == -1 else -10&#13;&#10;        shield_x = self.player.x + local_offset_x&#13;&#10;        shield_y = self.player.y + self.offset_y&#13;&#10;&#13;&#10;        # 방패 크기 (이미지 크기 * scale) - 충돌 범위를 매우 넓게&#13;&#10;        shield_width = self.image.w * self.scale_factor * 2.5  # 3배로 확대&#13;&#10;        shield_height = self.image.h * self.scale_factor * 2.5&#13;&#10;&#13;&#10;        # 투사체 크기&#13;&#10;        if hasattr(projectile, 'get_collision_box'):&#13;&#10;            proj_width, proj_height = projectile.get_collision_box()&#13;&#10;        else:&#13;&#10;            proj_width = 30&#13;&#10;            proj_height = 30&#13;&#10;&#13;&#10;        # AABB 충돌 감지&#13;&#10;        shield_left = shield_x - shield_width / 2&#13;&#10;        shield_right = shield_x + shield_width / 2&#13;&#10;        shield_bottom = shield_y - shield_height / 2&#13;&#10;        shield_top = shield_y + shield_height / 2&#13;&#10;&#13;&#10;        proj_left = projectile.x - proj_width / 2&#13;&#10;        proj_right = projectile.x + proj_width / 2&#13;&#10;        proj_bottom = projectile.y - proj_height / 2&#13;&#10;        proj_top = projectile.y + proj_height / 2&#13;&#10;&#13;&#10;        # 충돌 검사&#13;&#10;        if (shield_left &lt; proj_right and shield_right &gt; proj_left and&#13;&#10;            shield_bottom &lt; proj_top and shield_top &gt; proj_bottom):&#13;&#10;&#13;&#10;            print(f&quot;[Shield] AABB 충돌 감지!&quot;)&#13;&#10;&#13;&#10;            # 투사체가 플레이어 방향으로 날아오는지 확인&#13;&#10;            # 투사체에서 플레이어로 향하는 벡터 (투사체의 이동 방향과 유사)&#13;&#10;            proj_to_player_x = self.player.x - projectile.x&#13;&#10;            proj_to_player_y = self.player.y - projectile.y&#13;&#10;&#13;&#10;            # 투사체의 속도 벡터 확인 (투사체가 플레이어 쪽으로 오고 있는지)&#13;&#10;            if hasattr(projectile, 'dx') and hasattr(projectile, 'dy'):&#13;&#10;                # 투사체의 이동 방향과 플레이어 방향이 같은지 확인&#13;&#10;                dot_product = projectile.dx * proj_to_player_x + projectile.dy * proj_to_player_y&#13;&#10;                if dot_product &lt; 0:&#13;&#10;                    # 투사체가 플레이어에게서 멀어지고 있음 (이미 지나침)&#13;&#10;                    print(f&quot;[Shield] 투사체가 플레이어에게서 멀어지고 있음 - 방어 실패&quot;)&#13;&#10;                    return False&#13;&#10;&#13;&#10;            # 방어 이펙트 생성 (투사체 위치에 생성)&#13;&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#13;&#10;                try:&#13;&#10;                    from .guard_fx import GuardFX&#13;&#10;                    # 투사체(공격자) 위치에 이펙트 생성&#13;&#10;                    guard_fx = GuardFX(projectile.x, projectile.y, scale=self.scale_factor)&#13;&#10;                    self.player.world['effects_front'].append(guard_fx)&#13;&#10;                    print(f&quot;[Shield] 방어 이펙트 생성 완료 at ({int(projectile.x)}, {int(projectile.y)})&quot;)&#13;&#10;                except Exception as ex:&#13;&#10;                    print(f&quot;[Shield] 방어 이펙트 생성 실패: {ex}&quot;)&#13;&#10;&#13;&#10;            # 플레이어 넉백 (부드럽게)&#13;&#10;            knockback_strength = 100  # 픽셀 (초기 속도 기반)&#13;&#10;            distance = math.sqrt(proj_to_player_x**2 + proj_to_player_y**2)&#13;&#10;            if distance &gt; 0:&#13;&#10;                # 넉백 방향 계산 (투사체에서 멀어지는 방향)&#13;&#10;                self.player.knockback_dx = proj_to_player_x / distance&#13;&#10;                self.player.knockback_dy = proj_to_player_y / distance&#13;&#10;                # 넉백 속도 및 지속시간 설정&#13;&#10;                self.player.knockback_speed = knockback_strength&#13;&#10;                self.player.knockback_duration = 0.2  # 0.2초 동안 넉백&#13;&#10;                self.player.knockback_timer = 0.0  # 타이머 초기화&#13;&#10;                print(f&quot;[Shield] 방어 이펙트에 의한 넉백 발생: 방향=({self.player.knockback_dx:.2f}, {self.player.knockback_dy:.2f}), 속도={knockback_strength}&quot;)&#13;&#10;&#13;&#10;            return True&#13;&#10;&#13;&#10;        # print(f&quot;[Shield] 충돌 감지 안됨&quot;)&#13;&#10;        return False&#13;&#10;&#13;&#10;&#13;&#10;class Sword(Weapon):&#13;&#10;    &quot;&quot;&quot;검 클래스 (항상 캐릭터 뒤에 그려짐)&quot;&quot;&quot;&#13;&#10;    def __init__(self, player, image_path, scale=3.0):&#13;&#10;        super().__init__(player, 'sword', image_path, render_layer='back', scale=scale)&#13;&#10;        self.offset_x = 15  # 검은 좀 더 멀리&#13;&#10;        self.offset_y = 8 # 검의 기본 Y 오프셋&#13;&#10;&#13;&#10;        # 스테이지별(콤보) 시간 설정 (스테이지1 = 기본, 스테이지2 = 콤보)&#13;&#10;        self.stage = 1&#13;&#10;        # 기본(보정 전) 시간값 저장&#13;&#10;        self.stage1_attack_duration_base = 0.2  # 공격 모션 시간 (1스테이지)&#13;&#10;        self.stage1_attack_recovery_base = 0.3  # 후딜 (1스테이지)&#13;&#10;        self.stage2_attack_duration_base = 0.18  # 공격 모션 시간 (콤보)&#13;&#10;        self.stage2_attack_recovery_base = 0.35  # 후딜 (콤보)&#13;&#10;        self.stage3_attack_duration_base = 0.28  # 3스테이지 모션 시간&#13;&#10;        self.stage3_attack_recovery_base = 0.4   # 3스테이지 후딜&#13;&#10;&#13;&#10;        # 현재 활성화된 공격 시간 값 (초기값은 1스테이지 보정 적용)&#13;&#10;        self.attack_duration = self.stage1_attack_duration_base&#13;&#10;        self.attack_recovery = self.stage1_attack_recovery_base&#13;&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery&#13;&#10;&#13;&#10;        self.base_angle_offset = math.radians(25)  # 기본 각도 오프셋&#13;&#10;&#13;&#10;        # 공격 모션 관련 변수&#13;&#10;        self.attack_progress = 0.0  # 0.0 ~ 1.0&#13;&#10;        self.attack_angle_range = -math.radians(205)  # 0도 ~ 270도 회전 (검 자체 회전)&#13;&#10;        self.y_offset_down = -50  # progress 0.5까지 내려갈 y 오프셋&#13;&#10;&#13;&#10;        # 자전 및 공전 각도 범위 추가&#13;&#10;        self.rotation_angle_range = -math.radians(270)  # 자전: 0도 ~ 270도&#13;&#10;        self.orbit_angle_range = -math.radians(205)  # 공전: 0도 ~ 205도&#13;&#10;&#13;&#10;        # 콤보 관련 플래그&#13;&#10;        self.combo_queued = False  # 후딜 중에 콤보 입력이 들어왔는지&#13;&#10;&#13;&#10;    def _apply_speed(self, stage: int):&#13;&#10;        &quot;&quot;&quot;플레이어 stats.attack_speed로 해당 스테이지 시간값을 보정한다.&quot;&quot;&quot;&#13;&#10;        speed = 1.0&#13;&#10;        try:&#13;&#10;            if hasattr(self.player, 'stats'):&#13;&#10;                speed = max(0.1, float(self.player.stats.get('attack_speed')))&#13;&#10;        except Exception:&#13;&#10;            speed = 1.0&#13;&#10;        if stage == 1:&#13;&#10;            self.attack_duration = self.stage1_attack_duration_base / speed&#13;&#10;            self.attack_recovery = self.stage1_attack_recovery_base / speed&#13;&#10;        elif stage == 2:&#13;&#10;            self.attack_duration = self.stage2_attack_duration_base / speed&#13;&#10;            self.attack_recovery = self.stage2_attack_recovery_base / speed&#13;&#10;        elif stage == 3:&#13;&#10;            self.attack_duration = self.stage3_attack_duration_base / speed&#13;&#10;            self.attack_recovery = self.stage3_attack_recovery_base / speed&#13;&#10;        else:&#13;&#10;            pass&#13;&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;마우스 위치를 기준으로 무기 각도 계산 (카메라 보정 적용)&quot;&quot;&quot;&#13;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#13;&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#13;&#10;&#13;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#13;&#10;        dx = world_mouse_x - self.player.x&#13;&#10;        dy = world_mouse_y - self.player.y&#13;&#10;&#13;&#10;        # 각도 계산 (라디안)&#13;&#10;        self.angle = math.atan2(dy, dx)&#13;&#10;&#13;&#10;        # 공격 타이머 업데이트&#13;&#10;        if self.is_attacking:&#13;&#10;            dt = framework.get_delta_time()&#13;&#10;            self.attack_timer += dt&#13;&#10;&#13;&#10;            # 공격 progress 계산 (0.0 ~ 1.0)&#13;&#10;            if self.attack_timer &lt; self.attack_duration:&#13;&#10;                self.attack_progress = self.attack_timer / self.attack_duration&#13;&#10;            else:&#13;&#10;                self.attack_progress = 1.0&#13;&#10;&#13;&#10;            # 스테이지별 종료 처리&#13;&#10;            if self.attack_timer &gt;= self.total_attack_time:&#13;&#10;                # 3스테이지 종료 처리&#13;&#10;                if self.stage == 3:&#13;&#10;                    self.is_attacking = False&#13;&#10;                    self.attack_timer = 0.0&#13;&#10;                    self.attack_progress = 0.0&#13;&#10;                    self.stage = 1&#13;&#10;                    # 기본 스테이지 시간 복원&#13;&#10;                    self.attack_duration = self.stage1_attack_duration_base&#13;&#10;                    self.attack_recovery = self.stage1_attack_recovery_base&#13;&#10;                    self.total_attack_time = self.attack_duration + self.attack_recovery&#13;&#10;                    self.combo_queued = False&#13;&#10;                # 2스테이지 종료 처리&#13;&#10;                elif self.stage == 2:&#13;&#10;                    self.is_attacking = False&#13;&#10;                    self.attack_timer = 0.0&#13;&#10;                    self.attack_progress = 0.0&#13;&#10;                    self.stage = 1&#13;&#10;                    self.attack_duration = self.stage1_attack_duration_base&#13;&#10;                    self.attack_recovery = self.stage1_attack_recovery_base&#13;&#10;                    self.total_attack_time = self.attack_duration + self.attack_recovery&#13;&#10;                    self.combo_queued = False&#13;&#10;                else:&#13;&#10;                    # 1스테이지 종료&#13;&#10;                    self.is_attacking = False&#13;&#10;                    self.attack_timer = 0.0&#13;&#10;                    self.attack_progress = 0.0&#13;&#10;                    self.combo_queued = False&#13;&#10;&#13;&#10;    def attack(self):&#13;&#10;        &quot;&quot;&quot;공격 시작&#13;&#10;&#13;&#10;        동작 요약:&#13;&#10;        - 비공격 중이면 1스테이지 공격 시작&#13;&#10;        - 공격 중(후딜 영역)에 클릭하면 즉시 2스테이지(콤보) 공격으로 전환&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # 비공격 상태에서 시작&#13;&#10;        if not self.is_attacking:&#13;&#10;            self.is_attacking = True&#13;&#10;            self.attack_timer = 0.0&#13;&#10;            self.attack_progress = 0.0&#13;&#10;            self.stage = 1&#13;&#10;            # 스탯 보정 적용&#13;&#10;            self._apply_speed(1)&#13;&#10;            print(f&quot;{self.weapon_type} 공격! (stage 1)&quot;)&#13;&#10;&#13;&#10;            # 공격 이펙트 생성&#13;&#10;            from .player import VFX_Tier1_Sword_Swing&#13;&#10;&#13;&#10;            angle_deg = math.degrees(self.angle) % 360&#13;&#10;            if 90 &lt; angle_deg &lt; 270:  # 왼쪽 영역&#13;&#10;                flip = 'vh'&#13;&#10;            else:&#13;&#10;                flip = 'h'&#13;&#10;&#13;&#10;            attack_vfx = VFX_Tier1_Sword_Swing(&#13;&#10;                self.player.x,&#13;&#10;                self.player.y,&#13;&#10;                self.angle,&#13;&#10;                flip,&#13;&#10;                scale=4.5,&#13;&#10;                range_factor=60,&#13;&#10;                variant=1,&#13;&#10;                owner=self.player&#13;&#10;            )&#13;&#10;            # world['effects_front']에 추가 (없으면 player에 추가)&#13;&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#13;&#10;                self.player.world['effects_front'].append(attack_vfx)&#13;&#10;            else:&#13;&#10;                self.player.attack_effects.append(attack_vfx)&#13;&#10;&#13;&#10;            return True&#13;&#10;&#13;&#10;        # 공격 중일 때: 후딜 중에 콤보 입력을 받아 단계별 전환&#13;&#10;        else:&#13;&#10;            # 1스테이지 후딜에서 클릭 -&gt; 2스테이지&#13;&#10;            if self.attack_timer &gt;= self.attack_duration and self.stage == 1:&#13;&#10;                # 즉시 콤보(2스테이지)로 전환&#13;&#10;                self.stage = 2&#13;&#10;                self.attack_timer = 0.0&#13;&#10;                self.attack_progress = 0.0&#13;&#10;                # 스탯 보정 적용&#13;&#10;                self._apply_speed(2)&#13;&#10;                self.combo_queued = True&#13;&#10;                print(f&quot;{self.weapon_type} 콤보! (stage 2)&quot;)&#13;&#10;&#13;&#10;                # 콤보용 이펙트 생성&#13;&#10;                from .player import VFX_Tier1_Sword_Swing&#13;&#10;&#13;&#10;                angle_deg = math.degrees(self.angle) % 360&#13;&#10;                flip = 'vh' if 90 &lt; angle_deg &lt; 270 else 'h'&#13;&#10;&#13;&#10;                attack_vfx = VFX_Tier1_Sword_Swing(&#13;&#10;                    self.player.x,&#13;&#10;                    self.player.y,&#13;&#10;                    self.angle,&#13;&#10;                    flip,&#13;&#10;                    scale=5.5,&#13;&#10;                    range_factor=70,&#13;&#10;                    variant=2&#13;&#10;                )&#13;&#10;                # world['effects_front']에 추가 (없으면 player에 추가)&#13;&#10;                if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#13;&#10;                    self.player.world['effects_front'].append(attack_vfx)&#13;&#10;                else:&#13;&#10;                    self.player.attack_effects.append(attack_vfx)&#13;&#10;&#13;&#10;                return True&#13;&#10;&#13;&#10;            # 2스테이지 후딜에서 클릭 -&gt; 3스테이지 (헤비 스윙)&#13;&#10;            if self.attack_timer &gt;= self.attack_duration and self.stage == 2:&#13;&#10;                self.stage = 3&#13;&#10;                self.attack_timer = 0.0&#13;&#10;                self.attack_progress = 0.0&#13;&#10;                # 스탯 보정 적용&#13;&#10;                self._apply_speed(3)&#13;&#10;                self.combo_queued = True&#13;&#10;                print(f&quot;{self.weapon_type} 헤비 스윙! (stage 3)&quot;)&#13;&#10;&#13;&#10;                # 3스테이지 전용 이펙트 생성 (variant=3)&#13;&#10;                from .player import VFX_Tier1_Sword_Swing&#13;&#10;&#13;&#10;                angle_deg = math.degrees(self.angle) % 360&#13;&#10;                flip = 'vh' if 90 &lt; angle_deg &lt; 270 else 'h'&#13;&#10;&#13;&#10;                attack_vfx = VFX_Tier1_Sword_Swing(&#13;&#10;                    self.player.x,&#13;&#10;                    self.player.y,&#13;&#10;                    self.angle,&#13;&#10;                    flip,&#13;&#10;                    scale=6.0,&#13;&#10;                    range_factor=90,&#13;&#10;                    variant=3,&#13;&#10;                    owner=self.player&#13;&#10;                )&#13;&#10;                # world['effects_front']에 추가 (없으면 player에 추가)&#13;&#10;                if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#13;&#10;                    self.player.world['effects_front'].append(attack_vfx)&#13;&#10;                else:&#13;&#10;                    self.player.attack_effects.append(attack_vfx)&#13;&#10;&#13;&#10;                return True&#13;&#10;&#13;&#10;            # 그 외(공격 중이지만 아직 공격 모션 중이거나 이미 최고 단계면 무시)&#13;&#10;            return False&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        검을 회전시켜서 그리기 - 검 자체를 중심으로 회전 + 캐릭터 중심으로 공전&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 플레이어의 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 플레이어의 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # ========== 공격 모션에 따른 각도 및 오프셋 계산 ==========&#13;&#10;        sword_rotation = 0.0          # 검 자체의 회전 각도 (자전)&#13;&#10;        orbit_angle_offset = 0.0      # 캐릭터 중심 기준 공전 각도 오프셋&#13;&#10;        y_offset_modifier = 0.0       # Y축 위치 오프셋 (공격 시 아래로 내려감)&#13;&#10;&#13;&#10;        if self.is_attacking:&#13;&#10;            if self.attack_timer &lt; self.attack_duration:&#13;&#10;                # 공격 모션 중 (0 ~ attack_duration)&#13;&#10;                sword_rotation = self.rotation_angle_range * self.attack_progress  # 자전 각도&#13;&#10;                orbit_angle_offset = self.orbit_angle_range * self.attack_progress  # 공전 각도&#13;&#10;                # Y축 오프셋: 공격 시 검을 아래로 내림&#13;&#10;                y_offset_modifier = -3 * self.offset_y * self.attack_progress&#13;&#10;            else:&#13;&#10;                # 후딜레이 중 (attack_duration ~ total_attack_time)&#13;&#10;                sword_rotation = self.rotation_angle_range      # 자전 최대 각도 유지&#13;&#10;                orbit_angle_offset = self.orbit_angle_range    # 공전 최대 각도 유지&#13;&#10;                # Y축 오프셋: 후딜레이 동안 최대 아래 위치 유지&#13;&#10;                y_offset_modifier = -3 * self.offset_y&#13;&#10;&#13;&#10;        # ========== 2스테이지(콤보) 시 자전 방향 반전 ==========&#13;&#10;        # 콤보 공격 시 검이 반대 방향으로 회전하여 자연스러운 연계 공격 연출&#13;&#10;        invert_rotation = (getattr(self, 'stage', 1) == 2 and self.attack_timer &lt; self.attack_duration)&#13;&#10;        if invert_rotation:&#13;&#10;            sword_rotation = -sword_rotation&#13;&#10;&#13;&#10;        # ========== 검의 기본 각도 오프셋 ==========&#13;&#10;        base_offset = self.base_angle_offset&#13;&#10;&#13;&#10;        # ========== 마우스 위치에 따른 검의 방향 결정 ==========&#13;&#10;        angle_deg = math.degrees(self.angle) % 360&#13;&#10;&#13;&#10;        # 마우스가 왼쪽/오른쪽에 있는지에 따라 검의 위치와 반전 방향 결정&#13;&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽 영역&#13;&#10;            flip = 'v'  # 수직 반전&#13;&#10;            # 왼쪽: 공전 각도를 빼서 위치 계산&#13;&#10;            position_angle = self.angle - orbit_angle_offset&#13;&#10;            # 왼쪽: 자전 각도를 빼서 최종 각도 계산&#13;&#10;            final_angle = position_angle - sword_rotation&#13;&#10;        else:  # 오른쪽 영역&#13;&#10;            flip = ''&#13;&#10;            # 오른쪽: 공전 각도를 더해서 위치 계산&#13;&#10;            position_angle = self.angle + orbit_angle_offset&#13;&#10;            # 오른쪽: 자전 각도를 더해서 최종 각도 계산&#13;&#10;            final_angle = position_angle + sword_rotation&#13;&#10;&#13;&#10;        # ========== 검의 실제 화면 위치 계산 (카메라 적용 좌표 기준) ==========&#13;&#10;        # draw_x, draw_y는 이미 카메라가 적용된 화면 좌표이므로, 이를 기준으로 offset 적용&#13;&#10;        weapon_x = draw_x + self.offset_x * math.cos(position_angle)&#13;&#10;        weapon_y = draw_y + self.offset_y + self.offset_x * math.sin(position_angle) + y_offset_modifier&#13;&#10;&#13;&#10;        # ========== 검 이미지 그리기 ==========&#13;&#10;        self.image.clip_composite_draw(&#13;&#10;            0, 0, self.image.w, self.image.h,&#13;&#10;            final_angle + base_offset, flip,&#13;&#10;            weapon_x, weapon_y,&#13;&#10;            self.image.w * self.scale_factor,&#13;&#10;            self.image.h * self.scale_factor&#13;&#10;        )&#13;&#10;&#13;&#10;&#13;&#10;class EquipmentManager:&#13;&#10;    &quot;&quot;&quot;장비를 관리하는 매니저 클래스&quot;&quot;&quot;&#13;&#10;    def __init__(self, player):&#13;&#10;        self.player = player&#13;&#10;        self.back_equipment = []   # 캐릭터 뒤에 그려질 장비 (검 등)&#13;&#10;        self.front_equipment = []  # 캐릭터 앞에 그려질 장비 (방패 등)&#13;&#10;&#13;&#10;    def equip(self, equipment):&#13;&#10;        &quot;&quot;&quot;장비 장착&quot;&quot;&quot;&#13;&#10;        if equipment.render_layer == 'back':&#13;&#10;            self.back_equipment.append(equipment)&#13;&#10;        elif equipment.render_layer == 'front':&#13;&#10;            self.front_equipment.append(equipment)&#13;&#10;&#13;&#10;    def unequip(self, equipment):&#13;&#10;        &quot;&quot;&quot;장비 해제&quot;&quot;&quot;&#13;&#10;        if equipment in self.back_equipment:&#13;&#10;            self.back_equipment.remove(equipment)&#13;&#10;        if equipment in self.front_equipment:&#13;&#10;            self.front_equipment.remove(equipment)&#13;&#10;&#13;&#10;    def unequip_all(self):&#13;&#10;        &quot;&quot;&quot;모든 장비 해제&quot;&quot;&quot;&#13;&#10;        self.back_equipment.clear()&#13;&#10;        self.front_equipment.clear()&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;모든 장비 업데이트&quot;&quot;&quot;&#13;&#10;        for equipment in self.back_equipment + self.front_equipment:&#13;&#10;            equipment.update()&#13;&#10;&#13;&#10;    def handle_event(self, event):&#13;&#10;        &quot;&quot;&quot;장비 이벤트 처리 (좌클릭: 공격, 우클릭: 방패 전개 표시)&quot;&quot;&quot;&#13;&#10;        # 마우스 좌클릭 시 공격(검)&#13;&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#13;&#10;            for equipment in self.back_equipment:&#13;&#10;                equipment.attack()&#13;&#10;&#13;&#10;        # 마우스 우클릭: 방패 범위 표시 시작/종료&#13;&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_RIGHT:&#13;&#10;            # 디버그: 우클릭 다운 수신&#13;&#10;            try:&#13;&#10;                print('[Shield] RIGHT DOWN')&#13;&#10;            except Exception:&#13;&#10;                pass&#13;&#10;            for equipment in self.front_equipment:&#13;&#10;                if isinstance(equipment, Shield):&#13;&#10;                    equipment.start_block()&#13;&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_RIGHT:&#13;&#10;            # 디버그: 우클릭 업 수신&#13;&#10;            try:&#13;&#10;                print('[Shield] RIGHT UP')&#13;&#10;            except Exception:&#13;&#10;                pass&#13;&#10;            for equipment in self.front_equipment:&#13;&#10;                if isinstance(equipment, Shield):&#13;&#10;                    equipment.end_block()&#13;&#10;&#13;&#10;    def draw_back(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;캐릭터 뒤에 그려질 장비들&quot;&quot;&quot;&#13;&#10;        for equipment in self.back_equipment:&#13;&#10;            equipment.draw(draw_x, draw_y)&#13;&#10;&#13;&#10;    def draw_front(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;캐릭터 앞에 그려질 장비들&quot;&quot;&quot;&#13;&#10;        for equipment in self.front_equipment:&#13;&#10;            equipment.draw(draw_x, draw_y)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/loading_screen.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/loading_screen.py" />
              <option name="originalContent" value="# game_logic/loading_screen.py&#10;&quot;&quot;&quot;스테이지 로딩 화면 모듈&quot;&quot;&quot;&#10;&#10;import pico2d as p2&#10;from . import framework&#10;&#10;class LoadingScreen:&#10;    &quot;&quot;&quot;스테이지 로딩 화면 클래스&quot;&quot;&quot;&#10;&#10;    def __init__(self, loading_info):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            loading_info: 스테이지 모듈의 LOADING_SCREEN_INFO 딕셔너리&#10;                - stage_number: 스테이지 번호&#10;                - bg_image: 배경 이미지 경로&#10;                - animation_prefix: 애니메이션 이미지 경로 접두사&#10;                - animation_count: 애니메이션 프레임 수&#10;                - extra_animation (optional): 추가 애니메이션 정보&#10;        &quot;&quot;&quot;&#10;        self.loading_info = loading_info&#10;        self.stage_number = loading_info['stage_number']&#10;        self.bg_image = None&#10;        self.black_bg = None  # 검정 배경 이미지&#10;        self.loading_images = []&#10;        self.extra_images = []  # 추가 애니메이션 이미지&#10;        self.current_frame = 0&#10;        self.animation_time = 0.0&#10;        self.animation_speed = 10  # fps&#10;        self.is_complete = False&#10;        self.loading_duration = 0.0  # 로딩 경과 시간&#10;        self.min_loading_time = 3.0  # 최소 로딩 시간 (초)&#10;&#10;        # 이미지 로드&#10;        self._load_images()&#10;&#10;        print(f&quot;[LoadingScreen] Stage {self.stage_number} 로딩 화면 초기화 완료&quot;)&#10;&#10;    def _load_images(self):&#10;        &quot;&quot;&quot;로딩 화면 이미지들을 로드&quot;&quot;&quot;&#10;        try:&#10;            # 검정 배경 이미지 로드&#10;            black_bg_path = 'resources/Texture_organize/UI/Stage_Loading/BlackBG.png'&#10;            self.black_bg = p2.load_image(black_bg_path)&#10;            print(f&quot;[LoadingScreen] 검정 배경 이미지 로드 완료: {black_bg_path}&quot;)&#10;&#10;            # 배경 이미지 로드&#10;            bg_path = self.loading_info['bg_image']&#10;            self.bg_image = p2.load_image(bg_path)&#10;            print(f&quot;[LoadingScreen] 배경 이미지 로드 완료: {bg_path}&quot;)&#10;&#10;            # 로딩 애니메이션 이미지 로드&#10;            animation_prefix = self.loading_info['animation_prefix']&#10;            animation_count = self.loading_info['animation_count']&#10;&#10;            for i in range(animation_count):&#10;                img_path = f'{animation_prefix}{i:02d}.png'&#10;                img = p2.load_image(img_path)&#10;                self.loading_images.append(img)&#10;            print(f&quot;[LoadingScreen] 로딩 애니메이션 {len(self.loading_images)}개 이미지 로드 완료&quot;)&#10;&#10;            # 추가 애니메이션 로드 (있는 경우)&#10;            extra_anim = self.loading_info.get('extra_animation')&#10;            if extra_anim:&#10;                extra_prefix = extra_anim['prefix']&#10;                extra_count = extra_anim['count']&#10;&#10;                for i in range(extra_count):&#10;                    img_path = f'{extra_prefix}{i:02d}.png'&#10;                    img = p2.load_image(img_path)&#10;                    self.extra_images.append(img)&#10;                print(f&quot;[LoadingScreen] 추가 애니메이션 {len(self.extra_images)}개 이미지 로드 완료&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[LoadingScreen] 이미지 로드 실패: {e}\033[0m&quot;)&#10;            # 로드 실패 시 빈 이미지 리스트로 계속 진행&#10;            self.loading_images = []&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;로딩 화면 업데이트&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;        self.loading_duration += dt&#10;&#10;        # 애니메이션 업데이트&#10;        if len(self.loading_images) &gt; 0:&#10;            self.animation_time += dt&#10;            if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;                self.current_frame = (self.current_frame + 1) % len(self.loading_images)&#10;                self.animation_time = 0.0&#10;&#10;        # 최소 로딩 시간이 지나면 완료 표시&#10;        if self.loading_duration &gt;= self.min_loading_time:&#10;            self.is_complete = True&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;로딩 화면 그리기&quot;&quot;&quot;&#10;        # 캔버스 중앙 좌표 계산&#10;        canvas_width = p2.get_canvas_width()&#10;        canvas_height = p2.get_canvas_height()&#10;        center_x = canvas_width // 2&#10;        center_y = canvas_height // 2&#10;        scale = 5.0&#10;&#10;        # 캔버스 클리어&#10;        p2.clear_canvas()&#10;&#10;        # 검정 배경 이미지로 전체 화면 채우기 (192x108을 화면 크기로 늘림)&#10;        if self.black_bg:&#10;            self.black_bg.draw(center_x, center_y, canvas_width, canvas_height)&#10;&#10;        # 배경 그리기&#10;        if self.bg_image:&#10;            self.bg_image.draw(center_x, center_y * 1.656, canvas_width, canvas_height // 2)&#10;&#10;        # 로딩 애니메이션 그리기&#10;        if len(self.loading_images) &gt; 0:&#10;            loading_img = self.loading_images[self.current_frame]&#10;            # 화면 하단 중앙에 로딩 애니메이션 배치&#10;            loading_x = center_x&#10;            loading_y = canvas_height // 4  # 하단 1/4 위치&#10;&#10;            # 로딩 애니메이션 크기 설정&#10;            loading_width = loading_img.w * scale&#10;            loading_height = loading_img.h * scale&#10;&#10;            loading_img.draw(loading_x, loading_y * 3.18, loading_width, loading_height)&#10;&#10;        # 추가 애니메이션 그리기 (카트 등)&#10;        if len(self.extra_images) &gt; 0:&#10;            extra_anim = self.loading_info.get('extra_animation', {})&#10;            extra_scale = extra_anim.get('scale', 5.0)&#10;            position = extra_anim.get('position', 'bottom_left')&#10;&#10;            extra_img = self.extra_images[self.current_frame]&#10;            extra_width = extra_img.w * extra_scale&#10;            extra_height = extra_img.h * extra_scale&#10;&#10;            # 위치에 따라 좌표 계산&#10;            if position == 'bottom_left':&#10;                extra_x = canvas_width // 4  # 왼쪽 1/4 지점&#10;                extra_y = canvas_height // 4  # 하단 1/4 위치&#10;            elif position == 'bottom_right':&#10;                extra_x = canvas_width * 3 // 4  # 오른쪽 3/4 지점&#10;                extra_y = canvas_height // 4&#10;            elif position == 'center':&#10;                extra_x = center_x&#10;                extra_y = center_y&#10;            elif position == 'Cart':&#10;                extra_x = canvas_width // 2 * 1.1&#10;                extra_y = canvas_height // 2 * 1.3&#10;            else:&#10;                extra_x = canvas_width // 4&#10;                extra_y = canvas_height // 4&#10;&#10;            extra_img.draw(extra_x, extra_y, extra_width, extra_height)&#10;&#10;        # 로딩 텍스트 (옵션)&#10;        # p2.draw_text를 사용하려면 폰트 설정이 필요합니다&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;이벤트 처리 (로딩 중에는 입력 무시)&quot;&quot;&quot;&#10;        pass&#10;" />
              <option name="updatedContent" value="# game_logic/loading_screen.py&#13;&#10;&quot;&quot;&quot;스테이지 로딩 화면 모듈&quot;&quot;&quot;&#13;&#10;&#13;&#10;import pico2d as p2&#13;&#10;from . import framework&#13;&#10;&#13;&#10;class LoadingScreen:&#13;&#10;    &quot;&quot;&quot;스테이지 로딩 화면 클래스&quot;&quot;&quot;&#13;&#10;&#13;&#10;    def __init__(self, loading_info):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Args:&#13;&#10;            loading_info: 스테이지 모듈의 LOADING_SCREEN_INFO 딕셔너리&#13;&#10;                - stage_number: 스테이지 번호&#13;&#10;                - bg_image: 배경 이미지 경로&#13;&#10;                - animation_prefix: 애니메이션 이미지 경로 접두사&#13;&#10;                - animation_count: 애니메이션 프레임 수&#13;&#10;                - extra_animation (optional): 추가 애니메이션 정보&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.loading_info = loading_info&#13;&#10;        self.stage_number = loading_info['stage_number']&#13;&#10;        self.bg_image = None&#13;&#10;        self.black_bg = None  # 검정 배경 이미지&#13;&#10;        self.loading_images = []&#13;&#10;        self.extra_images = []  # 추가 애니메이션 이미지&#13;&#10;        self.current_frame = 0&#13;&#10;        self.animation_time = 0.0&#13;&#10;        self.animation_speed = 10  # fps&#13;&#10;        self.is_complete = False&#13;&#10;        self.loading_duration = 0.0  # 로딩 경과 시간&#13;&#10;        self.min_loading_time = 3.0  # 최소 로딩 시간 (초)&#13;&#10;&#13;&#10;        # 이미지 로드&#13;&#10;        self._load_images()&#13;&#10;&#13;&#10;        print(f&quot;[LoadingScreen] Stage {self.stage_number} 로딩 화면 초기화 완료&quot;)&#13;&#10;&#13;&#10;    def _load_images(self):&#13;&#10;        &quot;&quot;&quot;로딩 화면 이미지들을 로드&quot;&quot;&quot;&#13;&#10;        try:&#13;&#10;            # 검정 배경 이미지 로드&#13;&#10;            black_bg_path = 'resources/Texture_organize/UI/Stage_Loading/BlackBG.png'&#13;&#10;            self.black_bg = p2.load_image(black_bg_path)&#13;&#10;            print(f&quot;[LoadingScreen] 검정 배경 이미지 로드 완료: {black_bg_path}&quot;)&#13;&#10;&#13;&#10;            # 배경 이미지 로드&#13;&#10;            bg_path = self.loading_info['bg_image']&#13;&#10;            self.bg_image = p2.load_image(bg_path)&#13;&#10;            print(f&quot;[LoadingScreen] 배경 이미지 로드 완료: {bg_path}&quot;)&#13;&#10;&#13;&#10;            # 로딩 애니메이션 이미지 로드&#13;&#10;            animation_prefix = self.loading_info['animation_prefix']&#13;&#10;            animation_count = self.loading_info['animation_count']&#13;&#10;&#13;&#10;            for i in range(animation_count):&#13;&#10;                img_path = f'{animation_prefix}{i:02d}.png'&#13;&#10;                img = p2.load_image(img_path)&#13;&#10;                self.loading_images.append(img)&#13;&#10;            print(f&quot;[LoadingScreen] 로딩 애니메이션 {len(self.loading_images)}개 이미지 로드 완료&quot;)&#13;&#10;&#13;&#10;            # 추가 애니메이션 로드 (있는 경우)&#13;&#10;            extra_anim = self.loading_info.get('extra_animation')&#13;&#10;            if extra_anim:&#13;&#10;                extra_prefix = extra_anim['prefix']&#13;&#10;                extra_count = extra_anim['count']&#13;&#10;&#13;&#10;                for i in range(extra_count):&#13;&#10;                    img_path = f'{extra_prefix}{i:02d}.png'&#13;&#10;                    img = p2.load_image(img_path)&#13;&#10;                    self.extra_images.append(img)&#13;&#10;                print(f&quot;[LoadingScreen] 추가 애니메이션 {len(self.extra_images)}개 이미지 로드 완료&quot;)&#13;&#10;&#13;&#10;        except Exception as e:&#13;&#10;            print(f&quot;\033[91m[LoadingScreen] 이미지 로드 실패: {e}\033[0m&quot;)&#13;&#10;            # 로드 실패 시 빈 이미지 리스트로 계속 진행&#13;&#10;            self.loading_images = []&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;로딩 화면 업데이트&quot;&quot;&quot;&#13;&#10;        dt = framework.get_delta_time()&#13;&#10;        self.loading_duration += dt&#13;&#10;&#13;&#10;        # 애니메이션 업데이트&#13;&#10;        if len(self.loading_images) &gt; 0:&#13;&#10;            self.animation_time += dt&#13;&#10;            if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;                self.current_frame = (self.current_frame + 1) % len(self.loading_images)&#13;&#10;                self.animation_time = 0.0&#13;&#10;&#13;&#10;        # 최소 로딩 시간이 지나면 완료 표시&#13;&#10;        if self.loading_duration &gt;= self.min_loading_time:&#13;&#10;            self.is_complete = True&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self):&#13;&#10;        &quot;&quot;&quot;로딩 화면 그리기&quot;&quot;&quot;&#13;&#10;        # 캔버스 중앙 좌표 계산&#13;&#10;        canvas_width = p2.get_canvas_width()&#13;&#10;        canvas_height = p2.get_canvas_height()&#13;&#10;        center_x = canvas_width // 2&#13;&#10;        center_y = canvas_height // 2&#13;&#10;        scale = 5.0&#13;&#10;&#13;&#10;        # 캔버스 클리어&#13;&#10;        p2.clear_canvas()&#13;&#10;&#13;&#10;        # 검정 배경 이미지로 전체 화면 채우기 (192x108을 화면 크기로 늘림)&#13;&#10;        if self.black_bg:&#13;&#10;            self.black_bg.draw(center_x, center_y, canvas_width, canvas_height)&#13;&#10;&#13;&#10;        # 배경 그리기&#13;&#10;        if self.bg_image:&#13;&#10;            self.bg_image.draw(center_x, center_y * 1.656, canvas_width, canvas_height // 2)&#13;&#10;&#13;&#10;        # 로딩 애니메이션 그리기&#13;&#10;        if len(self.loading_images) &gt; 0:&#13;&#10;            loading_img = self.loading_images[self.current_frame]&#13;&#10;            # 화면 하단 중앙에 로딩 애니메이션 배치&#13;&#10;            loading_x = center_x&#13;&#10;            loading_y = canvas_height // 4  # 하단 1/4 위치&#13;&#10;&#13;&#10;            # 로딩 애니메이션 크기 설정&#13;&#10;            loading_width = loading_img.w * scale&#13;&#10;            loading_height = loading_img.h * scale&#13;&#10;&#13;&#10;            loading_img.draw(loading_x, loading_y * 3.18, loading_width, loading_height)&#13;&#10;&#13;&#10;        # 추가 애니메이션 그리기 (카트 등)&#13;&#10;        if len(self.extra_images) &gt; 0:&#13;&#10;            extra_anim = self.loading_info.get('extra_animation', {})&#13;&#10;            extra_scale = extra_anim.get('scale', 5.0)&#13;&#10;            position = extra_anim.get('position', 'bottom_left')&#13;&#10;&#13;&#10;            extra_img = self.extra_images[self.current_frame]&#13;&#10;            extra_width = extra_img.w * extra_scale&#13;&#10;            extra_height = extra_img.h * extra_scale&#13;&#10;&#13;&#10;            # 위치에 따라 좌표 계산&#13;&#10;            if position == 'bottom_left':&#13;&#10;                extra_x = canvas_width // 4  # 왼쪽 1/4 지점&#13;&#10;                extra_y = canvas_height // 4  # 하단 1/4 위치&#13;&#10;            elif position == 'bottom_right':&#13;&#10;                extra_x = canvas_width * 3 // 4  # 오른쪽 3/4 지점&#13;&#10;                extra_y = canvas_height // 4&#13;&#10;            elif position == 'center':&#13;&#10;                extra_x = center_x&#13;&#10;                extra_y = center_y&#13;&#10;            elif position == 'Cart':&#13;&#10;                extra_x = canvas_width // 2 * 1.1&#13;&#10;                extra_y = canvas_height // 2 * 1.3&#13;&#10;            else:&#13;&#10;                extra_x = canvas_width // 4&#13;&#10;                extra_y = canvas_height // 4&#13;&#10;&#13;&#10;            extra_img.draw(extra_x, extra_y, extra_width, extra_height)&#13;&#10;&#13;&#10;        # 로딩 텍스트 (옵션)&#13;&#10;        # p2.draw_text를 사용하려면 폰트 설정이 필요합니다&#13;&#10;&#13;&#10;    def handle_event(self, e):&#13;&#10;        &quot;&quot;&quot;이벤트 처리 (로딩 중에는 입력 무시)&quot;&quot;&quot;&#13;&#10;        pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/lobby_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/lobby_mode.py" />
              <option name="originalContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#10;# minimal, compatible with existing game_logic modules&#10;import pico2d as p2&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#10;&#10;import game_framework&#10;from .player import Player&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar&#10;from .cursor import Cursor&#10;from .loading_screen import LoadingScreen&#10;from . import defeat_mode&#10;# 사용할 스테이지 모듈들을 import 합니다.&#10;from .stages import stage_1, stage_2&#10;from PIL import Image&#10;import math&#10;&#10;# world layers: keep same keys as original main.py&#10;world = {&#10;    'sky' : [],&#10;    'ground': [],&#10;    'upper_ground': [],&#10;    'walls': [],&#10;    'effects_back': [],&#10;    'entities': [],&#10;    'effects_front': [],&#10;    'ui': [],&#10;    'extra_bg': [],&#10;    'extras': [],&#10;    'cursor': []&#10;}&#10;world['bg'] = world['ground']&#10;world['player'] = world['entities']  # 플레이어 참조를 위한 키 추가&#10;world_list = ['sky', 'ground', 'upper_ground', 'walls', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']&#10;&#10;class Camera:&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#10;        self.target = target&#10;        self.x = target.x&#10;        self.y = target.y&#10;        self.map_width = map_width&#10;        self.map_height = map_height&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1)&#10;&#10;    def update(self):&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP)&#10;        target_x = self.target.x&#10;        target_y = self.target.y&#10;        self.x += (target_x - self.x) * self.smooth&#10;        self.y += (target_y - self.y) * self.smooth&#10;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#10;        min_x = -self.map_width/2&#10;        max_x = self.map_width/2&#10;        min_y = -self.map_height/2&#10;        max_y = self.map_height/2&#10;&#10;        self.x = max(min_x, min(self.x, max_x))&#10;        self.y = max(min_y, min(self.y, max_y))&#10;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#10;        if self.map_width &lt;= self.screen_width:&#10;            self.x = 0&#10;        if self.map_height &lt;= self.screen_height:&#10;            self.y = 0&#10;        # self.x, self.y는 맵 중심 기준 카메라 위치&#10;        # 화면 중앙이 (0,0)이 되도록 보정&#10;&#10;    def apply(self, obj_x, obj_y):&#10;        # 카메라 위치만큼 오브젝트 위치 보정 (화면 중앙 기준)&#10;        # obj_x, obj_y: 맵 중심(0,0) 기준 좌표&#10;        # 반환값: 화면에 그릴 좌표 (pico2d 기준, 화면 중앙이 0,0)&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#10;&#10;# Camera 객체를 전역으로 선언&#10;camera = None&#10;&#10;def calculate_background_bounds():&#10;    &quot;&quot;&quot;&#10;    sky와 ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#10;&#10;    Returns:&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#10;    &quot;&quot;&quot;&#10;    min_x = float('inf')&#10;    max_x = float('-inf')&#10;    min_y = float('inf')&#10;    max_y = float('-inf')&#10;&#10;    # sky와 ground 레이어의 모든 객체를 순회&#10;    for layer_name in ['sky', 'ground']:&#10;        for obj in world[layer_name]:&#10;            # 객체가 x, y, image, scale 속성을 가지고 있는지 확인&#10;            if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image') and hasattr(obj, 'scale'):&#10;                # 객체의 중심 좌표&#10;                obj_x = obj.x&#10;                obj_y = obj.y&#10;&#10;                # 이미지 크기 계산 (scale 적용)&#10;                img_width = obj.image.w * obj.scale&#10;                img_height = obj.image.h * obj.scale&#10;&#10;                # 객체의 경계 계산 (중심 기준이므로 절반씩)&#10;                obj_left = obj_x - img_width / 2&#10;                obj_right = obj_x + img_width / 2&#10;                obj_bottom = obj_y - img_height / 2&#10;                obj_top = obj_y + img_height / 2&#10;&#10;                # 최소/최대 값 업데이트&#10;                min_x = min(min_x, obj_left)&#10;                max_x = max(max_x, obj_right)&#10;                min_y = min(min_y, obj_bottom)&#10;                max_y = max(max_y, obj_top)&#10;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환&#10;    if min_x == float('inf') or max_x == float('-inf'):&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#10;        return (-800, 800, -600, 600)&#10;&#10;    print(f&quot;[lobby_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#10;    return (min_x, max_x, min_y, max_y)&#10;&#10;def enter():&#10;    global world, camera&#10;    print(&quot;[lobby_mode] Starting enter()...&quot;)&#10;&#10;    # clear existing&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#10;&#10;    # sky&#10;    print(&quot;[lobby_mode] Creating Sky...&quot;)&#10;    whiteBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/WhiteBG.png'&#10;    skyBackGroundPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloudBall_Gradation.png'&#10;    skyBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Back.png'&#10;    skyMidPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Mid.png'&#10;    skyFrontPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Front.png'&#10;    cloudPropPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Prop.png'&#10;    whiteBack = LobbySky(whiteBackPath, 0, 0, 6.5)&#10;    skyBackGround = LobbySky(skyBackGroundPath, 0, 0, 5.4)&#10;    skyBack = LobbySky(skyBackPath, 0, 200)&#10;    skyMid = LobbySky(skyMidPath, 0, 0)&#10;    skyFront = LobbySky(skyFrontPath, 0, -200)&#10;    cloudProp = LobbySky(cloudPropPath, 0, -400)&#10;&#10;    world['sky'].append(whiteBack)&#10;    world['sky'].append(skyBackGround)&#10;    world['sky'].append(skyBack)&#10;    world['sky'].append(skyMid)&#10;    world['sky'].append(skyFront)&#10;    world['sky'].append(cloudProp)&#10;&#10;    # background&#10;    print(&quot;[lobby_mode] Creating Background...&quot;)&#10;    bg = LobbyBackGround()&#10;    world['bg'].append(bg)&#10;&#10;    # 낭떠러지(투명 영역) 벽 자동 생성&#10;    try:&#10;        print(&quot;[DEBUG] wall_blocks 생성 시도 중...&quot;)&#10;        # 배경의 화면 위치와 스케일을 전달&#10;        wall_blocks = generate_walls_from_png(&#10;            'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png',&#10;            block_size=8,&#10;            bg_x=bg.x,&#10;            bg_y=bg.y,&#10;            scale=bg.scale&#10;        )&#10;        print(f&quot;[DEBUG] wall_blocks 반환: {len(wall_blocks)}개&quot;)&#10;        for wall in wall_blocks:&#10;            world['walls'].append(wall)&#10;            pass&#10;        print(f&quot;[lobby_mode] Generated {len(wall_blocks)} walls from PNG transparency.&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Wall generation from PNG failed: {ex}\033[0m&quot;)&#10;&#10;    # create portal to play mode&#10;    print(&quot;[lobby_mode] Creating EnterTreePortal...&quot;)&#10;    try:&#10;        # 백그라운드 이미지와 스케일에 맞춰 가로 중앙, 세로는 위에서 30% 아래에 배치&#10;        portal_x = bg.x&#10;        portal_y = bg.y + (bg.image.h * bg.scale) / 2 - (bg.image.h * bg.scale) * 0.3&#10;        enterTree = EnterTreePortal(portal_x, portal_y, scale=bg.scale)&#10;        world['upper_ground'].append(enterTree)&#10;        print(f&quot;[lobby_mode] EnterTreePortal created at ({portal_x}, {portal_y}) with scale {bg.scale}&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Failed to create EnterTreePortal: {ex}\033[0m&quot;)&#10;&#10;    print(&quot;[lobby_mode] Creating player...&quot;)&#10;    # create player (use fallback if heavy Player init fails)&#10;    try:&#10;        player = Player()&#10;        player.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;        player.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;        print(&quot;[lobby_mode] Player created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#10;        from .inventory import InventoryData, seed_debug_inventory&#10;&#10;        class _FallbackPlayer:&#10;            def __init__(self):&#10;                self.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;                self.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;                self.face_dir = 1&#10;                self.scale_factor = 1.0&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;                self.particles = []&#10;                self.attack_effects = []&#10;                self.inventory = InventoryData(cols=6, rows=5)&#10;                try:&#10;                    seed_debug_inventory(self.inventory)&#10;                except Exception:&#10;                    print(&quot;\033[91m[lobby_mode] seed_debug_inventory failed\033[0m&quot;)&#10;                    pass&#10;                self.inventory_open = False&#10;&#10;            def update(self):&#10;                return True&#10;&#10;            def rebuild_inventory_passives(self):&#10;                return&#10;&#10;            def consume_item_at(self, r, c):&#10;                return False&#10;&#10;        player = _FallbackPlayer()&#10;&#10;    print(&quot;[lobby_mode] Attaching world reference to player...&quot;)&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#10;    try:&#10;        player.world = world&#10;    except Exception:&#10;        print(&quot;\033[91m[lobby_mode] Failed to attach world to player\033[0m&quot;)&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#10;    world['entities'].append(player)&#10;&#10;    # Camera 초기화 (Player를 target으로 설정)&#10;    # sky와 ground 레이어의 실제 배경 범위를 계산하여 카메라 제한 범위로 사용&#10;    try:&#10;        # 배경 범위 계산 (sky와 ground 레이어의 모든 객체 고려)&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;&#10;        # 배경 전체 크기 계산&#10;        map_width = max_x - min_x&#10;        map_height = max_y - min_y&#10;&#10;        screen_width = p2.get_canvas_width()&#10;        screen_height = p2.get_canvas_height()&#10;&#10;        global camera&#10;        camera = Camera(player, map_width, map_height, screen_width, screen_height)&#10;&#10;        # 카메라에 실제 배경 범위의 중심점 정보 전달 (오프셋 계산용)&#10;        camera.map_offset_x = (min_x + max_x) / 2&#10;        camera.map_offset_y = (min_y + max_y) / 2&#10;&#10;        print(f&quot;[lobby_mode] Camera initialized for player at ({player.x}, {player.y})&quot;)&#10;        print(f&quot;[lobby_mode] Map size: {map_width:.1f} x {map_height:.1f}, Offset: ({camera.map_offset_x:.1f}, {camera.map_offset_y:.1f})&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Camera initialization failed: {ex}\033[0m&quot;)&#10;&#10;    print(&quot;[lobby_mode] Creating inventory overlay...&quot;)&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#10;    try:&#10;        inv = InventoryOverlay(player, world)&#10;        print(&quot;[lobby_mode] InventoryOverlay created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] InventoryOverlay init failed, creating minimal stub: {ex}\033[0m&quot;)&#10;&#10;        class _InvStub:&#10;            def __init__(self, player, world=None):&#10;                self.player = player&#10;                self.world = world&#10;                self.dragging = False&#10;                self.drag_from = None&#10;                self.drag_icon = None&#10;                self.drag_qty = 0&#10;            def handle_event(self, e):&#10;                return&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        inv = _InvStub(player, world)&#10;    world['ui'].append(inv)&#10;&#10;    print(&quot;[lobby_mode] Creating cursor...&quot;)&#10;    # cursor on top (safe fallback)&#10;    try:&#10;        cursor = Cursor(player)&#10;        print(&quot;[lobby_mode] Cursor created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Cursor init failed, using stub cursor: {ex}\033[0m&quot;)&#10;&#10;        class _CursorStub:&#10;            def __init__(self, player=None):&#10;                self.player = player&#10;                self.x = 0&#10;                self.y = 0&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;            def handle_event(self, e):&#10;                return&#10;&#10;        cursor = _CursorStub(player)&#10;    world['cursor'].append(cursor)&#10;&#10;    # expose world to __main__ for legacy code that looks up main.world&#10;    try:&#10;        import sys&#10;        main_mod = sys.modules.get('__main__')&#10;        if main_mod is not None:&#10;            setattr(main_mod, 'world', world)&#10;    except Exception:&#10;        print(&quot;\033[91m[lobby_mode] Failed to expose world to __main__\033[0m&quot;)&#10;&#10;&#10;def exit():&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#10;&#10;&#10;def handle_events():&#10;    import game_framework as app_framework&#10;&#10;    events = p2.get_events()&#10;    player = world.get('player')&#10;    portal_triggered = False&#10;&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            app_framework.quit()&#10;            return&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#10;            app_framework.quit()&#10;            return&#10;        # F키 입력 시 포탈 충돌 체크&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == p2.SDLK_f:&#10;            for obj in world['upper_ground']:&#10;                if isinstance(obj, EnterTreePortal) and player:&#10;                    if obj.check_player_collision(player):&#10;                        if not portal_triggered:&#10;                            from . import play_mode&#10;                            print('[lobby_mode] EnterTreePortal triggered: switching to play_mode')&#10;                            app_framework.change_state(play_mode)&#10;                            portal_triggered = True&#10;&#10;        # broadcast to entities -&gt; ui -&gt; cursor&#10;        for o in list(world['entities']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for entity\033[0m&quot;)&#10;        for o in list(world['ui']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for UI\033[0m&quot;)&#10;        for o in list(world['cursor']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for cursor\033[0m&quot;)&#10;&#10;&#10;def update():&#10;    global camera&#10;    # 카메라 업데이트 추가&#10;    if camera is not None:&#10;        camera.update()&#10;&#10;    # 일반 게임 업데이트&#10;    for layer_name in world_list:&#10;        new_list = []&#10;        for o in list(world[layer_name]):&#10;            try:&#10;                if hasattr(o, 'update'):&#10;                    alive = o.update()&#10;                    if alive is False:&#10;                        continue&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to update object\033[0m&quot;)&#10;&#10;            # mark_for_removal 플래그 확인&#10;            if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#10;                print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#10;                continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#10;&#10;            new_list.append(o)&#10;        world[layer_name][:] = new_list&#10;&#10;    # 충돌 검사 시스템&#10;    from .projectile import Projectile&#10;    player = world.get('player')&#10;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#10;    effects_to_remove = set()&#10;    projectiles_to_remove = set()&#10;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#10;    for effect in world['effects_front']:&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#10;            for entity in world['entities']:&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#10;                    if entity.check_collision_with_effect(effect):&#10;                        # 디버그: 충돌 정보 출력&#10;                        attacker_name = &quot;Player&quot;&#10;                        if hasattr(effect, 'owner'):&#10;                            attacker_name = effect.owner.__class__.__name__&#10;                        target_name = entity.__class__.__name__&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#10;                        pass&#10;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#10;    if player:&#10;        for projectile in world['effects_front']:&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#10;            if isinstance(projectile, Projectile):&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#10;                if not projectile.from_player:&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#10;                        if player.check_collision_with_projectile(projectile):&#10;                            # 디버그: 충돌 정보 출력&#10;                            attacker_name = &quot;Unknown&quot;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#10;                                attacker_name = projectile.owner.__class__.__name__&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#10;                            projectiles_to_remove.add(projectile)&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#10;                else:&#10;                    for entity in world['entities']:&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#10;                            if entity.check_collision_with_projectile(projectile):&#10;                                # 디버그: 충돌 정보 출력&#10;                                target_name = entity.__class__.__name__&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#10;                                projectiles_to_remove.add(projectile)&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#10;&#10;    # 충돌한 투사체 제거&#10;    if projectiles_to_remove:&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#10;&#10;    # 포탈 위에 텍스트 표시&#10;    for obj in world['upper_ground']:&#10;        if isinstance(obj, EnterTreePortal) and player:&#10;            if obj.check_player_collision(player):&#10;                obj.trigger = True&#10;            else:&#10;                obj.trigger = False&#10;&#10;def draw():&#10;    global camera&#10;    p2.clear_canvas()&#10;    # 하늘을 가장 먼저 그리기 (배경 뒤)&#10;    for obj in world['sky']:&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y'):&#10;            if camera is not None:&#10;                draw_x, draw_y = camera.apply(obj.x, obj.y)&#10;            else:&#10;                draw_x, draw_y = obj.x, obj.y&#10;            if hasattr(obj, 'draw'):&#10;                obj.draw(draw_x, draw_y)&#10;        else:&#10;            if hasattr(obj, 'draw'):&#10;                obj.draw()&#10;&#10;    # 나머지 레이어들 (배경, 벽, 엔티티 등)&#10;    for layer in ['ground', 'walls', 'upper_ground', 'entities', 'effects_back', 'effects_front', 'extra_bg', 'extras']:&#10;        for obj in world[layer]:&#10;            if hasattr(obj, 'x') and hasattr(obj, 'y'):&#10;                if camera is not None:&#10;                    draw_x, draw_y = camera.apply(obj.x, obj.y)&#10;                else:&#10;                    draw_x, draw_y = obj.x, obj.y&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw(draw_x, draw_y)&#10;            else:&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw()&#10;    # UI, cursor 등은 카메라 적용하지 않음&#10;    for obj in world['ui']:&#10;        if hasattr(obj, 'draw'):&#10;            obj.draw()&#10;    for obj in world['cursor']:&#10;        if hasattr(obj, 'draw'):&#10;            obj.draw()&#10;    p2.update_canvas()&#10;&#10;class LobbySky:&#10;    def __init__(self, path, x=0, y=0, scale=3):&#10;        self.image = p2.load_image(path)&#10;        self.scale = scale&#10;        self.x = x  # 화면 중심(0,0) 기준&#10;        self.y = y  # 화면 중심(0,0) 기준&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        self.image.draw(draw_x, draw_y, self.image.w * self.scale * 2,&#10;                        self.image.h * self.scale * 1.5)&#10;        # 디버그용 히트박스 (필요시 주석 처리)&#10;        # p2.draw_rectangle(draw_x - (self.image.w * self.scale) / 2,&#10;        #                   draw_y - (self.image.h * self.scale) / 2,&#10;        #                   draw_x + (self.image.w * self.scale) / 2,&#10;        #                   draw_y + (self.image.h * self.scale) / 2)&#10;&#10;&#10;class LobbyBackGround:&#10;    image = None&#10;    def __init__(self):&#10;        if LobbyBackGround.image is None:&#10;            LobbyBackGround.image = p2.load_image('resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png')&#10;        self.scale = 6.5&#10;        self.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;        self.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        LobbyBackGround.image.draw(draw_x, draw_y, LobbyBackGround.image.w * self.scale, LobbyBackGround.image.h * self.scale)&#10;        # p2.draw_rectangle(draw_x - (LobbyBackGround.image.w * self.scale) / 2,&#10;        #                   draw_y - (LobbyBackGround.image.h * self.scale) / 2,&#10;        #                   draw_x + (LobbyBackGround.image.w * self.scale) / 2,&#10;        #                   draw_y + (LobbyBackGround.image.h * self.scale) / 2)&#10;&#10;class EnterTreePortal:&#10;    # frame lists (class-level so images are loaded only once)&#10;    portalImagesBegin = []&#10;    portalImagesCycle = []&#10;    portalFXBegin = []&#10;    portalFXCycle = []&#10;    loaded = False&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # load images once (safe: catch missing files)&#10;        if not EnterTreePortal.loaded:&#10;            try:&#10;                for i in range(18):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Begin{i:02d}.png'&#10;                    EnterTreePortal.portalImagesBegin.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalImagesBegin = []&#10;            try:&#10;                # cycle uses a single image in original assets, but keep as list for consistency&#10;                EnterTreePortal.portalImagesCycle.append(p2.load_image('resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Cycle00.png'))&#10;            except Exception:&#10;                EnterTreePortal.portalImagesCycle = []&#10;            try:&#10;                for i in range(18):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Begin{i:02d}.png'&#10;                    EnterTreePortal.portalFXBegin.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalFXBegin = []&#10;            try:&#10;                for i in range(11):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Cycle{i:02d}.png'&#10;                    EnterTreePortal.portalFXCycle.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalFXCycle = []&#10;            EnterTreePortal.loaded = True&#10;&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;        # self.trigger_radius = 50  # 플레이어가 접근해야 하는 반경&#10;        self.trigger = False&#10;&#10;        # animation state&#10;        self.begin_animation_done = False&#10;        self.frame_idx = 0&#10;        self.fx_idx = 0&#10;        self.frame_dt = 0.0&#10;        self.fx_dt = 0.0&#10;        self.frame_duration = 0.06  # seconds per frame&#10;        self.fx_duration = 0.06&#10;        self.last_time = p2.get_time()&#10;&#10;    def update(self):&#10;        # advance animation based on time delta&#10;        now = p2.get_time()&#10;        dt = now - getattr(self, 'last_time', now)&#10;        self.last_time = now&#10;        # update portal image animation&#10;        self.frame_dt += dt&#10;        if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#10;            # play begin sequence once&#10;            if self.frame_dt &gt;= self.frame_duration:&#10;                steps = int(self.frame_dt / self.frame_duration)&#10;                self.frame_dt -= steps * self.frame_duration&#10;                self.frame_idx += steps&#10;                if self.frame_idx &gt;= len(EnterTreePortal.portalImagesBegin):&#10;                    # start cycle&#10;                    self.begin_animation_done = True&#10;                    self.frame_idx = 0&#10;        else:&#10;            # loop cycle frames&#10;            if EnterTreePortal.portalImagesCycle:&#10;                if self.frame_dt &gt;= self.frame_duration:&#10;                    steps = int(self.frame_dt / self.frame_duration)&#10;                    self.frame_dt -= steps * self.frame_duration&#10;                    self.frame_idx = (self.frame_idx + steps) % max(1, len(EnterTreePortal.portalImagesCycle))&#10;&#10;        # update FX animation: try to play begin and then cycle&#10;        self.fx_dt += dt&#10;        if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#10;            if self.fx_dt &gt;= self.fx_duration:&#10;                steps = int(self.fx_dt / self.fx_duration)&#10;                self.fx_dt -= steps * self.fx_duration&#10;                self.fx_idx += steps&#10;                # clamp fx_idx so it doesn't grow unbounded; allow it to loop during begin&#10;                if self.fx_idx &gt;= len(EnterTreePortal.portalFXBegin):&#10;                    self.fx_idx = 0&#10;        else:&#10;            if EnterTreePortal.portalFXCycle:&#10;                if self.fx_dt &gt;= self.fx_duration:&#10;                    steps = int(self.fx_dt / self.fx_duration)&#10;                    self.fx_dt -= steps * self.fx_duration&#10;                    self.fx_idx = (self.fx_idx + steps) % max(1, len(EnterTreePortal.portalFXCycle))&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw portal image (begin or cycle)&#10;        try:&#10;            if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#10;                img = EnterTreePortal.portalImagesBegin[min(self.frame_idx, len(EnterTreePortal.portalImagesBegin)-1)]&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;            elif EnterTreePortal.portalImagesCycle:&#10;                img = EnterTreePortal.portalImagesCycle[self.frame_idx % len(EnterTreePortal.portalImagesCycle)]&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;        except Exception:&#10;            # drawing failure should not crash the game&#10;            pass&#10;&#10;        # draw FX overlay&#10;        try:&#10;            if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#10;                fx = EnterTreePortal.portalFXBegin[self.fx_idx % len(EnterTreePortal.portalFXBegin)]&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#10;            elif EnterTreePortal.portalFXCycle:&#10;                fx = EnterTreePortal.portalFXCycle[self.fx_idx % len(EnterTreePortal.portalFXCycle)]&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#10;        except Exception:&#10;            pass&#10;&#10;        # 포탈 위에 텍스트 그리기&#10;        if self.trigger:&#10;            try:&#10;                # print(f'[lobby_mode] Drawing portal text at ({draw_x}, {draw_y})')&#10;                font = p2.load_font('resources/Fonts/pixelroborobo.otf', 20)&#10;                text = &quot;[F] 모험하기&quot;&#10;                font_size = 40&#10;                approx_width = int(len(text) * font_size * 0.4)&#10;                font.draw(draw_x - approx_width // 2, draw_y + 10 * self.scale, text, (255, 255, 0))&#10;            except Exception as ex:&#10;                print(f'[lobby_mode] 포탈 텍스트 그리기 실패: {ex}')&#10;&#10;    def check_player_collision(self, player):&#10;        # 플레이어와 포탈의 히트박스 충돌 검사&#10;        # 플레이어의 크기(w, h)는 기본값 32x32로 가정, 필요시 Player에서 가져올 것&#10;        px = getattr(player, 'x', 0)&#10;        py = getattr(player, 'y', 0)&#10;        pw = getattr(player, 'w', 32)&#10;        ph = getattr(player, 'h', 32)&#10;        # 포탈의 히트박스는 중심 기준, 크기는 이미지 크기 * scale * 0.5 (적당히 조정)&#10;        portal_w = 61 * self.scale&#10;        portal_h = 47 * self.scale&#10;        portal_x = self.x - portal_w / 2&#10;        portal_y = self.y - portal_h / 2&#10;        return (px &lt; portal_x + portal_w and px + pw &gt; portal_x and&#10;                py &lt; portal_y + portal_h and py + ph &gt; portal_y)&#10;&#10;class LobbyWall:&#10;    def __init__(self, x, y, w, h):&#10;        self.x = x&#10;        self.y = y&#10;        self.w = w&#10;        self.h = h&#10;&#10;&#10;    def check_collision(self, px, py, pw, ph):&#10;        # 플레이어와 벽의 사각형 충돌 검사&#10;        return (self.x &lt; px + pw and self.x + self.w &gt; px and&#10;                self.y &lt; py + ph and self.y + self.h &gt; py)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 카메라 적용 좌표로 벽 영역을 빨간색으로 표시&#10;        try:&#10;            # p2.draw_rectangle(draw_x, draw_y, draw_x + self.w, draw_y + self.h)&#10;            pass&#10;        except Exception as ex:&#10;            print(f'[LobbyWall] draw() 실패 at ({draw_x}, {draw_y}, {self.w}, {self.h}), Exception {ex}')&#10;&#10;def generate_walls_from_png(png_path, block_size=16, bg_x=None, bg_y=None, scale=1.0):&#10;    print(f&quot;[DEBUG] generate_walls_from_png 시작: {png_path}, block_size={block_size}, bg_x={bg_x}, bg_y={bg_y}, scale={scale}&quot;)&#10;    try:&#10;        img = Image.open(png_path).convert('RGBA')&#10;    except Exception as ex:&#10;        print(f&quot;[DEBUG] 이미지 열기 실패: {ex}&quot;)&#10;        return []&#10;    width, height = img.size&#10;    walls = []&#10;    pixels = img.load()&#10;    transparent_count = 0&#10;    # 배경 이미지의 화면 내 좌표계 기준 좌표 계산&#10;    if bg_x is None: bg_x = width * scale / 2&#10;    if bg_y is None: bg_y = height * scale / 2&#10;    screen_left = bg_x - (width * scale) / 2&#10;    screen_top = bg_y + (height * scale) / 2&#10;    for y in range(0, height, block_size):&#10;        for x in range(0, width, block_size):&#10;            is_transparent = False&#10;            for dy in range(block_size):&#10;                for dx in range(block_size):&#10;                    if x+dx &lt; width and y+dy &lt; height:&#10;                        _, _, _, alpha = pixels[x+dx, y+dy]&#10;                        if alpha == 0:&#10;                            is_transparent = True&#10;                            transparent_count += 1&#10;                            break&#10;                if is_transparent:&#10;                    break&#10;            if is_transparent:&#10;                # 이미지 좌표를 화면 좌표로 변환 (좌상단 기준)&#10;                wall_x_img = x&#10;                wall_y_img = height - y - block_size&#10;                wall_x_screen = screen_left + wall_x_img * scale&#10;                wall_y_screen = bg_y - (height * scale) / 2 + wall_y_img * scale&#10;                walls.append(LobbyWall(wall_x_screen, wall_y_screen, block_size * scale, block_size * scale))&#10;    print(f&quot;[DEBUG] 투명 픽셀 수: {transparent_count}, 생성된 벽 수: {len(walls)}&quot;)&#10;    return walls&#10;" />
              <option name="updatedContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#10;# minimal, compatible with existing game_logic modules&#10;import pico2d as p2&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#10;&#10;import game_framework&#10;from .player import Player&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar&#10;from .cursor import Cursor&#10;from .loading_screen import LoadingScreen&#10;from . import defeat_mode&#10;# 사용할 스테이지 모듈들을 import 합니다.&#10;from .stages import stage_1, stage_2&#10;from PIL import Image&#10;import math&#10;&#10;# world layers: keep same keys as original main.py&#10;world = {&#10;    'sky' : [],&#10;    'ground': [],&#10;    'upper_ground': [],&#10;    'walls': [],&#10;    'effects_back': [],&#10;    'entities': [],&#10;    'effects_front': [],&#10;    'ui': [],&#10;    'extra_bg': [],&#10;    'extras': [],&#10;    'cursor': []&#10;}&#10;world['bg'] = world['ground']&#10;world['player'] = world['entities']  # 플레이어 참조를 위한 키 추가&#10;world_list = ['sky', 'ground', 'upper_ground', 'walls', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']&#10;&#10;class Camera:&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#10;        self.target = target&#10;        self.x = target.x&#10;        self.y = target.y&#10;        self.map_width = map_width&#10;        self.map_height = map_height&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1)&#10;&#10;    def update(self):&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP)&#10;        target_x = self.target.x&#10;        target_y = self.target.y&#10;        self.x += (target_x - self.x) * self.smooth&#10;        self.y += (target_y - self.y) * self.smooth&#10;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#10;        min_x = -self.map_width/2&#10;        max_x = self.map_width/2&#10;        min_y = -self.map_height/2&#10;        max_y = self.map_height/2&#10;&#10;        self.x = max(min_x, min(self.x, max_x))&#10;        self.y = max(min_y, min(self.y, max_y))&#10;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#10;        if self.map_width &lt;= self.screen_width:&#10;            self.x = 0&#10;        if self.map_height &lt;= self.screen_height:&#10;            self.y = 0&#10;        # self.x, self.y는 맵 중심 기준 카메라 위치&#10;        # 화면 중앙이 (0,0)이 되도록 보정&#10;&#10;    def apply(self, obj_x, obj_y):&#10;        # 카메라 위치만큼 오브젝트 위치 보정 (화면 중앙 기준)&#10;        # obj_x, obj_y: 맵 중심(0,0) 기준 좌표&#10;        # 반환값: 화면에 그릴 좌표 (pico2d 기준, 화면 중앙이 0,0)&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#10;&#10;# Camera 객체를 전역으로 선언&#10;camera = None&#10;&#10;def calculate_background_bounds():&#10;    &quot;&quot;&quot;&#10;    sky와 ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#10;&#10;    Returns:&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#10;    &quot;&quot;&quot;&#10;    min_x = float('inf')&#10;    max_x = float('-inf')&#10;    min_y = float('inf')&#10;    max_y = float('-inf')&#10;&#10;    # sky와 ground 레이어의 모든 객체를 순회&#10;    for layer_name in ['sky', 'ground']:&#10;        for obj in world[layer_name]:&#10;            # 객체가 x, y, image, scale 속성을 가지고 있는지 확인&#10;            if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image') and hasattr(obj, 'scale'):&#10;                # 객체의 중심 좌표&#10;                obj_x = obj.x&#10;                obj_y = obj.y&#10;&#10;                # 이미지 크기 계산 (scale 적용)&#10;                img_width = obj.image.w * obj.scale&#10;                img_height = obj.image.h * obj.scale&#10;&#10;                # 객체의 경계 계산 (중심 기준이므로 절반씩)&#10;                obj_left = obj_x - img_width / 2&#10;                obj_right = obj_x + img_width / 2&#10;                obj_bottom = obj_y - img_height / 2&#10;                obj_top = obj_y + img_height / 2&#10;&#10;                # 최소/최대 값 업데이트&#10;                min_x = min(min_x, obj_left)&#10;                max_x = max(max_x, obj_right)&#10;                min_y = min(min_y, obj_bottom)&#10;                max_y = max(max_y, obj_top)&#10;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환&#10;    if min_x == float('inf') or max_x == float('-inf'):&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#10;        return (-800, 800, -600, 600)&#10;&#10;    print(f&quot;[lobby_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#10;    return (min_x, max_x, min_y, max_y)&#10;&#10;def enter():&#10;    global world, camera&#10;    print(&quot;[lobby_mode] Starting enter()...&quot;)&#10;&#10;    # clear existing&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#10;&#10;    # sky&#10;    print(&quot;[lobby_mode] Creating Sky...&quot;)&#10;    whiteBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/WhiteBG.png'&#10;    skyBackGroundPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloudBall_Gradation.png'&#10;    skyBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Back.png'&#10;    skyMidPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Mid.png'&#10;    skyFrontPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Front.png'&#10;    cloudPropPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Prop.png'&#10;    whiteBack = LobbySky(whiteBackPath, 0, 0, 6.5)&#10;    skyBackGround = LobbySky(skyBackGroundPath, 0, 0, 5.4)&#10;    skyBack = LobbySky(skyBackPath, 0, 200)&#10;    skyMid = LobbySky(skyMidPath, 0, 0)&#10;    skyFront = LobbySky(skyFrontPath, 0, -200)&#10;    cloudProp = LobbySky(cloudPropPath, 0, -400)&#10;&#10;    world['sky'].append(whiteBack)&#10;    world['sky'].append(skyBackGround)&#10;    world['sky'].append(skyBack)&#10;    world['sky'].append(skyMid)&#10;    world['sky'].append(skyFront)&#10;    world['sky'].append(cloudProp)&#10;&#10;    # background&#10;    print(&quot;[lobby_mode] Creating Background...&quot;)&#10;    bg = LobbyBackGround()&#10;    world['bg'].append(bg)&#10;&#10;    # 낭떠러지(투명 영역) 벽 자동 생성&#10;    try:&#10;        print(&quot;[DEBUG] wall_blocks 생성 시도 중...&quot;)&#10;        # 배경의 화면 위치와 스케일을 전달&#10;        wall_blocks = generate_walls_from_png(&#10;            'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png',&#10;            block_size=8,&#10;            bg_x=bg.x,&#10;            bg_y=bg.y,&#10;            scale=bg.scale&#10;        )&#10;        print(f&quot;[DEBUG] wall_blocks 반환: {len(wall_blocks)}개&quot;)&#10;        for wall in wall_blocks:&#10;            world['walls'].append(wall)&#10;            pass&#10;        print(f&quot;[lobby_mode] Generated {len(wall_blocks)} walls from PNG transparency.&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Wall generation from PNG failed: {ex}\033[0m&quot;)&#10;&#10;    # create portal to play mode&#10;    print(&quot;[lobby_mode] Creating EnterTreePortal...&quot;)&#10;    try:&#10;        # 백그라운드 이미지와 스케일에 맞춰 가로 중앙, 세로는 위에서 30% 아래에 배치&#10;        portal_x = bg.x&#10;        portal_y = bg.y + (bg.image.h * bg.scale) / 2 - (bg.image.h * bg.scale) * 0.3&#10;        enterTree = EnterTreePortal(portal_x, portal_y, scale=bg.scale)&#10;        world['upper_ground'].append(enterTree)&#10;        print(f&quot;[lobby_mode] EnterTreePortal created at ({portal_x}, {portal_y}) with scale {bg.scale}&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Failed to create EnterTreePortal: {ex}\033[0m&quot;)&#10;&#10;    print(&quot;[lobby_mode] Creating player...&quot;)&#10;    # create player (use fallback if heavy Player init fails)&#10;    try:&#10;        player = Player()&#10;        player.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;        player.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;        print(&quot;[lobby_mode] Player created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#10;        from .inventory import InventoryData, seed_debug_inventory&#10;&#10;        class _FallbackPlayer:&#10;            def __init__(self):&#10;                self.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;                self.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;                self.face_dir = 1&#10;                self.scale_factor = 1.0&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;                self.particles = []&#10;                self.attack_effects = []&#10;                self.inventory = InventoryData(cols=6, rows=5)&#10;                try:&#10;                    seed_debug_inventory(self.inventory)&#10;                except Exception:&#10;                    print(&quot;\033[91m[lobby_mode] seed_debug_inventory failed\033[0m&quot;)&#10;                    pass&#10;                self.inventory_open = False&#10;&#10;            def update(self):&#10;                return True&#10;&#10;            def rebuild_inventory_passives(self):&#10;                return&#10;&#10;            def consume_item_at(self, r, c):&#10;                return False&#10;&#10;        player = _FallbackPlayer()&#10;&#10;    print(&quot;[lobby_mode] Attaching world reference to player...&quot;)&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#10;    try:&#10;        player.world = world&#10;    except Exception:&#10;        print(&quot;\033[91m[lobby_mode] Failed to attach world to player\033[0m&quot;)&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#10;    world['entities'].append(player)&#10;&#10;    # Camera 초기화 (Player를 target으로 설정)&#10;    # sky와 ground 레이어의 실제 배경 범위를 계산하여 카메라 제한 범위로 사용&#10;    try:&#10;        # 배경 범위 계산 (sky와 ground 레이어의 모든 객체 고려)&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;&#10;        # 배경 전체 크기 계산&#10;        map_width = max_x - min_x&#10;        map_height = max_y - min_y&#10;&#10;        screen_width = p2.get_canvas_width()&#10;        screen_height = p2.get_canvas_height()&#10;&#10;        global camera&#10;        camera = Camera(player, map_width, map_height, screen_width, screen_height)&#10;&#10;        # 카메라에 실제 배경 범위의 중심점 정보 전달 (오프셋 계산용)&#10;        camera.map_offset_x = (min_x + max_x) / 2&#10;        camera.map_offset_y = (min_y + max_y) / 2&#10;&#10;        print(f&quot;[lobby_mode] Camera initialized for player at ({player.x}, {player.y})&quot;)&#10;        print(f&quot;[lobby_mode] Map size: {map_width:.1f} x {map_height:.1f}, Offset: ({camera.map_offset_x:.1f}, {camera.map_offset_y:.1f})&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Camera initialization failed: {ex}\033[0m&quot;)&#10;&#10;    print(&quot;[lobby_mode] Creating inventory overlay...&quot;)&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#10;    try:&#10;        inv = InventoryOverlay(player, world)&#10;        print(&quot;[lobby_mode] InventoryOverlay created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] InventoryOverlay init failed, creating minimal stub: {ex}\033[0m&quot;)&#10;&#10;        class _InvStub:&#10;            def __init__(self, player, world=None):&#10;                self.player = player&#10;                self.world = world&#10;                self.dragging = False&#10;                self.drag_from = None&#10;                self.drag_icon = None&#10;                self.drag_qty = 0&#10;            def handle_event(self, e):&#10;                return&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        inv = _InvStub(player, world)&#10;    world['ui'].append(inv)&#10;&#10;    print(&quot;[lobby_mode] Creating cursor...&quot;)&#10;    # cursor on top (safe fallback)&#10;    try:&#10;        cursor = Cursor(player)&#10;        print(&quot;[lobby_mode] Cursor created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Cursor init failed, using stub cursor: {ex}\033[0m&quot;)&#10;&#10;        class _CursorStub:&#10;            def __init__(self, player=None):&#10;                self.player = player&#10;                self.x = 0&#10;                self.y = 0&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;            def handle_event(self, e):&#10;                return&#10;&#10;        cursor = _CursorStub(player)&#10;    world['cursor'].append(cursor)&#10;&#10;    # expose world to __main__ for legacy code that looks up main.world&#10;    try:&#10;        import sys&#10;        main_mod = sys.modules.get('__main__')&#10;        if main_mod is not None:&#10;            setattr(main_mod, 'world', world)&#10;    except Exception:&#10;        print(&quot;\033[91m[lobby_mode] Failed to expose world to __main__\033[0m&quot;)&#10;&#10;&#10;def exit():&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#10;&#10;&#10;def handle_events():&#10;    import game_framework as app_framework&#10;&#10;    events = p2.get_events()&#10;    player = world.get('player')&#10;    portal_triggered = False&#10;&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            app_framework.quit()&#10;            return&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#10;            app_framework.quit()&#10;            return&#10;        # F키 입력 시 포탈 충돌 체크&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == p2.SDLK_f:&#10;            for obj in world['upper_ground']:&#10;                if isinstance(obj, EnterTreePortal) and player:&#10;                    if obj.check_player_collision(player):&#10;                        if not portal_triggered:&#10;                            from . import play_mode&#10;                            print('[lobby_mode] EnterTreePortal triggered: switching to play_mode')&#10;                            app_framework.change_state(play_mode)&#10;                            portal_triggered = True&#10;&#10;        # broadcast to entities -&gt; ui -&gt; cursor&#10;        for o in list(world['entities']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for entity\033[0m&quot;)&#10;        for o in list(world['ui']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for UI\033[0m&quot;)&#10;        for o in list(world['cursor']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for cursor\033[0m&quot;)&#10;&#10;&#10;def update():&#10;    global camera&#10;    # 카메라 업데이트 추가&#10;    if camera is not None:&#10;        camera.update()&#10;&#10;    # 일반 게임 업데이트&#10;    for layer_name in world_list:&#10;        new_list = []&#10;        for o in list(world[layer_name]):&#10;            try:&#10;                if hasattr(o, 'update'):&#10;                    alive = o.update()&#10;                    if alive is False:&#10;                        continue&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to update object\033[0m&quot;)&#10;&#10;            # mark_for_removal 플래그 확인&#10;            if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#10;                print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#10;                continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#10;&#10;            new_list.append(o)&#10;        world[layer_name][:] = new_list&#10;&#10;    # 충돌 검사 시스템&#10;    from .projectile import Projectile&#10;    player = world.get('player')&#10;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#10;    effects_to_remove = set()&#10;    projectiles_to_remove = set()&#10;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#10;    for effect in world['effects_front']:&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#10;            for entity in world['entities']:&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#10;                    if entity.check_collision_with_effect(effect):&#10;                        # 디버그: 충돌 정보 출력&#10;                        attacker_name = &quot;Player&quot;&#10;                        if hasattr(effect, 'owner'):&#10;                            attacker_name = effect.owner.__class__.__name__&#10;                        target_name = entity.__class__.__name__&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#10;                        pass&#10;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#10;    if player:&#10;        for projectile in world['effects_front']:&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#10;            if isinstance(projectile, Projectile):&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#10;                if not projectile.from_player:&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#10;                        if player.check_collision_with_projectile(projectile):&#10;                            # 디버그: 충돌 정보 출력&#10;                            attacker_name = &quot;Unknown&quot;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#10;                                attacker_name = projectile.owner.__class__.__name__&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#10;                            projectiles_to_remove.add(projectile)&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#10;                else:&#10;                    for entity in world['entities']:&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#10;                            if entity.check_collision_with_projectile(projectile):&#10;                                # 디버그: 충돌 정보 출력&#10;                                target_name = entity.__class__.__name__&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#10;                                projectiles_to_remove.add(projectile)&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#10;&#10;    # 충돌한 투사체 제거&#10;    if projectiles_to_remove:&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#10;&#10;    # 포탈 위에 텍스트 표시&#10;    for obj in world['upper_ground']:&#10;        if isinstance(obj, EnterTreePortal) and player:&#10;            if obj.check_player_collision(player):&#10;                obj.trigger = True&#10;            else:&#10;                obj.trigger = False&#10;&#10;def draw():&#10;    global camera&#10;    p2.clear_canvas()&#10;    # 하늘을 가장 먼저 그리기 (배경 뒤)&#10;    for obj in world['sky']:&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y'):&#10;            if camera is not None:&#10;                draw_x, draw_y = camera.apply(obj.x, obj.y)&#10;            else:&#10;                draw_x, draw_y = obj.x, obj.y&#10;            if hasattr(obj, 'draw'):&#10;                obj.draw(draw_x, draw_y)&#10;        else:&#10;            if hasattr(obj, 'draw'):&#10;                obj.draw()&#10;&#10;    # 나머지 레이어들 (배경, 벽, 엔티티 등)&#10;    for layer in ['ground', 'walls', 'upper_ground', 'entities', 'effects_back', 'effects_front', 'extra_bg', 'extras']:&#10;        for obj in world[layer]:&#10;            if hasattr(obj, 'x') and hasattr(obj, 'y'):&#10;                if camera is not None:&#10;                    draw_x, draw_y = camera.apply(obj.x, obj.y)&#10;                else:&#10;                    draw_x, draw_y = obj.x, obj.y&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw(draw_x, draw_y)&#10;            else:&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw()&#10;    # UI, cursor 등은 카메라 적용하지 않음&#10;    for obj in world['ui']:&#10;        if hasattr(obj, 'draw'):&#10;            obj.draw()&#10;    for obj in world['cursor']:&#10;        if hasattr(obj, 'draw'):&#10;            obj.draw()&#10;    p2.update_canvas()&#10;&#10;class LobbySky:&#10;    def __init__(self, path, x=0, y=0, scale=3):&#10;        self.image = p2.load_image(path)&#10;        self.scale = scale&#10;        self.x = x  # 화면 중심(0,0) 기준&#10;        self.y = y  # 화면 중심(0,0) 기준&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        self.image.draw(draw_x, draw_y, self.image.w * self.scale * 2,&#10;                        self.image.h * self.scale * 1.5)&#10;        # 디버그용 히트박스 (필요시 주석 처리)&#10;        # p2.draw_rectangle(draw_x - (self.image.w * self.scale) / 2,&#10;        #                   draw_y - (self.image.h * self.scale) / 2,&#10;        #                   draw_x + (self.image.w * self.scale) / 2,&#10;        #                   draw_y + (self.image.h * self.scale) / 2)&#10;&#10;&#10;class LobbyBackGround:&#10;    image = None&#10;    def __init__(self):&#10;        if LobbyBackGround.image is None:&#10;            LobbyBackGround.image = p2.load_image('resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png')&#10;        self.scale = 6.5&#10;        self.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;        self.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        LobbyBackGround.image.draw(draw_x, draw_y, LobbyBackGround.image.w * self.scale, LobbyBackGround.image.h * self.scale)&#10;        # p2.draw_rectangle(draw_x - (LobbyBackGround.image.w * self.scale) / 2,&#10;        #                   draw_y - (LobbyBackGround.image.h * self.scale) / 2,&#10;        #                   draw_x + (LobbyBackGround.image.w * self.scale) / 2,&#10;        #                   draw_y + (LobbyBackGround.image.h * self.scale) / 2)&#10;&#10;class EnterTreePortal:&#10;    # frame lists (class-level so images are loaded only once)&#10;    portalImagesBegin = []&#10;    portalImagesCycle = []&#10;    portalFXBegin = []&#10;    portalFXCycle = []&#10;    loaded = False&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # load images once (safe: catch missing files)&#10;        if not EnterTreePortal.loaded:&#10;            try:&#10;                for i in range(18):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Begin{i:02d}.png'&#10;                    EnterTreePortal.portalImagesBegin.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalImagesBegin = []&#10;            try:&#10;                # cycle uses a single image in original assets, but keep as list for consistency&#10;                EnterTreePortal.portalImagesCycle.append(p2.load_image('resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Cycle00.png'))&#10;            except Exception:&#10;                EnterTreePortal.portalImagesCycle = []&#10;            try:&#10;                for i in range(18):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Begin{i:02d}.png'&#10;                    EnterTreePortal.portalFXBegin.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalFXBegin = []&#10;            try:&#10;                for i in range(11):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Cycle{i:02d}.png'&#10;                    EnterTreePortal.portalFXCycle.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalFXCycle = []&#10;            EnterTreePortal.loaded = True&#10;&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;        # self.trigger_radius = 50  # 플레이어가 접근해야 하는 반경&#10;        self.trigger = False&#10;&#10;        # animation state&#10;        self.begin_animation_done = False&#10;        self.frame_idx = 0&#10;        self.fx_idx = 0&#10;        self.frame_dt = 0.0&#10;        self.fx_dt = 0.0&#10;        self.frame_duration = 0.06  # seconds per frame&#10;        self.fx_duration = 0.06&#10;        self.last_time = p2.get_time()&#10;&#10;    def update(self):&#10;        # advance animation based on time delta&#10;        now = p2.get_time()&#10;        dt = now - getattr(self, 'last_time', now)&#10;        self.last_time = now&#10;        # update portal image animation&#10;        self.frame_dt += dt&#10;        if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#10;            # play begin sequence once&#10;            if self.frame_dt &gt;= self.frame_duration:&#10;                steps = int(self.frame_dt / self.frame_duration)&#10;                self.frame_dt -= steps * self.frame_duration&#10;                self.frame_idx += steps&#10;                if self.frame_idx &gt;= len(EnterTreePortal.portalImagesBegin):&#10;                    # start cycle&#10;                    self.begin_animation_done = True&#10;                    self.frame_idx = 0&#10;        else:&#10;            # loop cycle frames&#10;            if EnterTreePortal.portalImagesCycle:&#10;                if self.frame_dt &gt;= self.frame_duration:&#10;                    steps = int(self.frame_dt / self.frame_duration)&#10;                    self.frame_dt -= steps * self.frame_duration&#10;                    self.frame_idx = (self.frame_idx + steps) % max(1, len(EnterTreePortal.portalImagesCycle))&#10;&#10;        # update FX animation: try to play begin and then cycle&#10;        self.fx_dt += dt&#10;        if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#10;            if self.fx_dt &gt;= self.fx_duration:&#10;                steps = int(self.fx_dt / self.fx_duration)&#10;                self.fx_dt -= steps * self.fx_duration&#10;                self.fx_idx += steps&#10;                # clamp fx_idx so it doesn't grow unbounded; allow it to loop during begin&#10;                if self.fx_idx &gt;= len(EnterTreePortal.portalFXBegin):&#10;                    self.fx_idx = 0&#10;        else:&#10;            if EnterTreePortal.portalFXCycle:&#10;                if self.fx_dt &gt;= self.fx_duration:&#10;                    steps = int(self.fx_dt / self.fx_duration)&#10;                    self.fx_dt -= steps * self.fx_duration&#10;                    self.fx_idx = (self.fx_idx + steps) % max(1, len(EnterTreePortal.portalFXCycle))&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw portal image (begin or cycle)&#10;        try:&#10;            if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#10;                img = EnterTreePortal.portalImagesBegin[min(self.frame_idx, len(EnterTreePortal.portalImagesBegin)-1)]&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;            elif EnterTreePortal.portalImagesCycle:&#10;                img = EnterTreePortal.portalImagesCycle[self.frame_idx % len(EnterTreePortal.portalImagesCycle)]&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;        except Exception:&#10;            # drawing failure should not crash the game&#10;            pass&#10;&#10;        # draw FX overlay&#10;        try:&#10;            if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#10;                fx = EnterTreePortal.portalFXBegin[self.fx_idx % len(EnterTreePortal.portalFXBegin)]&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#10;            elif EnterTreePortal.portalFXCycle:&#10;                fx = EnterTreePortal.portalFXCycle[self.fx_idx % len(EnterTreePortal.portalFXCycle)]&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#10;        except Exception:&#10;            pass&#10;&#10;        # 포탈 위에 텍스트 그리기&#10;        if self.trigger:&#10;            try:&#10;                # print(f'[lobby_mode] Drawing portal text at ({draw_x}, {draw_y})')&#10;                font = p2.load_font('resources/Fonts/pixelroborobo.otf', 20)&#10;                text = &quot;[F] 모험하기&quot;&#10;                font_size = 40&#10;                approx_width = int(len(text) * font_size * 0.4)&#10;                font.draw(draw_x - approx_width // 2, draw_y + 10 * self.scale, text, (255, 255, 0))&#10;            except Exception as ex:&#10;                print(f'[lobby_mode] 포탈 텍스트 그리기 실패: {ex}')&#10;&#10;    def check_player_collision(self, player):&#10;        # 플레이어와 포탈의 히트박스 충돌 검사&#10;        # 플레이어의 크기(w, h)는 기본값 32x32로 가정, 필요시 Player에서 가져올 것&#10;        px = getattr(player, 'x', 0)&#10;        py = getattr(player, 'y', 0)&#10;        pw = getattr(player, 'w', 32)&#10;        ph = getattr(player, 'h', 32)&#10;        # 포탈의 히트박스는 중심 기준, 크기는 이미지 크기 * scale * 0.5 (적당히 조정)&#10;        portal_w = 61 * self.scale&#10;        portal_h = 47 * self.scale&#10;        portal_x = self.x - portal_w / 2&#10;        portal_y = self.y - portal_h / 2&#10;        return (px &lt; portal_x + portal_w and px + pw &gt; portal_x and&#10;                py &lt; portal_y + portal_h and py + ph &gt; portal_y)&#10;&#10;class LobbyWall:&#10;    def __init__(self, x, y, w, h):&#10;        self.x = x&#10;        self.y = y&#10;        self.w = w&#10;        self.h = h&#10;&#10;&#10;    def check_collision(self, px, py, pw, ph):&#10;        # 플레이어와 벽의 사각형 충돌 검사&#10;        return (self.x &lt; px + pw and self.x + self.w &gt; px and&#10;                self.y &lt; py + ph and self.y + self.h &gt; py)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 카메라 적용 좌표로 벽 영역을 빨간색으로 표시&#10;        try:&#10;            # p2.draw_rectangle(draw_x, draw_y, draw_x + self.w, draw_y + self.h)&#10;            pass&#10;        except Exception as ex:&#10;            print(f'[LobbyWall] draw() 실패 at ({draw_x}, {draw_y}, {self.w}, {self.h}), Exception {ex}')&#10;&#10;def generate_walls_from_png(png_path, block_size=16, bg_x=None, bg_y=None, scale=1.0):&#10;    print(f&quot;[DEBUG] generate_walls_from_png 시작: {png_path}, block_size={block_size}, bg_x={bg_x}, bg_y={bg_y}, scale={scale}&quot;)&#10;    try:&#10;        img = Image.open(png_path).convert('RGBA')&#10;    except Exception as ex:&#10;        print(f&quot;[DEBUG] 이미지 열기 실패: {ex}&quot;)&#10;        return []&#10;    width, height = img.size&#10;    walls = []&#10;    pixels = img.load()&#10;    transparent_count = 0&#10;    # 배경 이미지의 화면 내 좌표계 기준 좌표 계산&#10;    if bg_x is None: bg_x = width * scale / 2&#10;    if bg_y is None: bg_y = height * scale / 2&#10;    screen_left = bg_x - (width * scale) / 2&#10;    screen_top = bg_y + (height * scale) / 2&#10;    for y in range(0, height, block_size):&#10;        for x in range(0, width, block_size):&#10;            is_transparent = False&#10;            for dy in range(block_size):&#10;                for dx in range(block_size):&#10;                    if x+dx &lt; width and y+dy &lt; height:&#10;                        _, _, _, alpha = pixels[x+dx, y+dy]&#10;                        if alpha == 0:&#10;                            is_transparent = True&#10;                            transparent_count += 1&#10;                            break&#10;                if is_transparent:&#10;                    break&#10;            if is_transparent:&#10;                # 이미지 좌표를 화면 좌표로 변환 (좌상단 기준)&#10;                wall_x_img = x&#10;                wall_y_img = height - y - block_size&#10;                wall_x_screen = screen_left + wall_x_img * scale&#10;                wall_y_screen = bg_y - (height * scale) / 2 + wall_y_img * scale&#10;                walls.append(LobbyWall(wall_x_screen, wall_y_screen, block_size * scale, block_size * scale))&#10;    print(f&quot;[DEBUG] 투명 픽셀 수: {transparent_count}, 생성된 벽 수: {len(walls)}&quot;)&#10;    return walls" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/map.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/map.py" />
              <option name="originalContent" value="# map.py&#10;# Room.txt 기반 간단한 맵 로더 및 타일 엔티티 빌더&#10;# 작성자: 자동 생성&#10;# 사용 가정(중요):&#10;# - Room.txt 파일은 섹션 단위(예: [ground], [upper_ground], [walls], [cliff], [props])의 텍스트로 존재하며,&#10;#   각 섹션 밑에는 콤마(,)로 구분된 정수 타일 인덱스 행들이 있음.&#10;#   예:&#10;#   [ground]&#10;#   1,1,1,0,0&#10;#   1,2,2,0,0&#10;#&#10;# - 0은 빈 타일(배치 없음)을 의미.&#10;# - props 섹션은 현재 무시합니다.&#10;#&#10;# 제공하는 기능:&#10;# - Map.load_from_room_txt(path): Room.txt 파싱&#10;# - Map.build_into_world(world, tile_size=32, origin=(0,0)): world의 레이어들에 타일 엔티티를 추가&#10;# - TileEntity: 최소한의 update()/draw() 인터페이스(프로젝트의 실제 렌더링 파이프라인에 맞춰 확장 가능)&#10;&#10;import os&#10;from typing import Dict, List, Tuple, Optional&#10;&#10;try:&#10;    from pico2d import draw_rectangle&#10;except Exception:&#10;    # pico2d가 없으면 draw_rectangle을 대체하는 더미 함수로 허용&#10;    def draw_rectangle(l, b, r, t):&#10;        # no-op in headless/static analysis&#10;        return&#10;&#10;&#10;SUPPORTED_SECTIONS = ['ground', 'upper_ground', 'walls', 'cliff', 'props']&#10;&#10;&#10;class TileEntity:&#10;    &quot;&quot;&quot;맵에 배치되는 간단한 타일 엔티티.&#10;    실제 프로젝트에서는 이미지(tileset)과 애니메이션, 충돌박스 등을 연결해서 사용하면 됩니다.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, tile_id: int, x: int, y: int, size: int, layer: str):&#10;        self.tile_id = int(tile_id)&#10;        self.x = int(x)&#10;        self.y = int(y)&#10;        self.size = int(size)&#10;        self.layer = layer&#10;&#10;    def update(self):&#10;        # 기본 타일은 고정이므로 True를 반환하여 계속 유지&#10;        return True&#10;&#10;    def draw(self):&#10;        # 디버그용 간단한 사각형 그리기 (pico2d가 있으면 보임)&#10;        l = self.x&#10;        b = self.y&#10;        r = self.x + self.size&#10;        t = self.y + self.size&#10;        draw_rectangle(l, b, r, t)&#10;&#10;&#10;class Map:&#10;    def __init__(self, tile_size: int = 32):&#10;        self.tile_size = int(tile_size)&#10;        # 각 섹션에 대해 2D 리스트(행 리스트)로 타일 인덱스를 보관&#10;        self.layers: Dict[str, List[List[int]]] = {s: [] for s in SUPPORTED_SECTIONS}&#10;        self.width = 0&#10;        self.height = 0&#10;&#10;    @staticmethod&#10;    def _normalize_section_name(name: str) -&gt; str:&#10;        return name.strip().lower()&#10;&#10;    def load_from_room_txt(self, path: str) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Room.txt 형식(간단한 INI 스타일)을 파싱하여 self.layers에 채웁니다.&#10;        빈 라인 또는 주석(//, ;, #)은 무시합니다.&#10;&#10;        변경: 토큰 구분자는 공백(whitespace)을 사용합니다. 라인 내의 ','는 공백으로 대체되어&#10;        기존 콤마 형식과도 호환됩니다. 토큰 '0' 및 'X'/'x'는 빈 타일(0)으로 처리됩니다.&#10;        &quot;&quot;&quot;&#10;        if not os.path.isfile(path):&#10;            raise FileNotFoundError(f&quot;Room file not found: {path}&quot;)&#10;&#10;        current = None&#10;        with open(path, 'r', encoding='utf-8') as f:&#10;            for raw_line in f:&#10;                line = raw_line.strip()&#10;                if not line:&#10;                    continue&#10;                if line.startswith('//') or line.startswith('#') or line.startswith(';'):&#10;                    continue&#10;                if line.startswith('[') and line.endswith(']'):&#10;                    sec = self._normalize_section_name(line[1:-1])&#10;                    if sec not in SUPPORTED_SECTIONS:&#10;                        # 새 섹션을 만드려 하지 말고 지원되는 섹션만 처리&#10;                        current = None&#10;                        continue&#10;                    current = sec&#10;                    # reset existing content for the section&#10;                    self.layers[current] = []&#10;                    continue&#10;&#10;                if current is None:&#10;                    # 섹션 밖의 데이터는 무시&#10;                    continue&#10;&#10;                # ',' 구분자를 공백으로 바꿔 공백 분할을 사용하여 유연하게 처리&#10;                normalized = line.replace(',', ' ')&#10;                parts = [p.strip() for p in normalized.split() if p.strip() != '']&#10;                if not parts:&#10;                    continue&#10;                row: List[int] = []&#10;                for p in parts:&#10;                    # '0' 과 'X' 또는 'x' 를 빈타일로 처리&#10;                    if p == '0' or p.lower() == 'x':&#10;                        row.append(0)&#10;                        continue&#10;                    try:&#10;                        row.append(int(p))&#10;                    except ValueError:&#10;                        # 숫자로 변환할 수 없는 토큰이 있으면 빈타일로 처리&#10;                        row.append(0)&#10;                self.layers[current].append(row)&#10;&#10;        # 맵 전체 크기 계산 (가장 큰 폭/높이 사용)&#10;        max_w = 0&#10;        max_h = 0&#10;        for sec in SUPPORTED_SECTIONS:&#10;            h = len(self.layers.get(sec, []))&#10;            if h &gt; max_h:&#10;                max_h = h&#10;            for row in self.layers.get(sec, []):&#10;                if len(row) &gt; max_w:&#10;                    max_w = len(row)&#10;        self.width = max_w&#10;        self.height = max_h&#10;&#10;    def build_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0), replace: bool = True) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        파싱된 레이어 데이터를 바탕으로 `world` 딕셔너리의 레이어 리스트에 TileEntity들을 추가합니다.&#10;        - world: main.py에서 사용되는 world 딕셔너리 (예: keys: 'ground','upper_ground','walls',...)&#10;        - tile_size: 맵의 타일 픽셀 크기 (기본은 Map.tile_size)&#10;        - origin: (x0,y0) 맵 원점 좌표 (왼쪽 하단 기준)&#10;        - replace: True이면 이 함수가 추가할 레이어(ground/upper_ground/walls)의 기존 리스트를 비우고 새로 채웁니다.&#10;&#10;        이 함수는 props 섹션은 현재 무시합니다.&#10;        &quot;&quot;&quot;&#10;        ts = int(tile_size) if tile_size is not None else self.tile_size&#10;        x0, y0 = origin&#10;&#10;        target_layers = ['ground', 'upper_ground', 'walls']&#10;        if replace:&#10;            for tl in target_layers:&#10;                if tl in world and isinstance(world[tl], list):&#10;                    world[tl].clear()&#10;&#10;        # 맵 데이터의 행렬은 텍스트 상에서는 보통 위에서 아래로 작성됨을 가정.&#10;        # 여기서는 텍스트 행(0)이 맵의 &quot;상단&quot;이라고 가정하고 화면 좌표로는 높이를 고려해 y를 계산합니다.&#10;        for sec in ['ground', 'upper_ground', 'walls', 'cliff']:&#10;            rows = self.layers.get(sec, [])&#10;            h = len(rows)&#10;            for row_idx, row in enumerate(rows):&#10;                # 텍스트의 첫 행 -&gt; 맵 상단이므로 y 계산&#10;                # 맵 상단을 origin_y + (height - 1 - row_idx) * ts 로 배치&#10;                for col_idx, tile_id in enumerate(row):&#10;                    if tile_id == 0:&#10;                        continue&#10;                    # compute position&#10;                    # bottom-left origin&#10;                    x = x0 + col_idx * ts&#10;                    y = y0 + (self.height - 1 - row_idx) * ts&#10;                    ent = TileEntity(tile_id=tile_id, x=x, y=y, size=ts, layer=sec)&#10;                    # 저장된 그리드 좌표를 붙여 두면 나중에 크기 변경 시 재계산에 사용 가능&#10;                    ent._grid_col = col_idx&#10;                    ent._grid_row = row_idx&#10;                    ent._map_height = self.height&#10;                    ent._origin = (x0, y0)&#10;                    # 월드에 맞는 레이어 키가 존재하면 append&#10;                    if sec == 'ground':&#10;                        world.setdefault('ground', []).append(ent)&#10;                    elif sec == 'upper_ground':&#10;                        world.setdefault('upper_ground', []).append(ent)&#10;                    elif sec == 'walls' or sec == 'cliff':&#10;                        # 벽/절벽은 충돌 처리용으로 walls 레이어에 넣음&#10;                        world.setdefault('walls', []).append(ent)&#10;                    else:&#10;                        # props 등은 현재 무시&#10;                        pass&#10;&#10;    def rebuild_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        편의 메서드: 기존 내용을 교체(replace=True)하여 다시 빌드합니다.&#10;        &quot;&quot;&quot;&#10;        self.build_into_world(world, tile_size=tile_size, origin=origin, replace=True)&#10;&#10;    def apply_tile_size_to_world(self, world: Dict[str, list], new_tile_size: int, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        기존에 world에 배치된 TileEntity들이 그리드 좌표를 가지고 있다면,&#10;        각 엔티티의 size와 x,y를 새 타일 크기에 맞게 in-place로 갱신합니다.&#10;        - world: 월드 딕셔너리&#10;        - new_tile_size: 적용할 새 타일 크기&#10;        - origin: 맵 원점&#10;&#10;        이 방법은 엔티티를 새로 생성하지 않으므로 외부 참조가 유지됩니다.&#10;        만약 엔티티에 그리드 좌표가 없다면 동작하지 않습니다(그럴 경우 재빌드 필요).&#10;        &quot;&quot;&quot;&#10;        ts = int(new_tile_size)&#10;        x0, y0 = origin&#10;        layers = ['ground', 'upper_ground', 'walls']&#10;        updated = 0&#10;        for layer in layers:&#10;            for ent in list(world.get(layer, [])):&#10;                # ent가 grid 정보(_grid_col/_grid_row/_map_height)를 가지고 있으면 위치 재계산&#10;                if hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height'):&#10;                    col = int(ent._grid_col)&#10;                    row = int(ent._grid_row)&#10;                    map_h = int(ent._map_height)&#10;                    ent.size = ts&#10;                    ent.x = x0 + col * ts&#10;                    ent.y = y0 + (map_h - 1 - row) * ts&#10;                    # update stored origin too&#10;                    ent._origin = (x0, y0)&#10;                    updated += 1&#10;                else:&#10;                    # grid 정보가 없으면 이 엔티티는 무시 (재빌드를 권장)&#10;                    continue&#10;        try:&#10;            print(f&quot;apply_tile_size_to_world: applied new_tile_size={ts}, updated_entities={updated}&quot;)&#10;        except Exception:&#10;            pass&#10;&#10;    def set_tile_size(self, new_tile_size: int, world: Optional[Dict[str, list]] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Map의 기본 타일 크기를 변경합니다. 만약 `world`를 전달하면 해당 월드에 대해&#10;        가능한 경우 in-place로 크기/위치를 갱신하고, grid 정보가 부족하면 재빌드를 수행합니다.&#10;        &quot;&quot;&quot;&#10;        self.tile_size = int(new_tile_size)&#10;        if world is not None:&#10;            # 먼저 시도: in-place 적용 (grid 좌표가 있는 경우)&#10;            # 검사: 모든 엔티티들이 grid 좌표를 가지고 있는지 확인&#10;            ok = True&#10;            total = 0&#10;            for layer in ['ground', 'upper_ground', 'walls']:&#10;                for ent in world.get(layer, []):&#10;                    total += 1&#10;                    if not (hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height')):&#10;                        ok = False&#10;                        break&#10;                if not ok:&#10;                    break&#10;            if ok:&#10;                try:&#10;                    self.apply_tile_size_to_world(world, self.tile_size, origin)&#10;                    print(f&quot;set_tile_size: in-place applied to {total} entities, new_tile_size={self.tile_size}&quot;)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91mset_tile_size: in-place apply failed: {e}\033[0m&quot;)&#10;            else:&#10;                # 일부 엔티티에 grid 정보가 없으면 안전하게 재빌드&#10;                try:&#10;                    self.rebuild_into_world(world, tile_size=self.tile_size, origin=origin)&#10;                    print(f&quot;set_tile_size: rebuilt world with new_tile_size={self.tile_size}&quot;)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91mset_tile_size: rebuild failed: {e}\033[0m&quot;)&#10;&#10;&#10;# 간단한 자기검증 스크립트&#10;if __name__ == '__main__':&#10;    # 간단한 Room 텍스트 샘플을 메모리로 만들고 파싱 테스트&#10;    sample = '''&#10;[ground]&#10;1,1,1,0,0&#10;1,2,2,0,0&#10;&#10;[upper_ground]&#10;0,0,3,3,0&#10;&#10;[walls]&#10;0,4,0,0,0&#10;'''&#10;    import tempfile&#10;&#10;    p = tempfile.gettempdir() + os.sep + 'sample_room.txt'&#10;    with open(p, 'w', encoding='utf-8') as f:&#10;        f.write(sample)&#10;&#10;    m = Map(tile_size=128)&#10;    m.load_from_room_txt(p)&#10;    print('width,height:', m.width, m.height)&#10;    world = {k: [] for k in ['ground', 'upper_ground', 'walls', 'effects_back', 'effects_front', 'ui', 'cursor']}&#10;    m.build_into_world(world, origin=(0, 0))&#10;    for k in world:&#10;        print(k, len(world[k]))&#10;" />
              <option name="updatedContent" value="# map.py&#13;&#10;# Room.txt 기반 간단한 맵 로더 및 타일 엔티티 빌더&#13;&#10;# 작성자: 자동 생성&#13;&#10;# 사용 가정(중요):&#13;&#10;# - Room.txt 파일은 섹션 단위(예: [ground], [upper_ground], [walls], [cliff], [props])의 텍스트로 존재하며,&#13;&#10;#   각 섹션 밑에는 콤마(,)로 구분된 정수 타일 인덱스 행들이 있음.&#13;&#10;#   예:&#13;&#10;#   [ground]&#13;&#10;#   1,1,1,0,0&#13;&#10;#   1,2,2,0,0&#13;&#10;#&#13;&#10;# - 0은 빈 타일(배치 없음)을 의미.&#13;&#10;# - props 섹션은 현재 무시합니다.&#13;&#10;#&#13;&#10;# 제공하는 기능:&#13;&#10;# - Map.load_from_room_txt(path): Room.txt 파싱&#13;&#10;# - Map.build_into_world(world, tile_size=32, origin=(0,0)): world의 레이어들에 타일 엔티티를 추가&#13;&#10;# - TileEntity: 최소한의 update()/draw() 인터페이스(프로젝트의 실제 렌더링 파이프라인에 맞춰 확장 가능)&#13;&#10;&#13;&#10;import os&#13;&#10;from typing import Dict, List, Tuple, Optional&#13;&#10;&#13;&#10;try:&#13;&#10;    from pico2d import draw_rectangle&#13;&#10;except Exception:&#13;&#10;    # pico2d가 없으면 draw_rectangle을 대체하는 더미 함수로 허용&#13;&#10;    def draw_rectangle(l, b, r, t):&#13;&#10;        # no-op in headless/static analysis&#13;&#10;        return&#13;&#10;&#13;&#10;&#13;&#10;SUPPORTED_SECTIONS = ['ground', 'upper_ground', 'walls', 'cliff', 'props']&#13;&#10;&#13;&#10;&#13;&#10;class TileEntity:&#13;&#10;    &quot;&quot;&quot;맵에 배치되는 간단한 타일 엔티티.&#13;&#10;    실제 프로젝트에서는 이미지(tileset)과 애니메이션, 충돌박스 등을 연결해서 사용하면 됩니다.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;&#13;&#10;    def __init__(self, tile_id: int, x: int, y: int, size: int, layer: str):&#13;&#10;        self.tile_id = int(tile_id)&#13;&#10;        self.x = int(x)&#13;&#10;        self.y = int(y)&#13;&#10;        self.size = int(size)&#13;&#10;        self.layer = layer&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        # 기본 타일은 고정이므로 True를 반환하여 계속 유지&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self):&#13;&#10;        # 디버그용 간단한 사각형 그리기 (pico2d가 있으면 보임)&#13;&#10;        l = self.x&#13;&#10;        b = self.y&#13;&#10;        r = self.x + self.size&#13;&#10;        t = self.y + self.size&#13;&#10;        draw_rectangle(l, b, r, t)&#13;&#10;&#13;&#10;&#13;&#10;class Map:&#13;&#10;    def __init__(self, tile_size: int = 32):&#13;&#10;        self.tile_size = int(tile_size)&#13;&#10;        # 각 섹션에 대해 2D 리스트(행 리스트)로 타일 인덱스를 보관&#13;&#10;        self.layers: Dict[str, List[List[int]]] = {s: [] for s in SUPPORTED_SECTIONS}&#13;&#10;        self.width = 0&#13;&#10;        self.height = 0&#13;&#10;&#13;&#10;    @staticmethod&#13;&#10;    def _normalize_section_name(name: str) -&gt; str:&#13;&#10;        return name.strip().lower()&#13;&#10;&#13;&#10;    def load_from_room_txt(self, path: str) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Room.txt 형식(간단한 INI 스타일)을 파싱하여 self.layers에 채웁니다.&#13;&#10;        빈 라인 또는 주석(//, ;, #)은 무시합니다.&#13;&#10;&#13;&#10;        변경: 토큰 구분자는 공백(whitespace)을 사용합니다. 라인 내의 ','는 공백으로 대체되어&#13;&#10;        기존 콤마 형식과도 호환됩니다. 토큰 '0' 및 'X'/'x'는 빈 타일(0)으로 처리됩니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not os.path.isfile(path):&#13;&#10;            raise FileNotFoundError(f&quot;Room file not found: {path}&quot;)&#13;&#10;&#13;&#10;        current = None&#13;&#10;        with open(path, 'r', encoding='utf-8') as f:&#13;&#10;            for raw_line in f:&#13;&#10;                line = raw_line.strip()&#13;&#10;                if not line:&#13;&#10;                    continue&#13;&#10;                if line.startswith('//') or line.startswith('#') or line.startswith(';'):&#13;&#10;                    continue&#13;&#10;                if line.startswith('[') and line.endswith(']'):&#13;&#10;                    sec = self._normalize_section_name(line[1:-1])&#13;&#10;                    if sec not in SUPPORTED_SECTIONS:&#13;&#10;                        # 새 섹션을 만드려 하지 말고 지원되는 섹션만 처리&#13;&#10;                        current = None&#13;&#10;                        continue&#13;&#10;                    current = sec&#13;&#10;                    # reset existing content for the section&#13;&#10;                    self.layers[current] = []&#13;&#10;                    continue&#13;&#10;&#13;&#10;                if current is None:&#13;&#10;                    # 섹션 밖의 데이터는 무시&#13;&#10;                    continue&#13;&#10;&#13;&#10;                # ',' 구분자를 공백으로 바꿔 공백 분할을 사용하여 유연하게 처리&#13;&#10;                normalized = line.replace(',', ' ')&#13;&#10;                parts = [p.strip() for p in normalized.split() if p.strip() != '']&#13;&#10;                if not parts:&#13;&#10;                    continue&#13;&#10;                row: List[int] = []&#13;&#10;                for p in parts:&#13;&#10;                    # '0' 과 'X' 또는 'x' 를 빈타일로 처리&#13;&#10;                    if p == '0' or p.lower() == 'x':&#13;&#10;                        row.append(0)&#13;&#10;                        continue&#13;&#10;                    try:&#13;&#10;                        row.append(int(p))&#13;&#10;                    except ValueError:&#13;&#10;                        # 숫자로 변환할 수 없는 토큰이 있으면 빈타일로 처리&#13;&#10;                        row.append(0)&#13;&#10;                self.layers[current].append(row)&#13;&#10;&#13;&#10;        # 맵 전체 크기 계산 (가장 큰 폭/높이 사용)&#13;&#10;        max_w = 0&#13;&#10;        max_h = 0&#13;&#10;        for sec in SUPPORTED_SECTIONS:&#13;&#10;            h = len(self.layers.get(sec, []))&#13;&#10;            if h &gt; max_h:&#13;&#10;                max_h = h&#13;&#10;            for row in self.layers.get(sec, []):&#13;&#10;                if len(row) &gt; max_w:&#13;&#10;                    max_w = len(row)&#13;&#10;        self.width = max_w&#13;&#10;        self.height = max_h&#13;&#10;&#13;&#10;    def build_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0), replace: bool = True) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        파싱된 레이어 데이터를 바탕으로 `world` 딕셔너리의 레이어 리스트에 TileEntity들을 추가합니다.&#13;&#10;        - world: main.py에서 사용되는 world 딕셔너리 (예: keys: 'ground','upper_ground','walls',...)&#13;&#10;        - tile_size: 맵의 타일 픽셀 크기 (기본은 Map.tile_size)&#13;&#10;        - origin: (x0,y0) 맵 원점 좌표 (왼쪽 하단 기준)&#13;&#10;        - replace: True이면 이 함수가 추가할 레이어(ground/upper_ground/walls)의 기존 리스트를 비우고 새로 채웁니다.&#13;&#10;&#13;&#10;        이 함수는 props 섹션은 현재 무시합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        ts = int(tile_size) if tile_size is not None else self.tile_size&#13;&#10;        x0, y0 = origin&#13;&#10;&#13;&#10;        target_layers = ['ground', 'upper_ground', 'walls']&#13;&#10;        if replace:&#13;&#10;            for tl in target_layers:&#13;&#10;                if tl in world and isinstance(world[tl], list):&#13;&#10;                    world[tl].clear()&#13;&#10;&#13;&#10;        # 맵 데이터의 행렬은 텍스트 상에서는 보통 위에서 아래로 작성됨을 가정.&#13;&#10;        # 여기서는 텍스트 행(0)이 맵의 &quot;상단&quot;이라고 가정하고 화면 좌표로는 높이를 고려해 y를 계산합니다.&#13;&#10;        for sec in ['ground', 'upper_ground', 'walls', 'cliff']:&#13;&#10;            rows = self.layers.get(sec, [])&#13;&#10;            h = len(rows)&#13;&#10;            for row_idx, row in enumerate(rows):&#13;&#10;                # 텍스트의 첫 행 -&gt; 맵 상단이므로 y 계산&#13;&#10;                # 맵 상단을 origin_y + (height - 1 - row_idx) * ts 로 배치&#13;&#10;                for col_idx, tile_id in enumerate(row):&#13;&#10;                    if tile_id == 0:&#13;&#10;                        continue&#13;&#10;                    # compute position&#13;&#10;                    # bottom-left origin&#13;&#10;                    x = x0 + col_idx * ts&#13;&#10;                    y = y0 + (self.height - 1 - row_idx) * ts&#13;&#10;                    ent = TileEntity(tile_id=tile_id, x=x, y=y, size=ts, layer=sec)&#13;&#10;                    # 저장된 그리드 좌표를 붙여 두면 나중에 크기 변경 시 재계산에 사용 가능&#13;&#10;                    ent._grid_col = col_idx&#13;&#10;                    ent._grid_row = row_idx&#13;&#10;                    ent._map_height = self.height&#13;&#10;                    ent._origin = (x0, y0)&#13;&#10;                    # 월드에 맞는 레이어 키가 존재하면 append&#13;&#10;                    if sec == 'ground':&#13;&#10;                        world.setdefault('ground', []).append(ent)&#13;&#10;                    elif sec == 'upper_ground':&#13;&#10;                        world.setdefault('upper_ground', []).append(ent)&#13;&#10;                    elif sec == 'walls' or sec == 'cliff':&#13;&#10;                        # 벽/절벽은 충돌 처리용으로 walls 레이어에 넣음&#13;&#10;                        world.setdefault('walls', []).append(ent)&#13;&#10;                    else:&#13;&#10;                        # props 등은 현재 무시&#13;&#10;                        pass&#13;&#10;&#13;&#10;    def rebuild_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        편의 메서드: 기존 내용을 교체(replace=True)하여 다시 빌드합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.build_into_world(world, tile_size=tile_size, origin=origin, replace=True)&#13;&#10;&#13;&#10;    def apply_tile_size_to_world(self, world: Dict[str, list], new_tile_size: int, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        기존에 world에 배치된 TileEntity들이 그리드 좌표를 가지고 있다면,&#13;&#10;        각 엔티티의 size와 x,y를 새 타일 크기에 맞게 in-place로 갱신합니다.&#13;&#10;        - world: 월드 딕셔너리&#13;&#10;        - new_tile_size: 적용할 새 타일 크기&#13;&#10;        - origin: 맵 원점&#13;&#10;&#13;&#10;        이 방법은 엔티티를 새로 생성하지 않으므로 외부 참조가 유지됩니다.&#13;&#10;        만약 엔티티에 그리드 좌표가 없다면 동작하지 않습니다(그럴 경우 재빌드 필요).&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        ts = int(new_tile_size)&#13;&#10;        x0, y0 = origin&#13;&#10;        layers = ['ground', 'upper_ground', 'walls']&#13;&#10;        updated = 0&#13;&#10;        for layer in layers:&#13;&#10;            for ent in list(world.get(layer, [])):&#13;&#10;                # ent가 grid 정보(_grid_col/_grid_row/_map_height)를 가지고 있으면 위치 재계산&#13;&#10;                if hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height'):&#13;&#10;                    col = int(ent._grid_col)&#13;&#10;                    row = int(ent._grid_row)&#13;&#10;                    map_h = int(ent._map_height)&#13;&#10;                    ent.size = ts&#13;&#10;                    ent.x = x0 + col * ts&#13;&#10;                    ent.y = y0 + (map_h - 1 - row) * ts&#13;&#10;                    # update stored origin too&#13;&#10;                    ent._origin = (x0, y0)&#13;&#10;                    updated += 1&#13;&#10;                else:&#13;&#10;                    # grid 정보가 없으면 이 엔티티는 무시 (재빌드를 권장)&#13;&#10;                    continue&#13;&#10;        try:&#13;&#10;            print(f&quot;apply_tile_size_to_world: applied new_tile_size={ts}, updated_entities={updated}&quot;)&#13;&#10;        except Exception:&#13;&#10;            pass&#13;&#10;&#13;&#10;    def set_tile_size(self, new_tile_size: int, world: Optional[Dict[str, list]] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Map의 기본 타일 크기를 변경합니다. 만약 `world`를 전달하면 해당 월드에 대해&#13;&#10;        가능한 경우 in-place로 크기/위치를 갱신하고, grid 정보가 부족하면 재빌드를 수행합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.tile_size = int(new_tile_size)&#13;&#10;        if world is not None:&#13;&#10;            # 먼저 시도: in-place 적용 (grid 좌표가 있는 경우)&#13;&#10;            # 검사: 모든 엔티티들이 grid 좌표를 가지고 있는지 확인&#13;&#10;            ok = True&#13;&#10;            total = 0&#13;&#10;            for layer in ['ground', 'upper_ground', 'walls']:&#13;&#10;                for ent in world.get(layer, []):&#13;&#10;                    total += 1&#13;&#10;                    if not (hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height')):&#13;&#10;                        ok = False&#13;&#10;                        break&#13;&#10;                if not ok:&#13;&#10;                    break&#13;&#10;            if ok:&#13;&#10;                try:&#13;&#10;                    self.apply_tile_size_to_world(world, self.tile_size, origin)&#13;&#10;                    print(f&quot;set_tile_size: in-place applied to {total} entities, new_tile_size={self.tile_size}&quot;)&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91mset_tile_size: in-place apply failed: {e}\033[0m&quot;)&#13;&#10;            else:&#13;&#10;                # 일부 엔티티에 grid 정보가 없으면 안전하게 재빌드&#13;&#10;                try:&#13;&#10;                    self.rebuild_into_world(world, tile_size=self.tile_size, origin=origin)&#13;&#10;                    print(f&quot;set_tile_size: rebuilt world with new_tile_size={self.tile_size}&quot;)&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91mset_tile_size: rebuild failed: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;# 간단한 자기검증 스크립트&#13;&#10;if __name__ == '__main__':&#13;&#10;    # 간단한 Room 텍스트 샘플을 메모리로 만들고 파싱 테스트&#13;&#10;    sample = '''&#13;&#10;[ground]&#13;&#10;1,1,1,0,0&#13;&#10;1,2,2,0,0&#13;&#10;&#13;&#10;[upper_ground]&#13;&#10;0,0,3,3,0&#13;&#10;&#13;&#10;[walls]&#13;&#10;0,4,0,0,0&#13;&#10;'''&#13;&#10;    import tempfile&#13;&#10;&#13;&#10;    p = tempfile.gettempdir() + os.sep + 'sample_room.txt'&#13;&#10;    with open(p, 'w', encoding='utf-8') as f:&#13;&#10;        f.write(sample)&#13;&#10;&#13;&#10;    m = Map(tile_size=128)&#13;&#10;    m.load_from_room_txt(p)&#13;&#10;    print('width,height:', m.width, m.height)&#13;&#10;    world = {k: [] for k in ['ground', 'upper_ground', 'walls', 'effects_back', 'effects_front', 'ui', 'cursor']}&#13;&#10;    m.build_into_world(world, origin=(0, 0))&#13;&#10;    for k in world:&#13;&#10;        print(k, len(world[k]))" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/title_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/title_mode.py" />
              <option name="originalContent" value="# game_logic/title_mode.py&#10;&quot;&quot;&quot;타이틀 화면 모듈&quot;&quot;&quot;&#10;&#10;import pico2d as p2&#10;import ctypes&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE, SDLK_RETURN, SDLK_SPACE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_GetMouseState, SDL_MOUSEMOTION&#10;&#10;import game_framework&#10;from . import framework&#10;from .cursor import Cursor&#10;&#10;# 타이틀 화면 이미지&#10;title_image = None&#10;title_back_image = None&#10;&#10;# Tree 애니메이션&#10;tree_begin_images = []  # TreeBegin 애니메이션 (00~29)&#10;tree_loop_images = []   # Tree 루프 애니메이션 (00~15)&#10;animation_frame = 0&#10;animation_time = 0.0&#10;animation_fps = 12  # 초당 프레임 수&#10;is_begin_phase = True  # True: TreeBegin 재생 중, False: Tree 루프 재생 중&#10;&#10;# 스케일 팩터&#10;tree_scale = 3.0  # Tree 애니메이션 스케일&#10;title_scale = 3.0  # 타이틀 로고 스케일&#10;&#10;# 월드 레이어 (play_mode와 유사한 구조)&#10;world = {&#10;    'background': [],  # 배경 이미지&#10;    'tree_animation': [],  # Tree 애니메이션&#10;    'title': [],  # 타이틀 로고&#10;    'buttons': [],  # 메뉴 버튼들&#10;    'cursor': []  # 커서&#10;}&#10;&#10;# 배경 렌더러&#10;class BackgroundRenderer:&#10;    &quot;&quot;&quot;배경 이미지를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image):&#10;        self.image = image&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;            self.image.draw(center_x, center_y, canvas_width, canvas_height)&#10;&#10;# Tree 애니메이션 렌더러&#10;class TreeAnimationRenderer:&#10;    &quot;&quot;&quot;Tree 애니메이션을 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, begin_images, loop_images, scale):&#10;        self.begin_images = begin_images&#10;        self.loop_images = loop_images&#10;        self.scale = scale&#10;        self.current_frame = 0&#10;        self.animation_time = 0.0&#10;        self.animation_fps = 12&#10;        self.is_begin_phase = True&#10;&#10;    def update(self):&#10;        dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;        self.animation_time += dt&#10;&#10;        frame_time = 1.0 / self.animation_fps&#10;&#10;        if self.animation_time &gt;= frame_time:&#10;            self.animation_time -= frame_time&#10;&#10;            if self.is_begin_phase:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.begin_images):&#10;                    self.is_begin_phase = False&#10;                    self.current_frame = 0&#10;                    print(&quot;[title_mode] TreeBegin 완료, Tree 루프 시작&quot;)&#10;            else:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.loop_images):&#10;                    self.current_frame = 0&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        canvas_width = p2.get_canvas_width()&#10;        canvas_height = p2.get_canvas_height()&#10;        center_x = canvas_width // 2&#10;        center_y = canvas_height // 2&#10;&#10;        if self.is_begin_phase and self.begin_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.begin_images):&#10;                tree_img = self.begin_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;        elif not self.is_begin_phase and self.loop_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.loop_images):&#10;                tree_img = self.loop_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;&#10;# 타이틀 로고 렌더러&#10;class TitleRenderer:&#10;    &quot;&quot;&quot;타이틀 로고를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image, scale):&#10;        self.image = image&#10;        self.scale = scale&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;&#10;            title_width = int(self.image.w * self.scale)&#10;            title_height = int(self.image.h * self.scale)&#10;            self.image.draw(center_x, int(center_y * 0.7), title_width, title_height)&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False&#10;&#10;# 메뉴 버튼&#10;class MenuButton:&#10;    &quot;&quot;&quot;클릭 가능한 메뉴 버튼 클래스&quot;&quot;&quot;&#10;    _font = None  # 클래스 변수로 폰트 공유&#10;&#10;    def __init__(self, text, x, y, width, height, callback):&#10;        self.text = text&#10;        self.x = x  # 중심 x 좌표&#10;        self.y = y  # 중심 y 좌표&#10;        self.width = width&#10;        self.height = height&#10;        self.callback = callback&#10;        self.hovered = False&#10;&#10;        # 폰트 로드 (최초 1회만)&#10;        if MenuButton._font is None:&#10;            try:&#10;                from pico2d import load_font&#10;                import os&#10;                # 폰트 경로 후보 (한글 지원 폰트 우선)&#10;                font_candidates = [&#10;                    'resources/Fonts/pixelroborobo.otf',&#10;                ]&#10;                for font_path in font_candidates:&#10;                    try:&#10;                        MenuButton._font = load_font(font_path, 40)  # 버튼용 폰트 크기 40으로 증가&#10;                        print(f&quot;[MenuButton] 폰트 로드 성공: {font_path}&quot;)&#10;                        break&#10;                    except Exception:&#10;                        continue&#10;            except Exception as ex:&#10;                print(f&quot;[MenuButton] 폰트 로드 실패: {ex}&quot;)&#10;&#10;    def contains_point(self, px, py):&#10;        &quot;&quot;&quot;점이 버튼 내부에 있는지 확인&quot;&quot;&quot;&#10;        left = self.x - self.width // 2&#10;        right = self.x + self.width // 2&#10;        bottom = self.y - self.height // 2&#10;        top = self.y + self.height // 2&#10;        return left &lt;= px &lt;= right and bottom &lt;= py &lt;= top&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치에 따라 hover 상태 업데이트&quot;&quot;&quot;&#10;        # 마우스 위치 가져오기&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        mouse_x = mx_ptr.value&#10;        mouse_y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        self.hovered = self.contains_point(mouse_x, mouse_y)&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;버튼 그리기&quot;&quot;&quot;&#10;        # 버튼 배경 박스&#10;        if self.hovered:&#10;            # hover 상태: 밝은 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;        else:&#10;            # 일반 상태: 어두운 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;&#10;        # 텍스트 표시&#10;        if MenuButton._font:&#10;            # 텍스트 색상 (hover 상태에 따라 변경)&#10;            if self.hovered:&#10;                # hover 상태: 밝은 흰색&#10;                text_color = (255, 255, 150)&#10;                shadow_color = (0, 0, 0)&#10;            else:&#10;                # 일반 상태: 회색&#10;                text_color = (200, 200, 200)&#10;                shadow_color = (50, 50, 50)&#10;&#10;            # 그림자 효과 (가독성 향상)&#10;            MenuButton._font.draw(self.x - 2, self.y - 2, self.text, shadow_color)&#10;            MenuButton._font.draw(self.x - 1, self.y - 1, self.text, shadow_color)&#10;            # 실제 텍스트&#10;            MenuButton._font.draw(self.x, self.y, self.text, text_color)&#10;&#10;    def on_click(self):&#10;        &quot;&quot;&quot;버튼 클릭 시 콜백 실행&quot;&quot;&quot;&#10;        if self.callback:&#10;            self.callback()&#10;&#10;# 메뉴 버튼 리스트&#10;mouse_x, mouse_y = 0, 0&#10;&#10;def start_game():&#10;    &quot;&quot;&quot;게임 시작 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 시작&quot;)&#10;    import game_logic.play_mode as play_mode&#10;    import game_logic.lobby_mode as lobby_mode&#10;    game_framework.change_state(lobby_mode)&#10;&#10;def quit_game():&#10;    &quot;&quot;&quot;게임 종료 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 종료&quot;)&#10;    game_framework.quit()&#10;&#10;def enter():&#10;    &quot;&quot;&quot;타이틀 모드 진입&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images&#10;    global animation_frame, animation_time, is_begin_phase, world&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 진입&quot;)&#10;&#10;    # 월드 레이어 초기화&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    # 이미지 로드&#10;    title_back_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title_Back.png')&#10;    title_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title.png')&#10;&#10;    # Tree Begin 애니메이션 로드 (00~29)&#10;    tree_begin_images = []&#10;    for i in range(30):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_TreeBegin{i:02d}.png'&#10;        try:&#10;            img = p2.load_image(path)&#10;            tree_begin_images.append(img)&#10;        except Exception as e:&#10;            print(f&quot;[title_mode] TreeBegin 이미지 로드 실패: {path}, {e}&quot;)&#10;&#10;    print(f&quot;[title_mode] TreeBegin 이미지 {len(tree_begin_images)}개 로드 완료&quot;)&#10;&#10;    # Tree Loop 애니메이션 로드 (00~15)&#10;    tree_loop_images = []&#10;    for i in range(16):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_Tree{i:02d}.png'&#10;        try:&#10;            img = p2.load_image(path)&#10;            tree_loop_images.append(img)&#10;        except Exception as e:&#10;            print(f&quot;[title_mode] Tree 이미지 로드 실패: {path}, {e}&quot;)&#10;&#10;    print(f&quot;[title_mode] Tree 이미지 {len(tree_loop_images)}개 로드 완료&quot;)&#10;&#10;    # 월드 레이어에 객체 추가&#10;    # 1. 배경&#10;    world['background'].append(BackgroundRenderer(title_back_image))&#10;&#10;    # 2. Tree 애니메이션&#10;    tree_animator = TreeAnimationRenderer(tree_begin_images, tree_loop_images, tree_scale)&#10;    world['tree_animation'].append(tree_animator)&#10;&#10;    # 3. 타이틀 로고&#10;    world['title'].append(TitleRenderer(title_image, title_scale))&#10;&#10;    # 4. 메뉴 버튼 생성 (가로 정렬)&#10;    canvas_width = p2.get_canvas_width()&#10;    canvas_height = p2.get_canvas_height()&#10;    center_x = canvas_width // 2&#10;    button_y = canvas_height // 5.5  # 두 버튼 모두 같은 y 좌표&#10;    button_spacing = 220  # 버튼 간격(가로)&#10;    button_width = 200&#10;    button_height = 60&#10;&#10;    # 왼쪽: 시작, 오른쪽: 종료&#10;    world['buttons'].append(MenuButton(&quot;시작&quot;, center_x - button_spacing // 1.5, button_y, button_width, button_height, start_game))&#10;    world['buttons'].append(MenuButton(&quot;종료&quot;, center_x + button_spacing // 1.5, button_y, button_width, button_height, quit_game))&#10;&#10;    # 5. 커서&#10;    try:&#10;        cursor = TitleCursor()  # 타이틀 전용 커서 (인벤토리 커서 애니메이션 사용)&#10;        world['cursor'].append(cursor)&#10;        print(&quot;[title_mode] 타이틀 커서 생성 완료&quot;)&#10;    except Exception as ex:&#10;        print('[title_mode] 타이틀 커서 생성 실패:', ex)&#10;&#10;    print(&quot;[title_mode] 타이틀 이미지 로드 완료&quot;)&#10;&#10;def exit():&#10;    &quot;&quot;&quot;타이틀 모드 종료&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images, world&#10;&#10;    title_image = None&#10;    title_back_image = None&#10;    tree_begin_images = []&#10;    tree_loop_images = []&#10;&#10;    # 월드 레이어 정리&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 종료&quot;)&#10;&#10;def update():&#10;    &quot;&quot;&quot;타이틀 화면 업데이트&quot;&quot;&quot;&#10;    # 모든 레이어의 객체 업데이트&#10;    for layer_name in ['background', 'tree_animation', 'title', 'buttons', 'cursor']:&#10;        layer = world.get(layer_name, [])&#10;        new_list = []&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'update'):&#10;                    keep = obj.update()&#10;                    if keep is None or keep:&#10;                        new_list.append(obj)&#10;            except Exception as ex:&#10;                print(f'[title_mode] Update error in {layer_name}:', ex)&#10;                new_list.append(obj)&#10;        world[layer_name] = new_list&#10;&#10;def draw():&#10;    &quot;&quot;&quot;타이틀 화면 그리기&quot;&quot;&quot;&#10;    p2.clear_canvas()&#10;&#10;    # 레이어 순서대로 그리기&#10;    render_order = ['background', 'tree_animation', 'title', 'buttons', 'cursor']&#10;&#10;    for layer_name in render_order:&#10;        layer = world.get(layer_name, [])&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw()&#10;            except Exception as ex:&#10;                print(f'[title_mode] Draw error in {layer_name}:', ex)&#10;&#10;    p2.update_canvas()&#10;&#10;def handle_events():&#10;    &quot;&quot;&quot;이벤트 처리 (game_framework가 호출하는 함수)&quot;&quot;&quot;&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            game_framework.quit()&#10;        elif e.type == SDL_KEYDOWN:&#10;            if e.key == SDLK_ESCAPE:&#10;                game_framework.quit()&#10;            elif e.key == SDLK_RETURN or e.key == SDLK_SPACE:&#10;                # Enter 또는 Space 키를 누르면 게임 시작 (기존 동작 유지)&#10;                print(&quot;[title_mode] 게임 시작&quot;)&#10;                import game_logic.play_mode as play_mode&#10;                game_framework.change_state(play_mode)&#10;        elif e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                # 마우스 클릭 시 버튼 체크&#10;                for button in world.get('buttons', []):&#10;                    if button.hovered:&#10;                        button.on_click()&#10;                        break&#10;&#10;        # 커서에 이벤트 전달 (클릭 애니메이션 처리)&#10;        for cursor in world.get('cursor', []):&#10;            try:&#10;                if hasattr(cursor, 'handle_event'):&#10;                    cursor.handle_event(e)&#10;            except Exception:&#10;                pass&#10;&#10;def pause():&#10;    &quot;&quot;&quot;타이틀 모드 일시 정지&quot;&quot;&quot;&#10;    pass&#10;&#10;def resume():&#10;    &quot;&quot;&quot;타이틀 모드 재개&quot;&quot;&quot;&#10;    pass&#10;" />
              <option name="updatedContent" value="# game_logic/title_mode.py&#10;&quot;&quot;&quot;타이틀 화면 모듈&quot;&quot;&quot;&#10;&#10;import pico2d as p2&#10;import ctypes&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE, SDLK_RETURN, SDLK_SPACE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_GetMouseState, SDL_MOUSEMOTION&#10;&#10;import game_framework&#10;from . import framework&#10;from .cursor import Cursor&#10;&#10;# 타이틀 화면 이미지&#10;title_image = None&#10;title_back_image = None&#10;&#10;# Tree 애니메이션&#10;tree_begin_images = []  # TreeBegin 애니메이션 (00~29)&#10;tree_loop_images = []   # Tree 루프 애니메이션 (00~15)&#10;animation_frame = 0&#10;animation_time = 0.0&#10;animation_fps = 12  # 초당 프레임 수&#10;is_begin_phase = True  # True: TreeBegin 재생 중, False: Tree 루프 재생 중&#10;&#10;# 스케일 팩터&#10;tree_scale = 3.0  # Tree 애니메이션 스케일&#10;title_scale = 3.0  # 타이틀 로고 스케일&#10;&#10;# 월드 레이어 (play_mode와 유사한 구조)&#10;world = {&#10;    'background': [],  # 배경 이미지&#10;    'tree_animation': [],  # Tree 애니메이션&#10;    'title': [],  # 타이틀 로고&#10;    'buttons': [],  # 메뉴 버튼들&#10;    'cursor': []  # 커서&#10;}&#10;&#10;# 배경 렌더러&#10;class BackgroundRenderer:&#10;    &quot;&quot;&quot;배경 이미지를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image):&#10;        self.image = image&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;            self.image.draw(center_x, center_y, canvas_width, canvas_height)&#10;&#10;# Tree 애니메이션 렌더러&#10;class TreeAnimationRenderer:&#10;    &quot;&quot;&quot;Tree 애니메이션을 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, begin_images, loop_images, scale):&#10;        self.begin_images = begin_images&#10;        self.loop_images = loop_images&#10;        self.scale = scale&#10;        self.current_frame = 0&#10;        self.animation_time = 0.0&#10;        self.animation_fps = 12&#10;        self.is_begin_phase = True&#10;&#10;    def update(self):&#10;        dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;        self.animation_time += dt&#10;&#10;        frame_time = 1.0 / self.animation_fps&#10;&#10;        if self.animation_time &gt;= frame_time:&#10;            self.animation_time -= frame_time&#10;&#10;            if self.is_begin_phase:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.begin_images):&#10;                    self.is_begin_phase = False&#10;                    self.current_frame = 0&#10;                    print(&quot;[title_mode] TreeBegin 완료, Tree 루프 시작&quot;)&#10;            else:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.loop_images):&#10;                    self.current_frame = 0&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        canvas_width = p2.get_canvas_width()&#10;        canvas_height = p2.get_canvas_height()&#10;        center_x = canvas_width // 2&#10;        center_y = canvas_height // 2&#10;&#10;        if self.is_begin_phase and self.begin_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.begin_images):&#10;                tree_img = self.begin_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;        elif not self.is_begin_phase and self.loop_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.loop_images):&#10;                tree_img = self.loop_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;&#10;# 타이틀 로고 렌더러&#10;class TitleRenderer:&#10;    &quot;&quot;&quot;타이틀 로고를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image, scale):&#10;        self.image = image&#10;        self.scale = scale&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;&#10;            title_width = int(self.image.w * self.scale)&#10;            title_height = int(self.image.h * self.scale)&#10;            self.image.draw(center_x, int(center_y * 0.7), title_width, title_height)&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False&#10;&#10;# 메뉴 버튼&#10;class MenuButton:&#10;    &quot;&quot;&quot;클릭 가능한 메뉴 버튼 클래스&quot;&quot;&quot;&#10;    _font = None  # 클래스 변수로 폰트 공유&#10;&#10;    def __init__(self, text, x, y, width, height, callback):&#10;        self.text = text&#10;        self.x = x  # 중심 x 좌표&#10;        self.y = y  # 중심 y 좌표&#10;        self.width = width&#10;        self.height = height&#10;        self.callback = callback&#10;        self.hovered = False&#10;&#10;        # 폰트 로드 (최초 1회만)&#10;        if MenuButton._font is None:&#10;            try:&#10;                from pico2d import load_font&#10;                import os&#10;                # 폰트 경로 후보 (한글 지원 폰트 우선)&#10;                font_candidates = [&#10;                    'resources/Fonts/pixelroborobo.otf',&#10;                ]&#10;                for font_path in font_candidates:&#10;                    try:&#10;                        MenuButton._font = load_font(font_path, 40)  # 버튼용 폰트 크기 40으로 증가&#10;                        print(f&quot;[MenuButton] 폰트 로드 성공: {font_path}&quot;)&#10;                        break&#10;                    except Exception:&#10;                        continue&#10;            except Exception as ex:&#10;                print(f&quot;[MenuButton] 폰트 로드 실패: {ex}&quot;)&#10;&#10;    def contains_point(self, px, py):&#10;        &quot;&quot;&quot;점이 버튼 내부에 있는지 확인&quot;&quot;&quot;&#10;        left = self.x - self.width // 2&#10;        right = self.x + self.width // 2&#10;        bottom = self.y - self.height // 2&#10;        top = self.y + self.height // 2&#10;        return left &lt;= px &lt;= right and bottom &lt;= py &lt;= top&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치에 따라 hover 상태 업데이트&quot;&quot;&quot;&#10;        # 마우스 위치 가져오기&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        mouse_x = mx_ptr.value&#10;        mouse_y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        self.hovered = self.contains_point(mouse_x, mouse_y)&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;버튼 그리기&quot;&quot;&quot;&#10;        # 버튼 배경 박스&#10;        if self.hovered:&#10;            # hover 상태: 밝은 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;        else:&#10;            # 일반 상태: 어두운 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;&#10;        # 텍스트 표시&#10;        if MenuButton._font:&#10;            # 텍스트 색상 (hover 상태에 따라 변경)&#10;            if self.hovered:&#10;                # hover 상태: 밝은 흰색&#10;                text_color = (255, 255, 150)&#10;                shadow_color = (0, 0, 0)&#10;            else:&#10;                # 일반 상태: 회색&#10;                text_color = (200, 200, 200)&#10;                shadow_color = (50, 50, 50)&#10;&#10;            # 그림자 효과 (가독성 향상)&#10;            MenuButton._font.draw(self.x - 2, self.y - 2, self.text, shadow_color)&#10;            MenuButton._font.draw(self.x - 1, self.y - 1, self.text, shadow_color)&#10;            # 실제 텍스트&#10;            MenuButton._font.draw(self.x, self.y, self.text, text_color)&#10;&#10;    def on_click(self):&#10;        &quot;&quot;&quot;버튼 클릭 시 콜백 실행&quot;&quot;&quot;&#10;        if self.callback:&#10;            self.callback()&#10;&#10;# 메뉴 버튼 리스트&#10;mouse_x, mouse_y = 0, 0&#10;&#10;def start_game():&#10;    &quot;&quot;&quot;게임 시작 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 시작&quot;)&#10;    import game_logic.play_mode as play_mode&#10;    import game_logic.lobby_mode as lobby_mode&#10;    game_framework.change_state(lobby_mode)&#10;&#10;def quit_game():&#10;    &quot;&quot;&quot;게임 종료 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 종료&quot;)&#10;    game_framework.quit()&#10;&#10;def enter():&#10;    &quot;&quot;&quot;타이틀 모드 진입&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images&#10;    global animation_frame, animation_time, is_begin_phase, world&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 진입&quot;)&#10;&#10;    # 월드 레이어 초기화&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    # 이미지 로드&#10;    title_back_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title_Back.png')&#10;    title_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title.png')&#10;&#10;    # Tree Begin 애니메이션 로드 (00~29)&#10;    tree_begin_images = []&#10;    for i in range(30):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_TreeBegin{i:02d}.png'&#10;        try:&#10;            img = p2.load_image(path)&#10;            tree_begin_images.append(img)&#10;        except Exception as e:&#10;            print(f&quot;[title_mode] TreeBegin 이미지 로드 실패: {path}, {e}&quot;)&#10;&#10;    print(f&quot;[title_mode] TreeBegin 이미지 {len(tree_begin_images)}개 로드 완료&quot;)&#10;&#10;    # Tree Loop 애니메이션 로드 (00~15)&#10;    tree_loop_images = []&#10;    for i in range(16):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_Tree{i:02d}.png'&#10;        try:&#10;            img = p2.load_image(path)&#10;            tree_loop_images.append(img)&#10;        except Exception as e:&#10;            print(f&quot;[title_mode] Tree 이미지 로드 실패: {path}, {e}&quot;)&#10;&#10;    print(f&quot;[title_mode] Tree 이미지 {len(tree_loop_images)}개 로드 완료&quot;)&#10;&#10;    # 월드 레이어에 객체 추가&#10;    # 1. 배경&#10;    world['background'].append(BackgroundRenderer(title_back_image))&#10;&#10;    # 2. Tree 애니메이션&#10;    tree_animator = TreeAnimationRenderer(tree_begin_images, tree_loop_images, tree_scale)&#10;    world['tree_animation'].append(tree_animator)&#10;&#10;    # 3. 타이틀 로고&#10;    world['title'].append(TitleRenderer(title_image, title_scale))&#10;&#10;    # 4. 메뉴 버튼 생성 (가로 정렬)&#10;    canvas_width = p2.get_canvas_width()&#10;    canvas_height = p2.get_canvas_height()&#10;    center_x = canvas_width // 2&#10;    button_y = canvas_height // 5.5  # 두 버튼 모두 같은 y 좌표&#10;    button_spacing = 220  # 버튼 간격(가로)&#10;    button_width = 200&#10;    button_height = 60&#10;&#10;    # 왼쪽: 시작, 오른쪽: 종료&#10;    world['buttons'].append(MenuButton(&quot;시작&quot;, center_x - button_spacing // 1.5, button_y, button_width, button_height, start_game))&#10;    world['buttons'].append(MenuButton(&quot;종료&quot;, center_x + button_spacing // 1.5, button_y, button_width, button_height, quit_game))&#10;&#10;    # 5. 커서&#10;    try:&#10;        cursor = TitleCursor()  # 타이틀 전용 커서 (인벤토리 커서 애니메이션 사용)&#10;        world['cursor'].append(cursor)&#10;        print(&quot;[title_mode] 타이틀 커서 생성 완료&quot;)&#10;    except Exception as ex:&#10;        print('[title_mode] 타이틀 커서 생성 실패:', ex)&#10;&#10;    print(&quot;[title_mode] 타이틀 이미지 로드 완료&quot;)&#10;&#10;def exit():&#10;    &quot;&quot;&quot;타이틀 모드 종료&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images, world&#10;&#10;    title_image = None&#10;    title_back_image = None&#10;    tree_begin_images = []&#10;    tree_loop_images = []&#10;&#10;    # 월드 레이어 정리&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 종료&quot;)&#10;&#10;def update():&#10;    &quot;&quot;&quot;타이틀 화면 업데이트&quot;&quot;&quot;&#10;    # 모든 레이어의 객체 업데이트&#10;    for layer_name in ['background', 'tree_animation', 'title', 'buttons', 'cursor']:&#10;        layer = world.get(layer_name, [])&#10;        new_list = []&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'update'):&#10;                    keep = obj.update()&#10;                    if keep is None or keep:&#10;                        new_list.append(obj)&#10;            except Exception as ex:&#10;                print(f'[title_mode] Update error in {layer_name}:', ex)&#10;                new_list.append(obj)&#10;        world[layer_name] = new_list&#10;&#10;def draw():&#10;    &quot;&quot;&quot;타이틀 화면 그리기&quot;&quot;&quot;&#10;    p2.clear_canvas()&#10;&#10;    # 레이어 순서대로 그리기&#10;    render_order = ['background', 'tree_animation', 'title', 'buttons', 'cursor']&#10;&#10;    for layer_name in render_order:&#10;        layer = world.get(layer_name, [])&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw()&#10;            except Exception as ex:&#10;                print(f'[title_mode] Draw error in {layer_name}:', ex)&#10;&#10;    p2.update_canvas()&#10;&#10;def handle_events():&#10;    &quot;&quot;&quot;이벤트 처리 (game_framework가 호출하는 함수)&quot;&quot;&quot;&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            game_framework.quit()&#10;        elif e.type == SDL_KEYDOWN:&#10;            if e.key == SDLK_ESCAPE:&#10;                game_framework.quit()&#10;            elif e.key == SDLK_RETURN or e.key == SDLK_SPACE:&#10;                # Enter 또는 Space 키를 누르면 게임 시작 (기존 동작 유지)&#10;                print(&quot;[title_mode] 게임 시작&quot;)&#10;                import game_logic.play_mode as play_mode&#10;                game_framework.change_state(play_mode)&#10;        elif e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                # 마우스 클릭 시 버튼 체크&#10;                for button in world.get('buttons', []):&#10;                    if button.hovered:&#10;                        button.on_click()&#10;                        break&#10;&#10;        # 커서에 이벤트 전달 (클릭 애니메이션 처리)&#10;        for cursor in world.get('cursor', []):&#10;            try:&#10;                if hasattr(cursor, 'handle_event'):&#10;                    cursor.handle_event(e)&#10;            except Exception:&#10;                pass&#10;&#10;def pause():&#10;    &quot;&quot;&quot;타이틀 모드 일시 정지&quot;&quot;&quot;&#10;    pass&#10;&#10;def resume():&#10;    &quot;&quot;&quot;타이틀 모드 재개&quot;&quot;&quot;&#10;    pass" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>