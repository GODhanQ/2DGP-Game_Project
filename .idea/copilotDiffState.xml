<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game_logic/cursor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/cursor.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False&#10;" />
              <option name="updatedContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/monsters/Boss_Logic/panther_assassin_4pattern.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/monsters/Boss_Logic/panther_assassin_4pattern.py" />
              <option name="originalContent" value="import pico2d as p2&#10;import random&#10;import math&#10;import game_framework as framework&#10;from ...behavior_tree import BehaviorTree&#10;from ..panther_assassin import Clone&#10;&#10;class AttackPattern4Action:&#10;    &quot;&quot;&quot;&#10;    panther_assassin.py의 보스 개체(PantherAssassin)의 공격패턴 4 구현 클래스&#10;    패턴4 - 은신과 분신 2체를 랜덤 위치에 소환 후 플레이어를 향해 수리검 10회 연속 투척 이후 본체 은신 풀림&#10;    자세한 설명:&#10;    1. 은신과 동시에 분신 2체를 Panther의 위치에 소환후 랜덤한 위치로 이동시킨다.&#10;        분신 소환시 분신이 위치로 부드럽게 이동한다 + 이동시 제자리에 동일한 모션 하나를 더 만들어&#10;        alpha를 0.5초만에 1에서 0으로 점점 줄여가며 사라지게 한다 (이동 이펙트)&#10;    2. 분신에서만 PantherShuriken 투척 (본체는 투척하지 않음)&#10;    3. 수리검은 플레이어를 향해 10회 연속 투척, 투척 간격은 매우 짧음&#10;    4. 모든 수리검 투척이 끝나면 본체의 은신이 풀림&#10;    5. 패턴 종료&#10;&#10;    기본 모션 경로: resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character&#10;    Throw 1st 와 Throw 2nd 모션을 번갈아 가며 재생하여 양손에서 수리검을 던지는 효과 연출&#10;    투척 1st 모션: PantherAssassin_Throw_1st{i:02d}.png 0 ~ 5&#10;    투척 2nd 모션: PantherAssassin_Throw_2nd{i:02d}.png 0 ~ 5&#10;    이동 모션: PantherAssassin_Move{i:02d}.png 0 ~ 7&#10;&#10;    주의: 분신은 본체와 구별을 위해 image_asset_manager.py의 make_dark 함수를 이용해&#10;        원본 이미지보다 검정색으로 편향된 이미지를 사용하여 구분한다.&#10;&#10;        이 분신은 충돌 처리나 공격 처리 등이 필요 없으며, 단순히 시각 효과 용도이므로&#10;        별도의 몬스터 객체로 만들지 않고 패턴 내부에서 위치 정보만 관리한다.&#10;&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;&#10;        # 은신 모션 관련 변수&#10;        self.stealth_animation_frames = 11  # Die 모션 프레임 수 (0~10)&#10;        self.stealth_frame = 0  # 현재 은신 모션 프레임&#10;        self.stealth_frame_duration = 0.08  # 프레임당 시간 (초)&#10;        self.is_stealth_animation_done = False  # 은신 모션 완료 플래그&#10;        self.is_unstealth_animation_done = False  # 은신 해제 모션 완료 플래그&#10;&#10;        # 은신 관련 변수&#10;        self.stealth_duration = 1.0  # 은신 지속 시간&#10;        self.is_stealthed = False  # 은신 상태&#10;&#10;        # 분신 소환 관련 변수&#10;        self.clone_count = 2  # 분신 개수&#10;        self.clones = []  # Clone 객체 리스트&#10;        self.clones_spawned = False  # 분신 소환 완료 플래그 (버그 수정용)&#10;&#10;        # 수리검 투척 관련 변수&#10;        self.shot_count = 0  # 현재 투척 횟수&#10;        self.max_shots = 10  # 최대 투척 횟수 (10회)&#10;        self.shot_interval = 0.15  # 투척 간격 (매우 짧음)&#10;        self.projectile_speed = 700  # 수리검 속도&#10;&#10;        # 본체 텔레포트 관련 변수&#10;        self.teleport_target_x = 0  # 텔레포트 목표 위치 X&#10;        self.teleport_target_y = 0  # 텔레포트 목표 위치 Y&#10;&#10;        # 이미지 로드&#10;        self._load_images()&#10;&#10;    def _load_images(self):&#10;        &quot;&quot;&quot;애니메이션 이미지 로드&quot;&quot;&quot;&#10;        try:&#10;            from game_logic import image_asset_manager as iam&#10;&#10;            base_path = &quot;resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character&quot;&#10;            print(f&quot;[Pattern4._load_images] 이미지 로드 시작 - 경로: {base_path}&quot;)&#10;&#10;            # 원본 이미지 로드 및 분신용 어두운 이미지 생성&#10;            self.original_images = {&#10;                'throw_1st': [],&#10;                'throw_2nd': [],&#10;                'move': [],&#10;                'stealth': []  # 은신 모션 추가 (Die 모션 재활용)&#10;            }&#10;&#10;            self.clone_images = {&#10;                'throw_1st': [],&#10;                'throw_2nd': [],&#10;                'move': [],&#10;                'die': []  # Die 모션 추가 (분신 사라지는 애니메이션용)&#10;            }&#10;&#10;            # Throw 1st 모션 (0~5)&#10;            for i in range(6):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Throw_1st{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['throw_1st'].append(img)&#10;&#10;                    # 경로 등록 후 어두운 버전 생성 (panther_assassin과 동일한 방식)&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['throw_1st'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern4._load_images] Throw_1st{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;                    import traceback&#10;                    traceback.print_exc()&#10;&#10;            # Throw 2nd 모션 (0~5)&#10;            for i in range(6):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Throw_2nd{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['throw_2nd'].append(img)&#10;&#10;                    # 경로 등록 후 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['throw_2nd'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern4._load_images] Throw_2nd{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;                    import traceback&#10;                    traceback.print_exc()&#10;&#10;            # Move 모션 (0~7)&#10;            for i in range(8):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Move{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['move'].append(img)&#10;&#10;                    # 경로 등록 후 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['move'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern4._load_images] Move{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;                    import traceback&#10;                    traceback.print_exc()&#10;&#10;            # Stealth 모션 (Die 모션 재활용, 0~10)&#10;            for i in range(11):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Die{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['stealth'].append(img)&#10;                    &#10;                    # 분신용 Die 애니메이션도 어두운 버전으로 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_die_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['die'].append(clone_die_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern4._load_images] Die{i:02d}.png (은신 모션) 로드 실패: {e}\033[0m&quot;)&#10;                    import traceback&#10;                    traceback.print_exc()&#10;&#10;            print(f&quot;[Pattern4._load_images] 원본 이미지 로드 결과 - &quot;&#10;                  f&quot;Throw1st: {len(self.original_images['throw_1st'])}개, &quot;&#10;                  f&quot;Throw2nd: {len(self.original_images['throw_2nd'])}개, &quot;&#10;                  f&quot;Move: {len(self.original_images['move'])}개, &quot;&#10;                  f&quot;Stealth: {len(self.original_images['stealth'])}개&quot;)&#10;&#10;            print(f&quot;[Pattern4._load_images] 분신 이미지 생성 완료 - &quot;&#10;                  f&quot;Throw1st: {len(self.clone_images['throw_1st'])}개, &quot;&#10;                  f&quot;Throw2nd: {len(self.clone_images['throw_2nd'])}개, &quot;&#10;                  f&quot;Move: {len(self.clone_images['move'])}개&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern4._load_images] 전체 로드 과정 오류: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 4 로직 실행&quot;&quot;&quot;&#10;        try:&#10;            dt = framework.get_delta_time()&#10;&#10;            if self.phase == 0:&#10;                # Phase 0: 초기화 및 은신 애니메이션 시작&#10;                self.timer = 0.0&#10;                self.stealth_frame = 0&#10;                self.is_stealth_animation_done = False&#10;                self.is_unstealth_animation_done = False&#10;                self.clones = []&#10;                self.clones_spawned = False&#10;                self.shot_count = 0&#10;&#10;                # 패턴 4 시작 시 본체 무적 활성화&#10;                self.panther.invincible = True&#10;                print(&quot;[Pattern4] 패턴 시작 - 은신 애니메이션 재생 (무적 활성화)&quot;)&#10;&#10;                self.phase = 1&#10;&#10;            elif self.phase == 1:&#10;                # Phase 1: 은신 애니메이션 재생 (0 -&gt; 10 프레임) + 분신 소환 동시 진행&#10;                self.timer += dt&#10;&#10;                # 분신 소환 (최초 1회만, 은신 애니메이션과 동시에 생성)&#10;                if not self.clones_spawned:&#10;                    try:&#10;                        print(f&quot;[Pattern4] 은신과 동시에 분신 소환 시작 - 본체 위치: ({self.panther.x:.0f}, {self.panther.y:.0f})&quot;)&#10;&#10;                        # 모든 분신을 한 번에 생성&#10;                        for i in range(self.clone_count):&#10;                            # 각 분신마다 랜덤 위치 계산&#10;                            angle = random.uniform(0, 360)&#10;                            rad = math.radians(angle)&#10;                            distance = random.uniform(150, 250)  # 본체로부터 거리&#10;&#10;                            target_x = self.panther.x + math.cos(rad) * distance&#10;                            target_y = self.panther.y + math.sin(rad) * distance&#10;&#10;                            # 분신 생성 (본체 위치에서 시작, 본체의 scale_factor 전달)&#10;                            clone = Clone(&#10;                                self.panther.x, self.panther.y,&#10;                                target_x, target_y,&#10;                                self.clone_images,&#10;                                self.panther.scale_factor  # 본체와 동일한 scale 사용&#10;                            )&#10;                            self.clones.append(clone)&#10;&#10;                            # effects_front 레이어에 추가 (카메라 좌표 자동 적용, 충돌 검사 제외)&#10;                            if self.panther.world and 'effects_front' in self.panther.world:&#10;                                self.panther.world['effects_front'].append(clone)&#10;                                print(f&quot;[Pattern4] 분신 {i+1}/{self.clone_count} 소환: ({target_x:.0f}, {target_y:.0f}) - effects_front 레이어에 추가됨&quot;)&#10;&#10;                        self.clones_spawned = True  # 소환 완료 플래그 설정&#10;                        print(f&quot;[Pattern4] 모든 분신 소환 완료! 총 {len(self.clones)}체&quot;)&#10;&#10;                    except Exception as e:&#10;                        print(f&quot;\033[91m[Pattern4] 분신 소환 중 오류: {e}\033[0m&quot;)&#10;                        import traceback&#10;                        traceback.print_exc()&#10;&#10;                # 프레임 업데이트&#10;                if self.timer &gt;= self.stealth_frame_duration:&#10;                    self.stealth_frame += 1&#10;                    self.timer = 0.0&#10;&#10;                    # 은신 애니메이션 완료 체크 (0~10, 총 11프레임)&#10;                    if self.stealth_frame &gt;= self.stealth_animation_frames:&#10;                        self.is_stealth_animation_done = True&#10;                        self.is_stealthed = True&#10;                        self.timer = 0.0&#10;                        self.phase = 2&#10;                        print(&quot;[Pattern4] 은신 애니메이션 완료! 분신 이동 대기&quot;)&#10;&#10;            elif self.phase == 2:&#10;                # Phase 2: 은신 중 - 분신 이동 대기&#10;                self.timer += dt&#10;&#10;                # 모든 분신의 이동 완료 체크&#10;                if self.clones_spawned and len(self.clones) == self.clone_count:&#10;                    # 모든 분신이 목표 위치에 도착했는지 확인&#10;                    all_moved = all(not clone.is_moving for clone in self.clones)&#10;&#10;                    if all_moved:&#10;                        # Phase 3으로 전환 (수리검 투척 시작)&#10;                        self.timer = 0.0&#10;                        self.phase = 3&#10;                        print(&quot;[Pattern4] 분신 이동 완료! 수리검 투척 시작!&quot;)&#10;&#10;            elif self.phase == 3:&#10;                # Phase 3: 수리검 투척 (분신에서만)&#10;                self.timer += dt&#10;&#10;                # 투척 간격마다 수리검 발사&#10;                if self.timer &gt;= self.shot_interval:&#10;                    if self.shot_count &lt; self.max_shots:&#10;                        try:&#10;                            # 각 분신에서 수리검 발사&#10;                            for clone in self.clones:&#10;                                if self.panther.target and self.panther.world and 'effects_front' in self.panther.world:&#10;                                    # PantherShuriken 생성&#10;                                    from ..panther_assassin import PantherShuriken&#10;                                    shuriken = PantherShuriken(&#10;                                        clone.x, clone.y,&#10;                                        self.panther.target.x, self.panther.target.y,&#10;                                        speed=self.projectile_speed,&#10;                                        from_player=False,&#10;                                        damage=15,&#10;                                        scale=2.5&#10;                                    )&#10;&#10;                                    # world의 effects_front 레이어에 추가&#10;                                    self.panther.world['effects_front'].append(shuriken)&#10;                                    print(f&quot;[Pattern4] 수리검 생성: ({int(clone.x)}, {int(clone.y)}) -&gt; ({int(self.panther.target.x)}, {int(self.panther.target.y)})&quot;)&#10;&#10;                                # 투척 애니메이션 교대 (1st &lt;-&gt; 2nd)&#10;                                throw_type = 'throw_1st' if self.shot_count % 2 == 0 else 'throw_2nd'&#10;                                clone.switch_throw_animation(throw_type)&#10;&#10;                            self.shot_count += 1&#10;                            self.timer = 0.0&#10;                            print(f&quot;[Pattern4] 수리검 발사 {self.shot_count}/{self.max_shots} (분신 {len(self.clones)}체)&quot;)&#10;&#10;                        except Exception as e:&#10;                            print(f&quot;\033[91m[Pattern4] 수리검 발사 중 오류: {e}\033[0m&quot;)&#10;                            import traceback&#10;                            traceback.print_exc()&#10;&#10;                # 모든 수리검 발사 완료&#10;                if self.shot_count &gt;= self.max_shots:&#10;                    # 본체 텔레포트 목표 위치 계산 (플레이어 주위 랜덤 위치)&#10;                    if self.panther.target:&#10;                        angle = random.uniform(0, 360)&#10;                        rad = math.radians(angle)&#10;                        distance = random.uniform(100, 200)  # 플레이어로부터 거리&#10;&#10;                        self.teleport_target_x = self.panther.target.x + math.cos(rad) * distance&#10;                        self.teleport_target_y = self.panther.target.y + math.sin(rad) * distance&#10;&#10;                        # 본체 텔레포트 즉시 실행&#10;                        self.panther.x = self.teleport_target_x&#10;                        self.panther.y = self.teleport_target_y&#10;                        print(f&quot;[Pattern4] 본체 텔레포트 완료: ({self.panther.x:.0f}, {self.panther.y:.0f})&quot;)&#10;                    else:&#10;                        # 타겟이 없으면 현재 위치 유지&#10;                        self.teleport_target_x = self.panther.x&#10;                        self.teleport_target_y = self.panther.y&#10;&#10;                    self.phase = 4&#10;                    self.timer = 0.0&#10;                    self.stealth_frame = self.stealth_animation_frames - 1  # 역재생 시작 (10부터 시작)&#10;                    print(&quot;[Pattern4] 수리검 투척 완료! 텔레포트 후 은신 해제 애니메이션 시작&quot;)&#10;&#10;            elif self.phase == 4:&#10;                # Phase 4: 은신 해제 애니메이션 재생 (10 -&gt; 0 프레임, 역순)&#10;                # 이미 Phase 3에서 텔레포트가 완료된 상태&#10;                self.timer += dt&#10;&#10;                # 프레임 업데이트 (역순)&#10;                if self.timer &gt;= self.stealth_frame_duration:&#10;                    self.stealth_frame -= 1&#10;                    self.timer = 0.0&#10;&#10;                    # 은신 해제 애니메이션 완료 체크&#10;                    if self.stealth_frame &lt; 0:&#10;                        self.is_unstealth_animation_done = True&#10;                        self.is_stealthed = False&#10;                        self.phase = 5&#10;                        print(&quot;[Pattern4] 은신 해제 애니메이션 완료!&quot;)&#10;&#10;            elif self.phase == 5:&#10;                # Phase 5: 패턴 종료 정리&#10;&#10;                # 패턴 4 종료 시 본체 무적 해제&#10;                self.panther.invincible = False&#10;                print(&quot;[Pattern4] 패턴 종료! (무적 해제)&quot;)&#10;&#10;                # 분신에게 사라지는 애니메이션 시작 명령&#10;                for clone in self.clones:&#10;                    clone.start_dying()&#10;                    print(f&quot;[Pattern4] 분신 Die 애니메이션 시작 - 위치: ({clone.x:.0f}, {clone.y:.0f})&quot;)&#10;&#10;                # 분신은 자동으로 애니메이션 후 제거되므로 여기서는 리스트만 비움&#10;                self.clones = []&#10;&#10;                # 패턴 종료&#10;                self.phase = 0&#10;                if hasattr(self.panther, 'attack_timer') and hasattr(self.panther, 'attack_cooldown'):&#10;                    self.panther.attack_timer = self.panther.attack_cooldown&#10;                return BehaviorTree.SUCCESS&#10;&#10;            return BehaviorTree.RUNNING&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern4.update] 전체 업데이트 오류 (phase={self.phase}): {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;            # 오류 발생 시에도 무적 해제 (안전장치)&#10;            self.panther.invincible = False&#10;            print(&quot;[Pattern4] 오류로 인한 긴급 무적 해제&quot;)&#10;&#10;            return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 4 전용 그리기 메서드&#10;&#10;        본체의 은신/해제 애니메이션을 그립니다.&#10;        - Phase 1: 은신 애니메이션 (0 -&gt; 10 프레임)&#10;        - Phase 2, 3: 은신 상태 (본체 숨김)&#10;        - Phase 4: 은신 해제 애니메이션 (10 -&gt; 0 프레임, 역순)&#10;        - Phase 5: 정상 상태 (기본 Idle 애니메이션)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Phase 1: 은신 애니메이션 재생 (0 -&gt; 10)&#10;            if self.phase == 1 and len(self.original_images['stealth']) &gt; 0:&#10;                if 0 &lt;= self.stealth_frame &lt; len(self.original_images['stealth']):&#10;                    img = self.original_images['stealth'][self.stealth_frame]&#10;                    img.draw(&#10;                        draw_x, draw_y,&#10;                        img.w * self.panther.scale_factor,&#10;                        img.h * self.panther.scale_factor&#10;                    )&#10;&#10;            # Phase 2, 3: 은신 상태 (본체 숨김 - 아무것도 그리지 않음)&#10;            elif self.phase in [2, 3]:&#10;                pass  # 본체는 보이지 않음&#10;&#10;            # Phase 4: 은신 해제 애니메이션 재생 (10 -&gt; 0, 역순)&#10;            elif self.phase == 4 and len(self.original_images['stealth']) &gt; 0:&#10;                if 0 &lt;= self.stealth_frame &lt; len(self.original_images['stealth']):&#10;                    img = self.original_images['stealth'][self.stealth_frame]&#10;                    img.draw(&#10;                        draw_x, draw_y,&#10;                        img.w * self.panther.scale_factor,&#10;                        img.h * self.panther.scale_factor&#10;                    )&#10;&#10;            # Phase 0, 5: 기본 Idle 애니메이션 (PantherAssassin의 기본 draw에서 처리)&#10;            else:&#10;                # 기본 상태는 PantherAssassin.draw()에서 처리하도록 패스&#10;                pass&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern4.draw] 그리기 오류: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;" />
              <option name="updatedContent" value="import pico2d as p2&#10;import random&#10;import math&#10;import game_framework as framework&#10;from ...behavior_tree import BehaviorTree&#10;from ..panther_assassin import Clone&#10;&#10;class AttackPattern4Action:&#10;    &quot;&quot;&quot;&#10;    panther_assassin.py의 보스 개체(PantherAssassin)의 공격패턴 4 구현 클래스&#10;    패턴4 - 은신과 분신 2체를 랜덤 위치에 소환 후 플레이어를 향해 수리검 10회 연속 투척 이후 본체 은신 풀림&#10;    자세한 설명:&#10;    1. 은신과 동시에 분신 2체를 Panther의 위치에 소환후 랜덤한 위치로 이동시킨다.&#10;        분신 소환시 분신이 위치로 부드럽게 이동한다 + 이동시 제자리에 동일한 모션 하나를 더 만들어&#10;        alpha를 0.5초만에 1에서 0으로 점점 줄여가며 사라지게 한다 (이동 이펙트)&#10;    2. 분신에서만 PantherShuriken 투척 (본체는 투척하지 않음)&#10;    3. 수리검은 플레이어를 향해 10회 연속 투척, 투척 간격은 매우 짧음&#10;    4. 모든 수리검 투척이 끝나면 본체의 은신이 풀림&#10;    5. 패턴 종료&#10;&#10;    기본 모션 경로: resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character&#10;    Throw 1st 와 Throw 2nd 모션을 번갈아 가며 재생하여 양손에서 수리검을 던지는 효과 연출&#10;    투척 1st 모션: PantherAssassin_Throw_1st{i:02d}.png 0 ~ 5&#10;    투척 2nd 모션: PantherAssassin_Throw_2nd{i:02d}.png 0 ~ 5&#10;    이동 모션: PantherAssassin_Move{i:02d}.png 0 ~ 7&#10;&#10;    주의: 분신은 본체와 구별을 위해 image_asset_manager.py의 make_dark 함수를 이용해&#10;        원본 이미지보다 검정색으로 편향된 이미지를 사용하여 구분한다.&#10;&#10;        이 분신은 충돌 처리나 공격 처리 등이 필요 없으며, 단순히 시각 효과 용도이므로&#10;        별도의 몬스터 객체로 만들지 않고 패턴 내부에서 위치 정보만 관리한다.&#10;&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;&#10;        # 은신 모션 관련 변수&#10;        self.stealth_animation_frames = 11  # Die 모션 프레임 수 (0~10)&#10;        self.stealth_frame = 0  # 현재 은신 모션 프레임&#10;        self.stealth_frame_duration = 0.08  # 프레임당 시간 (초)&#10;        self.is_stealth_animation_done = False  # 은신 모션 완료 플래그&#10;        self.is_unstealth_animation_done = False  # 은신 해제 모션 완료 플래그&#10;&#10;        # 은신 관련 변수&#10;        self.stealth_duration = 1.0  # 은신 지속 시간&#10;        self.is_stealthed = False  # 은신 상태&#10;&#10;        # 분신 소환 관련 변수&#10;        self.clone_count = 2  # 분신 개수&#10;        self.clones = []  # Clone 객체 리스트&#10;        self.clones_spawned = False  # 분신 소환 완료 플래그 (버그 수정용)&#10;&#10;        # 수리검 투척 관련 변수&#10;        self.shot_count = 0  # 현재 투척 횟수&#10;        self.max_shots = 10  # 최대 투척 횟수 (10회)&#10;        self.shot_interval = 0.15  # 투척 간격 (매우 짧음)&#10;        self.projectile_speed = 700  # 수리검 속도&#10;&#10;        # 본체 텔레포트 관련 변수&#10;        self.teleport_target_x = 0  # 텔레포트 목표 위치 X&#10;        self.teleport_target_y = 0  # 텔레포트 목표 위치 Y&#10;&#10;        # 이미지 로드&#10;        self._load_images()&#10;&#10;    def _load_images(self):&#10;        &quot;&quot;&quot;애니메이션 이미지 로드&quot;&quot;&quot;&#10;        try:&#10;            from game_logic import image_asset_manager as iam&#10;&#10;            base_path = &quot;resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character&quot;&#10;            print(f&quot;[Pattern4._load_images] 이미지 로드 시작 - 경로: {base_path}&quot;)&#10;&#10;            # 원본 이미지 로드 및 분신용 어두운 이미지 생성&#10;            self.original_images = {&#10;                'throw_1st': [],&#10;                'throw_2nd': [],&#10;                'move': [],&#10;                'stealth': []  # 은신 모션 추가 (Die 모션 재활용)&#10;            }&#10;&#10;            self.clone_images = {&#10;                'throw_1st': [],&#10;                'throw_2nd': [],&#10;                'move': [],&#10;                'die': []  # Die 모션 추가 (분신 사라지는 애니메이션용)&#10;            }&#10;&#10;            # Throw 1st 모션 (0~5)&#10;            for i in range(6):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Throw_1st{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['throw_1st'].append(img)&#10;&#10;                    # 경로 등록 후 어두운 버전 생성 (panther_assassin과 동일한 방식)&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['throw_1st'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern4._load_images] Throw_1st{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;                    import traceback&#10;                    traceback.print_exc()&#10;&#10;            # Throw 2nd 모션 (0~5)&#10;            for i in range(6):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Throw_2nd{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['throw_2nd'].append(img)&#10;&#10;                    # 경로 등록 후 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['throw_2nd'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern4._load_images] Throw_2nd{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;                    import traceback&#10;                    traceback.print_exc()&#10;&#10;            # Move 모션 (0~7)&#10;            for i in range(8):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Move{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['move'].append(img)&#10;&#10;                    # 경로 등록 후 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['move'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern4._load_images] Move{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;                    import traceback&#10;                    traceback.print_exc()&#10;&#10;            # Stealth 모션 (Die 모션 재활용, 0~10)&#10;            for i in range(11):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Die{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['stealth'].append(img)&#10;                    &#10;                    # 분신용 Die 애니메이션도 어두운 버전으로 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_die_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['die'].append(clone_die_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern4._load_images] Die{i:02d}.png (은신 모션) 로드 실패: {e}\033[0m&quot;)&#10;                    import traceback&#10;                    traceback.print_exc()&#10;&#10;            print(f&quot;[Pattern4._load_images] 원본 이미지 로드 결과 - &quot;&#10;                  f&quot;Throw1st: {len(self.original_images['throw_1st'])}개, &quot;&#10;                  f&quot;Throw2nd: {len(self.original_images['throw_2nd'])}개, &quot;&#10;                  f&quot;Move: {len(self.original_images['move'])}개, &quot;&#10;                  f&quot;Stealth: {len(self.original_images['stealth'])}개&quot;)&#10;&#10;            print(f&quot;[Pattern4._load_images] 분신 이미지 생성 완료 - &quot;&#10;                  f&quot;Throw1st: {len(self.clone_images['throw_1st'])}개, &quot;&#10;                  f&quot;Throw2nd: {len(self.clone_images['throw_2nd'])}개, &quot;&#10;                  f&quot;Move: {len(self.clone_images['move'])}개&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern4._load_images] 전체 로드 과정 오류: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 4 로직 실행&quot;&quot;&quot;&#10;        try:&#10;            dt = framework.get_delta_time()&#10;&#10;            if self.phase == 0:&#10;                # Phase 0: 초기화 및 은신 애니메이션 시작&#10;                self.timer = 0.0&#10;                self.stealth_frame = 0&#10;                self.is_stealth_animation_done = False&#10;                self.is_unstealth_animation_done = False&#10;                self.clones = []&#10;                self.clones_spawned = False&#10;                self.shot_count = 0&#10;&#10;                # 패턴 4 시작 시 본체 무적 활성화&#10;                self.panther.invincible = True&#10;                print(&quot;[Pattern4] 패턴 시작 - 은신 애니메이션 재생 (무적 활성화)&quot;)&#10;&#10;                self.phase = 1&#10;&#10;            elif self.phase == 1:&#10;                # Phase 1: 은신 애니메이션 재생 (0 -&gt; 10 프레임) + 분신 소환 동시 진행&#10;                self.timer += dt&#10;&#10;                # 분신 소환 (최초 1회만, 은신 애니메이션과 동시에 생성)&#10;                if not self.clones_spawned:&#10;                    try:&#10;                        print(f&quot;[Pattern4] 은신과 동시에 분신 소환 시작 - 본체 위치: ({self.panther.x:.0f}, {self.panther.y:.0f})&quot;)&#10;&#10;                        # 모든 분신을 한 번에 생성&#10;                        for i in range(self.clone_count):&#10;                            # 각 분신마다 랜덤 위치 계산&#10;                            angle = random.uniform(0, 360)&#10;                            rad = math.radians(angle)&#10;                            distance = random.uniform(150, 250)  # 본체로부터 거리&#10;&#10;                            target_x = self.panther.x + math.cos(rad) * distance&#10;                            target_y = self.panther.y + math.sin(rad) * distance&#10;&#10;                            # 분신 생성 (본체 위치에서 시작, 본체의 scale_factor 전달)&#10;                            clone = Clone(&#10;                                self.panther.x, self.panther.y,&#10;                                target_x, target_y,&#10;                                self.clone_images,&#10;                                self.panther.scale_factor  # 본체와 동일한 scale 사용&#10;                            )&#10;                            self.clones.append(clone)&#10;&#10;                            # effects_front 레이어에 추가 (카메라 좌표 자동 적용, 충돌 검사 제외)&#10;                            if self.panther.world and 'effects_front' in self.panther.world:&#10;                                self.panther.world['effects_front'].append(clone)&#10;                                print(f&quot;[Pattern4] 분신 {i+1}/{self.clone_count} 소환: ({target_x:.0f}, {target_y:.0f}) - effects_front 레이어에 추가됨&quot;)&#10;&#10;                        self.clones_spawned = True  # 소환 완료 플래그 설정&#10;                        print(f&quot;[Pattern4] 모든 분신 소환 완료! 총 {len(self.clones)}체&quot;)&#10;&#10;                    except Exception as e:&#10;                        print(f&quot;\033[91m[Pattern4] 분신 소환 중 오류: {e}\033[0m&quot;)&#10;                        import traceback&#10;                        traceback.print_exc()&#10;&#10;                # 프레임 업데이트&#10;                if self.timer &gt;= self.stealth_frame_duration:&#10;                    self.stealth_frame += 1&#10;                    self.timer = 0.0&#10;&#10;                    # 은신 애니메이션 완료 체크 (0~10, 총 11프레임)&#10;                    if self.stealth_frame &gt;= self.stealth_animation_frames:&#10;                        self.is_stealth_animation_done = True&#10;                        self.is_stealthed = True&#10;                        self.timer = 0.0&#10;                        self.phase = 2&#10;                        print(&quot;[Pattern4] 은신 애니메이션 완료! 분신 이동 대기&quot;)&#10;&#10;            elif self.phase == 2:&#10;                # Phase 2: 은신 중 - 분신 이동 대기&#10;                self.timer += dt&#10;&#10;                # 모든 분신의 이동 완료 체크&#10;                if self.clones_spawned and len(self.clones) == self.clone_count:&#10;                    # 모든 분신이 목표 위치에 도착했는지 확인&#10;                    all_moved = all(not clone.is_moving for clone in self.clones)&#10;&#10;                    if all_moved:&#10;                        # Phase 3으로 전환 (수리검 투척 시작)&#10;                        self.timer = 0.0&#10;                        self.phase = 3&#10;                        print(&quot;[Pattern4] 분신 이동 완료! 수리검 투척 시작!&quot;)&#10;&#10;            elif self.phase == 3:&#10;                # Phase 3: 수리검 투척 (분신에서만)&#10;                self.timer += dt&#10;&#10;                # 투척 간격마다 수리검 발사&#10;                if self.timer &gt;= self.shot_interval:&#10;                    if self.shot_count &lt; self.max_shots:&#10;                        try:&#10;                            # 각 분신에서 수리검 발사&#10;                            for clone in self.clones:&#10;                                if self.panther.target and self.panther.world and 'effects_front' in self.panther.world:&#10;                                    # PantherShuriken 생성&#10;                                    from ..panther_assassin import PantherShuriken&#10;                                    shuriken = PantherShuriken(&#10;                                        clone.x, clone.y,&#10;                                        self.panther.target.x, self.panther.target.y,&#10;                                        speed=self.projectile_speed,&#10;                                        from_player=False,&#10;                                        damage=15,&#10;                                        scale=2.5&#10;                                    )&#10;&#10;                                    # world의 effects_front 레이어에 추가&#10;                                    self.panther.world['effects_front'].append(shuriken)&#10;                                    print(f&quot;[Pattern4] 수리검 생성: ({int(clone.x)}, {int(clone.y)}) -&gt; ({int(self.panther.target.x)}, {int(self.panther.target.y)})&quot;)&#10;&#10;                                # 투척 애니메이션 교대 (1st &lt;-&gt; 2nd)&#10;                                throw_type = 'throw_1st' if self.shot_count % 2 == 0 else 'throw_2nd'&#10;                                clone.switch_throw_animation(throw_type)&#10;&#10;                            self.shot_count += 1&#10;                            self.timer = 0.0&#10;                            print(f&quot;[Pattern4] 수리검 발사 {self.shot_count}/{self.max_shots} (분신 {len(self.clones)}체)&quot;)&#10;&#10;                        except Exception as e:&#10;                            print(f&quot;\033[91m[Pattern4] 수리검 발사 중 오류: {e}\033[0m&quot;)&#10;                            import traceback&#10;                            traceback.print_exc()&#10;&#10;                # 모든 수리검 발사 완료&#10;                if self.shot_count &gt;= self.max_shots:&#10;                    # 본체 텔레포트 목표 위치 계산 (플레이어 주위 랜덤 위치)&#10;                    if self.panther.target:&#10;                        angle = random.uniform(0, 360)&#10;                        rad = math.radians(angle)&#10;                        distance = random.uniform(100, 200)  # 플레이어로부터 거리&#10;&#10;                        self.teleport_target_x = self.panther.target.x + math.cos(rad) * distance&#10;                        self.teleport_target_y = self.panther.target.y + math.sin(rad) * distance&#10;&#10;                        # 본체 텔레포트 즉시 실행&#10;                        self.panther.x = self.teleport_target_x&#10;                        self.panther.y = self.teleport_target_y&#10;                        print(f&quot;[Pattern4] 본체 텔레포트 완료: ({self.panther.x:.0f}, {self.panther.y:.0f})&quot;)&#10;                    else:&#10;                        # 타겟이 없으면 현재 위치 유지&#10;                        self.teleport_target_x = self.panther.x&#10;                        self.teleport_target_y = self.panther.y&#10;&#10;                    self.phase = 4&#10;                    self.timer = 0.0&#10;                    self.stealth_frame = self.stealth_animation_frames - 1  # 역재생 시작 (10부터 시작)&#10;                    print(&quot;[Pattern4] 수리검 투척 완료! 텔레포트 후 은신 해제 애니메이션 시작&quot;)&#10;&#10;            elif self.phase == 4:&#10;                # Phase 4: 은신 해제 애니메이션 재생 (10 -&gt; 0 프레임, 역순)&#10;                # 이미 Phase 3에서 텔레포트가 완료된 상태&#10;                self.timer += dt&#10;&#10;                # 프레임 업데이트 (역순)&#10;                if self.timer &gt;= self.stealth_frame_duration:&#10;                    self.stealth_frame -= 1&#10;                    self.timer = 0.0&#10;&#10;                    # 은신 해제 애니메이션 완료 체크&#10;                    if self.stealth_frame &lt; 0:&#10;                        self.is_unstealth_animation_done = True&#10;                        self.is_stealthed = False&#10;                        self.phase = 5&#10;                        print(&quot;[Pattern4] 은신 해제 애니메이션 완료!&quot;)&#10;&#10;            elif self.phase == 5:&#10;                # Phase 5: 패턴 종료 정리&#10;&#10;                # 패턴 4 종료 시 본체 무적 해제&#10;                self.panther.invincible = False&#10;                print(&quot;[Pattern4] 패턴 종료! (무적 해제)&quot;)&#10;&#10;                # 분신에게 사라지는 애니메이션 시작 명령&#10;                for clone in self.clones:&#10;                    clone.start_dying()&#10;                    print(f&quot;[Pattern4] 분신 Die 애니메이션 시작 - 위치: ({clone.x:.0f}, {clone.y:.0f})&quot;)&#10;&#10;                # 분신은 자동으로 애니메이션 후 제거되므로 여기서는 리스트만 비움&#10;                self.clones = []&#10;&#10;                # 패턴 종료&#10;                self.phase = 0&#10;                if hasattr(self.panther, 'attack_timer') and hasattr(self.panther, 'attack_cooldown'):&#10;                    self.panther.attack_timer = self.panther.attack_cooldown&#10;                return BehaviorTree.SUCCESS&#10;&#10;            return BehaviorTree.RUNNING&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern4.update] 전체 업데이트 오류 (phase={self.phase}): {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;            # 오류 발생 시에도 무적 해제 (안전장치)&#10;            self.panther.invincible = False&#10;            print(&quot;[Pattern4] 오류로 인한 긴급 무적 해제&quot;)&#10;&#10;            return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 4 전용 그리기 메서드&#10;&#10;        본체의 은신/해제 애니메이션을 그립니다.&#10;        - Phase 1: 은신 애니메이션 (0 -&gt; 10 프레임)&#10;        - Phase 2, 3: 은신 상태 (본체 숨김)&#10;        - Phase 4: 은신 해제 애니메이션 (10 -&gt; 0 프레임, 역순)&#10;        - Phase 5: 정상 상태 (기본 Idle 애니메이션)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Phase 1: 은신 애니메이션 재생 (0 -&gt; 10)&#10;            if self.phase == 1 and len(self.original_images['stealth']) &gt; 0:&#10;                if 0 &lt;= self.stealth_frame &lt; len(self.original_images['stealth']):&#10;                    img = self.original_images['stealth'][self.stealth_frame]&#10;                    img.draw(&#10;                        draw_x, draw_y,&#10;                        img.w * self.panther.scale_factor,&#10;                        img.h * self.panther.scale_factor&#10;                    )&#10;&#10;            # Phase 2, 3: 은신 상태 (본체 숨김 - 아무것도 그리지 않음)&#10;            elif self.phase in [2, 3]:&#10;                pass  # 본체는 보이지 않음&#10;&#10;            # Phase 4: 은신 해제 애니메이션 재생 (10 -&gt; 0, 역순)&#10;            elif self.phase == 4 and len(self.original_images['stealth']) &gt; 0:&#10;                if 0 &lt;= self.stealth_frame &lt; len(self.original_images['stealth']):&#10;                    img = self.original_images['stealth'][self.stealth_frame]&#10;                    img.draw(&#10;                        draw_x, draw_y,&#10;                        img.w * self.panther.scale_factor,&#10;                        img.h * self.panther.scale_factor&#10;                    )&#10;&#10;            # Phase 0, 5: 기본 Idle 애니메이션 (PantherAssassin의 기본 draw에서 처리)&#10;            else:&#10;                # 기본 상태는 PantherAssassin.draw()에서 처리하도록 패스&#10;                pass&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern4.draw] 그리기 오류: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/monsters/Boss_Logic/panther_assassin_5pattern.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/monsters/Boss_Logic/panther_assassin_5pattern.py" />
              <option name="originalContent" value="import pico2d as p2&#10;import random&#10;import math&#10;import game_framework as framework&#10;from ...behavior_tree import BehaviorTree&#10;&#10;&#10;class AttackPattern5Action:&#10;    &quot;&quot;&quot;&#10;    패턴5 - 분신 1체 랜덤 위치에 소환후 모든 방향 방사형으로 수리검 투척 2회 ( 두 번째 투척 수리검의 속도는 첫 번째 투척 속도의 반 )&#10;    자세한 설명:&#10;    1. 플레이어 주변으로 분신 1체를 소환한다. 소환 방식은 panther_assassin_4pattern.py의 패턴4와 동일하다.&#10;    2. 분신이 이동을 완료하면, 분신에서 모든 방향으로 수리검을 투척한다. (360도)&#10;        - 첫 번째 투척은 기본 속도(650 픽셀/초)로 투척한다.&#10;        - 두 번째 투척은 첫 번째 투척의 절반 속도(325 픽셀/초)로 투척한다.&#10;        - 수리검 투척은 첫번째 투척 후, 0.15초 후에 두 번째 투척이 이루어진다.&#10;    3. 수리검 투척이 완료되면, 분신은 사라진다.&#10;    4. 패턴이 종료된다.&#10;&#10;    기본 모션 경로 : 'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character'&#10;    투척시 모션 : PantherAssassin_Whirlwind{i:02d}.png 0 ~ 5&#10;        - 던지는 동안 계속해서 반복 재생&#10;    투척 이후 모션 : PantherAssassin_Throw_All_Withdraw{i:02d}.png 0 ~ 9&#10;&#10;    주의 :&#10;        - 수리검은 PantherShuriken를 사용한다.&#10;        - 투척 이후 모션 재생 후 패턴 종료&#10;        - 투척 각도는 0도, 90도, 180도, 270도 를 기준으로 +- 10도는 투척 각도에서 제외한다.&#10;          이렇게 하여 플레이어가 피하기 쉽도록 한다.&#10;          각 투척 각도(10~80, 100~170, 190~260, 280~350)에서 약 7개씩 투척된다.&#10;        - 투척 휠윈드 모션 3 이후 부터 투척한다.&#10;        - 분신과 본체 모두 똑같이 행동한다. (투척 모션 재생 등)&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;&#10;        # 분신 소환 관련 변수&#10;        self.clone_count = 1  # 분신 개수 (1체)&#10;        self.clone = None  # 분신 객체&#10;        self.clones_spawned = False  # 분신 소환 완료 플래그&#10;&#10;        # 수리검 투척 관련 변수&#10;        self.shot_count = 0  # 현재 투척 횟수 (1회, 2회)&#10;        self.max_shots = 2  # 최대 투척 횟수 (2회)&#10;        self.shot_interval = 0.1  # 투척 간격 (0.15초)&#10;        self.first_speed = 650  # 첫 번째 투척 속도 (650 픽셀/초)&#10;        self.second_speed = 325  # 두 번째 투척 속도 (325 픽셀/초, 첫 번째의 반)&#10;        self.projectiles_per_shot = 35  # 한 번에 발사하는 수리검 개수 (약 7개씩 * 4구간)&#10;&#10;        # 애니메이션 관련 변수&#10;        self.whirlwind_frame = 0  # Whirlwind 애니메이션 프레임&#10;        self.whirlwind_frame_timer = 0.0&#10;        self.whirlwind_frame_speed = 12.0  # 초당 프레임 수&#10;        self.whirlwind_total_frames = 6  # 0~5 (총 6프레임)&#10;        self.throw_start_frame = 3  # 3번 프레임부터 투척 시작&#10;        self.has_thrown_in_cycle = False  # 현재 사이클에서 이미 투척했는지&#10;&#10;        self.withdraw_frame = 0  # Withdraw 애니메이션 프레임&#10;        self.withdraw_frame_timer = 0.0&#10;        self.withdraw_frame_speed = 15.0  # 초당 프레임 수&#10;        self.withdraw_total_frames = 10  # 0~9 (총 10프레임)&#10;&#10;        # 이미지 로드&#10;        self._load_images()&#10;&#10;    def _load_images(self):&#10;        &quot;&quot;&quot;애니메이션 이미지 로드&quot;&quot;&quot;&#10;        try:&#10;            from game_logic import image_asset_manager as iam&#10;&#10;            base_path = &quot;resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character&quot;&#10;            print(f&quot;[Pattern5._load_images] 이미지 로드 시작 - 경로: {base_path}&quot;)&#10;&#10;            # 원본 이미지 로드 및 분신용 어두운 이미지 생성&#10;            self.original_images = {&#10;                'whirlwind': [],&#10;                'withdraw': [],&#10;                'move': [],&#10;                'stealth': [],  # 은신 모션 (Die 모션 재활용)&#10;                'die': []  # 분신 사라지는 애니메이션용&#10;            }&#10;&#10;            self.clone_images = {&#10;                'whirlwind': [],&#10;                'withdraw': [],&#10;                'move': [],&#10;                'die': []&#10;            }&#10;&#10;            # Whirlwind 모션 (0~5)&#10;            for i in range(6):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Whirlwind{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['whirlwind'].append(img)&#10;&#10;                    # 분신용 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['whirlwind'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern5._load_images] Whirlwind{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;&#10;            # Throw_All_Withdraw 모션 (0~9)&#10;            for i in range(10):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Throw_All_Withdraw{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['withdraw'].append(img)&#10;&#10;                    # 분신용 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['withdraw'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern5._load_images] Throw_All_Withdraw{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;&#10;            # Move 모션 (0~7)&#10;            for i in range(8):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Move{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['move'].append(img)&#10;&#10;                    # 분신용 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['move'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern5._load_images] Move{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;&#10;            # Die 모션 (0~10) - 분신 사라지는 애니메이션용&#10;            for i in range(11):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Die{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['die'].append(img)&#10;&#10;                    # 분신용 Die 애니메이션&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_die_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['die'].append(clone_die_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern5._load_images] Die{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;&#10;            # Stealth 모션도 Die 모션 사용 (본체용)&#10;            self.original_images['stealth'] = self.original_images['die']&#10;&#10;            print(f&quot;[Pattern5._load_images] 원본 이미지 로드 완료 - &quot;&#10;                  f&quot;Whirlwind: {len(self.original_images['whirlwind'])}개, &quot;&#10;                  f&quot;Withdraw: {len(self.original_images['withdraw'])}개, &quot;&#10;                  f&quot;Move: {len(self.original_images['move'])}개, &quot;&#10;                  f&quot;Die: {len(self.original_images['die'])}개&quot;)&#10;&#10;            print(f&quot;[Pattern5._load_images] 분신 이미지 생성 완료 - &quot;&#10;                  f&quot;Whirlwind: {len(self.clone_images['whirlwind'])}개, &quot;&#10;                  f&quot;Withdraw: {len(self.clone_images['withdraw'])}개, &quot;&#10;                  f&quot;Move: {len(self.clone_images['move'])}개, &quot;&#10;                  f&quot;Die: {len(self.clone_images['die'])}개&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern5._load_images] 전체 로드 과정 오류: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 5 로직 실행&quot;&quot;&quot;&#10;        try:&#10;            dt = framework.get_delta_time()&#10;&#10;            if self.phase == 0:&#10;                # Phase 0: 초기화 및 분신 소환 시작&#10;                self.timer = 0.0&#10;                self.shot_count = 0&#10;                self.whirlwind_frame = 0&#10;                self.whirlwind_frame_timer = 0.0&#10;                self.has_thrown_in_cycle = False&#10;                self.clone = None&#10;                self.clones_spawned = False&#10;&#10;                print(&quot;[Pattern5] 패턴 시작 - 분신 소환 시작!&quot;)&#10;                self.phase = 1&#10;&#10;            elif self.phase == 1:&#10;                # Phase 1: 분신 소환 (본체 위치에 생성 후 랜덤 위치로 이동)&#10;                if not self.clones_spawned:&#10;                    try:&#10;                        print(f&quot;[Pattern5] 분신 소환 - 본체 위치: ({self.panther.x:.0f}, {self.panther.y:.0f})&quot;)&#10;&#10;                        # 랜덤 위치 계산 (본체로부터 거리)&#10;                        angle = random.uniform(0, 360)&#10;                        rad = math.radians(angle)&#10;                        distance = random.uniform(200, 300)&#10;&#10;                        target_x = self.panther.x + math.cos(rad) * distance&#10;                        target_y = self.panther.y + math.sin(rad) * distance&#10;&#10;                        # 분신 생성&#10;                        from ..panther_assassin import Clone&#10;                        self.clone = Clone(&#10;                            self.panther.x, self.panther.y,&#10;                            target_x, target_y,&#10;                            self.clone_images,&#10;                            self.panther.scale_factor&#10;                        )&#10;&#10;                        # effects_front 레이어에 추가&#10;                        if self.panther.world and 'effects_front' in self.panther.world:&#10;                            self.panther.world['effects_front'].append(self.clone)&#10;                            print(f&quot;[Pattern5] 분신 소환 완료: ({target_x:.0f}, {target_y:.0f}) - effects_front 레이어에 추가됨&quot;)&#10;&#10;                        self.clones_spawned = True&#10;&#10;                    except Exception as e:&#10;                        print(f&quot;\033[91m[Pattern5] 분신 소환 중 오류: {e}\033[0m&quot;)&#10;                        import traceback&#10;                        traceback.print_exc()&#10;&#10;                # 분신 이동 완료 대기 (이 단계에서는 본체가 IDLE 모션 유지)&#10;                if self.clones_spawned and self.clone and not self.clone.is_moving:&#10;                    print(&quot;[Pattern5] 분신 이동 완료! 수리검 투척 준비&quot;)&#10;                    self.timer = 0.0&#10;                    self.whirlwind_frame = 0&#10;                    self.whirlwind_frame_timer = 0.0&#10;                    self.has_thrown_in_cycle = False&#10;                    &#10;                    # 분신을 Whirlwind 애니메이션으로 전환&#10;                    self.clone.switch_animation('whirlwind')&#10;                    self.phase = 2&#10;&#10;            elif self.phase == 2:&#10;                # Phase 2: Whirlwind 애니메이션 재생 및 첫 번째 수리검 투척&#10;                self.whirlwind_frame_timer += dt&#10;&#10;                if self.whirlwind_frame_timer &gt;= 1.0 / self.whirlwind_frame_speed:&#10;                    self.whirlwind_frame_timer = 0.0&#10;&#10;                    # 프레임 3에 도달하면 첫 번째 투척&#10;                    if self.whirlwind_frame &gt;= self.throw_start_frame and not self.has_thrown_in_cycle:&#10;                        self._shoot_shurikens_360(self.first_speed)&#10;                        self.shot_count = 1&#10;                        self.has_thrown_in_cycle = True&#10;                        print(f&quot;[Pattern5] 1차 투척 완료 (속도: {self.first_speed})&quot;)&#10;&#10;                    self.whirlwind_frame += 1&#10;&#10;                    # Whirlwind 애니메이션 반복 (0~5)&#10;                    if self.whirlwind_frame &gt;= self.whirlwind_total_frames:&#10;                        self.whirlwind_frame = 0&#10;                        self.has_thrown_in_cycle = False&#10;&#10;                        # 첫 번째 투척 완료 후 대기로 전환&#10;                        if self.shot_count &gt;= 1:&#10;                            self.timer = 0.0&#10;                            self.phase = 3&#10;                            print(&quot;[Pattern5] 1차 투척 완료, 2차 투척 대기&quot;)&#10;&#10;            elif self.phase == 3:&#10;                # Phase 3: 두 번째 투척 대기 (0.1초) - Whirlwind 애니메이션 계속 재생&#10;                self.timer += dt&#10;                &#10;                # Whirlwind 애니메이션 계속 재생&#10;                self.whirlwind_frame_timer += dt&#10;                if self.whirlwind_frame_timer &gt;= 1.0 / self.whirlwind_frame_speed:&#10;                    self.whirlwind_frame_timer = 0.0&#10;                    self.whirlwind_frame = (self.whirlwind_frame + 1) % self.whirlwind_total_frames&#10;&#10;                if self.timer &gt;= self.shot_interval:&#10;                    # 두 번째 투척 준비&#10;                    self.whirlwind_frame = 0&#10;                    self.whirlwind_frame_timer = 0.0&#10;                    self.has_thrown_in_cycle = False&#10;                    self.phase = 4&#10;                    print(&quot;[Pattern5] 2차 투척 시작&quot;)&#10;&#10;            elif self.phase == 4:&#10;                # Phase 4: Whirlwind 애니메이션 재생 및 두 번째 수리검 투척&#10;                self.whirlwind_frame_timer += dt&#10;&#10;                if self.whirlwind_frame_timer &gt;= 1.0 / self.whirlwind_frame_speed:&#10;                    self.whirlwind_frame_timer = 0.0&#10;&#10;                    # 프레임 3에 도달하면 두 번째 투척&#10;                    if self.whirlwind_frame &gt;= self.throw_start_frame and not self.has_thrown_in_cycle:&#10;                        self._shoot_shurikens_360(self.second_speed)&#10;                        self.shot_count = 2&#10;                        self.has_thrown_in_cycle = True&#10;                        print(f&quot;[Pattern5] 2차 투척 완료 (속도: {self.second_speed})&quot;)&#10;&#10;                    self.whirlwind_frame += 1&#10;&#10;                    # Whirlwind 애니메이션 반복&#10;                    if self.whirlwind_frame &gt;= self.whirlwind_total_frames:&#10;                        self.whirlwind_frame = 0&#10;                        self.has_thrown_in_cycle = False&#10;&#10;                        # 두 번째 투척 완료 후 Withdraw 애니메이션으로 전환&#10;                        if self.shot_count &gt;= 2:&#10;                            self.withdraw_frame = 0&#10;                            self.withdraw_frame_timer = 0.0&#10;                            &#10;                            # 분신을 Withdraw 애니메이션으로 전환&#10;                            if self.clone:&#10;                                self.clone.switch_animation('withdraw')&#10;                            self.phase = 5&#10;                            print(&quot;[Pattern5] 2차 투척 완료, Withdraw 애니메이션 시작&quot;)&#10;&#10;            elif self.phase == 5:&#10;                # Phase 5: Throw_All_Withdraw 애니메이션 재생&#10;                self.withdraw_frame_timer += dt&#10;&#10;                if self.withdraw_frame_timer &gt;= 1.0 / self.withdraw_frame_speed:&#10;                    self.withdraw_frame += 1&#10;                    self.withdraw_frame_timer = 0.0&#10;&#10;                    # Withdraw 애니메이션 종료 (0~9)&#10;                    if self.withdraw_frame &gt;= self.withdraw_total_frames:&#10;                        # 분신 사라지는 애니메이션 시작&#10;                        if self.clone:&#10;                            self.clone.start_dying()&#10;                        self.phase = 6&#10;                        print(&quot;[Pattern5] Withdraw 애니메이션 완료, 분신 소멸 시작&quot;)&#10;&#10;            elif self.phase == 6:&#10;                # Phase 6: 분신 사라지는 애니메이션 대기&#10;                # 분신의 Die 애니메이션이 완료될 때까지 대기&#10;                if self.clone and (self.clone.to_be_removed or self.clone.mark_for_removal):&#10;                    # 패턴 완료&#10;                    self.phase = 0&#10;                    self.panther.attack_timer = self.panther.attack_cooldown&#10;                    print(&quot;[Pattern5] 패턴 완료!&quot;)&#10;                    return BehaviorTree.SUCCESS&#10;&#10;            return BehaviorTree.RUNNING&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern5.update] 오류 발생: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            # 오류 발생 시 패턴 종료&#10;            self.phase = 0&#10;            self.panther.attack_timer = self.panther.attack_cooldown&#10;            return BehaviorTree.FAIL&#10;&#10;    def _shoot_shurikens_360(self, speed):&#10;        &quot;&quot;&quot;&#10;        360도 모든 방향으로 수리검 발사 (0, 90, 180, 270도 +-10도 제외)&#10;&#10;        Args:&#10;            speed: 수리검 속도&#10;        &quot;&quot;&quot;&#10;        if not self.clone or not self.panther.world:&#10;            return&#10;&#10;        try:&#10;            # 투척 제외 각도: 0, 90, 180, 270도 기준 +-10도&#10;            # 플레이어가 피하기 쉽도록 4방향 각도는 제외&#10;            excluded_angle = 10  # 각 방향에서 제외할 각도 범위 (±10도)&#10;&#10;            # 허용된 각도 범위 계산&#10;            # 0도 제외: 350~360, 0~10 제외 → 10~80 허용&#10;            # 90도 제외: 80~100 제외 → 100~170 허용&#10;            # 180도 제외: 170~190 제외 → 190~260 허용&#10;            # 270도 제외: 260~280 제외 → 280~350 허용&#10;            allowed_ranges = [&#10;                (10, 80),      # 1사분면 (0도 제외 후)&#10;                (100, 170),    # 2사분면 (90도 제외 후)&#10;                (190, 260),    # 3사분면 (180도 제외 후)&#10;                (280, 350),    # 4사분면 (270도 제외 후)&#10;            ]&#10;&#10;            # 각 범위에서 7개씩 수리검 발사&#10;            shurikens_per_range = 7&#10;            total_shurikens = 0&#10;&#10;            for angle_min, angle_max in allowed_ranges:&#10;                angle_step = (angle_max - angle_min) / (shurikens_per_range - 1)&#10;&#10;                for i in range(shurikens_per_range):&#10;                    angle = angle_min + angle_step * i&#10;                    rad = math.radians(angle)&#10;&#10;                    # 수리검이 날아갈 목표 위치 계산 (충분히 먼 거리)&#10;                    target_distance = 2000&#10;                    target_x = self.clone.x + math.cos(rad) * target_distance&#10;                    target_y = self.clone.y + math.sin(rad) * target_distance&#10;&#10;                    # 본체에서 수리검 발사&#10;                    from ..panther_assassin import PantherShuriken&#10;                    shuriken_body = PantherShuriken(&#10;                        self.panther.x, self.panther.y,&#10;                        target_x, target_y,&#10;                        speed=speed,&#10;                        from_player=False,&#10;                        damage=20,&#10;                        scale=2.5&#10;                    )&#10;                    self.panther.world['effects_front'].append(shuriken_body)&#10;                    total_shurikens += 1&#10;&#10;                    # 분신에서 수리검 발사&#10;                    shuriken_clone = PantherShuriken(&#10;                        self.clone.x, self.clone.y,&#10;                        target_x, target_y,&#10;                        speed=speed,&#10;                        from_player=False,&#10;                        damage=20,&#10;                        scale=2.5&#10;                    )&#10;                    self.panther.world['effects_front'].append(shuriken_clone)&#10;                    total_shurikens += 1&#10;&#10;            print(f&quot;[Pattern5] 360도 방사형 수리검 발사 완료&quot;)&#10;            print(f&quot;  - 속도: {speed} 픽셀/초&quot;)&#10;            print(f&quot;  - 총 수리검 개수: {total_shurikens}개 (본체: {shurikens_per_range * 4}개, 분신: {shurikens_per_range * 4}개)&quot;)&#10;            print(f&quot;  - 각 사분면당: {shurikens_per_range}개씩&quot;)&#10;            print(f&quot;  - 제외 각도: 0°±{excluded_angle}°, 90°±{excluded_angle}°, 180°±{excluded_angle}°, 270°±{excluded_angle}°&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern5._shoot_shurikens_360] 수리검 발사 중 오류: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 5 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # 본체 애니메이션 그리기&#10;            if self.phase in [2, 3, 4]:  # Whirlwind 애니메이션 중&#10;                if self.original_images['whirlwind'] and self.whirlwind_frame &lt; len(self.original_images['whirlwind']):&#10;                    img = self.original_images['whirlwind'][self.whirlwind_frame]&#10;                    if img:&#10;                        img.draw(draw_x, draw_y, img.w * self.panther.scale_factor, img.h * self.panther.scale_factor)&#10;&#10;            elif self.phase == 5:  # Withdraw 애니메이션 중&#10;                if self.original_images['withdraw'] and self.withdraw_frame &lt; len(self.original_images['withdraw']):&#10;                    img = self.original_images['withdraw'][self.withdraw_frame]&#10;                    if img:&#10;                        img.draw(draw_x, draw_y, img.w * self.panther.scale_factor, img.h * self.panther.scale_factor)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern5.draw] 드로잉 중 오류: {e}\033[0m&quot;)&#10;" />
              <option name="updatedContent" value="import pico2d as p2&#10;import random&#10;import math&#10;import game_framework as framework&#10;from ...behavior_tree import BehaviorTree&#10;&#10;&#10;class AttackPattern5Action:&#10;    &quot;&quot;&quot;&#10;    패턴5 - 분신 1체 랜덤 위치에 소환후 모든 방향 방사형으로 수리검 투척 2회 ( 두 번째 투척 수리검의 속도는 첫 번째 투척 속도의 반 )&#10;    자세한 설명:&#10;    1. 플레이어 주변으로 분신 1체를 소환한다. 소환 방식은 panther_assassin_4pattern.py의 패턴4와 동일하다.&#10;    2. 분신이 이동을 완료하면, 분신에서 모든 방향으로 수리검을 투척한다. (360도)&#10;        - 첫 번째 투척은 기본 속도(650 픽셀/초)로 투척한다.&#10;        - 두 번째 투척은 첫 번째 투척의 절반 속도(325 픽셀/초)로 투척한다.&#10;        - 수리검 투척은 첫번째 투척 후, 0.15초 후에 두 번째 투척이 이루어진다.&#10;    3. 수리검 투척이 완료되면, 분신은 사라진다.&#10;    4. 패턴이 종료된다.&#10;&#10;    기본 모션 경로 : 'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character'&#10;    투척시 모션 : PantherAssassin_Whirlwind{i:02d}.png 0 ~ 5&#10;        - 던지는 동안 계속해서 반복 재생&#10;    투척 이후 모션 : PantherAssassin_Throw_All_Withdraw{i:02d}.png 0 ~ 9&#10;&#10;    주의 :&#10;        - 수리검은 PantherShuriken를 사용한다.&#10;        - 투척 이후 모션 재생 후 패턴 종료&#10;        - 투척 각도는 0도, 90도, 180도, 270도 를 기준으로 +- 10도는 투척 각도에서 제외한다.&#10;          이렇게 하여 플레이어가 피하기 쉽도록 한다.&#10;          각 투척 각도(10~80, 100~170, 190~260, 280~350)에서 약 7개씩 투척된다.&#10;        - 투척 휠윈드 모션 3 이후 부터 투척한다.&#10;        - 분신과 본체 모두 똑같이 행동한다. (투척 모션 재생 등)&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;&#10;        # 분신 소환 관련 변수&#10;        self.clone_count = 1  # 분신 개수 (1체)&#10;        self.clone = None  # 분신 객체&#10;        self.clones_spawned = False  # 분신 소환 완료 플래그&#10;&#10;        # 수리검 투척 관련 변수&#10;        self.shot_count = 0  # 현재 투척 횟수 (1회, 2회)&#10;        self.max_shots = 2  # 최대 투척 횟수 (2회)&#10;        self.shot_interval = 0.1  # 투척 간격 (0.15초)&#10;        self.first_speed = 650  # 첫 번째 투척 속도 (650 픽셀/초)&#10;        self.second_speed = 325  # 두 번째 투척 속도 (325 픽셀/초, 첫 번째의 반)&#10;        self.projectiles_per_shot = 35  # 한 번에 발사하는 수리검 개수 (약 7개씩 * 4구간)&#10;&#10;        # 애니메이션 관련 변수&#10;        self.whirlwind_frame = 0  # Whirlwind 애니메이션 프레임&#10;        self.whirlwind_frame_timer = 0.0&#10;        self.whirlwind_frame_speed = 12.0  # 초당 프레임 수&#10;        self.whirlwind_total_frames = 6  # 0~5 (총 6프레임)&#10;        self.throw_start_frame = 3  # 3번 프레임부터 투척 시작&#10;        self.has_thrown_in_cycle = False  # 현재 사이클에서 이미 투척했는지&#10;&#10;        self.withdraw_frame = 0  # Withdraw 애니메이션 프레임&#10;        self.withdraw_frame_timer = 0.0&#10;        self.withdraw_frame_speed = 15.0  # 초당 프레임 수&#10;        self.withdraw_total_frames = 10  # 0~9 (총 10프레임)&#10;&#10;        # 이미지 로드&#10;        self._load_images()&#10;&#10;    def _load_images(self):&#10;        &quot;&quot;&quot;애니메이션 이미지 로드&quot;&quot;&quot;&#10;        try:&#10;            from game_logic import image_asset_manager as iam&#10;&#10;            base_path = &quot;resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character&quot;&#10;            print(f&quot;[Pattern5._load_images] 이미지 로드 시작 - 경로: {base_path}&quot;)&#10;&#10;            # 원본 이미지 로드 및 분신용 어두운 이미지 생성&#10;            self.original_images = {&#10;                'whirlwind': [],&#10;                'withdraw': [],&#10;                'move': [],&#10;                'stealth': [],  # 은신 모션 (Die 모션 재활용)&#10;                'die': []  # 분신 사라지는 애니메이션용&#10;            }&#10;&#10;            self.clone_images = {&#10;                'whirlwind': [],&#10;                'withdraw': [],&#10;                'move': [],&#10;                'die': []&#10;            }&#10;&#10;            # Whirlwind 모션 (0~5)&#10;            for i in range(6):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Whirlwind{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['whirlwind'].append(img)&#10;&#10;                    # 분신용 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['whirlwind'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern5._load_images] Whirlwind{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;&#10;            # Throw_All_Withdraw 모션 (0~9)&#10;            for i in range(10):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Throw_All_Withdraw{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['withdraw'].append(img)&#10;&#10;                    # 분신용 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['withdraw'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern5._load_images] Throw_All_Withdraw{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;&#10;            # Move 모션 (0~7)&#10;            for i in range(8):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Move{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['move'].append(img)&#10;&#10;                    # 분신용 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['move'].append(clone_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern5._load_images] Move{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;&#10;            # Die 모션 (0~10) - 분신 사라지는 애니메이션용&#10;            for i in range(11):&#10;                try:&#10;                    img_path = f&quot;{base_path}/PantherAssassin_Die{i:02d}.png&quot;&#10;                    img = p2.load_image(img_path)&#10;                    self.original_images['die'].append(img)&#10;&#10;                    # 분신용 Die 애니메이션&#10;                    iam.register_image_path(img, img_path)&#10;                    clone_die_img = iam.make_dark(img, darkness=0.25)&#10;                    self.clone_images['die'].append(clone_die_img)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[Pattern5._load_images] Die{i:02d}.png 로드 실패: {e}\033[0m&quot;)&#10;&#10;            # Stealth 모션도 Die 모션 사용 (본체용)&#10;            self.original_images['stealth'] = self.original_images['die']&#10;&#10;            print(f&quot;[Pattern5._load_images] 원본 이미지 로드 완료 - &quot;&#10;                  f&quot;Whirlwind: {len(self.original_images['whirlwind'])}개, &quot;&#10;                  f&quot;Withdraw: {len(self.original_images['withdraw'])}개, &quot;&#10;                  f&quot;Move: {len(self.original_images['move'])}개, &quot;&#10;                  f&quot;Die: {len(self.original_images['die'])}개&quot;)&#10;&#10;            print(f&quot;[Pattern5._load_images] 분신 이미지 생성 완료 - &quot;&#10;                  f&quot;Whirlwind: {len(self.clone_images['whirlwind'])}개, &quot;&#10;                  f&quot;Withdraw: {len(self.clone_images['withdraw'])}개, &quot;&#10;                  f&quot;Move: {len(self.clone_images['move'])}개, &quot;&#10;                  f&quot;Die: {len(self.clone_images['die'])}개&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern5._load_images] 전체 로드 과정 오류: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 5 로직 실행&quot;&quot;&quot;&#10;        try:&#10;            dt = framework.get_delta_time()&#10;&#10;            if self.phase == 0:&#10;                # Phase 0: 초기화 및 분신 소환 시작&#10;                self.timer = 0.0&#10;                self.shot_count = 0&#10;                self.whirlwind_frame = 0&#10;                self.whirlwind_frame_timer = 0.0&#10;                self.has_thrown_in_cycle = False&#10;                self.clone = None&#10;                self.clones_spawned = False&#10;&#10;                print(&quot;[Pattern5] 패턴 시작 - 분신 소환 시작!&quot;)&#10;                self.phase = 1&#10;&#10;            elif self.phase == 1:&#10;                # Phase 1: 분신 소환 (본체 위치에 생성 후 랜덤 위치로 이동)&#10;                if not self.clones_spawned:&#10;                    try:&#10;                        print(f&quot;[Pattern5] 분신 소환 - 본체 위치: ({self.panther.x:.0f}, {self.panther.y:.0f})&quot;)&#10;&#10;                        # 랜덤 위치 계산 (본체로부터 거리)&#10;                        angle = random.uniform(0, 360)&#10;                        rad = math.radians(angle)&#10;                        distance = random.uniform(200, 300)&#10;&#10;                        target_x = self.panther.x + math.cos(rad) * distance&#10;                        target_y = self.panther.y + math.sin(rad) * distance&#10;&#10;                        # 분신 생성&#10;                        from ..panther_assassin import Clone&#10;                        self.clone = Clone(&#10;                            self.panther.x, self.panther.y,&#10;                            target_x, target_y,&#10;                            self.clone_images,&#10;                            self.panther.scale_factor&#10;                        )&#10;&#10;                        # effects_front 레이어에 추가&#10;                        if self.panther.world and 'effects_front' in self.panther.world:&#10;                            self.panther.world['effects_front'].append(self.clone)&#10;                            print(f&quot;[Pattern5] 분신 소환 완료: ({target_x:.0f}, {target_y:.0f}) - effects_front 레이어에 추가됨&quot;)&#10;&#10;                        self.clones_spawned = True&#10;&#10;                    except Exception as e:&#10;                        print(f&quot;\033[91m[Pattern5] 분신 소환 중 오류: {e}\033[0m&quot;)&#10;                        import traceback&#10;                        traceback.print_exc()&#10;&#10;                # 분신 이동 완료 대기 (이 단계에서는 본체가 IDLE 모션 유지)&#10;                if self.clones_spawned and self.clone and not self.clone.is_moving:&#10;                    print(&quot;[Pattern5] 분신 이동 완료! 수리검 투척 준비&quot;)&#10;                    self.timer = 0.0&#10;                    self.whirlwind_frame = 0&#10;                    self.whirlwind_frame_timer = 0.0&#10;                    self.has_thrown_in_cycle = False&#10;                    &#10;                    # 분신을 Whirlwind 애니메이션으로 전환&#10;                    self.clone.switch_animation('whirlwind')&#10;                    self.phase = 2&#10;&#10;            elif self.phase == 2:&#10;                # Phase 2: Whirlwind 애니메이션 재생 및 첫 번째 수리검 투척&#10;                self.whirlwind_frame_timer += dt&#10;&#10;                if self.whirlwind_frame_timer &gt;= 1.0 / self.whirlwind_frame_speed:&#10;                    self.whirlwind_frame_timer = 0.0&#10;&#10;                    # 프레임 3에 도달하면 첫 번째 투척&#10;                    if self.whirlwind_frame &gt;= self.throw_start_frame and not self.has_thrown_in_cycle:&#10;                        self._shoot_shurikens_360(self.first_speed)&#10;                        self.shot_count = 1&#10;                        self.has_thrown_in_cycle = True&#10;                        print(f&quot;[Pattern5] 1차 투척 완료 (속도: {self.first_speed})&quot;)&#10;&#10;                    self.whirlwind_frame += 1&#10;&#10;                    # Whirlwind 애니메이션 반복 (0~5)&#10;                    if self.whirlwind_frame &gt;= self.whirlwind_total_frames:&#10;                        self.whirlwind_frame = 0&#10;                        self.has_thrown_in_cycle = False&#10;&#10;                        # 첫 번째 투척 완료 후 대기로 전환&#10;                        if self.shot_count &gt;= 1:&#10;                            self.timer = 0.0&#10;                            self.phase = 3&#10;                            print(&quot;[Pattern5] 1차 투척 완료, 2차 투척 대기&quot;)&#10;&#10;            elif self.phase == 3:&#10;                # Phase 3: 두 번째 투척 대기 (0.1초) - Whirlwind 애니메이션 계속 재생&#10;                self.timer += dt&#10;                &#10;                # Whirlwind 애니메이션 계속 재생&#10;                self.whirlwind_frame_timer += dt&#10;                if self.whirlwind_frame_timer &gt;= 1.0 / self.whirlwind_frame_speed:&#10;                    self.whirlwind_frame_timer = 0.0&#10;                    self.whirlwind_frame = (self.whirlwind_frame + 1) % self.whirlwind_total_frames&#10;&#10;                if self.timer &gt;= self.shot_interval:&#10;                    # 두 번째 투척 준비&#10;                    self.whirlwind_frame = 0&#10;                    self.whirlwind_frame_timer = 0.0&#10;                    self.has_thrown_in_cycle = False&#10;                    self.phase = 4&#10;                    print(&quot;[Pattern5] 2차 투척 시작&quot;)&#10;&#10;            elif self.phase == 4:&#10;                # Phase 4: Whirlwind 애니메이션 재생 및 두 번째 수리검 투척&#10;                self.whirlwind_frame_timer += dt&#10;&#10;                if self.whirlwind_frame_timer &gt;= 1.0 / self.whirlwind_frame_speed:&#10;                    self.whirlwind_frame_timer = 0.0&#10;&#10;                    # 프레임 3에 도달하면 두 번째 투척&#10;                    if self.whirlwind_frame &gt;= self.throw_start_frame and not self.has_thrown_in_cycle:&#10;                        self._shoot_shurikens_360(self.second_speed)&#10;                        self.shot_count = 2&#10;                        self.has_thrown_in_cycle = True&#10;                        print(f&quot;[Pattern5] 2차 투척 완료 (속도: {self.second_speed})&quot;)&#10;&#10;                    self.whirlwind_frame += 1&#10;&#10;                    # Whirlwind 애니메이션 반복&#10;                    if self.whirlwind_frame &gt;= self.whirlwind_total_frames:&#10;                        self.whirlwind_frame = 0&#10;                        self.has_thrown_in_cycle = False&#10;&#10;                        # 두 번째 투척 완료 후 Withdraw 애니메이션으로 전환&#10;                        if self.shot_count &gt;= 2:&#10;                            self.withdraw_frame = 0&#10;                            self.withdraw_frame_timer = 0.0&#10;                            &#10;                            # 분신을 Withdraw 애니메이션으로 전환&#10;                            if self.clone:&#10;                                self.clone.switch_animation('withdraw')&#10;                            self.phase = 5&#10;                            print(&quot;[Pattern5] 2차 투척 완료, Withdraw 애니메이션 시작&quot;)&#10;&#10;            elif self.phase == 5:&#10;                # Phase 5: Throw_All_Withdraw 애니메이션 재생&#10;                self.withdraw_frame_timer += dt&#10;&#10;                if self.withdraw_frame_timer &gt;= 1.0 / self.withdraw_frame_speed:&#10;                    self.withdraw_frame += 1&#10;                    self.withdraw_frame_timer = 0.0&#10;&#10;                    # Withdraw 애니메이션 종료 (0~9)&#10;                    if self.withdraw_frame &gt;= self.withdraw_total_frames:&#10;                        # 분신 사라지는 애니메이션 시작&#10;                        if self.clone:&#10;                            self.clone.start_dying()&#10;                        self.phase = 6&#10;                        print(&quot;[Pattern5] Withdraw 애니메이션 완료, 분신 소멸 시작&quot;)&#10;&#10;            elif self.phase == 6:&#10;                # Phase 6: 분신 사라지는 애니메이션 대기&#10;                # 분신의 Die 애니메이션이 완료될 때까지 대기&#10;                if self.clone and (self.clone.to_be_removed or self.clone.mark_for_removal):&#10;                    # 패턴 완료&#10;                    self.phase = 0&#10;                    self.panther.attack_timer = self.panther.attack_cooldown&#10;                    print(&quot;[Pattern5] 패턴 완료!&quot;)&#10;                    return BehaviorTree.SUCCESS&#10;&#10;            return BehaviorTree.RUNNING&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern5.update] 오류 발생: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;            # 오류 발생 시 패턴 종료&#10;            self.phase = 0&#10;            self.panther.attack_timer = self.panther.attack_cooldown&#10;            return BehaviorTree.FAIL&#10;&#10;    def _shoot_shurikens_360(self, speed):&#10;        &quot;&quot;&quot;&#10;        360도 모든 방향으로 수리검 발사 (0, 90, 180, 270도 +-10도 제외)&#10;&#10;        Args:&#10;            speed: 수리검 속도&#10;        &quot;&quot;&quot;&#10;        if not self.clone or not self.panther.world:&#10;            return&#10;&#10;        try:&#10;            # 투척 제외 각도: 0, 90, 180, 270도 기준 +-10도&#10;            # 플레이어가 피하기 쉽도록 4방향 각도는 제외&#10;            excluded_angle = 10  # 각 방향에서 제외할 각도 범위 (±10도)&#10;&#10;            # 허용된 각도 범위 계산&#10;            # 0도 제외: 350~360, 0~10 제외 → 10~80 허용&#10;            # 90도 제외: 80~100 제외 → 100~170 허용&#10;            # 180도 제외: 170~190 제외 → 190~260 허용&#10;            # 270도 제외: 260~280 제외 → 280~350 허용&#10;            allowed_ranges = [&#10;                (10, 80),      # 1사분면 (0도 제외 후)&#10;                (100, 170),    # 2사분면 (90도 제외 후)&#10;                (190, 260),    # 3사분면 (180도 제외 후)&#10;                (280, 350),    # 4사분면 (270도 제외 후)&#10;            ]&#10;&#10;            # 각 범위에서 7개씩 수리검 발사&#10;            shurikens_per_range = 7&#10;            total_shurikens = 0&#10;&#10;            for angle_min, angle_max in allowed_ranges:&#10;                angle_step = (angle_max - angle_min) / (shurikens_per_range - 1)&#10;&#10;                for i in range(shurikens_per_range):&#10;                    angle = angle_min + angle_step * i&#10;                    rad = math.radians(angle)&#10;&#10;                    # 수리검이 날아갈 목표 위치 계산 (충분히 먼 거리)&#10;                    target_distance = 2000&#10;                    target_x = self.clone.x + math.cos(rad) * target_distance&#10;                    target_y = self.clone.y + math.sin(rad) * target_distance&#10;&#10;                    # 본체에서 수리검 발사&#10;                    from ..panther_assassin import PantherShuriken&#10;                    shuriken_body = PantherShuriken(&#10;                        self.panther.x, self.panther.y,&#10;                        target_x, target_y,&#10;                        speed=speed,&#10;                        from_player=False,&#10;                        damage=20,&#10;                        scale=2.5&#10;                    )&#10;                    self.panther.world['effects_front'].append(shuriken_body)&#10;                    total_shurikens += 1&#10;&#10;                    # 분신에서 수리검 발사&#10;                    shuriken_clone = PantherShuriken(&#10;                        self.clone.x, self.clone.y,&#10;                        target_x, target_y,&#10;                        speed=speed,&#10;                        from_player=False,&#10;                        damage=20,&#10;                        scale=2.5&#10;                    )&#10;                    self.panther.world['effects_front'].append(shuriken_clone)&#10;                    total_shurikens += 1&#10;&#10;            print(f&quot;[Pattern5] 360도 방사형 수리검 발사 완료&quot;)&#10;            print(f&quot;  - 속도: {speed} 픽셀/초&quot;)&#10;            print(f&quot;  - 총 수리검 개수: {total_shurikens}개 (본체: {shurikens_per_range * 4}개, 분신: {shurikens_per_range * 4}개)&quot;)&#10;            print(f&quot;  - 각 사분면당: {shurikens_per_range}개씩&quot;)&#10;            print(f&quot;  - 제외 각도: 0°±{excluded_angle}°, 90°±{excluded_angle}°, 180°±{excluded_angle}°, 270°±{excluded_angle}°&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern5._shoot_shurikens_360] 수리검 발사 중 오류: {e}\033[0m&quot;)&#10;            import traceback&#10;            traceback.print_exc()&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 5 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # 본체 애니메이션 그리기&#10;            if self.phase in [2, 3, 4]:  # Whirlwind 애니메이션 중&#10;                if self.original_images['whirlwind'] and self.whirlwind_frame &lt; len(self.original_images['whirlwind']):&#10;                    img = self.original_images['whirlwind'][self.whirlwind_frame]&#10;                    if img:&#10;                        img.draw(draw_x, draw_y, img.w * self.panther.scale_factor, img.h * self.panther.scale_factor)&#10;&#10;            elif self.phase == 5:  # Withdraw 애니메이션 중&#10;                if self.original_images['withdraw'] and self.withdraw_frame &lt; len(self.original_images['withdraw']):&#10;                    img = self.original_images['withdraw'][self.withdraw_frame]&#10;                    if img:&#10;                        img.draw(draw_x, draw_y, img.w * self.panther.scale_factor, img.h * self.panther.scale_factor)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[Pattern5.draw] 드로잉 중 오류: {e}\033[0m&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/state_machine.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/state_machine.py" />
              <option name="originalContent" value="from .event_to_string import event_to_string&#10;import game_framework&#10;from .inventory import InventoryData&#10;&#10;&#10;class StateMachine:&#10;    def __init__(self, start_state, rules):&#10;        self.cur_state = start_state&#10;        self.rules = rules&#10;        self.cur_state.enter(('START', None))&#10;&#10;    def update(self):&#10;        self.cur_state.do()&#10;&#10;    def draw(self, draw_x = None, draw_y = None):&#10;        self.cur_state.draw(draw_x, draw_y)&#10;&#10;    def current_state(self):&#10;        return self.cur_state&#10;&#10;    def set_state(self, state):&#10;        self.cur_state = state&#10;&#10;    def handle_state_event(self, state_event):&#10;        processed_event = False&#10;        for check_event in self.rules[self.cur_state].keys():&#10;            if check_event(state_event):&#10;                next_state = self.rules[self.cur_state][check_event]&#10;&#10;                # 특수 처리: INVENTORY 상태에서 Tab_down이면 prev_state로 복귀&#10;                if next_state is None and hasattr(self.cur_state, 'prev_state') and self.cur_state.prev_state is not None:&#10;                    next_state = self.cur_state.prev_state&#10;&#10;                # 특수 처리: DASH 상태에서 DASH_END이면 return_to_idle에 따라 IDLE 또는 RUN으로 복귀&#10;                if next_state is None and hasattr(self.cur_state, 'return_to_idle'):&#10;                    # Dash의 return_to_idle 플래그 확인&#10;                    if self.cur_state.return_to_idle:&#10;                        # Idle로 복귀&#10;                        next_state = self.cur_state.player.IDLE&#10;                    else:&#10;                        # Run으로 복귀&#10;                        next_state = self.cur_state.player.RUN&#10;&#10;                self.cur_state.exit(state_event)&#10;                next_state.enter(state_event)&#10;&#10;                print(f'{self.cur_state.__class__.__name__}'&#10;                      f' ======{event_to_string(state_event)}======&gt; '&#10;                      f'{next_state.__class__.__name__}')&#10;                self.cur_state = next_state&#10;                processed_event = True&#10;                return&#10;        if not processed_event:&#10;            event_str = event_to_string(state_event)&#10;            es = event_str.upper() if isinstance(event_str, str) else ''&#10;            is_mouse_motion = ('MOUSE' in es and 'MOTION' in es) or ('MOUSEMOTION' in es)&#10;            if not is_mouse_motion:&#10;                # print('Refused Event:', self.cur_state.__class__.__name__, 'Input : ', event_to_string(state_event))&#10;                pass&#10;" />
              <option name="updatedContent" value="from .event_to_string import event_to_string&#13;&#10;import game_framework&#13;&#10;from .inventory import InventoryData&#13;&#10;&#13;&#10;&#13;&#10;class StateMachine:&#13;&#10;    def __init__(self, start_state, rules):&#13;&#10;        self.cur_state = start_state&#13;&#10;        self.rules = rules&#13;&#10;        self.cur_state.enter(('START', None))&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        self.cur_state.do()&#13;&#10;&#13;&#10;    def draw(self, draw_x = None, draw_y = None):&#13;&#10;        self.cur_state.draw(draw_x, draw_y)&#13;&#10;&#13;&#10;    def current_state(self):&#13;&#10;        return self.cur_state&#13;&#10;&#13;&#10;    def set_state(self, state):&#13;&#10;        self.cur_state = state&#13;&#10;&#13;&#10;    def handle_state_event(self, state_event):&#13;&#10;        processed_event = False&#13;&#10;        for check_event in self.rules[self.cur_state].keys():&#13;&#10;            if check_event(state_event):&#13;&#10;                next_state = self.rules[self.cur_state][check_event]&#13;&#10;&#13;&#10;                # 특수 처리: INVENTORY 상태에서 Tab_down이면 prev_state로 복귀&#13;&#10;                if next_state is None and hasattr(self.cur_state, 'prev_state') and self.cur_state.prev_state is not None:&#13;&#10;                    next_state = self.cur_state.prev_state&#13;&#10;&#13;&#10;                # 특수 처리: DASH 상태에서 DASH_END이면 return_to_idle에 따라 IDLE 또는 RUN으로 복귀&#13;&#10;                if next_state is None and hasattr(self.cur_state, 'return_to_idle'):&#13;&#10;                    # Dash의 return_to_idle 플래그 확인&#13;&#10;                    if self.cur_state.return_to_idle:&#13;&#10;                        # Idle로 복귀&#13;&#10;                        next_state = self.cur_state.player.IDLE&#13;&#10;                    else:&#13;&#10;                        # Run으로 복귀&#13;&#10;                        next_state = self.cur_state.player.RUN&#13;&#10;&#13;&#10;                self.cur_state.exit(state_event)&#13;&#10;                next_state.enter(state_event)&#13;&#10;&#13;&#10;                print(f'{self.cur_state.__class__.__name__}'&#13;&#10;                      f' ======{event_to_string(state_event)}======&gt; '&#13;&#10;                      f'{next_state.__class__.__name__}')&#13;&#10;                self.cur_state = next_state&#13;&#10;                processed_event = True&#13;&#10;                return&#13;&#10;        if not processed_event:&#13;&#10;            event_str = event_to_string(state_event)&#13;&#10;            es = event_str.upper() if isinstance(event_str, str) else ''&#13;&#10;            is_mouse_motion = ('MOUSE' in es and 'MOTION' in es) or ('MOUSEMOTION' in es)&#13;&#10;            if not is_mouse_motion:&#13;&#10;                # print('Refused Event:', self.cur_state.__class__.__name__, 'Input : ', event_to_string(state_event))&#13;&#10;                pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/vfx.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/vfx.py" />
              <option name="originalContent" value="import os&#10;from pico2d import load_image&#10;import pico2d as p2&#10;import game_framework&#10;&#10;class AnimatedVFX:&#10;    &quot;&quot;&quot;간단한 프레임 애니메이션 VFX 엔티티&#10;    - folder: 폴더 경로 (예: resources/Texture_organize/VFX/Potion_Common)&#10;    - prefix: 파일명 접두사 (예: 'Potion_Back_FX')&#10;    - frames: 프레임 수&#10;    - frame_time: 각 프레임 지속 시간&#10;    - x,y: 위치&#10;    - scale: 크기 배율&#10;    &quot;&quot;&quot;&#10;    def __init__(self, folder, prefix, frames, frame_time, x, y, scale=1.0, life=None):&#10;        self.folder = folder&#10;        self.prefix = prefix&#10;        self.frames_count = frames&#10;        self.frame_time = frame_time&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;        self.images = []&#10;        self.frame = 0&#10;        self.acc = 0.0&#10;        self.life = life if life is not None else frames * frame_time&#10;        self._load_frames()&#10;&#10;    def _load_frames(self):&#10;        self.images = []&#10;        for i in range(self.frames_count):&#10;            name1 = f&quot;{self.prefix}{i:02d}.png&quot;&#10;            path = os.path.join(self.folder, name1)&#10;            try:&#10;                img = load_image(path)&#10;                self.images.append(img)&#10;            except Exception:&#10;                # 로드 실패하면 다음 프레임도 시도하지만 중단&#10;                print(f'\033[91m[AnimatedVFX] Failed to load frame: {path}\033[0m')&#10;                break&#10;        # fallback: 만약 아무 프레임도 로드되지 않으면 try single file without index&#10;        if not self.images:&#10;            single = os.path.join(self.folder, f&quot;{self.prefix}.png&quot;)&#10;            try:&#10;                img = load_image(single)&#10;                self.images.append(img)&#10;            except Exception:&#10;                print(f'\033[91m[AnimatedVFX] Failed to load single image: {single}\033[0m')&#10;        # adjust frames_count to actual loaded&#10;        self.frames_count = len(self.images)&#10;&#10;    def update(self, dt=None):&#10;        # dt None이면 framework에서 값을 가져옴 (main.update_world가 인자로 주지 않으므로)&#10;        if dt is None:&#10;            dt = game_framework.get_delta_time()&#10;        if self.life &lt;= 0:&#10;            return False&#10;        self.life -= dt&#10;        if self.frames_count == 0:&#10;            return self.life &gt; 0&#10;        self.acc += dt&#10;        while self.acc &gt;= self.frame_time and self.frame &lt; self.frames_count - 1:&#10;            self.acc -= self.frame_time&#10;            self.frame += 1&#10;        return self.life &gt; 0&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if self.images and 0 &lt;= self.frame &lt; len(self.images):&#10;            img = self.images[self.frame]&#10;            img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;&#10;&#10;class GuardFX:&#10;    &quot;&quot;&quot;방패 방어 성공 시 표시되는 이펙트&quot;&quot;&quot;&#10;    images = None&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if GuardFX.images is None:&#10;            GuardFX.images = []&#10;            try:&#10;                for i in range(5):  # GuardFX1_0.png ~ GuardFX1_4.png&#10;                    img = p2.load_image(f'resources/Texture_organize/Weapon/SwordANDShield/Guard_FX/GuardFX1_{i}.png')&#10;                    GuardFX.images.append(img)&#10;                print(f&quot;[GuardFX] Loaded {len(GuardFX.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[GuardFX] Failed to load images: {e}\033[0m&quot;)&#10;                GuardFX.images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 20  # 빠르게 재생 (20 FPS)&#10;        self.finished = False&#10;&#10;        print(f&quot;[GuardFX] 생성됨 at world({int(x)}, {int(y)}), 총 프레임: {len(GuardFX.images) if GuardFX.images else 0}&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#10;        if self.finished:&#10;            return False&#10;&#10;        dt = game_framework.get_delta_time()&#10;        self.animation_time += dt&#10;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            self.frame += 1&#10;            self.animation_time = 0&#10;&#10;            # 애니메이션이 끝나면 제거&#10;            if GuardFX.images and self.frame &gt;= len(GuardFX.images):&#10;                self.finished = True&#10;                return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        이펙트 그리기&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if not GuardFX.images or len(GuardFX.images) == 0:&#10;            print(&quot;[GuardFX] 이미지가 없음!&quot;)&#10;            return&#10;&#10;        if self.finished:&#10;            return&#10;&#10;        frame_idx = min(self.frame, len(GuardFX.images) - 1)&#10;        try:&#10;            # 카메라가 적용된 좌표(draw_x, draw_y)를 사용하여 그리기&#10;            GuardFX.images[frame_idx].draw(&#10;                draw_x, draw_y,&#10;                GuardFX.images[frame_idx].w * self.scale,&#10;                GuardFX.images[frame_idx].h * self.scale&#10;            )&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[GuardFX] draw 에러: {e}\033[0m&quot;)&#10;&#10;&#10;class ShieldCrashEffect:&#10;    &quot;&quot;&quot;방패가 깨질 때 표시되는 이펙트 (Crash_Blue)&quot;&quot;&quot;&#10;    front_images = None&#10;    back_images = None&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if ShieldCrashEffect.front_images is None:&#10;            ShieldCrashEffect.front_images = []&#10;            try:&#10;                for i in range(11):  # Crash_Blue_Front_FX00 ~ FX10 (0~10)&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Front_FX0{i}.png')&#10;                    ShieldCrashEffect.front_images.append(img)&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.front_images)} front images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load front images: {e}\033[0m&quot;)&#10;                ShieldCrashEffect.front_images = []&#10;&#10;        if ShieldCrashEffect.back_images is None:&#10;            ShieldCrashEffect.back_images = []&#10;            try:&#10;                for i in range(3, 9):  # Crash_Blue_Back_FX03 ~ FX08 (3~8)&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Back_FX0{i}.png')&#10;                    ShieldCrashEffect.back_images.append(img)&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.back_images)} back images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load back images: {e}\033[0m&quot;)&#10;                ShieldCrashEffect.back_images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 20  # 빠른 애니메이션 (20 FPS)&#10;        self.finished = False&#10;&#10;        print(f&quot;[ShieldCrashEffect] 생성됨 at world({int(x)}, {int(y)})&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#10;        if self.finished:&#10;            return False&#10;&#10;        dt = game_framework.get_delta_time()&#10;        self.animation_time += dt&#10;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            self.frame += 1&#10;            self.animation_time = 0&#10;&#10;            # Front 이미지 기준으로 애니메이션이 끝나면 제거&#10;            if ShieldCrashEffect.front_images and self.frame &gt;= len(ShieldCrashEffect.front_images):&#10;                self.finished = True&#10;                return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        이펙트 그리기 (Front와 Back을 레이어링)&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if self.finished:&#10;            return&#10;&#10;        # Front 이미지 그리기 (0~10 프레임)&#10;        if ShieldCrashEffect.front_images and self.frame &lt; len(ShieldCrashEffect.front_images):&#10;            try:&#10;                ShieldCrashEffect.front_images[self.frame].draw(&#10;                    draw_x, draw_y,&#10;                    ShieldCrashEffect.front_images[self.frame].w * self.scale,&#10;                    ShieldCrashEffect.front_images[self.frame].h * self.scale&#10;                )&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] front draw 에러: {e}\033[0m&quot;)&#10;&#10;        # Back 이미지 그리기 (Front 프레임 3부터 시작)&#10;        # Front frame 3 = Back index 0 (Back_FX03)&#10;        # Front frame 4 = Back index 1 (Back_FX04) ...&#10;        if self.frame &gt;= 3:&#10;            back_index = self.frame - 3&#10;            if ShieldCrashEffect.back_images and back_index &lt; len(ShieldCrashEffect.back_images):&#10;                try:&#10;                    ShieldCrashEffect.back_images[back_index].draw(&#10;                        draw_x, draw_y,&#10;                        ShieldCrashEffect.back_images[back_index].w * self.scale,&#10;                        ShieldCrashEffect.back_images[back_index].h * self.scale&#10;                    )&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[ShieldCrashEffect] back draw 에러: {e}\033[0m&quot;)&#10;&#10;&#10;class DashTrailEffect:&#10;    &quot;&quot;&quot;대시 시 남는 잔상 이펙트 - 0.3초간 알파값이 1에서 0으로 페이드아웃&quot;&quot;&quot;&#10;    trail_image = None  # 클래스 변수로 이미지 한 번만 로드&#10;&#10;    def __init__(self, x, y, face_dir, scale=3.0):&#10;        &quot;&quot;&quot;&#10;        대시 잔상 이펙트 생성&#10;        &#10;        Args:&#10;            x: 월드 X 좌표&#10;            y: 월드 Y 좌표&#10;            face_dir: 플레이어의 방향 (1: 오른쪽, -1: 왼쪽)&#10;            scale: 이미지 크기 배율&#10;        &quot;&quot;&quot;&#10;        self.x = x&#10;        self.y = y&#10;        self.face_dir = face_dir&#10;        self.scale = scale&#10;        &#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if DashTrailEffect.trail_image is None:&#10;            try:&#10;                img_path = os.path.join('resources', 'Texture_organize', 'Player_character', 'PlayerDashTrailFx0.png')&#10;                DashTrailEffect.trail_image = load_image(img_path)&#10;                print(f&quot;[DashTrailEffect] 이미지 로드 성공: {img_path}&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[DashTrailEffect] 이미지 로드 실패: {e}\033[0m&quot;)&#10;                DashTrailEffect.trail_image = None&#10;        &#10;        # 페이드아웃 설정&#10;        self.fade_duration = 0.3  # 0.3초간 페이드아웃&#10;        self.elapsed_time = 0.0&#10;        self.alpha = 1.0  # 초기 알파값 1.0 (완전 불투명)&#10;    &#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        이펙트 업데이트 - 알파값을 시간에 따라 감소&#10;        &#10;        Returns:&#10;            bool: True면 계속 유지, False면 제거&#10;        &quot;&quot;&quot;&#10;        dt = game_framework.get_delta_time()&#10;        self.elapsed_time += dt&#10;        &#10;        # 알파값 계산 (1.0 -&gt; 0.0으로 선형 감소)&#10;        if self.elapsed_time &lt; self.fade_duration:&#10;            self.alpha = 1.0 - (self.elapsed_time / self.fade_duration)&#10;        else:&#10;            self.alpha = 0.0&#10;            return False  # 알파값이 0이 되면 제거&#10;        &#10;        return True&#10;    &#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        잔상 이펙트 그리기&#10;        &#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if not DashTrailEffect.trail_image:&#10;            return&#10;        &#10;        # 알파값이 0이면 그리지 않음&#10;        if self.alpha &lt;= 0:&#10;            return&#10;        &#10;        # 방향에 따라 flip 설정&#10;        flip = '' if self.face_dir == 1 else 'h'&#10;        &#10;        # 알파값 설정하여 그리기&#10;        DashTrailEffect.trail_image.opacify(self.alpha)&#10;        DashTrailEffect.trail_image.clip_composite_draw(&#10;            0, 0, &#10;            DashTrailEffect.trail_image.w, &#10;            DashTrailEffect.trail_image.h,&#10;            0, flip,&#10;            draw_x, draw_y,&#10;            DashTrailEffect.trail_image.w * self.scale,&#10;            DashTrailEffect.trail_image.h * self.scale&#10;        )&#10;        # 알파값 복원 (다른 이미지에 영향 주지 않도록)&#10;        DashTrailEffect.trail_image.opacify(1.0)" />
              <option name="updatedContent" value="import os&#13;&#10;from pico2d import load_image&#13;&#10;import pico2d as p2&#13;&#10;import game_framework&#13;&#10;&#13;&#10;class AnimatedVFX:&#13;&#10;    &quot;&quot;&quot;간단한 프레임 애니메이션 VFX 엔티티&#13;&#10;    - folder: 폴더 경로 (예: resources/Texture_organize/VFX/Potion_Common)&#13;&#10;    - prefix: 파일명 접두사 (예: 'Potion_Back_FX')&#13;&#10;    - frames: 프레임 수&#13;&#10;    - frame_time: 각 프레임 지속 시간&#13;&#10;    - x,y: 위치&#13;&#10;    - scale: 크기 배율&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    def __init__(self, folder, prefix, frames, frame_time, x, y, scale=1.0, life=None):&#13;&#10;        self.folder = folder&#13;&#10;        self.prefix = prefix&#13;&#10;        self.frames_count = frames&#13;&#10;        self.frame_time = frame_time&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;        self.images = []&#13;&#10;        self.frame = 0&#13;&#10;        self.acc = 0.0&#13;&#10;        self.life = life if life is not None else frames * frame_time&#13;&#10;        self._load_frames()&#13;&#10;&#13;&#10;    def _load_frames(self):&#13;&#10;        self.images = []&#13;&#10;        for i in range(self.frames_count):&#13;&#10;            name1 = f&quot;{self.prefix}{i:02d}.png&quot;&#13;&#10;            path = os.path.join(self.folder, name1)&#13;&#10;            try:&#13;&#10;                img = load_image(path)&#13;&#10;                self.images.append(img)&#13;&#10;            except Exception:&#13;&#10;                # 로드 실패하면 다음 프레임도 시도하지만 중단&#13;&#10;                print(f'\033[91m[AnimatedVFX] Failed to load frame: {path}\033[0m')&#13;&#10;                break&#13;&#10;        # fallback: 만약 아무 프레임도 로드되지 않으면 try single file without index&#13;&#10;        if not self.images:&#13;&#10;            single = os.path.join(self.folder, f&quot;{self.prefix}.png&quot;)&#13;&#10;            try:&#13;&#10;                img = load_image(single)&#13;&#10;                self.images.append(img)&#13;&#10;            except Exception:&#13;&#10;                print(f'\033[91m[AnimatedVFX] Failed to load single image: {single}\033[0m')&#13;&#10;        # adjust frames_count to actual loaded&#13;&#10;        self.frames_count = len(self.images)&#13;&#10;&#13;&#10;    def update(self, dt=None):&#13;&#10;        # dt None이면 framework에서 값을 가져옴 (main.update_world가 인자로 주지 않으므로)&#13;&#10;        if dt is None:&#13;&#10;            dt = game_framework.get_delta_time()&#13;&#10;        if self.life &lt;= 0:&#13;&#10;            return False&#13;&#10;        self.life -= dt&#13;&#10;        if self.frames_count == 0:&#13;&#10;            return self.life &gt; 0&#13;&#10;        self.acc += dt&#13;&#10;        while self.acc &gt;= self.frame_time and self.frame &lt; self.frames_count - 1:&#13;&#10;            self.acc -= self.frame_time&#13;&#10;            self.frame += 1&#13;&#10;        return self.life &gt; 0&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        if self.images and 0 &lt;= self.frame &lt; len(self.images):&#13;&#10;            img = self.images[self.frame]&#13;&#10;            img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#13;&#10;&#13;&#10;&#13;&#10;class GuardFX:&#13;&#10;    &quot;&quot;&quot;방패 방어 성공 시 표시되는 이펙트&quot;&quot;&quot;&#13;&#10;    images = None&#13;&#10;&#13;&#10;    def __init__(self, x, y, scale=3.0):&#13;&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;&#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if GuardFX.images is None:&#13;&#10;            GuardFX.images = []&#13;&#10;            try:&#13;&#10;                for i in range(5):  # GuardFX1_0.png ~ GuardFX1_4.png&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/Weapon/SwordANDShield/Guard_FX/GuardFX1_{i}.png')&#13;&#10;                    GuardFX.images.append(img)&#13;&#10;                print(f&quot;[GuardFX] Loaded {len(GuardFX.images)} images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[GuardFX] Failed to load images: {e}\033[0m&quot;)&#13;&#10;                GuardFX.images = []&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.animation_time = 0&#13;&#10;        self.animation_speed = 20  # 빠르게 재생 (20 FPS)&#13;&#10;        self.finished = False&#13;&#10;&#13;&#10;        print(f&quot;[GuardFX] 생성됨 at world({int(x)}, {int(y)}), 총 프레임: {len(GuardFX.images) if GuardFX.images else 0}&quot;)&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return False&#13;&#10;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.animation_time += dt&#13;&#10;&#13;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;            self.frame += 1&#13;&#10;            self.animation_time = 0&#13;&#10;&#13;&#10;            # 애니메이션이 끝나면 제거&#13;&#10;            if GuardFX.images and self.frame &gt;= len(GuardFX.images):&#13;&#10;                self.finished = True&#13;&#10;                return False&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 그리기&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not GuardFX.images or len(GuardFX.images) == 0:&#13;&#10;            print(&quot;[GuardFX] 이미지가 없음!&quot;)&#13;&#10;            return&#13;&#10;&#13;&#10;        if self.finished:&#13;&#10;            return&#13;&#10;&#13;&#10;        frame_idx = min(self.frame, len(GuardFX.images) - 1)&#13;&#10;        try:&#13;&#10;            # 카메라가 적용된 좌표(draw_x, draw_y)를 사용하여 그리기&#13;&#10;            GuardFX.images[frame_idx].draw(&#13;&#10;                draw_x, draw_y,&#13;&#10;                GuardFX.images[frame_idx].w * self.scale,&#13;&#10;                GuardFX.images[frame_idx].h * self.scale&#13;&#10;            )&#13;&#10;        except Exception as e:&#13;&#10;            print(f&quot;\033[91m[GuardFX] draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;class ShieldCrashEffect:&#13;&#10;    &quot;&quot;&quot;방패가 깨질 때 표시되는 이펙트 (Crash_Blue)&quot;&quot;&quot;&#13;&#10;    front_images = None&#13;&#10;    back_images = None&#13;&#10;&#13;&#10;    def __init__(self, x, y, scale=3.0):&#13;&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;&#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if ShieldCrashEffect.front_images is None:&#13;&#10;            ShieldCrashEffect.front_images = []&#13;&#10;            try:&#13;&#10;                for i in range(11):  # Crash_Blue_Front_FX00 ~ FX10 (0~10)&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Front_FX0{i}.png')&#13;&#10;                    ShieldCrashEffect.front_images.append(img)&#13;&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.front_images)} front images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load front images: {e}\033[0m&quot;)&#13;&#10;                ShieldCrashEffect.front_images = []&#13;&#10;&#13;&#10;        if ShieldCrashEffect.back_images is None:&#13;&#10;            ShieldCrashEffect.back_images = []&#13;&#10;            try:&#13;&#10;                for i in range(3, 9):  # Crash_Blue_Back_FX03 ~ FX08 (3~8)&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Back_FX0{i}.png')&#13;&#10;                    ShieldCrashEffect.back_images.append(img)&#13;&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.back_images)} back images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load back images: {e}\033[0m&quot;)&#13;&#10;                ShieldCrashEffect.back_images = []&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.animation_time = 0&#13;&#10;        self.animation_speed = 20  # 빠른 애니메이션 (20 FPS)&#13;&#10;        self.finished = False&#13;&#10;&#13;&#10;        print(f&quot;[ShieldCrashEffect] 생성됨 at world({int(x)}, {int(y)})&quot;)&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return False&#13;&#10;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.animation_time += dt&#13;&#10;&#13;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;            self.frame += 1&#13;&#10;            self.animation_time = 0&#13;&#10;&#13;&#10;            # Front 이미지 기준으로 애니메이션이 끝나면 제거&#13;&#10;            if ShieldCrashEffect.front_images and self.frame &gt;= len(ShieldCrashEffect.front_images):&#13;&#10;                self.finished = True&#13;&#10;                return False&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 그리기 (Front와 Back을 레이어링)&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return&#13;&#10;&#13;&#10;        # Front 이미지 그리기 (0~10 프레임)&#13;&#10;        if ShieldCrashEffect.front_images and self.frame &lt; len(ShieldCrashEffect.front_images):&#13;&#10;            try:&#13;&#10;                ShieldCrashEffect.front_images[self.frame].draw(&#13;&#10;                    draw_x, draw_y,&#13;&#10;                    ShieldCrashEffect.front_images[self.frame].w * self.scale,&#13;&#10;                    ShieldCrashEffect.front_images[self.frame].h * self.scale&#13;&#10;                )&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] front draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;        # Back 이미지 그리기 (Front 프레임 3부터 시작)&#13;&#10;        # Front frame 3 = Back index 0 (Back_FX03)&#13;&#10;        # Front frame 4 = Back index 1 (Back_FX04) ...&#13;&#10;        if self.frame &gt;= 3:&#13;&#10;            back_index = self.frame - 3&#13;&#10;            if ShieldCrashEffect.back_images and back_index &lt; len(ShieldCrashEffect.back_images):&#13;&#10;                try:&#13;&#10;                    ShieldCrashEffect.back_images[back_index].draw(&#13;&#10;                        draw_x, draw_y,&#13;&#10;                        ShieldCrashEffect.back_images[back_index].w * self.scale,&#13;&#10;                        ShieldCrashEffect.back_images[back_index].h * self.scale&#13;&#10;                    )&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91m[ShieldCrashEffect] back draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;class DashTrailEffect:&#13;&#10;    &quot;&quot;&quot;대시 시 남는 잔상 이펙트 - 0.3초간 알파값이 1에서 0으로 페이드아웃&quot;&quot;&quot;&#13;&#10;    trail_image = None  # 클래스 변수로 이미지 한 번만 로드&#13;&#10;&#13;&#10;    def __init__(self, x, y, face_dir, scale=3.0):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        대시 잔상 이펙트 생성&#13;&#10;        &#13;&#10;        Args:&#13;&#10;            x: 월드 X 좌표&#13;&#10;            y: 월드 Y 좌표&#13;&#10;            face_dir: 플레이어의 방향 (1: 오른쪽, -1: 왼쪽)&#13;&#10;            scale: 이미지 크기 배율&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.face_dir = face_dir&#13;&#10;        self.scale = scale&#13;&#10;        &#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if DashTrailEffect.trail_image is None:&#13;&#10;            try:&#13;&#10;                img_path = os.path.join('resources', 'Texture_organize', 'Player_character', 'PlayerDashTrailFx0.png')&#13;&#10;                DashTrailEffect.trail_image = load_image(img_path)&#13;&#10;                print(f&quot;[DashTrailEffect] 이미지 로드 성공: {img_path}&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[DashTrailEffect] 이미지 로드 실패: {e}\033[0m&quot;)&#13;&#10;                DashTrailEffect.trail_image = None&#13;&#10;        &#13;&#10;        # 페이드아웃 설정&#13;&#10;        self.fade_duration = 0.3  # 0.3초간 페이드아웃&#13;&#10;        self.elapsed_time = 0.0&#13;&#10;        self.alpha = 1.0  # 초기 알파값 1.0 (완전 불투명)&#13;&#10;    &#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 업데이트 - 알파값을 시간에 따라 감소&#13;&#10;        &#13;&#10;        Returns:&#13;&#10;            bool: True면 계속 유지, False면 제거&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.elapsed_time += dt&#13;&#10;        &#13;&#10;        # 알파값 계산 (1.0 -&gt; 0.0으로 선형 감소)&#13;&#10;        if self.elapsed_time &lt; self.fade_duration:&#13;&#10;            self.alpha = 1.0 - (self.elapsed_time / self.fade_duration)&#13;&#10;        else:&#13;&#10;            self.alpha = 0.0&#13;&#10;            return False  # 알파값이 0이 되면 제거&#13;&#10;        &#13;&#10;        return True&#13;&#10;    &#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        잔상 이펙트 그리기&#13;&#10;        &#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not DashTrailEffect.trail_image:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # 알파값이 0이면 그리지 않음&#13;&#10;        if self.alpha &lt;= 0:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # 방향에 따라 flip 설정&#13;&#10;        flip = '' if self.face_dir == 1 else 'h'&#13;&#10;        &#13;&#10;        # 알파값 설정하여 그리기&#13;&#10;        DashTrailEffect.trail_image.opacify(self.alpha)&#13;&#10;        DashTrailEffect.trail_image.clip_composite_draw(&#13;&#10;            0, 0, &#13;&#10;            DashTrailEffect.trail_image.w, &#13;&#10;            DashTrailEffect.trail_image.h,&#13;&#10;            0, flip,&#13;&#10;            draw_x, draw_y,&#13;&#10;            DashTrailEffect.trail_image.w * self.scale,&#13;&#10;            DashTrailEffect.trail_image.h * self.scale&#13;&#10;        )&#13;&#10;        # 알파값 복원 (다른 이미지에 영향 주지 않도록)&#13;&#10;        DashTrailEffect.trail_image.opacify(1.0)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>