<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game_framework.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_framework.py" />
              <option name="originalContent" value="import time&#10;import game_logic.framework as gl_framework&#10;&#10;current_state = None&#10;_running = False&#10;&#10;&#10;def change_state(new_state, *args, **kwargs):&#10;    global current_state&#10;    # exit old state&#10;    try:&#10;        if current_state and hasattr(current_state, 'exit'):&#10;            current_state.exit()&#10;    except Exception:&#10;        print(f'\033[91m[game_framework] Exception during exit of state {current_state}\033[0m')&#10;&#10;    # change state&#10;    current_state = new_state&#10;    # enter new state (with args if provided)&#10;    run(current_state, *args, **kwargs)&#10;&#10;&#10;def run(start_state, *args, **kwargs):&#10;    &quot;&quot;&quot;Start the main loop with start_state (module-like object that exposes&#10;    enter/exit/handle_events/update/draw).&quot;&quot;&quot;&#10;    global current_state, _running&#10;    current_state = start_state&#10;    try:&#10;        if current_state and hasattr(current_state, 'enter'):&#10;            if args or kwargs:&#10;                current_state.enter(*args, **kwargs)&#10;            else:&#10;                current_state.enter()&#10;    except Exception as ex:&#10;        print(f'\033[91m[game_framework] Exception {ex} during enter of state {current_state}\033[0m')&#10;&#10;    _running = True&#10;    last_time = time.time()&#10;    try:&#10;        while _running:&#10;            now = time.time()&#10;            dt = now - last_time&#10;            last_time = now&#10;            # update global delta_time used by game_logic modules&#10;            try:&#10;                gl_framework.set_delta_time(dt)&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during set_delta_time() with dt={dt}\033[0m')&#10;&#10;            if current_state is None:&#10;                break&#10;&#10;            # event handling&#10;            try:&#10;                if hasattr(current_state, 'handle_events'):&#10;                    current_state.handle_events()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during handle_events() of state {current_state}\033[0m')&#10;                print(f'\033[91m[game_framework] Or Entering Next State with {current_state} handle_events()\033[0m')&#10;                print('\033[91m[game_framework]Continuing main loop...\033[0m')&#10;&#10;            # update&#10;            try:&#10;                if hasattr(current_state, 'update'):&#10;                    current_state.update()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during update() of state {current_state}\033[0m')&#10;&#10;            # draw&#10;            try:&#10;                if hasattr(current_state, 'draw'):&#10;                    current_state.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during draw() of state {current_state}\033[0m')&#10;&#10;            # small sleep to avoid 100% CPU (frame limiter is handled by resource loads)&#10;            time.sleep(gl_framework.frame_time if hasattr(gl_framework, 'frame_time') else 0.01)&#10;    finally:&#10;        try:&#10;            if current_state and hasattr(current_state, 'exit'):&#10;                current_state.exit()&#10;        except Exception as ex:&#10;            print(f'\033[91m[game_framework] Exception {ex} during exit() of state {current_state}\033[0m')&#10;&#10;&#10;def quit():&#10;    global _running&#10;    _running = False&#10;" />
              <option name="updatedContent" value="import time&#10;import game_logic.framework as gl_framework&#10;&#10;current_state = None&#10;_running = False&#10;&#10;&#10;def change_state(new_state, *args, **kwargs):&#10;    global current_state&#10;    # exit old state&#10;    try:&#10;        if current_state and hasattr(current_state, 'exit'):&#10;            current_state.exit()&#10;    except Exception:&#10;        print(f'\033[91m[game_framework] Exception during exit of state {current_state}\033[0m')&#10;&#10;    # change state&#10;    current_state = new_state&#10;    # enter new state (with args if provided)&#10;    run(current_state, *args, **kwargs)&#10;&#10;&#10;def run(start_state, *args, **kwargs):&#10;    &quot;&quot;&quot;Start the main loop with start_state (module-like object that exposes&#10;    enter/exit/handle_events/update/draw).&quot;&quot;&quot;&#10;    global current_state, _running&#10;    current_state = start_state&#10;    try:&#10;        if current_state and hasattr(current_state, 'enter'):&#10;            if args or kwargs:&#10;                current_state.enter(*args, **kwargs)&#10;            else:&#10;                current_state.enter()&#10;    except Exception as ex:&#10;        print(f'\033[91m[game_framework] Exception {ex} during enter of state {current_state}\033[0m')&#10;&#10;    _running = True&#10;    last_time = time.time()&#10;    try:&#10;        while _running:&#10;            now = time.time()&#10;            dt = now - last_time&#10;            last_time = now&#10;            # update global delta_time used by game_logic modules&#10;            try:&#10;                gl_framework.set_delta_time(dt)&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during set_delta_time() with dt={dt}\033[0m')&#10;&#10;            if current_state is None:&#10;                break&#10;&#10;            # event handling&#10;            try:&#10;                if hasattr(current_state, 'handle_events'):&#10;                    current_state.handle_events()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during handle_events() of state {current_state}\033[0m')&#10;                print(f'\033[91m[game_framework] Or Entering Next State with {current_state} handle_events()\033[0m')&#10;                print('\033[91m[game_framework]Continuing main loop...\033[0m')&#10;&#10;            # update&#10;            try:&#10;                if hasattr(current_state, 'update'):&#10;                    current_state.update()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during update() of state {current_state}\033[0m')&#10;&#10;            # draw&#10;            try:&#10;                if hasattr(current_state, 'draw'):&#10;                    current_state.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[game_framework] Exception {ex} during draw() of state {current_state}\033[0m')&#10;&#10;            # small sleep to avoid 100% CPU (frame limiter is handled by resource loads)&#10;            time.sleep(gl_framework.frame_time if hasattr(gl_framework, 'frame_time') else 0.01)&#10;    finally:&#10;        try:&#10;            if current_state and hasattr(current_state, 'exit'):&#10;                current_state.exit()&#10;        except Exception as ex:&#10;            print(f'\033[91m[game_framework] Exception {ex} during exit() of state {current_state}\033[0m')&#10;&#10;&#10;def quit():&#10;    global _running&#10;    _running = False" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/background.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/background.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;간단한 배경 이미지 클래스&#10;&quot;&quot;&quot;&#10;import pico2d as p2&#10;&#10;&#10;class FixedBackground:&#10;    &quot;&quot;&quot;고정된 배경 이미지를 표시하는 클래스&quot;&quot;&quot;&#10;&#10;    def __init__(self, image_path, width, height):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            image_path: 배경 이미지 경로&#10;            width: 배경 이미지 너비&#10;            height: 배경 이미지 높이&#10;        &quot;&quot;&quot;&#10;        try:&#10;            self.image = p2.load_image(image_path)&#10;            self.width = width&#10;            self.height = height&#10;            # 배경의 월드 좌표 (맵 중심 기준)&#10;            self.x = 0&#10;            self.y = 0&#10;            self.scale = 1.0&#10;            print(f&quot;[FixedBackground] 배경 이미지 로드 성공: {image_path}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[FixedBackground] 배경 이미지 로드 실패: {image_path}, 에러: {e}\033[0m&quot;)&#10;            self.image = None&#10;            self.width = width&#10;            self.height = height&#10;            self.x = 0&#10;            self.y = 0&#10;            self.scale = 1.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;배경은 업데이트가 필요 없음&quot;&quot;&quot;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;배경 이미지 그리기 (카메라 좌표 적용)&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 x 좌표&#10;            draw_y: 카메라가 적용된 화면 y 좌표&#10;        &quot;&quot;&quot;&#10;        if self.image:&#10;            self.image.draw(&#10;                draw_x,&#10;                draw_y,&#10;                self.width,&#10;                self.height&#10;            )&#10;&#10;class StageMap:&#10;    &quot;&quot;&quot;&#10;    스테이지 맵 이미지를 표시하는 클래스&#10;     L 카메라 좌표 적용하는 맵.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, image_path, width, height):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            image_path: 맵 이미지 경로&#10;            width: 맵 이미지 너비&#10;            height: 맵 이미지 높이&#10;        &quot;&quot;&quot;&#10;        try:&#10;            self.image = p2.load_image(image_path)&#10;            self.width = width&#10;            self.height = height&#10;            # 맵의 월드 좌표 (맵 중심 기준)&#10;            self.x = 0&#10;            self.y = 0&#10;            self.scale = 1.0&#10;            print(f&quot;[StageMap] 맵 이미지 로드 성공: {image_path}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[StageMap] 맵 이미지 로드 실패: {image_path}, 에러: {e}\033[0m&quot;)&#10;            self.image = None&#10;            self.width = width&#10;            self.height = height&#10;            self.x = 0&#10;            self.y = 0&#10;            self.scale = 1.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;맵은 업데이트가 필요 없음&quot;&quot;&quot;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;맵 이미지 그리기 (카메라 좌표 적용)&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 x 좌표&#10;            draw_y: 카메라가 적용된 화면 y 좌표&#10;        &quot;&quot;&quot;&#10;        if self.image:&#10;            self.image.draw(&#10;                draw_x,&#10;                draw_y,&#10;                self.width,&#10;                self.height&#10;            )" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;간단한 배경 이미지 클래스&#10;&quot;&quot;&quot;&#10;import pico2d as p2&#10;&#10;&#10;class FixedBackground:&#10;    &quot;&quot;&quot;고정된 배경 이미지를 표시하는 클래스&quot;&quot;&quot;&#10;&#10;    def __init__(self, image_path, width, height):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            image_path: 배경 이미지 경로&#10;            width: 배경 이미지 너비&#10;            height: 배경 이미지 높이&#10;        &quot;&quot;&quot;&#10;        try:&#10;            self.image = p2.load_image(image_path)&#10;            self.width = width&#10;            self.height = height&#10;            # 배경의 월드 좌표 (맵 중심 기준)&#10;            self.x = 0&#10;            self.y = 0&#10;            self.scale = 1.0&#10;            print(f&quot;[FixedBackground] 배경 이미지 로드 성공: {image_path}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[FixedBackground] 배경 이미지 로드 실패: {image_path}, 에러: {e}\033[0m&quot;)&#10;            self.image = None&#10;            self.width = width&#10;            self.height = height&#10;            self.x = 0&#10;            self.y = 0&#10;            self.scale = 1.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;배경은 업데이트가 필요 없음&quot;&quot;&quot;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;배경 이미지 그리기 (카메라 좌표 적용)&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 x 좌표&#10;            draw_y: 카메라가 적용된 화면 y 좌표&#10;        &quot;&quot;&quot;&#10;        if self.image:&#10;            self.image.draw(&#10;                draw_x,&#10;                draw_y,&#10;                self.width,&#10;                self.height&#10;            )&#10;&#10;class StageMap:&#10;    &quot;&quot;&quot;&#10;    스테이지 맵 이미지를 표시하는 클래스&#10;     L 카메라 좌표 적용하는 맵.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, image_path, width, height):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            image_path: 맵 이미지 경로&#10;            width: 맵 이미지 너비&#10;            height: 맵 이미지 높이&#10;        &quot;&quot;&quot;&#10;        try:&#10;            self.image = p2.load_image(image_path)&#10;            self.width = width&#10;            self.height = height&#10;            # 맵의 월드 좌표 (맵 중심 기준)&#10;            self.x = 0&#10;            self.y = 0&#10;            self.scale = 1.0&#10;            print(f&quot;[StageMap] 맵 이미지 로드 성공: {image_path}&quot;)&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[StageMap] 맵 이미지 로드 실패: {image_path}, 에러: {e}\033[0m&quot;)&#10;            self.image = None&#10;            self.width = width&#10;            self.height = height&#10;            self.x = 0&#10;            self.y = 0&#10;            self.scale = 1.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;맵은 업데이트가 필요 없음&quot;&quot;&quot;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;맵 이미지 그리기 (카메라 좌표 적용)&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 x 좌표&#10;            draw_y: 카메라가 적용된 화면 y 좌표&#10;        &quot;&quot;&quot;&#10;        if self.image:&#10;            self.image.draw(&#10;                draw_x,&#10;                draw_y,&#10;                self.width,&#10;                self.height&#10;            )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/cursor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/cursor.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;import math&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;from . import framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        if right_held and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;" />
              <option name="updatedContent" value="import ctypes&#13;&#10;import os&#13;&#10;import math&#13;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#13;&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#13;&#10;from . import framework&#13;&#10;&#13;&#10;class Cursor:&#13;&#10;    def __init__(self, player=None):&#13;&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#13;&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#13;&#10;        self.x, self.y = 0, 0&#13;&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#13;&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#13;&#10;&#13;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#13;&#10;        self.player = player&#13;&#10;        self.last_inventory_open = False&#13;&#10;&#13;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#13;&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#13;&#10;        self.inv_frames = []&#13;&#10;        for i in range(0, 7):&#13;&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#13;&#10;            try:&#13;&#10;                self.inv_frames.append(load_image(path))&#13;&#10;            except Exception as ex:&#13;&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#13;&#10;                self.inv_frames = []&#13;&#10;                break&#13;&#10;&#13;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#13;&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#13;&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#13;&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#13;&#10;        self.inv_anchor = (0.10, 0.90)&#13;&#10;&#13;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#13;&#10;        try:&#13;&#10;            self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#13;&#10;        except Exception as ex:&#13;&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#13;&#10;            self.shield_range_image = None&#13;&#10;        self.shield_range_scale = 4.0&#13;&#10;&#13;&#10;        # 애니메이션 상태&#13;&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#13;&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#13;&#10;        self.frame_timer = 0.0&#13;&#10;        self.frame_duration = 0.06    # 프레임당 시간&#13;&#10;        self.mouse_down = False&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        # 마우스 위치 갱신&#13;&#10;        mx = ctypes.c_int(0)&#13;&#10;        my = ctypes.c_int(0)&#13;&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#13;&#10;        canvas_h = get_canvas_height()&#13;&#10;        self.x = mx.value&#13;&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#13;&#10;&#13;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#13;&#10;&#13;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#13;&#10;        if inv_open != self.last_inventory_open:&#13;&#10;            self.anim_state = 'idle_up'&#13;&#10;            self.frame_idx = 6&#13;&#10;            self.frame_timer = 0.0&#13;&#10;            self.mouse_down = False&#13;&#10;            self.last_inventory_open = inv_open&#13;&#10;&#13;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#13;&#10;        if inv_open and self.inv_frames:&#13;&#10;            dt = framework.get_delta_time()&#13;&#10;            self.frame_timer += dt&#13;&#10;            if self.anim_state == 'down':&#13;&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#13;&#10;                if self.frame_timer &gt;= self.frame_duration:&#13;&#10;                    self.frame_timer -= self.frame_duration&#13;&#10;                    if self.frame_idx &lt; 1:&#13;&#10;                        self.frame_idx += 1&#13;&#10;                # 눌린 상태 유지 시 frame 1 고정&#13;&#10;                if self.mouse_down:&#13;&#10;                    self.frame_idx = max(self.frame_idx, 1)&#13;&#10;                else:&#13;&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#13;&#10;                    self.anim_state = 'up'&#13;&#10;                    self.frame_idx = 2&#13;&#10;                    self.frame_timer = 0.0&#13;&#10;            elif self.anim_state == 'up':&#13;&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#13;&#10;                if self.frame_timer &gt;= self.frame_duration:&#13;&#10;                    self.frame_timer -= self.frame_duration&#13;&#10;                    if self.frame_idx &lt; 6:&#13;&#10;                        self.frame_idx += 1&#13;&#10;                    if self.frame_idx &gt;= 6:&#13;&#10;                        self.anim_state = 'idle_up'&#13;&#10;                        self.frame_idx = 6&#13;&#10;            else:&#13;&#10;                # idle_up: 프레임 6 유지&#13;&#10;                self.frame_idx = 6&#13;&#10;&#13;&#10;    def draw(self, draw_x=None, draw_y=None):&#13;&#10;        if draw_x is None:&#13;&#10;            draw_x = self.x&#13;&#10;        if draw_y is None:&#13;&#10;            draw_y = self.y&#13;&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#13;&#10;        right_held = False&#13;&#10;        try:&#13;&#10;            mx = ctypes.c_int(0)&#13;&#10;            my = ctypes.c_int(0)&#13;&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#13;&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#13;&#10;            right_held = bool(state &amp; right_mask)&#13;&#10;        except Exception:&#13;&#10;            right_held = False&#13;&#10;&#13;&#10;        shield_block = False&#13;&#10;        draw_in_entity = False&#13;&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#13;&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#13;&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#13;&#10;&#13;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#13;&#10;        if right_held and self.shield_range_image is not None and not draw_in_entity:&#13;&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#13;&#10;            camera = None&#13;&#10;            try:&#13;&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#13;&#10;                import game_logic.play_mode as play&#13;&#10;                camera = getattr(play, 'camera', None)&#13;&#10;&#13;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#13;&#10;                if camera is None:&#13;&#10;                    import game_logic.lobby_mode as lobby&#13;&#10;                    camera = getattr(lobby, 'camera', None)&#13;&#10;            except Exception as ex:&#13;&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#13;&#10;                camera = None&#13;&#10;&#13;&#10;            # 마우스 화면 좌표 가져오기&#13;&#10;            mx2 = ctypes.c_int(0)&#13;&#10;            my2 = ctypes.c_int(0)&#13;&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#13;&#10;&#13;&#10;            canvas_h = get_canvas_height()&#13;&#10;            canvas_w = get_canvas_width()&#13;&#10;            mouse_screen_x = mx2.value&#13;&#10;            mouse_screen_y = canvas_h - my2.value&#13;&#10;&#13;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#13;&#10;            if camera is not None:&#13;&#10;                half_w = canvas_w // 2&#13;&#10;                half_h = canvas_h // 2&#13;&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#13;&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#13;&#10;            else:&#13;&#10;                mouse_world_x = mouse_screen_x&#13;&#10;                mouse_world_y = mouse_screen_y&#13;&#10;&#13;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#13;&#10;            dx = mouse_world_x - self.player.x&#13;&#10;            dy = mouse_world_y - self.player.y&#13;&#10;&#13;&#10;            # 각도 계산&#13;&#10;            angle = math.atan2(dy, dx)&#13;&#10;            base_offset = -math.pi / 2&#13;&#10;            theta = angle + base_offset&#13;&#10;&#13;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#13;&#10;            if camera is not None:&#13;&#10;                half_w = canvas_w // 2&#13;&#10;                half_h = canvas_h // 2&#13;&#10;                player_screen_x = self.player.x - camera.x + half_w&#13;&#10;                player_screen_y = self.player.y - camera.y + half_h&#13;&#10;            else:&#13;&#10;                player_screen_x = self.player.x&#13;&#10;                player_screen_y = self.player.y&#13;&#10;&#13;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#13;&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#13;&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#13;&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#13;&#10;&#13;&#10;            self.shield_range_image.clip_composite_draw(&#13;&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#13;&#10;                theta, '',&#13;&#10;                draw_x_shield, draw_y_shield,&#13;&#10;                self.shield_range_image.w * self.shield_range_scale,&#13;&#10;                self.shield_range_image.h * self.shield_range_scale&#13;&#10;            )&#13;&#10;            # 디버그 로그 - 카메라 정보 추가&#13;&#10;            # if camera is not None:&#13;&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#13;&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#13;&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#13;&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#13;&#10;            # else:&#13;&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#13;&#10;&#13;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#13;&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#13;&#10;            img = self.inv_frames[self.frame_idx]&#13;&#10;            w = img.w * self.scale_factor&#13;&#10;            h = img.h * self.scale_factor&#13;&#10;            ax, ay = self.inv_anchor&#13;&#10;            cx = self.x + (0.5 - ax) * w&#13;&#10;            cy = self.y + (0.5 - ay) * h&#13;&#10;            img.draw(cx, cy, w, h)&#13;&#10;        else:&#13;&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#13;&#10;&#13;&#10;    def handle_event(self, event):&#13;&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#13;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#13;&#10;        if not inv_open:&#13;&#10;            return&#13;&#10;        if not self.inv_frames:&#13;&#10;            return&#13;&#10;        # 마우스 좌클릭 이벤트 처리&#13;&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#13;&#10;            self.mouse_down = True&#13;&#10;            self.anim_state = 'down'&#13;&#10;            self.frame_idx = 0&#13;&#10;            self.frame_timer = 0.0&#13;&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#13;&#10;            self.mouse_down = False&#13;&#10;            # 업 애니메이션 시작 (2부터)&#13;&#10;            self.anim_state = 'up'&#13;&#10;            self.frame_idx = 2&#13;&#10;            self.frame_timer = 0.0" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/defeat_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/defeat_mode.py" />
              <option name="originalContent" value="import pico2d as p2&#10;from pico2d import draw_rectangle&#10;&#10;import game_framework&#10;&#10;# defeat_mode의 world 레이어 구조 (play_mode와 유사)&#10;world = {&#10;    'backgrounds': [],&#10;    'entities': [],  # player 등&#10;    'ui': [],&#10;}&#10;&#10;def enter(player):&#10;    &quot;&quot;&quot;패배 모드 진입. 기존 player 객체를 그대로 world에 보관.&quot;&quot;&quot;&#10;    print(&quot;[defeat_mode] enter() - player 객체 전달받음&quot;)&#10;    world['entities'].clear()&#10;    world['ui'].clear()&#10;    world['entities'].append(player)&#10;    player.x = p2.get_canvas_width() // 2&#10;    player.y = p2.get_canvas_height() // 2&#10;    BG = BGimage('resources/Texture_organize/UI/Stage_Loading/BlackBG.png')&#10;    world['backgrounds'].append(BG)&#10;&#10;&#10;&#10;def exit():&#10;    world['entities'].clear()&#10;    world['ui'].clear()&#10;&#10;def update():&#10;    # 필요시 player 등 업데이트&#10;    for layer in ['backgrounds', 'entities', 'ui']:&#10;        for o in world[layer]:&#10;            if hasattr(o, 'update'):&#10;                o.update()&#10;&#10;def draw():&#10;    try:&#10;        p2.clear_canvas()&#10;        # (원한다면 player 등 그리기)&#10;        for layer in ['backgrounds', 'entities', 'ui']:&#10;            for o in world[layer]:&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        o.draw()&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[defeat_mode] draw error in {layer}: {e}\033[0m&quot;)&#10;&#10;        # 화면 중앙에 &quot;패배&quot; 메시지 출력&#10;        canvas_w = p2.get_canvas_width()&#10;        canvas_h = p2.get_canvas_height()&#10;        center_x = canvas_w // 2&#10;        center_y = canvas_h // 1.25&#10;        # 폰트 로드 (한글 지원 폰트 우선)&#10;        try:&#10;            font = p2.load_font('resources/Fonts/pixelroborobo.otf', 80)&#10;        except Exception:&#10;            font = None&#10;        text = &quot;패배&quot;&#10;        font_size = 80&#10;        approx_width = int(len(text) * font_size * 1.0)&#10;&#10;        if font:&#10;            font.draw(center_x - approx_width // 2, center_y, text, (255, 80, 80))&#10;        else:&#10;            p2.draw_text(text, center_x - 40, center_y, (255, 80, 80))&#10;    except Exception as e:&#10;        print(f&quot;\033[91m[defeat_mode] draw() exception: {e}\033[0m&quot;)&#10;    p2.update_canvas()&#10;&#10;def handle_events():&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == p2.SDL_QUIT:&#10;            game_framework.quit()&#10;        elif e.type == p2.SDL_KEYDOWN:&#10;            if e.key == p2.SDLK_ESCAPE:&#10;                game_framework.quit()&#10;            # 필요시 엔터 등으로 타이틀로 복귀 등 추가 가능&#10;&#10;def pause():&#10;    pass&#10;&#10;def resume():&#10;    pass&#10;&#10;class BGimage:&#10;    &quot;&quot;&quot;패배 모드용 배경 이미지 클래스&quot;&quot;&quot;&#10;    def __init__(self, image_path):&#10;        try:&#10;            self.image = p2.load_image(image_path)&#10;        except Exception:&#10;            self.image = None&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def do(self):&#10;        pass&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_w = p2.get_canvas_width()&#10;            canvas_h = p2.get_canvas_height()&#10;            self.image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)" />
              <option name="updatedContent" value="import pico2d as p2&#10;from pico2d import draw_rectangle&#10;&#10;import game_framework&#10;&#10;# defeat_mode의 world 레이어 구조 (play_mode와 유사)&#10;world = {&#10;    'backgrounds': [],&#10;    'entities': [],  # player 등&#10;    'ui': [],&#10;}&#10;&#10;def enter(player):&#10;    &quot;&quot;&quot;패배 모드 진입. 기존 player 객체를 그대로 world에 보관.&quot;&quot;&quot;&#10;    print(&quot;[defeat_mode] enter() - player 객체 전달받음&quot;)&#10;    world['entities'].clear()&#10;    world['ui'].clear()&#10;    world['entities'].append(player)&#10;    player.x = p2.get_canvas_width() // 2&#10;    player.y = p2.get_canvas_height() // 2&#10;    BG = BGimage('resources/Texture_organize/UI/Stage_Loading/BlackBG.png')&#10;    world['backgrounds'].append(BG)&#10;&#10;&#10;&#10;def exit():&#10;    world['entities'].clear()&#10;    world['ui'].clear()&#10;&#10;def update():&#10;    # 필요시 player 등 업데이트&#10;    for layer in ['backgrounds', 'entities', 'ui']:&#10;        for o in world[layer]:&#10;            if hasattr(o, 'update'):&#10;                o.update()&#10;&#10;def draw():&#10;    try:&#10;        p2.clear_canvas()&#10;        # (원한다면 player 등 그리기)&#10;        for layer in ['backgrounds', 'entities', 'ui']:&#10;            for o in world[layer]:&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        o.draw()&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[defeat_mode] draw error in {layer}: {e}\033[0m&quot;)&#10;&#10;        # 화면 중앙에 &quot;패배&quot; 메시지 출력&#10;        canvas_w = p2.get_canvas_width()&#10;        canvas_h = p2.get_canvas_height()&#10;        center_x = canvas_w // 2&#10;        center_y = canvas_h // 1.25&#10;        # 폰트 로드 (한글 지원 폰트 우선)&#10;        try:&#10;            font = p2.load_font('resources/Fonts/pixelroborobo.otf', 80)&#10;        except Exception:&#10;            font = None&#10;        text = &quot;패배&quot;&#10;        font_size = 80&#10;        approx_width = int(len(text) * font_size * 1.0)&#10;&#10;        if font:&#10;            font.draw(center_x - approx_width // 2, center_y, text, (255, 80, 80))&#10;        else:&#10;            p2.draw_text(text, center_x - 40, center_y, (255, 80, 80))&#10;    except Exception as e:&#10;        print(f&quot;\033[91m[defeat_mode] draw() exception: {e}\033[0m&quot;)&#10;    p2.update_canvas()&#10;&#10;def handle_events():&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == p2.SDL_QUIT:&#10;            game_framework.quit()&#10;        elif e.type == p2.SDL_KEYDOWN:&#10;            if e.key == p2.SDLK_ESCAPE:&#10;                game_framework.quit()&#10;            # 필요시 엔터 등으로 타이틀로 복귀 등 추가 가능&#10;&#10;def pause():&#10;    pass&#10;&#10;def resume():&#10;    pass&#10;&#10;class BGimage:&#10;    &quot;&quot;&quot;패배 모드용 배경 이미지 클래스&quot;&quot;&quot;&#10;    def __init__(self, image_path):&#10;        try:&#10;            self.image = p2.load_image(image_path)&#10;        except Exception:&#10;            self.image = None&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def do(self):&#10;        pass&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_w = p2.get_canvas_width()&#10;            canvas_h = p2.get_canvas_height()&#10;            self.image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/equipment.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/equipment.py" />
              <option name="originalContent" value="import ctypes&#10;import math&#10;import os&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;from . import framework&#10;&#10;&#10;def get_mouse_world_position(player):&#10;    &quot;&quot;&quot;&#10;    마우스 화면 좌표를 월드 좌표로 변환하는 헬퍼 함수&#10;    카메라 스크롤을 고려하여 정확한 월드 좌표를 반환&#10;&#10;    Args:&#10;        player: 플레이어 객체 (world 참조를 통해 camera 접근)&#10;&#10;    Returns:&#10;        tuple: (world_x, world_y) 월드 좌표계에서의 마우스 위치&#10;    &quot;&quot;&quot;&#10;    # 마우스 화면 좌표 가져오기&#10;    mx = ctypes.c_int(0)&#10;    my = ctypes.c_int(0)&#10;    SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;&#10;    # pico2d 좌표계로 변환 (Y축 반전)&#10;    canvas_h = get_canvas_height()&#10;    canvas_w = get_canvas_width()&#10;    mouse_screen_x = mx.value&#10;    mouse_screen_y = canvas_h - my.value&#10;&#10;    # 카메라 오프셋 적용하여 월드 좌표로 변환&#10;    # play_mode와 lobby_mode 모두에서 카메라 가져오기&#10;    camera = None&#10;    try:&#10;        # 먼저 play_mode에서 카메라 가져오기 시도&#10;        import game_logic.play_mode as play&#10;        camera = getattr(play, 'camera', None)&#10;&#10;        # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;        if camera is None:&#10;            import game_logic.lobby_mode as lobby&#10;            camera = getattr(lobby, 'camera', None)&#10;    except Exception as ex:&#10;        # 카메라 가져오기 실패 시 None 유지&#10;        pass&#10;&#10;    if camera is not None:&#10;        # 화면 좌표 -&gt; 월드 좌표 변환&#10;        # camera.apply()의 역연산: world_pos = screen_pos - (screen_center - camera_pos)&#10;        half_w = canvas_w // 2&#10;        half_h = canvas_h // 2&#10;        world_x = mouse_screen_x - half_w + camera.x&#10;        world_y = mouse_screen_y - half_h + camera.y&#10;    else:&#10;        # 카메라가 없으면 화면 좌표 그대로 사용&#10;        world_x = mouse_screen_x&#10;        world_y = mouse_screen_y&#10;&#10;    return world_x, world_y&#10;&#10;&#10;# 방패 범위 이펙트 클래스&#10;class ShieldRangeEffect:&#10;    &quot;&quot;&quot;&#10;    방패 범위 표시 이펙트 - world['effects_front']에서 관리&#10;    우클릭으로 방패를 전개할 때 표시되는 범위 이펙트&#10;&#10;    주의: 이 클래스는 x, y 속성을 가지지 않습니다.&#10;    lobby_mode.py의 draw 루프에서 특별 처리가 필요합니다.&#10;    &quot;&quot;&quot;&#10;    _range_image = None  # 클래스 변수로 이미지 공유&#10;&#10;    def __init__(self, player, shield):&#10;        # 이미지 최초 1회만 로드 (클래스 변수 사용)&#10;        if ShieldRangeEffect._range_image is None:&#10;            range_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'shieldRange.png')&#10;            try:&#10;                ShieldRangeEffect._range_image = load_image(range_path)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load shield range image: {ex}\033[0m&quot;)&#10;                ShieldRangeEffect._range_image = None&#10;&#10;        self.player = player&#10;        self.shield = shield&#10;        self.range_scale = 4.0  # 방패 범위 이펙트 크기 조정&#10;&#10;        # x, y 속성 제거: 카메라 적용을 위해 플레이어 참조만 유지&#10;        # draw()에서 player의 카메라 적용된 좌표를 직접 받아서 사용&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        매 프레임마다 호출되어 이펙트 상태 업데이트&#10;        방패가 blocking 상태가 아니면 False를 반환하여 제거됨&#10;        &quot;&quot;&quot;&#10;        # 방패의 blocking 상태가 해제되면 이펙트도 제거&#10;        if not self.shield.blocking:&#10;            return False&#10;        # x, y 동기화 제거: player 참조만 유지&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        방패 범위 이펙트 그리기&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 플레이어의 화면 X 좌표&#10;            draw_y: 카메라가 적용된 플레이어의 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if ShieldRangeEffect._range_image is None:&#10;            return&#10;&#10;        # 방패 범위 각도 계산 (마우스 방향 기준, -90도 오프셋 적용)&#10;        base_offset = -math.pi / 2&#10;        theta = self.shield.range_angle + base_offset&#10;&#10;        # 카메라가 적용된 draw_x, draw_y를 기준으로 방패 범위 이펙트 그리기&#10;        ShieldRangeEffect._range_image.clip_composite_draw(&#10;            0, 0, ShieldRangeEffect._range_image.w, ShieldRangeEffect._range_image.h,&#10;            theta, '',&#10;            draw_x, draw_y,&#10;            ShieldRangeEffect._range_image.w * self.range_scale,&#10;            ShieldRangeEffect._range_image.h * self.range_scale&#10;        )&#10;&#10;&#10;class Weapon:&#10;    &quot;&quot;&quot;기본 무기 클래스&quot;&quot;&quot;&#10;    def __init__(self, player, weapon_type, image_path, render_layer='back', scale=3.0):&#10;        self.player = player&#10;        self.weapon_type = weapon_type  # 'sword', 'shield', 'wand' 등&#10;        self.render_layer = render_layer  # 'back' 또는 'front'&#10;        self.scale_factor = scale&#10;&#10;        # 이미지 로드&#10;        self.image = load_image(image_path)&#10;&#10;        # 무기 위치 오프셋 (플레이어 중심 기준)&#10;        self.offset_x = 20  # 기본 오프셋&#10;        self.offset_y = 0&#10;&#10;        # 회전 각도&#10;        self.angle = 0  # 라디안&#10;&#10;        # 공격 상태&#10;        self.is_attacking = False&#10;        self.attack_timer = 0.0&#10;        self.attack_duration = 0.3  # 실제 공격 애니메이션 시간&#10;        self.attack_recovery = 0.15  # 공격 후 딜레이 (후딜레이)&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery  # 총 공격 시간&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치를 기준으로 무기 각도 계산 (카메라 보정 적용)&quot;&quot;&quot;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#10;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;        dx = world_mouse_x - self.player.x&#10;        dy = world_mouse_y - self.player.y&#10;&#10;        # 각도 계산 (라디안)&#10;        self.angle = math.atan2(dy, dx)&#10;&#10;        # 공격 타이머 업데이트&#10;        if self.is_attacking:&#10;            dt = framework.get_delta_time()&#10;            self.attack_timer += dt&#10;            if self.attack_timer &gt;= self.total_attack_time:&#10;                self.is_attacking = False&#10;                self.attack_timer = 0.0&#10;&#10;    def attack(self):&#10;        &quot;&quot;&quot;공격 시작&quot;&quot;&quot;&#10;        if not self.is_attacking:&#10;            self.is_attacking = True&#10;            self.attack_timer = 0.0&#10;            print(f&quot;{self.weapon_type} 공격!&quot;)&#10;            return True&#10;        return False&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;무기를 회전시켜서 그리기&quot;&quot;&quot;&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        # 무기 위치 계산 (카메라 적용된 플레이어 위치 기준)&#10;        weapon_x = draw_x + self.offset_x * math.cos(self.angle)&#10;        weapon_y = draw_y + self.offset_y + self.offset_x * math.sin(self.angle)&#10;&#10;        # 좌우 반전 결정&#10;        flip = 'h' if self.player.face_dir == -1 else ''&#10;&#10;        # 회전된 무기 그리기&#10;        self.image.clip_composite_draw(&#10;            0, 0, self.image.w, self.image.h,&#10;            self.angle, flip,&#10;            weapon_x, weapon_y,&#10;            self.image.w * self.scale_factor,&#10;            self.image.h * self.scale_factor&#10;        )&#10;&#10;&#10;class Shield(Weapon):&#10;    &quot;&quot;&quot;방패 클래스 (항상 캐릭터 앞에 그려짐)&quot;&quot;&quot;&#10;    def __init__(self, player, image_path, scale=3.0):&#10;        super().__init__(player, 'shield', image_path, render_layer='front', scale=scale)&#10;        self.offset_x = -10  # 기본 X 오프셋(사용 안 함)&#10;        self.offset_y = -10  # Y 오프셋 유지&#10;&#10;        # 우클릭 방패 전개 상태&#10;        self.blocking = False&#10;        self.range_angle = 0.0&#10;&#10;        # 방패 범위 이펙트 참조 (world['effects_front']에서 관리)&#10;        self.range_effect = None&#10;&#10;        # 바라보는 방향으로 방패를 살짝 앞으로 이동시키는 오프셋(픽셀)&#10;        self.forward_offset = 18&#10;&#10;    def start_block(self):&#10;        self.blocking = True&#10;&#10;    def end_block(self):&#10;        self.blocking = False&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;방패: 우클릭 유지 시 각도를 커서 방향으로 갱신 (카메라 보정 적용)&quot;&quot;&quot;&#10;        # 인벤토리가 열려 있으면 방패 입력/전개 무시&#10;        if getattr(self.player, 'inventory_open', False):&#10;            self.blocking = False&#10;            if self.is_attacking:&#10;                dt = framework.get_delta_time()&#10;                self.attack_timer += dt&#10;                if self.attack_timer &gt;= self.attack_duration:&#10;                    self.is_attacking = False&#10;                    self.attack_timer = 0.0&#10;            return&#10;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#10;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;        dx = world_mouse_x - self.player.x&#10;        dy = world_mouse_y - self.player.y&#10;&#10;        # 방패 범위 각도 계산 (라디안)&#10;        self.range_angle = math.atan2(dy, dx)&#10;&#10;        # 이전 blocking 상태 저장&#10;        was_blocking = self.blocking&#10;&#10;        # 프레임별 우클릭 유지 여부를 직접 폴링하여 blocking 동기화 (이벤트 누락 대비)&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        try:&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            self.blocking = bool(state &amp; right_mask)&#10;        except Exception:&#10;            pass&#10;&#10;        # blocking 상태가 변경되었을 때 이펙트 생성/제거&#10;        if self.blocking and not was_blocking:&#10;            # blocking 시작: 이펙트 생성&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#10;                self.range_effect = ShieldRangeEffect(self.player, self)&#10;                self.player.world['effects_front'].append(self.range_effect)&#10;        elif not self.blocking and was_blocking:&#10;            # blocking 종료: 이펙트는 자동으로 제거됨 (update에서 False 반환)&#10;            self.range_effect = None&#10;&#10;        # 기존 공격 타이머 로직 유지(필요 시)&#10;        if self.is_attacking:&#10;            dt = framework.get_delta_time()&#10;            self.attack_timer += dt&#10;            if self.attack_timer &gt;= self.attack_duration:&#10;                self.is_attacking = False&#10;                self.attack_timer = 0.0&#10;&#10;    def attack(self):&#10;        &quot;&quot;&quot;방패는 막기 동작 (현재는 사용하지 않음)&quot;&quot;&quot;&#10;        if not self.is_attacking:&#10;            self.is_attacking = True&#10;            self.attack_timer = 0.0&#10;            print(f&quot;방패로 막기!&quot;)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;방패 본체 그리기 (범위 이미지는 world['effects_front']에서 관리)&quot;&quot;&quot;&#10;        # 방패 본체는 회전 없이 플레이어 앞에 고정&#10;        flip = 'h' if self.player.face_dir == -1 else ''&#10;        # 전개 중일 때만 앞으로 이동, 아니면 기존의 작은 좌우 오프셋 유지&#10;        if self.blocking:&#10;            local_offset_x = self.forward_offset if self.player.face_dir == 1 else -self.forward_offset&#10;        else:&#10;            local_offset_x = 10 if self.player.face_dir == -1 else -10&#10;&#10;        # 바라보는 방향에 따른 방패 로컬 오프셋 적용&#10;        weapon_x = draw_x + local_offset_x&#10;        weapon_y = draw_y + self.offset_y&#10;&#10;        self.image.clip_composite_draw(&#10;            0, 0, self.image.w, self.image.h,&#10;            0, flip,&#10;            weapon_x, weapon_y,&#10;            self.image.w * self.scale_factor,&#10;            self.image.h * self.scale_factor&#10;        )&#10;&#10;    def check_projectile_block(self, projectile):&#10;        &quot;&quot;&quot;투사체가 방패에 막혔는지 확인&#10;&#10;        Args:&#10;            projectile: 투사체 객체&#10;&#10;        Returns:&#10;            bool: 방패에 막혔으면 True, 아니면 False&#10;        &quot;&quot;&quot;&#10;        # 방패를 전개하지 않았으면 막을 수 없음&#10;        if not self.blocking:&#10;            return False&#10;&#10;        # print(f&quot;[Shield] 방패 전개 중, 투사체 충돌 체크 시작&quot;)&#10;&#10;        # 방패 중심 위치 계산&#10;        if self.blocking:&#10;            local_offset_x = self.forward_offset if self.player.face_dir == 1 else -self.forward_offset&#10;        else:&#10;            local_offset_x = 10 if self.player.face_dir == -1 else -10&#10;        shield_x = self.player.x + local_offset_x&#10;        shield_y = self.player.y + self.offset_y&#10;&#10;        # 방패 크기 (이미지 크기 * scale) - 충돌 범위를 매우 넓게&#10;        shield_width = self.image.w * self.scale_factor * 2.5  # 3배로 확대&#10;        shield_height = self.image.h * self.scale_factor * 2.5&#10;&#10;        # 투사체 크기&#10;        if hasattr(projectile, 'get_collision_box'):&#10;            proj_width, proj_height = projectile.get_collision_box()&#10;        else:&#10;            proj_width = 30&#10;            proj_height = 30&#10;&#10;        # AABB 충돌 감지&#10;        shield_left = shield_x - shield_width / 2&#10;        shield_right = shield_x + shield_width / 2&#10;        shield_bottom = shield_y - shield_height / 2&#10;        shield_top = shield_y + shield_height / 2&#10;&#10;        proj_left = projectile.x - proj_width / 2&#10;        proj_right = projectile.x + proj_width / 2&#10;        proj_bottom = projectile.y - proj_height / 2&#10;        proj_top = projectile.y + proj_height / 2&#10;&#10;        # 충돌 검사&#10;        if (shield_left &lt; proj_right and shield_right &gt; proj_left and&#10;            shield_bottom &lt; proj_top and shield_top &gt; proj_bottom):&#10;&#10;            print(f&quot;[Shield] AABB 충돌 감지!&quot;)&#10;&#10;            # 투사체가 플레이어 방향으로 날아오는지 확인&#10;            # 투사체에서 플레이어로 향하는 벡터 (투사체의 이동 방향과 유사)&#10;            proj_to_player_x = self.player.x - projectile.x&#10;            proj_to_player_y = self.player.y - projectile.y&#10;&#10;            # 투사체의 속도 벡터 확인 (투사체가 플레이어 쪽으로 오고 있는지)&#10;            if hasattr(projectile, 'dx') and hasattr(projectile, 'dy'):&#10;                # 투사체의 이동 방향과 플레이어 방향이 같은지 확인&#10;                dot_product = projectile.dx * proj_to_player_x + projectile.dy * proj_to_player_y&#10;                if dot_product &lt; 0:&#10;                    # 투사체가 플레이어에게서 멀어지고 있음 (이미 지나침)&#10;                    print(f&quot;[Shield] 투사체가 플레이어에게서 멀어지고 있음 - 방어 실패&quot;)&#10;                    return False&#10;&#10;            # 방어 이펙트 생성 (투사체 위치에 생성)&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#10;                try:&#10;                    from .guard_fx import GuardFX&#10;                    # 투사체(공격자) 위치에 이펙트 생성&#10;                    guard_fx = GuardFX(projectile.x, projectile.y, scale=self.scale_factor)&#10;                    self.player.world['effects_front'].append(guard_fx)&#10;                    print(f&quot;[Shield] 방어 이펙트 생성 완료 at ({int(projectile.x)}, {int(projectile.y)})&quot;)&#10;                except Exception as ex:&#10;                    print(f&quot;[Shield] 방어 이펙트 생성 실패: {ex}&quot;)&#10;&#10;            # 플레이어 넉백 (부드럽게)&#10;            knockback_strength = 100  # 픽셀 (초기 속도 기반)&#10;            distance = math.sqrt(proj_to_player_x**2 + proj_to_player_y**2)&#10;            if distance &gt; 0:&#10;                # 넉백 방향 계산 (투사체에서 멀어지는 방향)&#10;                self.player.knockback_dx = proj_to_player_x / distance&#10;                self.player.knockback_dy = proj_to_player_y / distance&#10;                # 넉백 속도 및 지속시간 설정&#10;                self.player.knockback_speed = knockback_strength&#10;                self.player.knockback_duration = 0.2  # 0.2초 동안 넉백&#10;                self.player.knockback_timer = 0.0  # 타이머 초기화&#10;                print(f&quot;[Shield] 방어 이펙트에 의한 넉백 발생: 방향=({self.player.knockback_dx:.2f}, {self.player.knockback_dy:.2f}), 속도={knockback_strength}&quot;)&#10;&#10;            return True&#10;&#10;        # print(f&quot;[Shield] 충돌 감지 안됨&quot;)&#10;        return False&#10;&#10;&#10;class Sword(Weapon):&#10;    &quot;&quot;&quot;검 클래스 (항상 캐릭터 뒤에 그려짐)&quot;&quot;&quot;&#10;    def __init__(self, player, image_path, scale=3.0):&#10;        super().__init__(player, 'sword', image_path, render_layer='back', scale=scale)&#10;        self.offset_x = 15  # 검은 좀 더 멀리&#10;        self.offset_y = 8 # 검의 기본 Y 오프셋&#10;&#10;        # 스테이지별(콤보) 시간 설정 (스테이지1 = 기본, 스테이지2 = 콤보)&#10;        self.stage = 1&#10;        # 기본(보정 전) 시간값 저장&#10;        self.stage1_attack_duration_base = 0.2  # 공격 모션 시간 (1스테이지)&#10;        self.stage1_attack_recovery_base = 0.3  # 후딜 (1스테이지)&#10;        self.stage2_attack_duration_base = 0.18  # 공격 모션 시간 (콤보)&#10;        self.stage2_attack_recovery_base = 0.35  # 후딜 (콤보)&#10;        self.stage3_attack_duration_base = 0.28  # 3스테이지 모션 시간&#10;        self.stage3_attack_recovery_base = 0.4   # 3스테이지 후딜&#10;&#10;        # 현재 활성화된 공격 시간 값 (초기값은 1스테이지 보정 적용)&#10;        self.attack_duration = self.stage1_attack_duration_base&#10;        self.attack_recovery = self.stage1_attack_recovery_base&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery&#10;&#10;        self.base_angle_offset = math.radians(25)  # 기본 각도 오프셋&#10;&#10;        # 공격 모션 관련 변수&#10;        self.attack_progress = 0.0  # 0.0 ~ 1.0&#10;        self.attack_angle_range = -math.radians(205)  # 0도 ~ 270도 회전 (검 자체 회전)&#10;        self.y_offset_down = -50  # progress 0.5까지 내려갈 y 오프셋&#10;&#10;        # 자전 및 공전 각도 범위 추가&#10;        self.rotation_angle_range = -math.radians(270)  # 자전: 0도 ~ 270도&#10;        self.orbit_angle_range = -math.radians(205)  # 공전: 0도 ~ 205도&#10;&#10;        # 콤보 관련 플래그&#10;        self.combo_queued = False  # 후딜 중에 콤보 입력이 들어왔는지&#10;&#10;    def _apply_speed(self, stage: int):&#10;        &quot;&quot;&quot;플레이어 stats.attack_speed로 해당 스테이지 시간값을 보정한다.&quot;&quot;&quot;&#10;        speed = 1.0&#10;        try:&#10;            if hasattr(self.player, 'stats'):&#10;                speed = max(0.1, float(self.player.stats.get('attack_speed')))&#10;        except Exception:&#10;            speed = 1.0&#10;        if stage == 1:&#10;            self.attack_duration = self.stage1_attack_duration_base / speed&#10;            self.attack_recovery = self.stage1_attack_recovery_base / speed&#10;        elif stage == 2:&#10;            self.attack_duration = self.stage2_attack_duration_base / speed&#10;            self.attack_recovery = self.stage2_attack_recovery_base / speed&#10;        elif stage == 3:&#10;            self.attack_duration = self.stage3_attack_duration_base / speed&#10;            self.attack_recovery = self.stage3_attack_recovery_base / speed&#10;        else:&#10;            pass&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치를 기준으로 무기 각도 계산 (카메라 보정 적용)&quot;&quot;&quot;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#10;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;        dx = world_mouse_x - self.player.x&#10;        dy = world_mouse_y - self.player.y&#10;&#10;        # 각도 계산 (라디안)&#10;        self.angle = math.atan2(dy, dx)&#10;&#10;        # 공격 타이머 업데이트&#10;        if self.is_attacking:&#10;            dt = framework.get_delta_time()&#10;            self.attack_timer += dt&#10;&#10;            # 공격 progress 계산 (0.0 ~ 1.0)&#10;            if self.attack_timer &lt; self.attack_duration:&#10;                self.attack_progress = self.attack_timer / self.attack_duration&#10;            else:&#10;                self.attack_progress = 1.0&#10;&#10;            # 스테이지별 종료 처리&#10;            if self.attack_timer &gt;= self.total_attack_time:&#10;                # 3스테이지 종료 처리&#10;                if self.stage == 3:&#10;                    self.is_attacking = False&#10;                    self.attack_timer = 0.0&#10;                    self.attack_progress = 0.0&#10;                    self.stage = 1&#10;                    # 기본 스테이지 시간 복원&#10;                    self.attack_duration = self.stage1_attack_duration_base&#10;                    self.attack_recovery = self.stage1_attack_recovery_base&#10;                    self.total_attack_time = self.attack_duration + self.attack_recovery&#10;                    self.combo_queued = False&#10;                # 2스테이지 종료 처리&#10;                elif self.stage == 2:&#10;                    self.is_attacking = False&#10;                    self.attack_timer = 0.0&#10;                    self.attack_progress = 0.0&#10;                    self.stage = 1&#10;                    self.attack_duration = self.stage1_attack_duration_base&#10;                    self.attack_recovery = self.stage1_attack_recovery_base&#10;                    self.total_attack_time = self.attack_duration + self.attack_recovery&#10;                    self.combo_queued = False&#10;                else:&#10;                    # 1스테이지 종료&#10;                    self.is_attacking = False&#10;                    self.attack_timer = 0.0&#10;                    self.attack_progress = 0.0&#10;                    self.combo_queued = False&#10;&#10;    def attack(self):&#10;        &quot;&quot;&quot;공격 시작&#10;&#10;        동작 요약:&#10;        - 비공격 중이면 1스테이지 공격 시작&#10;        - 공격 중(후딜 영역)에 클릭하면 즉시 2스테이지(콤보) 공격으로 전환&#10;        &quot;&quot;&quot;&#10;        # 비공격 상태에서 시작&#10;        if not self.is_attacking:&#10;            self.is_attacking = True&#10;            self.attack_timer = 0.0&#10;            self.attack_progress = 0.0&#10;            self.stage = 1&#10;            # 스탯 보정 적용&#10;            self._apply_speed(1)&#10;            print(f&quot;{self.weapon_type} 공격! (stage 1)&quot;)&#10;&#10;            # 공격 이펙트 생성&#10;            from .player import VFX_Tier1_Sword_Swing&#10;&#10;            angle_deg = math.degrees(self.angle) % 360&#10;            if 90 &lt; angle_deg &lt; 270:  # 왼쪽 영역&#10;                flip = 'vh'&#10;            else:&#10;                flip = 'h'&#10;&#10;            attack_vfx = VFX_Tier1_Sword_Swing(&#10;                self.player.x,&#10;                self.player.y,&#10;                self.angle,&#10;                flip,&#10;                scale=4.5,&#10;                range_factor=60,&#10;                variant=1,&#10;                owner=self.player&#10;            )&#10;            # world['effects_front']에 추가 (없으면 player에 추가)&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#10;                self.player.world['effects_front'].append(attack_vfx)&#10;            else:&#10;                self.player.attack_effects.append(attack_vfx)&#10;&#10;            return True&#10;&#10;        # 공격 중일 때: 후딜 중에 콤보 입력을 받아 단계별 전환&#10;        else:&#10;            # 1스테이지 후딜에서 클릭 -&gt; 2스테이지&#10;            if self.attack_timer &gt;= self.attack_duration and self.stage == 1:&#10;                # 즉시 콤보(2스테이지)로 전환&#10;                self.stage = 2&#10;                self.attack_timer = 0.0&#10;                self.attack_progress = 0.0&#10;                # 스탯 보정 적용&#10;                self._apply_speed(2)&#10;                self.combo_queued = True&#10;                print(f&quot;{self.weapon_type} 콤보! (stage 2)&quot;)&#10;&#10;                # 콤보용 이펙트 생성&#10;                from .player import VFX_Tier1_Sword_Swing&#10;&#10;                angle_deg = math.degrees(self.angle) % 360&#10;                flip = 'vh' if 90 &lt; angle_deg &lt; 270 else 'h'&#10;&#10;                attack_vfx = VFX_Tier1_Sword_Swing(&#10;                    self.player.x,&#10;                    self.player.y,&#10;                    self.angle,&#10;                    flip,&#10;                    scale=5.5,&#10;                    range_factor=70,&#10;                    variant=2&#10;                )&#10;                # world['effects_front']에 추가 (없으면 player에 추가)&#10;                if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#10;                    self.player.world['effects_front'].append(attack_vfx)&#10;                else:&#10;                    self.player.attack_effects.append(attack_vfx)&#10;&#10;                return True&#10;&#10;            # 2스테이지 후딜에서 클릭 -&gt; 3스테이지 (헤비 스윙)&#10;            if self.attack_timer &gt;= self.attack_duration and self.stage == 2:&#10;                self.stage = 3&#10;                self.attack_timer = 0.0&#10;                self.attack_progress = 0.0&#10;                # 스탯 보정 적용&#10;                self._apply_speed(3)&#10;                self.combo_queued = True&#10;                print(f&quot;{self.weapon_type} 헤비 스윙! (stage 3)&quot;)&#10;&#10;                # 3스테이지 전용 이펙트 생성 (variant=3)&#10;                from .player import VFX_Tier1_Sword_Swing&#10;&#10;                angle_deg = math.degrees(self.angle) % 360&#10;                flip = 'vh' if 90 &lt; angle_deg &lt; 270 else 'h'&#10;&#10;                attack_vfx = VFX_Tier1_Sword_Swing(&#10;                    self.player.x,&#10;                    self.player.y,&#10;                    self.angle,&#10;                    flip,&#10;                    scale=6.0,&#10;                    range_factor=90,&#10;                    variant=3,&#10;                    owner=self.player&#10;                )&#10;                # world['effects_front']에 추가 (없으면 player에 추가)&#10;                if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#10;                    self.player.world['effects_front'].append(attack_vfx)&#10;                else:&#10;                    self.player.attack_effects.append(attack_vfx)&#10;&#10;                return True&#10;&#10;            # 그 외(공격 중이지만 아직 공격 모션 중이거나 이미 최고 단계면 무시)&#10;            return False&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        검을 회전시켜서 그리기 - 검 자체를 중심으로 회전 + 캐릭터 중심으로 공전&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 플레이어의 화면 X 좌표&#10;            draw_y: 카메라가 적용된 플레이어의 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        # ========== 공격 모션에 따른 각도 및 오프셋 계산 ==========&#10;        sword_rotation = 0.0          # 검 자체의 회전 각도 (자전)&#10;        orbit_angle_offset = 0.0      # 캐릭터 중심 기준 공전 각도 오프셋&#10;        y_offset_modifier = 0.0       # Y축 위치 오프셋 (공격 시 아래로 내려감)&#10;&#10;        if self.is_attacking:&#10;            if self.attack_timer &lt; self.attack_duration:&#10;                # 공격 모션 중 (0 ~ attack_duration)&#10;                sword_rotation = self.rotation_angle_range * self.attack_progress  # 자전 각도&#10;                orbit_angle_offset = self.orbit_angle_range * self.attack_progress  # 공전 각도&#10;                # Y축 오프셋: 공격 시 검을 아래로 내림&#10;                y_offset_modifier = -3 * self.offset_y * self.attack_progress&#10;            else:&#10;                # 후딜레이 중 (attack_duration ~ total_attack_time)&#10;                sword_rotation = self.rotation_angle_range      # 자전 최대 각도 유지&#10;                orbit_angle_offset = self.orbit_angle_range    # 공전 최대 각도 유지&#10;                # Y축 오프셋: 후딜레이 동안 최대 아래 위치 유지&#10;                y_offset_modifier = -3 * self.offset_y&#10;&#10;        # ========== 2스테이지(콤보) 시 자전 방향 반전 ==========&#10;        # 콤보 공격 시 검이 반대 방향으로 회전하여 자연스러운 연계 공격 연출&#10;        invert_rotation = (getattr(self, 'stage', 1) == 2 and self.attack_timer &lt; self.attack_duration)&#10;        if invert_rotation:&#10;            sword_rotation = -sword_rotation&#10;&#10;        # ========== 검의 기본 각도 오프셋 ==========&#10;        base_offset = self.base_angle_offset&#10;&#10;        # ========== 마우스 위치에 따른 검의 방향 결정 ==========&#10;        angle_deg = math.degrees(self.angle) % 360&#10;&#10;        # 마우스가 왼쪽/오른쪽에 있는지에 따라 검의 위치와 반전 방향 결정&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽 영역&#10;            flip = 'v'  # 수직 반전&#10;            # 왼쪽: 공전 각도를 빼서 위치 계산&#10;            position_angle = self.angle - orbit_angle_offset&#10;            # 왼쪽: 자전 각도를 빼서 최종 각도 계산&#10;            final_angle = position_angle - sword_rotation&#10;        else:  # 오른쪽 영역&#10;            flip = ''&#10;            # 오른쪽: 공전 각도를 더해서 위치 계산&#10;            position_angle = self.angle + orbit_angle_offset&#10;            # 오른쪽: 자전 각도를 더해서 최종 각도 계산&#10;            final_angle = position_angle + sword_rotation&#10;&#10;        # ========== 검의 실제 화면 위치 계산 (카메라 적용 좌표 기준) ==========&#10;        # draw_x, draw_y는 이미 카메라가 적용된 화면 좌표이므로, 이를 기준으로 offset 적용&#10;        weapon_x = draw_x + self.offset_x * math.cos(position_angle)&#10;        weapon_y = draw_y + self.offset_y + self.offset_x * math.sin(position_angle) + y_offset_modifier&#10;&#10;        # ========== 검 이미지 그리기 ==========&#10;        self.image.clip_composite_draw(&#10;            0, 0, self.image.w, self.image.h,&#10;            final_angle + base_offset, flip,&#10;            weapon_x, weapon_y,&#10;            self.image.w * self.scale_factor,&#10;            self.image.h * self.scale_factor&#10;        )&#10;&#10;&#10;class EquipmentManager:&#10;    &quot;&quot;&quot;장비를 관리하는 매니저 클래스&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.back_equipment = []   # 캐릭터 뒤에 그려질 장비 (검 등)&#10;        self.front_equipment = []  # 캐릭터 앞에 그려질 장비 (방패 등)&#10;&#10;    def equip(self, equipment):&#10;        &quot;&quot;&quot;장비 장착&quot;&quot;&quot;&#10;        if equipment.render_layer == 'back':&#10;            self.back_equipment.append(equipment)&#10;        elif equipment.render_layer == 'front':&#10;            self.front_equipment.append(equipment)&#10;&#10;    def unequip(self, equipment):&#10;        &quot;&quot;&quot;장비 해제&quot;&quot;&quot;&#10;        if equipment in self.back_equipment:&#10;            self.back_equipment.remove(equipment)&#10;        if equipment in self.front_equipment:&#10;            self.front_equipment.remove(equipment)&#10;&#10;    def unequip_all(self):&#10;        &quot;&quot;&quot;모든 장비 해제&quot;&quot;&quot;&#10;        self.back_equipment.clear()&#10;        self.front_equipment.clear()&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;모든 장비 업데이트&quot;&quot;&quot;&#10;        for equipment in self.back_equipment + self.front_equipment:&#10;            equipment.update()&#10;&#10;    def handle_event(self, event):&#10;        &quot;&quot;&quot;장비 이벤트 처리 (좌클릭: 공격, 우클릭: 방패 전개 표시)&quot;&quot;&quot;&#10;        # 마우스 좌클릭 시 공격(검)&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            for equipment in self.back_equipment:&#10;                equipment.attack()&#10;&#10;        # 마우스 우클릭: 방패 범위 표시 시작/종료&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_RIGHT:&#10;            # 디버그: 우클릭 다운 수신&#10;            try:&#10;                print('[Shield] RIGHT DOWN')&#10;            except Exception:&#10;                pass&#10;            for equipment in self.front_equipment:&#10;                if isinstance(equipment, Shield):&#10;                    equipment.start_block()&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_RIGHT:&#10;            # 디버그: 우클릭 업 수신&#10;            try:&#10;                print('[Shield] RIGHT UP')&#10;            except Exception:&#10;                pass&#10;            for equipment in self.front_equipment:&#10;                if isinstance(equipment, Shield):&#10;                    equipment.end_block()&#10;&#10;    def draw_back(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;캐릭터 뒤에 그려질 장비들&quot;&quot;&quot;&#10;        for equipment in self.back_equipment:&#10;            equipment.draw(draw_x, draw_y)&#10;&#10;    def draw_front(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;캐릭터 앞에 그려질 장비들&quot;&quot;&quot;&#10;        for equipment in self.front_equipment:&#10;            equipment.draw(draw_x, draw_y)&#10;" />
              <option name="updatedContent" value="import ctypes&#13;&#10;import math&#13;&#10;import os&#13;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#13;&#10;from sdl2 import SDL_GetMouseState, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#13;&#10;from . import framework&#13;&#10;&#13;&#10;&#13;&#10;def get_mouse_world_position(player):&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    마우스 화면 좌표를 월드 좌표로 변환하는 헬퍼 함수&#13;&#10;    카메라 스크롤을 고려하여 정확한 월드 좌표를 반환&#13;&#10;&#13;&#10;    Args:&#13;&#10;        player: 플레이어 객체 (world 참조를 통해 camera 접근)&#13;&#10;&#13;&#10;    Returns:&#13;&#10;        tuple: (world_x, world_y) 월드 좌표계에서의 마우스 위치&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    # 마우스 화면 좌표 가져오기&#13;&#10;    mx = ctypes.c_int(0)&#13;&#10;    my = ctypes.c_int(0)&#13;&#10;    SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#13;&#10;&#13;&#10;    # pico2d 좌표계로 변환 (Y축 반전)&#13;&#10;    canvas_h = get_canvas_height()&#13;&#10;    canvas_w = get_canvas_width()&#13;&#10;    mouse_screen_x = mx.value&#13;&#10;    mouse_screen_y = canvas_h - my.value&#13;&#10;&#13;&#10;    # 카메라 오프셋 적용하여 월드 좌표로 변환&#13;&#10;    # play_mode와 lobby_mode 모두에서 카메라 가져오기&#13;&#10;    camera = None&#13;&#10;    try:&#13;&#10;        # 먼저 play_mode에서 카메라 가져오기 시도&#13;&#10;        import game_logic.play_mode as play&#13;&#10;        camera = getattr(play, 'camera', None)&#13;&#10;&#13;&#10;        # play_mode 카메라가 없으면 lobby_mode에서 시도&#13;&#10;        if camera is None:&#13;&#10;            import game_logic.lobby_mode as lobby&#13;&#10;            camera = getattr(lobby, 'camera', None)&#13;&#10;    except Exception as ex:&#13;&#10;        # 카메라 가져오기 실패 시 None 유지&#13;&#10;        pass&#13;&#10;&#13;&#10;    if camera is not None:&#13;&#10;        # 화면 좌표 -&gt; 월드 좌표 변환&#13;&#10;        # camera.apply()의 역연산: world_pos = screen_pos - (screen_center - camera_pos)&#13;&#10;        half_w = canvas_w // 2&#13;&#10;        half_h = canvas_h // 2&#13;&#10;        world_x = mouse_screen_x - half_w + camera.x&#13;&#10;        world_y = mouse_screen_y - half_h + camera.y&#13;&#10;    else:&#13;&#10;        # 카메라가 없으면 화면 좌표 그대로 사용&#13;&#10;        world_x = mouse_screen_x&#13;&#10;        world_y = mouse_screen_y&#13;&#10;&#13;&#10;    return world_x, world_y&#13;&#10;&#13;&#10;&#13;&#10;# 방패 범위 이펙트 클래스&#13;&#10;class ShieldRangeEffect:&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    방패 범위 표시 이펙트 - world['effects_front']에서 관리&#13;&#10;    우클릭으로 방패를 전개할 때 표시되는 범위 이펙트&#13;&#10;&#13;&#10;    주의: 이 클래스는 x, y 속성을 가지지 않습니다.&#13;&#10;    lobby_mode.py의 draw 루프에서 특별 처리가 필요합니다.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    _range_image = None  # 클래스 변수로 이미지 공유&#13;&#10;&#13;&#10;    def __init__(self, player, shield):&#13;&#10;        # 이미지 최초 1회만 로드 (클래스 변수 사용)&#13;&#10;        if ShieldRangeEffect._range_image is None:&#13;&#10;            range_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'shieldRange.png')&#13;&#10;            try:&#13;&#10;                ShieldRangeEffect._range_image = load_image(range_path)&#13;&#10;            except Exception as ex:&#13;&#10;                print(f&quot;\033[91mFailed to load shield range image: {ex}\033[0m&quot;)&#13;&#10;                ShieldRangeEffect._range_image = None&#13;&#10;&#13;&#10;        self.player = player&#13;&#10;        self.shield = shield&#13;&#10;        self.range_scale = 4.0  # 방패 범위 이펙트 크기 조정&#13;&#10;&#13;&#10;        # x, y 속성 제거: 카메라 적용을 위해 플레이어 참조만 유지&#13;&#10;        # draw()에서 player의 카메라 적용된 좌표를 직접 받아서 사용&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        매 프레임마다 호출되어 이펙트 상태 업데이트&#13;&#10;        방패가 blocking 상태가 아니면 False를 반환하여 제거됨&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # 방패의 blocking 상태가 해제되면 이펙트도 제거&#13;&#10;        if not self.shield.blocking:&#13;&#10;            return False&#13;&#10;        # x, y 동기화 제거: player 참조만 유지&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        방패 범위 이펙트 그리기&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 플레이어의 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 플레이어의 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if ShieldRangeEffect._range_image is None:&#13;&#10;            return&#13;&#10;&#13;&#10;        # 방패 범위 각도 계산 (마우스 방향 기준, -90도 오프셋 적용)&#13;&#10;        base_offset = -math.pi / 2&#13;&#10;        theta = self.shield.range_angle + base_offset&#13;&#10;&#13;&#10;        # 카메라가 적용된 draw_x, draw_y를 기준으로 방패 범위 이펙트 그리기&#13;&#10;        ShieldRangeEffect._range_image.clip_composite_draw(&#13;&#10;            0, 0, ShieldRangeEffect._range_image.w, ShieldRangeEffect._range_image.h,&#13;&#10;            theta, '',&#13;&#10;            draw_x, draw_y,&#13;&#10;            ShieldRangeEffect._range_image.w * self.range_scale,&#13;&#10;            ShieldRangeEffect._range_image.h * self.range_scale&#13;&#10;        )&#13;&#10;&#13;&#10;&#13;&#10;class Weapon:&#13;&#10;    &quot;&quot;&quot;기본 무기 클래스&quot;&quot;&quot;&#13;&#10;    def __init__(self, player, weapon_type, image_path, render_layer='back', scale=3.0):&#13;&#10;        self.player = player&#13;&#10;        self.weapon_type = weapon_type  # 'sword', 'shield', 'wand' 등&#13;&#10;        self.render_layer = render_layer  # 'back' 또는 'front'&#13;&#10;        self.scale_factor = scale&#13;&#10;&#13;&#10;        # 이미지 로드&#13;&#10;        self.image = load_image(image_path)&#13;&#10;&#13;&#10;        # 무기 위치 오프셋 (플레이어 중심 기준)&#13;&#10;        self.offset_x = 20  # 기본 오프셋&#13;&#10;        self.offset_y = 0&#13;&#10;&#13;&#10;        # 회전 각도&#13;&#10;        self.angle = 0  # 라디안&#13;&#10;&#13;&#10;        # 공격 상태&#13;&#10;        self.is_attacking = False&#13;&#10;        self.attack_timer = 0.0&#13;&#10;        self.attack_duration = 0.3  # 실제 공격 애니메이션 시간&#13;&#10;        self.attack_recovery = 0.15  # 공격 후 딜레이 (후딜레이)&#13;&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery  # 총 공격 시간&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;마우스 위치를 기준으로 무기 각도 계산 (카메라 보정 적용)&quot;&quot;&quot;&#13;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#13;&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#13;&#10;&#13;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#13;&#10;        dx = world_mouse_x - self.player.x&#13;&#10;        dy = world_mouse_y - self.player.y&#13;&#10;&#13;&#10;        # 각도 계산 (라디안)&#13;&#10;        self.angle = math.atan2(dy, dx)&#13;&#10;&#13;&#10;        # 공격 타이머 업데이트&#13;&#10;        if self.is_attacking:&#13;&#10;            dt = framework.get_delta_time()&#13;&#10;            self.attack_timer += dt&#13;&#10;            if self.attack_timer &gt;= self.total_attack_time:&#13;&#10;                self.is_attacking = False&#13;&#10;                self.attack_timer = 0.0&#13;&#10;&#13;&#10;    def attack(self):&#13;&#10;        &quot;&quot;&quot;공격 시작&quot;&quot;&quot;&#13;&#10;        if not self.is_attacking:&#13;&#10;            self.is_attacking = True&#13;&#10;            self.attack_timer = 0.0&#13;&#10;            print(f&quot;{self.weapon_type} 공격!&quot;)&#13;&#10;            return True&#13;&#10;        return False&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;무기를 회전시켜서 그리기&quot;&quot;&quot;&#13;&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#13;&#10;        # 무기 위치 계산 (카메라 적용된 플레이어 위치 기준)&#13;&#10;        weapon_x = draw_x + self.offset_x * math.cos(self.angle)&#13;&#10;        weapon_y = draw_y + self.offset_y + self.offset_x * math.sin(self.angle)&#13;&#10;&#13;&#10;        # 좌우 반전 결정&#13;&#10;        flip = 'h' if self.player.face_dir == -1 else ''&#13;&#10;&#13;&#10;        # 회전된 무기 그리기&#13;&#10;        self.image.clip_composite_draw(&#13;&#10;            0, 0, self.image.w, self.image.h,&#13;&#10;            self.angle, flip,&#13;&#10;            weapon_x, weapon_y,&#13;&#10;            self.image.w * self.scale_factor,&#13;&#10;            self.image.h * self.scale_factor&#13;&#10;        )&#13;&#10;&#13;&#10;&#13;&#10;class Shield(Weapon):&#13;&#10;    &quot;&quot;&quot;방패 클래스 (항상 캐릭터 앞에 그려짐)&quot;&quot;&quot;&#13;&#10;    def __init__(self, player, image_path, scale=3.0):&#13;&#10;        super().__init__(player, 'shield', image_path, render_layer='front', scale=scale)&#13;&#10;        self.offset_x = -10  # 기본 X 오프셋(사용 안 함)&#13;&#10;        self.offset_y = -10  # Y 오프셋 유지&#13;&#10;&#13;&#10;        # 우클릭 방패 전개 상태&#13;&#10;        self.blocking = False&#13;&#10;        self.range_angle = 0.0&#13;&#10;&#13;&#10;        # 방패 범위 이펙트 참조 (world['effects_front']에서 관리)&#13;&#10;        self.range_effect = None&#13;&#10;&#13;&#10;        # 바라보는 방향으로 방패를 살짝 앞으로 이동시키는 오프셋(픽셀)&#13;&#10;        self.forward_offset = 18&#13;&#10;&#13;&#10;    def start_block(self):&#13;&#10;        self.blocking = True&#13;&#10;&#13;&#10;    def end_block(self):&#13;&#10;        self.blocking = False&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;방패: 우클릭 유지 시 각도를 커서 방향으로 갱신 (카메라 보정 적용)&quot;&quot;&quot;&#13;&#10;        # 인벤토리가 열려 있으면 방패 입력/전개 무시&#13;&#10;        if getattr(self.player, 'inventory_open', False):&#13;&#10;            self.blocking = False&#13;&#10;            if self.is_attacking:&#13;&#10;                dt = framework.get_delta_time()&#13;&#10;                self.attack_timer += dt&#13;&#10;                if self.attack_timer &gt;= self.attack_duration:&#13;&#10;                    self.is_attacking = False&#13;&#10;                    self.attack_timer = 0.0&#13;&#10;            return&#13;&#10;&#13;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#13;&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#13;&#10;&#13;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#13;&#10;        dx = world_mouse_x - self.player.x&#13;&#10;        dy = world_mouse_y - self.player.y&#13;&#10;&#13;&#10;        # 방패 범위 각도 계산 (라디안)&#13;&#10;        self.range_angle = math.atan2(dy, dx)&#13;&#10;&#13;&#10;        # 이전 blocking 상태 저장&#13;&#10;        was_blocking = self.blocking&#13;&#10;&#13;&#10;        # 프레임별 우클릭 유지 여부를 직접 폴링하여 blocking 동기화 (이벤트 누락 대비)&#13;&#10;        mx = ctypes.c_int(0)&#13;&#10;        my = ctypes.c_int(0)&#13;&#10;        state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#13;&#10;        try:&#13;&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#13;&#10;            self.blocking = bool(state &amp; right_mask)&#13;&#10;        except Exception:&#13;&#10;            pass&#13;&#10;&#13;&#10;        # blocking 상태가 변경되었을 때 이펙트 생성/제거&#13;&#10;        if self.blocking and not was_blocking:&#13;&#10;            # blocking 시작: 이펙트 생성&#13;&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#13;&#10;                self.range_effect = ShieldRangeEffect(self.player, self)&#13;&#10;                self.player.world['effects_front'].append(self.range_effect)&#13;&#10;        elif not self.blocking and was_blocking:&#13;&#10;            # blocking 종료: 이펙트는 자동으로 제거됨 (update에서 False 반환)&#13;&#10;            self.range_effect = None&#13;&#10;&#13;&#10;        # 기존 공격 타이머 로직 유지(필요 시)&#13;&#10;        if self.is_attacking:&#13;&#10;            dt = framework.get_delta_time()&#13;&#10;            self.attack_timer += dt&#13;&#10;            if self.attack_timer &gt;= self.attack_duration:&#13;&#10;                self.is_attacking = False&#13;&#10;                self.attack_timer = 0.0&#13;&#10;&#13;&#10;    def attack(self):&#13;&#10;        &quot;&quot;&quot;방패는 막기 동작 (현재는 사용하지 않음)&quot;&quot;&quot;&#13;&#10;        if not self.is_attacking:&#13;&#10;            self.is_attacking = True&#13;&#10;            self.attack_timer = 0.0&#13;&#10;            print(f&quot;방패로 막기!&quot;)&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;방패 본체 그리기 (범위 이미지는 world['effects_front']에서 관리)&quot;&quot;&quot;&#13;&#10;        # 방패 본체는 회전 없이 플레이어 앞에 고정&#13;&#10;        flip = 'h' if self.player.face_dir == -1 else ''&#13;&#10;        # 전개 중일 때만 앞으로 이동, 아니면 기존의 작은 좌우 오프셋 유지&#13;&#10;        if self.blocking:&#13;&#10;            local_offset_x = self.forward_offset if self.player.face_dir == 1 else -self.forward_offset&#13;&#10;        else:&#13;&#10;            local_offset_x = 10 if self.player.face_dir == -1 else -10&#13;&#10;&#13;&#10;        # 바라보는 방향에 따른 방패 로컬 오프셋 적용&#13;&#10;        weapon_x = draw_x + local_offset_x&#13;&#10;        weapon_y = draw_y + self.offset_y&#13;&#10;&#13;&#10;        self.image.clip_composite_draw(&#13;&#10;            0, 0, self.image.w, self.image.h,&#13;&#10;            0, flip,&#13;&#10;            weapon_x, weapon_y,&#13;&#10;            self.image.w * self.scale_factor,&#13;&#10;            self.image.h * self.scale_factor&#13;&#10;        )&#13;&#10;&#13;&#10;    def check_projectile_block(self, projectile):&#13;&#10;        &quot;&quot;&quot;투사체가 방패에 막혔는지 확인&#13;&#10;&#13;&#10;        Args:&#13;&#10;            projectile: 투사체 객체&#13;&#10;&#13;&#10;        Returns:&#13;&#10;            bool: 방패에 막혔으면 True, 아니면 False&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # 방패를 전개하지 않았으면 막을 수 없음&#13;&#10;        if not self.blocking:&#13;&#10;            return False&#13;&#10;&#13;&#10;        # print(f&quot;[Shield] 방패 전개 중, 투사체 충돌 체크 시작&quot;)&#13;&#10;&#13;&#10;        # 방패 중심 위치 계산&#13;&#10;        if self.blocking:&#13;&#10;            local_offset_x = self.forward_offset if self.player.face_dir == 1 else -self.forward_offset&#13;&#10;        else:&#13;&#10;            local_offset_x = 10 if self.player.face_dir == -1 else -10&#13;&#10;        shield_x = self.player.x + local_offset_x&#13;&#10;        shield_y = self.player.y + self.offset_y&#13;&#10;&#13;&#10;        # 방패 크기 (이미지 크기 * scale) - 충돌 범위를 매우 넓게&#13;&#10;        shield_width = self.image.w * self.scale_factor * 2.5  # 3배로 확대&#13;&#10;        shield_height = self.image.h * self.scale_factor * 2.5&#13;&#10;&#13;&#10;        # 투사체 크기&#13;&#10;        if hasattr(projectile, 'get_collision_box'):&#13;&#10;            proj_width, proj_height = projectile.get_collision_box()&#13;&#10;        else:&#13;&#10;            proj_width = 30&#13;&#10;            proj_height = 30&#13;&#10;&#13;&#10;        # AABB 충돌 감지&#13;&#10;        shield_left = shield_x - shield_width / 2&#13;&#10;        shield_right = shield_x + shield_width / 2&#13;&#10;        shield_bottom = shield_y - shield_height / 2&#13;&#10;        shield_top = shield_y + shield_height / 2&#13;&#10;&#13;&#10;        proj_left = projectile.x - proj_width / 2&#13;&#10;        proj_right = projectile.x + proj_width / 2&#13;&#10;        proj_bottom = projectile.y - proj_height / 2&#13;&#10;        proj_top = projectile.y + proj_height / 2&#13;&#10;&#13;&#10;        # 충돌 검사&#13;&#10;        if (shield_left &lt; proj_right and shield_right &gt; proj_left and&#13;&#10;            shield_bottom &lt; proj_top and shield_top &gt; proj_bottom):&#13;&#10;&#13;&#10;            print(f&quot;[Shield] AABB 충돌 감지!&quot;)&#13;&#10;&#13;&#10;            # 투사체가 플레이어 방향으로 날아오는지 확인&#13;&#10;            # 투사체에서 플레이어로 향하는 벡터 (투사체의 이동 방향과 유사)&#13;&#10;            proj_to_player_x = self.player.x - projectile.x&#13;&#10;            proj_to_player_y = self.player.y - projectile.y&#13;&#10;&#13;&#10;            # 투사체의 속도 벡터 확인 (투사체가 플레이어 쪽으로 오고 있는지)&#13;&#10;            if hasattr(projectile, 'dx') and hasattr(projectile, 'dy'):&#13;&#10;                # 투사체의 이동 방향과 플레이어 방향이 같은지 확인&#13;&#10;                dot_product = projectile.dx * proj_to_player_x + projectile.dy * proj_to_player_y&#13;&#10;                if dot_product &lt; 0:&#13;&#10;                    # 투사체가 플레이어에게서 멀어지고 있음 (이미 지나침)&#13;&#10;                    print(f&quot;[Shield] 투사체가 플레이어에게서 멀어지고 있음 - 방어 실패&quot;)&#13;&#10;                    return False&#13;&#10;&#13;&#10;            # 방어 이펙트 생성 (투사체 위치에 생성)&#13;&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#13;&#10;                try:&#13;&#10;                    from .guard_fx import GuardFX&#13;&#10;                    # 투사체(공격자) 위치에 이펙트 생성&#13;&#10;                    guard_fx = GuardFX(projectile.x, projectile.y, scale=self.scale_factor)&#13;&#10;                    self.player.world['effects_front'].append(guard_fx)&#13;&#10;                    print(f&quot;[Shield] 방어 이펙트 생성 완료 at ({int(projectile.x)}, {int(projectile.y)})&quot;)&#13;&#10;                except Exception as ex:&#13;&#10;                    print(f&quot;[Shield] 방어 이펙트 생성 실패: {ex}&quot;)&#13;&#10;&#13;&#10;            # 플레이어 넉백 (부드럽게)&#13;&#10;            knockback_strength = 100  # 픽셀 (초기 속도 기반)&#13;&#10;            distance = math.sqrt(proj_to_player_x**2 + proj_to_player_y**2)&#13;&#10;            if distance &gt; 0:&#13;&#10;                # 넉백 방향 계산 (투사체에서 멀어지는 방향)&#13;&#10;                self.player.knockback_dx = proj_to_player_x / distance&#13;&#10;                self.player.knockback_dy = proj_to_player_y / distance&#13;&#10;                # 넉백 속도 및 지속시간 설정&#13;&#10;                self.player.knockback_speed = knockback_strength&#13;&#10;                self.player.knockback_duration = 0.2  # 0.2초 동안 넉백&#13;&#10;                self.player.knockback_timer = 0.0  # 타이머 초기화&#13;&#10;                print(f&quot;[Shield] 방어 이펙트에 의한 넉백 발생: 방향=({self.player.knockback_dx:.2f}, {self.player.knockback_dy:.2f}), 속도={knockback_strength}&quot;)&#13;&#10;&#13;&#10;            return True&#13;&#10;&#13;&#10;        # print(f&quot;[Shield] 충돌 감지 안됨&quot;)&#13;&#10;        return False&#13;&#10;&#13;&#10;&#13;&#10;class Sword(Weapon):&#13;&#10;    &quot;&quot;&quot;검 클래스 (항상 캐릭터 뒤에 그려짐)&quot;&quot;&quot;&#13;&#10;    def __init__(self, player, image_path, scale=3.0):&#13;&#10;        super().__init__(player, 'sword', image_path, render_layer='back', scale=scale)&#13;&#10;        self.offset_x = 15  # 검은 좀 더 멀리&#13;&#10;        self.offset_y = 8 # 검의 기본 Y 오프셋&#13;&#10;&#13;&#10;        # 스테이지별(콤보) 시간 설정 (스테이지1 = 기본, 스테이지2 = 콤보)&#13;&#10;        self.stage = 1&#13;&#10;        # 기본(보정 전) 시간값 저장&#13;&#10;        self.stage1_attack_duration_base = 0.2  # 공격 모션 시간 (1스테이지)&#13;&#10;        self.stage1_attack_recovery_base = 0.3  # 후딜 (1스테이지)&#13;&#10;        self.stage2_attack_duration_base = 0.18  # 공격 모션 시간 (콤보)&#13;&#10;        self.stage2_attack_recovery_base = 0.35  # 후딜 (콤보)&#13;&#10;        self.stage3_attack_duration_base = 0.28  # 3스테이지 모션 시간&#13;&#10;        self.stage3_attack_recovery_base = 0.4   # 3스테이지 후딜&#13;&#10;&#13;&#10;        # 현재 활성화된 공격 시간 값 (초기값은 1스테이지 보정 적용)&#13;&#10;        self.attack_duration = self.stage1_attack_duration_base&#13;&#10;        self.attack_recovery = self.stage1_attack_recovery_base&#13;&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery&#13;&#10;&#13;&#10;        self.base_angle_offset = math.radians(25)  # 기본 각도 오프셋&#13;&#10;&#13;&#10;        # 공격 모션 관련 변수&#13;&#10;        self.attack_progress = 0.0  # 0.0 ~ 1.0&#13;&#10;        self.attack_angle_range = -math.radians(205)  # 0도 ~ 270도 회전 (검 자체 회전)&#13;&#10;        self.y_offset_down = -50  # progress 0.5까지 내려갈 y 오프셋&#13;&#10;&#13;&#10;        # 자전 및 공전 각도 범위 추가&#13;&#10;        self.rotation_angle_range = -math.radians(270)  # 자전: 0도 ~ 270도&#13;&#10;        self.orbit_angle_range = -math.radians(205)  # 공전: 0도 ~ 205도&#13;&#10;&#13;&#10;        # 콤보 관련 플래그&#13;&#10;        self.combo_queued = False  # 후딜 중에 콤보 입력이 들어왔는지&#13;&#10;&#13;&#10;    def _apply_speed(self, stage: int):&#13;&#10;        &quot;&quot;&quot;플레이어 stats.attack_speed로 해당 스테이지 시간값을 보정한다.&quot;&quot;&quot;&#13;&#10;        speed = 1.0&#13;&#10;        try:&#13;&#10;            if hasattr(self.player, 'stats'):&#13;&#10;                speed = max(0.1, float(self.player.stats.get('attack_speed')))&#13;&#10;        except Exception:&#13;&#10;            speed = 1.0&#13;&#10;        if stage == 1:&#13;&#10;            self.attack_duration = self.stage1_attack_duration_base / speed&#13;&#10;            self.attack_recovery = self.stage1_attack_recovery_base / speed&#13;&#10;        elif stage == 2:&#13;&#10;            self.attack_duration = self.stage2_attack_duration_base / speed&#13;&#10;            self.attack_recovery = self.stage2_attack_recovery_base / speed&#13;&#10;        elif stage == 3:&#13;&#10;            self.attack_duration = self.stage3_attack_duration_base / speed&#13;&#10;            self.attack_recovery = self.stage3_attack_recovery_base / speed&#13;&#10;        else:&#13;&#10;            pass&#13;&#10;        self.total_attack_time = self.attack_duration + self.attack_recovery&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;마우스 위치를 기준으로 무기 각도 계산 (카메라 보정 적용)&quot;&quot;&quot;&#13;&#10;        # 마우스 월드 좌표 계산 (카메라 오프셋 고려)&#13;&#10;        world_mouse_x, world_mouse_y = get_mouse_world_position(self.player)&#13;&#10;&#13;&#10;        # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#13;&#10;        dx = world_mouse_x - self.player.x&#13;&#10;        dy = world_mouse_y - self.player.y&#13;&#10;&#13;&#10;        # 각도 계산 (라디안)&#13;&#10;        self.angle = math.atan2(dy, dx)&#13;&#10;&#13;&#10;        # 공격 타이머 업데이트&#13;&#10;        if self.is_attacking:&#13;&#10;            dt = framework.get_delta_time()&#13;&#10;            self.attack_timer += dt&#13;&#10;&#13;&#10;            # 공격 progress 계산 (0.0 ~ 1.0)&#13;&#10;            if self.attack_timer &lt; self.attack_duration:&#13;&#10;                self.attack_progress = self.attack_timer / self.attack_duration&#13;&#10;            else:&#13;&#10;                self.attack_progress = 1.0&#13;&#10;&#13;&#10;            # 스테이지별 종료 처리&#13;&#10;            if self.attack_timer &gt;= self.total_attack_time:&#13;&#10;                # 3스테이지 종료 처리&#13;&#10;                if self.stage == 3:&#13;&#10;                    self.is_attacking = False&#13;&#10;                    self.attack_timer = 0.0&#13;&#10;                    self.attack_progress = 0.0&#13;&#10;                    self.stage = 1&#13;&#10;                    # 기본 스테이지 시간 복원&#13;&#10;                    self.attack_duration = self.stage1_attack_duration_base&#13;&#10;                    self.attack_recovery = self.stage1_attack_recovery_base&#13;&#10;                    self.total_attack_time = self.attack_duration + self.attack_recovery&#13;&#10;                    self.combo_queued = False&#13;&#10;                # 2스테이지 종료 처리&#13;&#10;                elif self.stage == 2:&#13;&#10;                    self.is_attacking = False&#13;&#10;                    self.attack_timer = 0.0&#13;&#10;                    self.attack_progress = 0.0&#13;&#10;                    self.stage = 1&#13;&#10;                    self.attack_duration = self.stage1_attack_duration_base&#13;&#10;                    self.attack_recovery = self.stage1_attack_recovery_base&#13;&#10;                    self.total_attack_time = self.attack_duration + self.attack_recovery&#13;&#10;                    self.combo_queued = False&#13;&#10;                else:&#13;&#10;                    # 1스테이지 종료&#13;&#10;                    self.is_attacking = False&#13;&#10;                    self.attack_timer = 0.0&#13;&#10;                    self.attack_progress = 0.0&#13;&#10;                    self.combo_queued = False&#13;&#10;&#13;&#10;    def attack(self):&#13;&#10;        &quot;&quot;&quot;공격 시작&#13;&#10;&#13;&#10;        동작 요약:&#13;&#10;        - 비공격 중이면 1스테이지 공격 시작&#13;&#10;        - 공격 중(후딜 영역)에 클릭하면 즉시 2스테이지(콤보) 공격으로 전환&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # 비공격 상태에서 시작&#13;&#10;        if not self.is_attacking:&#13;&#10;            self.is_attacking = True&#13;&#10;            self.attack_timer = 0.0&#13;&#10;            self.attack_progress = 0.0&#13;&#10;            self.stage = 1&#13;&#10;            # 스탯 보정 적용&#13;&#10;            self._apply_speed(1)&#13;&#10;            print(f&quot;{self.weapon_type} 공격! (stage 1)&quot;)&#13;&#10;&#13;&#10;            # 공격 이펙트 생성&#13;&#10;            from .player import VFX_Tier1_Sword_Swing&#13;&#10;&#13;&#10;            angle_deg = math.degrees(self.angle) % 360&#13;&#10;            if 90 &lt; angle_deg &lt; 270:  # 왼쪽 영역&#13;&#10;                flip = 'vh'&#13;&#10;            else:&#13;&#10;                flip = 'h'&#13;&#10;&#13;&#10;            attack_vfx = VFX_Tier1_Sword_Swing(&#13;&#10;                self.player.x,&#13;&#10;                self.player.y,&#13;&#10;                self.angle,&#13;&#10;                flip,&#13;&#10;                scale=4.5,&#13;&#10;                range_factor=60,&#13;&#10;                variant=1,&#13;&#10;                owner=self.player&#13;&#10;            )&#13;&#10;            # world['effects_front']에 추가 (없으면 player에 추가)&#13;&#10;            if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#13;&#10;                self.player.world['effects_front'].append(attack_vfx)&#13;&#10;            else:&#13;&#10;                self.player.attack_effects.append(attack_vfx)&#13;&#10;&#13;&#10;            return True&#13;&#10;&#13;&#10;        # 공격 중일 때: 후딜 중에 콤보 입력을 받아 단계별 전환&#13;&#10;        else:&#13;&#10;            # 1스테이지 후딜에서 클릭 -&gt; 2스테이지&#13;&#10;            if self.attack_timer &gt;= self.attack_duration and self.stage == 1:&#13;&#10;                # 즉시 콤보(2스테이지)로 전환&#13;&#10;                self.stage = 2&#13;&#10;                self.attack_timer = 0.0&#13;&#10;                self.attack_progress = 0.0&#13;&#10;                # 스탯 보정 적용&#13;&#10;                self._apply_speed(2)&#13;&#10;                self.combo_queued = True&#13;&#10;                print(f&quot;{self.weapon_type} 콤보! (stage 2)&quot;)&#13;&#10;&#13;&#10;                # 콤보용 이펙트 생성&#13;&#10;                from .player import VFX_Tier1_Sword_Swing&#13;&#10;&#13;&#10;                angle_deg = math.degrees(self.angle) % 360&#13;&#10;                flip = 'vh' if 90 &lt; angle_deg &lt; 270 else 'h'&#13;&#10;&#13;&#10;                attack_vfx = VFX_Tier1_Sword_Swing(&#13;&#10;                    self.player.x,&#13;&#10;                    self.player.y,&#13;&#10;                    self.angle,&#13;&#10;                    flip,&#13;&#10;                    scale=5.5,&#13;&#10;                    range_factor=70,&#13;&#10;                    variant=2&#13;&#10;                )&#13;&#10;                # world['effects_front']에 추가 (없으면 player에 추가)&#13;&#10;                if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#13;&#10;                    self.player.world['effects_front'].append(attack_vfx)&#13;&#10;                else:&#13;&#10;                    self.player.attack_effects.append(attack_vfx)&#13;&#10;&#13;&#10;                return True&#13;&#10;&#13;&#10;            # 2스테이지 후딜에서 클릭 -&gt; 3스테이지 (헤비 스윙)&#13;&#10;            if self.attack_timer &gt;= self.attack_duration and self.stage == 2:&#13;&#10;                self.stage = 3&#13;&#10;                self.attack_timer = 0.0&#13;&#10;                self.attack_progress = 0.0&#13;&#10;                # 스탯 보정 적용&#13;&#10;                self._apply_speed(3)&#13;&#10;                self.combo_queued = True&#13;&#10;                print(f&quot;{self.weapon_type} 헤비 스윙! (stage 3)&quot;)&#13;&#10;&#13;&#10;                # 3스테이지 전용 이펙트 생성 (variant=3)&#13;&#10;                from .player import VFX_Tier1_Sword_Swing&#13;&#10;&#13;&#10;                angle_deg = math.degrees(self.angle) % 360&#13;&#10;                flip = 'vh' if 90 &lt; angle_deg &lt; 270 else 'h'&#13;&#10;&#13;&#10;                attack_vfx = VFX_Tier1_Sword_Swing(&#13;&#10;                    self.player.x,&#13;&#10;                    self.player.y,&#13;&#10;                    self.angle,&#13;&#10;                    flip,&#13;&#10;                    scale=6.0,&#13;&#10;                    range_factor=90,&#13;&#10;                    variant=3,&#13;&#10;                    owner=self.player&#13;&#10;                )&#13;&#10;                # world['effects_front']에 추가 (없으면 player에 추가)&#13;&#10;                if hasattr(self.player, 'world') and self.player.world and 'effects_front' in self.player.world:&#13;&#10;                    self.player.world['effects_front'].append(attack_vfx)&#13;&#10;                else:&#13;&#10;                    self.player.attack_effects.append(attack_vfx)&#13;&#10;&#13;&#10;                return True&#13;&#10;&#13;&#10;            # 그 외(공격 중이지만 아직 공격 모션 중이거나 이미 최고 단계면 무시)&#13;&#10;            return False&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        검을 회전시켜서 그리기 - 검 자체를 중심으로 회전 + 캐릭터 중심으로 공전&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 플레이어의 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 플레이어의 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        # ========== 공격 모션에 따른 각도 및 오프셋 계산 ==========&#13;&#10;        sword_rotation = 0.0          # 검 자체의 회전 각도 (자전)&#13;&#10;        orbit_angle_offset = 0.0      # 캐릭터 중심 기준 공전 각도 오프셋&#13;&#10;        y_offset_modifier = 0.0       # Y축 위치 오프셋 (공격 시 아래로 내려감)&#13;&#10;&#13;&#10;        if self.is_attacking:&#13;&#10;            if self.attack_timer &lt; self.attack_duration:&#13;&#10;                # 공격 모션 중 (0 ~ attack_duration)&#13;&#10;                sword_rotation = self.rotation_angle_range * self.attack_progress  # 자전 각도&#13;&#10;                orbit_angle_offset = self.orbit_angle_range * self.attack_progress  # 공전 각도&#13;&#10;                # Y축 오프셋: 공격 시 검을 아래로 내림&#13;&#10;                y_offset_modifier = -3 * self.offset_y * self.attack_progress&#13;&#10;            else:&#13;&#10;                # 후딜레이 중 (attack_duration ~ total_attack_time)&#13;&#10;                sword_rotation = self.rotation_angle_range      # 자전 최대 각도 유지&#13;&#10;                orbit_angle_offset = self.orbit_angle_range    # 공전 최대 각도 유지&#13;&#10;                # Y축 오프셋: 후딜레이 동안 최대 아래 위치 유지&#13;&#10;                y_offset_modifier = -3 * self.offset_y&#13;&#10;&#13;&#10;        # ========== 2스테이지(콤보) 시 자전 방향 반전 ==========&#13;&#10;        # 콤보 공격 시 검이 반대 방향으로 회전하여 자연스러운 연계 공격 연출&#13;&#10;        invert_rotation = (getattr(self, 'stage', 1) == 2 and self.attack_timer &lt; self.attack_duration)&#13;&#10;        if invert_rotation:&#13;&#10;            sword_rotation = -sword_rotation&#13;&#10;&#13;&#10;        # ========== 검의 기본 각도 오프셋 ==========&#13;&#10;        base_offset = self.base_angle_offset&#13;&#10;&#13;&#10;        # ========== 마우스 위치에 따른 검의 방향 결정 ==========&#13;&#10;        angle_deg = math.degrees(self.angle) % 360&#13;&#10;&#13;&#10;        # 마우스가 왼쪽/오른쪽에 있는지에 따라 검의 위치와 반전 방향 결정&#13;&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽 영역&#13;&#10;            flip = 'v'  # 수직 반전&#13;&#10;            # 왼쪽: 공전 각도를 빼서 위치 계산&#13;&#10;            position_angle = self.angle - orbit_angle_offset&#13;&#10;            # 왼쪽: 자전 각도를 빼서 최종 각도 계산&#13;&#10;            final_angle = position_angle - sword_rotation&#13;&#10;        else:  # 오른쪽 영역&#13;&#10;            flip = ''&#13;&#10;            # 오른쪽: 공전 각도를 더해서 위치 계산&#13;&#10;            position_angle = self.angle + orbit_angle_offset&#13;&#10;            # 오른쪽: 자전 각도를 더해서 최종 각도 계산&#13;&#10;            final_angle = position_angle + sword_rotation&#13;&#10;&#13;&#10;        # ========== 검의 실제 화면 위치 계산 (카메라 적용 좌표 기준) ==========&#13;&#10;        # draw_x, draw_y는 이미 카메라가 적용된 화면 좌표이므로, 이를 기준으로 offset 적용&#13;&#10;        weapon_x = draw_x + self.offset_x * math.cos(position_angle)&#13;&#10;        weapon_y = draw_y + self.offset_y + self.offset_x * math.sin(position_angle) + y_offset_modifier&#13;&#10;&#13;&#10;        # ========== 검 이미지 그리기 ==========&#13;&#10;        self.image.clip_composite_draw(&#13;&#10;            0, 0, self.image.w, self.image.h,&#13;&#10;            final_angle + base_offset, flip,&#13;&#10;            weapon_x, weapon_y,&#13;&#10;            self.image.w * self.scale_factor,&#13;&#10;            self.image.h * self.scale_factor&#13;&#10;        )&#13;&#10;&#13;&#10;&#13;&#10;class EquipmentManager:&#13;&#10;    &quot;&quot;&quot;장비를 관리하는 매니저 클래스&quot;&quot;&quot;&#13;&#10;    def __init__(self, player):&#13;&#10;        self.player = player&#13;&#10;        self.back_equipment = []   # 캐릭터 뒤에 그려질 장비 (검 등)&#13;&#10;        self.front_equipment = []  # 캐릭터 앞에 그려질 장비 (방패 등)&#13;&#10;&#13;&#10;    def equip(self, equipment):&#13;&#10;        &quot;&quot;&quot;장비 장착&quot;&quot;&quot;&#13;&#10;        if equipment.render_layer == 'back':&#13;&#10;            self.back_equipment.append(equipment)&#13;&#10;        elif equipment.render_layer == 'front':&#13;&#10;            self.front_equipment.append(equipment)&#13;&#10;&#13;&#10;    def unequip(self, equipment):&#13;&#10;        &quot;&quot;&quot;장비 해제&quot;&quot;&quot;&#13;&#10;        if equipment in self.back_equipment:&#13;&#10;            self.back_equipment.remove(equipment)&#13;&#10;        if equipment in self.front_equipment:&#13;&#10;            self.front_equipment.remove(equipment)&#13;&#10;&#13;&#10;    def unequip_all(self):&#13;&#10;        &quot;&quot;&quot;모든 장비 해제&quot;&quot;&quot;&#13;&#10;        self.back_equipment.clear()&#13;&#10;        self.front_equipment.clear()&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;모든 장비 업데이트&quot;&quot;&quot;&#13;&#10;        for equipment in self.back_equipment + self.front_equipment:&#13;&#10;            equipment.update()&#13;&#10;&#13;&#10;    def handle_event(self, event):&#13;&#10;        &quot;&quot;&quot;장비 이벤트 처리 (좌클릭: 공격, 우클릭: 방패 전개 표시)&quot;&quot;&quot;&#13;&#10;        # 마우스 좌클릭 시 공격(검)&#13;&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#13;&#10;            for equipment in self.back_equipment:&#13;&#10;                equipment.attack()&#13;&#10;&#13;&#10;        # 마우스 우클릭: 방패 범위 표시 시작/종료&#13;&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_RIGHT:&#13;&#10;            # 디버그: 우클릭 다운 수신&#13;&#10;            try:&#13;&#10;                print('[Shield] RIGHT DOWN')&#13;&#10;            except Exception:&#13;&#10;                pass&#13;&#10;            for equipment in self.front_equipment:&#13;&#10;                if isinstance(equipment, Shield):&#13;&#10;                    equipment.start_block()&#13;&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_RIGHT:&#13;&#10;            # 디버그: 우클릭 업 수신&#13;&#10;            try:&#13;&#10;                print('[Shield] RIGHT UP')&#13;&#10;            except Exception:&#13;&#10;                pass&#13;&#10;            for equipment in self.front_equipment:&#13;&#10;                if isinstance(equipment, Shield):&#13;&#10;                    equipment.end_block()&#13;&#10;&#13;&#10;    def draw_back(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;캐릭터 뒤에 그려질 장비들&quot;&quot;&quot;&#13;&#10;        for equipment in self.back_equipment:&#13;&#10;            equipment.draw(draw_x, draw_y)&#13;&#10;&#13;&#10;    def draw_front(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;캐릭터 앞에 그려질 장비들&quot;&quot;&quot;&#13;&#10;        for equipment in self.front_equipment:&#13;&#10;            equipment.draw(draw_x, draw_y)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/loading_screen.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/loading_screen.py" />
              <option name="originalContent" value="# game_logic/loading_screen.py&#10;&quot;&quot;&quot;스테이지 로딩 화면 모듈&quot;&quot;&quot;&#10;&#10;import pico2d as p2&#10;from . import framework&#10;&#10;class LoadingScreen:&#10;    &quot;&quot;&quot;스테이지 로딩 화면 클래스&quot;&quot;&quot;&#10;&#10;    def __init__(self, loading_info):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            loading_info: 스테이지 모듈의 LOADING_SCREEN_INFO 딕셔너리&#10;                - stage_number: 스테이지 번호&#10;                - bg_image: 배경 이미지 경로&#10;                - animation_prefix: 애니메이션 이미지 경로 접두사&#10;                - animation_count: 애니메이션 프레임 수&#10;                - extra_animation (optional): 추가 애니메이션 정보&#10;        &quot;&quot;&quot;&#10;        self.loading_info = loading_info&#10;        self.stage_number = loading_info['stage_number']&#10;        self.bg_image = None&#10;        self.black_bg = None  # 검정 배경 이미지&#10;        self.loading_images = []&#10;        self.extra_images = []  # 추가 애니메이션 이미지&#10;        self.current_frame = 0&#10;        self.animation_time = 0.0&#10;        self.animation_speed = 10  # fps&#10;        self.is_complete = False&#10;        self.loading_duration = 0.0  # 로딩 경과 시간&#10;        self.min_loading_time = 3.0  # 최소 로딩 시간 (초)&#10;&#10;        # 이미지 로드&#10;        self._load_images()&#10;&#10;        print(f&quot;[LoadingScreen] Stage {self.stage_number} 로딩 화면 초기화 완료&quot;)&#10;&#10;    def _load_images(self):&#10;        &quot;&quot;&quot;로딩 화면 이미지들을 로드&quot;&quot;&quot;&#10;        try:&#10;            # 검정 배경 이미지 로드&#10;            black_bg_path = 'resources/Texture_organize/UI/Stage_Loading/BlackBG.png'&#10;            self.black_bg = p2.load_image(black_bg_path)&#10;            print(f&quot;[LoadingScreen] 검정 배경 이미지 로드 완료: {black_bg_path}&quot;)&#10;&#10;            # 배경 이미지 로드&#10;            bg_path = self.loading_info['bg_image']&#10;            self.bg_image = p2.load_image(bg_path)&#10;            print(f&quot;[LoadingScreen] 배경 이미지 로드 완료: {bg_path}&quot;)&#10;&#10;            # 로딩 애니메이션 이미지 로드&#10;            animation_prefix = self.loading_info['animation_prefix']&#10;            animation_count = self.loading_info['animation_count']&#10;&#10;            for i in range(animation_count):&#10;                img_path = f'{animation_prefix}{i:02d}.png'&#10;                img = p2.load_image(img_path)&#10;                self.loading_images.append(img)&#10;            print(f&quot;[LoadingScreen] 로딩 애니메이션 {len(self.loading_images)}개 이미지 로드 완료&quot;)&#10;&#10;            # 추가 애니메이션 로드 (있는 경우)&#10;            extra_anim = self.loading_info.get('extra_animation')&#10;            if extra_anim:&#10;                extra_prefix = extra_anim['prefix']&#10;                extra_count = extra_anim['count']&#10;&#10;                for i in range(extra_count):&#10;                    img_path = f'{extra_prefix}{i:02d}.png'&#10;                    img = p2.load_image(img_path)&#10;                    self.extra_images.append(img)&#10;                print(f&quot;[LoadingScreen] 추가 애니메이션 {len(self.extra_images)}개 이미지 로드 완료&quot;)&#10;&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[LoadingScreen] 이미지 로드 실패: {e}\033[0m&quot;)&#10;            # 로드 실패 시 빈 이미지 리스트로 계속 진행&#10;            self.loading_images = []&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;로딩 화면 업데이트&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;        self.loading_duration += dt&#10;&#10;        # 애니메이션 업데이트&#10;        if len(self.loading_images) &gt; 0:&#10;            self.animation_time += dt&#10;            if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;                self.current_frame = (self.current_frame + 1) % len(self.loading_images)&#10;                self.animation_time = 0.0&#10;&#10;        # 최소 로딩 시간이 지나면 완료 표시&#10;        if self.loading_duration &gt;= self.min_loading_time:&#10;            self.is_complete = True&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;로딩 화면 그리기&quot;&quot;&quot;&#10;        # 캔버스 중앙 좌표 계산&#10;        canvas_width = p2.get_canvas_width()&#10;        canvas_height = p2.get_canvas_height()&#10;        center_x = canvas_width // 2&#10;        center_y = canvas_height // 2&#10;        scale = 5.0&#10;&#10;        # 캔버스 클리어&#10;        p2.clear_canvas()&#10;&#10;        # 검정 배경 이미지로 전체 화면 채우기 (192x108을 화면 크기로 늘림)&#10;        if self.black_bg:&#10;            self.black_bg.draw(center_x, center_y, canvas_width, canvas_height)&#10;&#10;        # 배경 그리기&#10;        if self.bg_image:&#10;            self.bg_image.draw(center_x, center_y * 1.656, canvas_width, canvas_height // 2)&#10;&#10;        # 로딩 애니메이션 그리기&#10;        if len(self.loading_images) &gt; 0:&#10;            loading_img = self.loading_images[self.current_frame]&#10;            # 화면 하단 중앙에 로딩 애니메이션 배치&#10;            loading_x = center_x&#10;            loading_y = canvas_height // 4  # 하단 1/4 위치&#10;&#10;            # 로딩 애니메이션 크기 설정&#10;            loading_width = loading_img.w * scale&#10;            loading_height = loading_img.h * scale&#10;&#10;            loading_img.draw(loading_x, loading_y * 3.18, loading_width, loading_height)&#10;&#10;        # 추가 애니메이션 그리기 (카트 등)&#10;        if len(self.extra_images) &gt; 0:&#10;            extra_anim = self.loading_info.get('extra_animation', {})&#10;            extra_scale = extra_anim.get('scale', 5.0)&#10;            position = extra_anim.get('position', 'bottom_left')&#10;&#10;            extra_img = self.extra_images[self.current_frame]&#10;            extra_width = extra_img.w * extra_scale&#10;            extra_height = extra_img.h * extra_scale&#10;&#10;            # 위치에 따라 좌표 계산&#10;            if position == 'bottom_left':&#10;                extra_x = canvas_width // 4  # 왼쪽 1/4 지점&#10;                extra_y = canvas_height // 4  # 하단 1/4 위치&#10;            elif position == 'bottom_right':&#10;                extra_x = canvas_width * 3 // 4  # 오른쪽 3/4 지점&#10;                extra_y = canvas_height // 4&#10;            elif position == 'center':&#10;                extra_x = center_x&#10;                extra_y = center_y&#10;            elif position == 'Cart':&#10;                extra_x = canvas_width // 2 * 1.1&#10;                extra_y = canvas_height // 2 * 1.3&#10;            else:&#10;                extra_x = canvas_width // 4&#10;                extra_y = canvas_height // 4&#10;&#10;            extra_img.draw(extra_x, extra_y, extra_width, extra_height)&#10;&#10;        # 로딩 텍스트 (옵션)&#10;        # p2.draw_text를 사용하려면 폰트 설정이 필요합니다&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;이벤트 처리 (로딩 중에는 입력 무시)&quot;&quot;&quot;&#10;        pass&#10;" />
              <option name="updatedContent" value="# game_logic/loading_screen.py&#13;&#10;&quot;&quot;&quot;스테이지 로딩 화면 모듈&quot;&quot;&quot;&#13;&#10;&#13;&#10;import pico2d as p2&#13;&#10;from . import framework&#13;&#10;&#13;&#10;class LoadingScreen:&#13;&#10;    &quot;&quot;&quot;스테이지 로딩 화면 클래스&quot;&quot;&quot;&#13;&#10;&#13;&#10;    def __init__(self, loading_info):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Args:&#13;&#10;            loading_info: 스테이지 모듈의 LOADING_SCREEN_INFO 딕셔너리&#13;&#10;                - stage_number: 스테이지 번호&#13;&#10;                - bg_image: 배경 이미지 경로&#13;&#10;                - animation_prefix: 애니메이션 이미지 경로 접두사&#13;&#10;                - animation_count: 애니메이션 프레임 수&#13;&#10;                - extra_animation (optional): 추가 애니메이션 정보&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.loading_info = loading_info&#13;&#10;        self.stage_number = loading_info['stage_number']&#13;&#10;        self.bg_image = None&#13;&#10;        self.black_bg = None  # 검정 배경 이미지&#13;&#10;        self.loading_images = []&#13;&#10;        self.extra_images = []  # 추가 애니메이션 이미지&#13;&#10;        self.current_frame = 0&#13;&#10;        self.animation_time = 0.0&#13;&#10;        self.animation_speed = 10  # fps&#13;&#10;        self.is_complete = False&#13;&#10;        self.loading_duration = 0.0  # 로딩 경과 시간&#13;&#10;        self.min_loading_time = 3.0  # 최소 로딩 시간 (초)&#13;&#10;&#13;&#10;        # 이미지 로드&#13;&#10;        self._load_images()&#13;&#10;&#13;&#10;        print(f&quot;[LoadingScreen] Stage {self.stage_number} 로딩 화면 초기화 완료&quot;)&#13;&#10;&#13;&#10;    def _load_images(self):&#13;&#10;        &quot;&quot;&quot;로딩 화면 이미지들을 로드&quot;&quot;&quot;&#13;&#10;        try:&#13;&#10;            # 검정 배경 이미지 로드&#13;&#10;            black_bg_path = 'resources/Texture_organize/UI/Stage_Loading/BlackBG.png'&#13;&#10;            self.black_bg = p2.load_image(black_bg_path)&#13;&#10;            print(f&quot;[LoadingScreen] 검정 배경 이미지 로드 완료: {black_bg_path}&quot;)&#13;&#10;&#13;&#10;            # 배경 이미지 로드&#13;&#10;            bg_path = self.loading_info['bg_image']&#13;&#10;            self.bg_image = p2.load_image(bg_path)&#13;&#10;            print(f&quot;[LoadingScreen] 배경 이미지 로드 완료: {bg_path}&quot;)&#13;&#10;&#13;&#10;            # 로딩 애니메이션 이미지 로드&#13;&#10;            animation_prefix = self.loading_info['animation_prefix']&#13;&#10;            animation_count = self.loading_info['animation_count']&#13;&#10;&#13;&#10;            for i in range(animation_count):&#13;&#10;                img_path = f'{animation_prefix}{i:02d}.png'&#13;&#10;                img = p2.load_image(img_path)&#13;&#10;                self.loading_images.append(img)&#13;&#10;            print(f&quot;[LoadingScreen] 로딩 애니메이션 {len(self.loading_images)}개 이미지 로드 완료&quot;)&#13;&#10;&#13;&#10;            # 추가 애니메이션 로드 (있는 경우)&#13;&#10;            extra_anim = self.loading_info.get('extra_animation')&#13;&#10;            if extra_anim:&#13;&#10;                extra_prefix = extra_anim['prefix']&#13;&#10;                extra_count = extra_anim['count']&#13;&#10;&#13;&#10;                for i in range(extra_count):&#13;&#10;                    img_path = f'{extra_prefix}{i:02d}.png'&#13;&#10;                    img = p2.load_image(img_path)&#13;&#10;                    self.extra_images.append(img)&#13;&#10;                print(f&quot;[LoadingScreen] 추가 애니메이션 {len(self.extra_images)}개 이미지 로드 완료&quot;)&#13;&#10;&#13;&#10;        except Exception as e:&#13;&#10;            print(f&quot;\033[91m[LoadingScreen] 이미지 로드 실패: {e}\033[0m&quot;)&#13;&#10;            # 로드 실패 시 빈 이미지 리스트로 계속 진행&#13;&#10;            self.loading_images = []&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;로딩 화면 업데이트&quot;&quot;&quot;&#13;&#10;        dt = framework.get_delta_time()&#13;&#10;        self.loading_duration += dt&#13;&#10;&#13;&#10;        # 애니메이션 업데이트&#13;&#10;        if len(self.loading_images) &gt; 0:&#13;&#10;            self.animation_time += dt&#13;&#10;            if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;                self.current_frame = (self.current_frame + 1) % len(self.loading_images)&#13;&#10;                self.animation_time = 0.0&#13;&#10;&#13;&#10;        # 최소 로딩 시간이 지나면 완료 표시&#13;&#10;        if self.loading_duration &gt;= self.min_loading_time:&#13;&#10;            self.is_complete = True&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self):&#13;&#10;        &quot;&quot;&quot;로딩 화면 그리기&quot;&quot;&quot;&#13;&#10;        # 캔버스 중앙 좌표 계산&#13;&#10;        canvas_width = p2.get_canvas_width()&#13;&#10;        canvas_height = p2.get_canvas_height()&#13;&#10;        center_x = canvas_width // 2&#13;&#10;        center_y = canvas_height // 2&#13;&#10;        scale = 5.0&#13;&#10;&#13;&#10;        # 캔버스 클리어&#13;&#10;        p2.clear_canvas()&#13;&#10;&#13;&#10;        # 검정 배경 이미지로 전체 화면 채우기 (192x108을 화면 크기로 늘림)&#13;&#10;        if self.black_bg:&#13;&#10;            self.black_bg.draw(center_x, center_y, canvas_width, canvas_height)&#13;&#10;&#13;&#10;        # 배경 그리기&#13;&#10;        if self.bg_image:&#13;&#10;            self.bg_image.draw(center_x, center_y * 1.656, canvas_width, canvas_height // 2)&#13;&#10;&#13;&#10;        # 로딩 애니메이션 그리기&#13;&#10;        if len(self.loading_images) &gt; 0:&#13;&#10;            loading_img = self.loading_images[self.current_frame]&#13;&#10;            # 화면 하단 중앙에 로딩 애니메이션 배치&#13;&#10;            loading_x = center_x&#13;&#10;            loading_y = canvas_height // 4  # 하단 1/4 위치&#13;&#10;&#13;&#10;            # 로딩 애니메이션 크기 설정&#13;&#10;            loading_width = loading_img.w * scale&#13;&#10;            loading_height = loading_img.h * scale&#13;&#10;&#13;&#10;            loading_img.draw(loading_x, loading_y * 3.18, loading_width, loading_height)&#13;&#10;&#13;&#10;        # 추가 애니메이션 그리기 (카트 등)&#13;&#10;        if len(self.extra_images) &gt; 0:&#13;&#10;            extra_anim = self.loading_info.get('extra_animation', {})&#13;&#10;            extra_scale = extra_anim.get('scale', 5.0)&#13;&#10;            position = extra_anim.get('position', 'bottom_left')&#13;&#10;&#13;&#10;            extra_img = self.extra_images[self.current_frame]&#13;&#10;            extra_width = extra_img.w * extra_scale&#13;&#10;            extra_height = extra_img.h * extra_scale&#13;&#10;&#13;&#10;            # 위치에 따라 좌표 계산&#13;&#10;            if position == 'bottom_left':&#13;&#10;                extra_x = canvas_width // 4  # 왼쪽 1/4 지점&#13;&#10;                extra_y = canvas_height // 4  # 하단 1/4 위치&#13;&#10;            elif position == 'bottom_right':&#13;&#10;                extra_x = canvas_width * 3 // 4  # 오른쪽 3/4 지점&#13;&#10;                extra_y = canvas_height // 4&#13;&#10;            elif position == 'center':&#13;&#10;                extra_x = center_x&#13;&#10;                extra_y = center_y&#13;&#10;            elif position == 'Cart':&#13;&#10;                extra_x = canvas_width // 2 * 1.1&#13;&#10;                extra_y = canvas_height // 2 * 1.3&#13;&#10;            else:&#13;&#10;                extra_x = canvas_width // 4&#13;&#10;                extra_y = canvas_height // 4&#13;&#10;&#13;&#10;            extra_img.draw(extra_x, extra_y, extra_width, extra_height)&#13;&#10;&#13;&#10;        # 로딩 텍스트 (옵션)&#13;&#10;        # p2.draw_text를 사용하려면 폰트 설정이 필요합니다&#13;&#10;&#13;&#10;    def handle_event(self, e):&#13;&#10;        &quot;&quot;&quot;이벤트 처리 (로딩 중에는 입력 무시)&quot;&quot;&quot;&#13;&#10;        pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/lobby_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/lobby_mode.py" />
              <option name="originalContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#10;# minimal, compatible with existing game_logic modules&#10;import pico2d as p2&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#10;&#10;import game_framework&#10;from .player import Player&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar&#10;from .cursor import Cursor&#10;from .loading_screen import LoadingScreen&#10;from . import defeat_mode&#10;# 사용할 스테이지 모듈들을 import 합니다.&#10;from .stages import stage_1, stage_2&#10;from PIL import Image&#10;import math&#10;&#10;# world layers: keep same keys as original main.py&#10;world = {&#10;    'sky' : [],&#10;    'ground': [],&#10;    'upper_ground': [],&#10;    'walls': [],&#10;    'effects_back': [],&#10;    'entities': [],&#10;    'effects_front': [],&#10;    'ui': [],&#10;    'extra_bg': [],&#10;    'extras': [],&#10;    'cursor': []&#10;}&#10;world['bg'] = world['ground']&#10;world['player'] = world['entities']  # 플레이어 참조를 위한 키 추가&#10;world_list = ['sky', 'ground', 'upper_ground', 'walls', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']&#10;&#10;class Camera:&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#10;        self.target = target&#10;        self.x = target.x&#10;        self.y = target.y&#10;        self.map_width = map_width&#10;        self.map_height = map_height&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1)&#10;&#10;    def update(self):&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP)&#10;        target_x = self.target.x&#10;        target_y = self.target.y&#10;        self.x += (target_x - self.x) * self.smooth&#10;        self.y += (target_y - self.y) * self.smooth&#10;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#10;        min_x = -self.map_width/2&#10;        max_x = self.map_width/2&#10;        min_y = -self.map_height/2&#10;        max_y = self.map_height/2&#10;&#10;        self.x = max(min_x, min(self.x, max_x))&#10;        self.y = max(min_y, min(self.y, max_y))&#10;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#10;        if self.map_width &lt;= self.screen_width:&#10;            self.x = 0&#10;        if self.map_height &lt;= self.screen_height:&#10;            self.y = 0&#10;        # self.x, self.y는 맵 중심 기준 카메라 위치&#10;        # 화면 중앙이 (0,0)이 되도록 보정&#10;&#10;    def apply(self, obj_x, obj_y):&#10;        # 카메라 위치만큼 오브젝트 위치 보정 (화면 중앙 기준)&#10;        # obj_x, obj_y: 맵 중심(0,0) 기준 좌표&#10;        # 반환값: 화면에 그릴 좌표 (pico2d 기준, 화면 중앙이 0,0)&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#10;&#10;# Camera 객체를 전역으로 선언&#10;camera = None&#10;&#10;def calculate_background_bounds():&#10;    &quot;&quot;&quot;&#10;    sky와 ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#10;&#10;    Returns:&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#10;    &quot;&quot;&quot;&#10;    min_x = float('inf')&#10;    max_x = float('-inf')&#10;    min_y = float('inf')&#10;    max_y = float('-inf')&#10;&#10;    # sky와 ground 레이어의 모든 객체를 순회&#10;    for layer_name in ['sky', 'ground']:&#10;        for obj in world[layer_name]:&#10;            # 객체가 x, y, image, scale 속성을 가지고 있는지 확인&#10;            if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image') and hasattr(obj, 'scale'):&#10;                # 객체의 중심 좌표&#10;                obj_x = obj.x&#10;                obj_y = obj.y&#10;&#10;                # 이미지 크기 계산 (scale 적용)&#10;                img_width = obj.image.w * obj.scale&#10;                img_height = obj.image.h * obj.scale&#10;&#10;                # 객체의 경계 계산 (중심 기준이므로 절반씩)&#10;                obj_left = obj_x - img_width / 2&#10;                obj_right = obj_x + img_width / 2&#10;                obj_bottom = obj_y - img_height / 2&#10;                obj_top = obj_y + img_height / 2&#10;&#10;                # 최소/최대 값 업데이트&#10;                min_x = min(min_x, obj_left)&#10;                max_x = max(max_x, obj_right)&#10;                min_y = min(min_y, obj_bottom)&#10;                max_y = max(max_y, obj_top)&#10;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환&#10;    if min_x == float('inf') or max_x == float('-inf'):&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#10;        return (-800, 800, -600, 600)&#10;&#10;    print(f&quot;[lobby_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#10;    return (min_x, max_x, min_y, max_y)&#10;&#10;def enter():&#10;    global world, camera&#10;    print(&quot;[lobby_mode] Starting enter()...&quot;)&#10;&#10;    # clear existing&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#10;&#10;    # sky&#10;    print(&quot;[lobby_mode] Creating Sky...&quot;)&#10;    whiteBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/WhiteBG.png'&#10;    skyBackGroundPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloudBall_Gradation.png'&#10;    skyBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Back.png'&#10;    skyMidPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Mid.png'&#10;    skyFrontPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Front.png'&#10;    cloudPropPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Prop.png'&#10;    whiteBack = LobbySky(whiteBackPath, 0, 0, 6.5)&#10;    skyBackGround = LobbySky(skyBackGroundPath, 0, 0, 5.4)&#10;    skyBack = LobbySky(skyBackPath, 0, 200)&#10;    skyMid = LobbySky(skyMidPath, 0, 0)&#10;    skyFront = LobbySky(skyFrontPath, 0, -200)&#10;    cloudProp = LobbySky(cloudPropPath, 0, -400)&#10;&#10;    world['sky'].append(whiteBack)&#10;    world['sky'].append(skyBackGround)&#10;    world['sky'].append(skyBack)&#10;    world['sky'].append(skyMid)&#10;    world['sky'].append(skyFront)&#10;    world['sky'].append(cloudProp)&#10;&#10;    # background&#10;    print(&quot;[lobby_mode] Creating Background...&quot;)&#10;    bg = LobbyBackGround()&#10;    world['bg'].append(bg)&#10;&#10;    # 낭떠러지(투명 영역) 벽 자동 생성&#10;    try:&#10;        print(&quot;[DEBUG] wall_blocks 생성 시도 중...&quot;)&#10;        # 배경의 화면 위치와 스케일을 전달&#10;        wall_blocks = generate_walls_from_png(&#10;            'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png',&#10;            block_size=8,&#10;            bg_x=bg.x,&#10;            bg_y=bg.y,&#10;            scale=bg.scale&#10;        )&#10;        print(f&quot;[DEBUG] wall_blocks 반환: {len(wall_blocks)}개&quot;)&#10;        for wall in wall_blocks:&#10;            world['walls'].append(wall)&#10;            pass&#10;        print(f&quot;[lobby_mode] Generated {len(wall_blocks)} walls from PNG transparency.&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Wall generation from PNG failed: {ex}\033[0m&quot;)&#10;&#10;    # create portal to play mode&#10;    print(&quot;[lobby_mode] Creating EnterTreePortal...&quot;)&#10;    try:&#10;        # 백그라운드 이미지와 스케일에 맞춰 가로 중앙, 세로는 위에서 30% 아래에 배치&#10;        portal_x = bg.x&#10;        portal_y = bg.y + (bg.image.h * bg.scale) / 2 - (bg.image.h * bg.scale) * 0.3&#10;        enterTree = EnterTreePortal(portal_x, portal_y, scale=bg.scale)&#10;        world['upper_ground'].append(enterTree)&#10;        print(f&quot;[lobby_mode] EnterTreePortal created at ({portal_x}, {portal_y}) with scale {bg.scale}&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Failed to create EnterTreePortal: {ex}\033[0m&quot;)&#10;&#10;    print(&quot;[lobby_mode] Creating player...&quot;)&#10;    # create player (use fallback if heavy Player init fails)&#10;    try:&#10;        player = Player()&#10;        player.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;        player.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;        print(&quot;[lobby_mode] Player created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#10;        from .inventory import InventoryData, seed_debug_inventory&#10;&#10;        class _FallbackPlayer:&#10;            def __init__(self):&#10;                self.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;                self.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;                self.face_dir = 1&#10;                self.scale_factor = 1.0&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;                self.particles = []&#10;                self.attack_effects = []&#10;                self.inventory = InventoryData(cols=6, rows=5)&#10;                try:&#10;                    seed_debug_inventory(self.inventory)&#10;                except Exception:&#10;                    print(&quot;\033[91m[lobby_mode] seed_debug_inventory failed\033[0m&quot;)&#10;                    pass&#10;                self.inventory_open = False&#10;&#10;            def update(self):&#10;                return True&#10;&#10;            def rebuild_inventory_passives(self):&#10;                return&#10;&#10;            def consume_item_at(self, r, c):&#10;                return False&#10;&#10;        player = _FallbackPlayer()&#10;&#10;    print(&quot;[lobby_mode] Attaching world reference to player...&quot;)&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#10;    try:&#10;        player.world = world&#10;    except Exception:&#10;        print(&quot;\033[91m[lobby_mode] Failed to attach world to player\033[0m&quot;)&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#10;    world['entities'].append(player)&#10;&#10;    # Camera 초기화 (Player를 target으로 설정)&#10;    # sky와 ground 레이어의 실제 배경 범위를 계산하여 카메라 제한 범위로 사용&#10;    try:&#10;        # 배경 범위 계산 (sky와 ground 레이어의 모든 객체 고려)&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;&#10;        # 배경 전체 크기 계산&#10;        map_width = max_x - min_x&#10;        map_height = max_y - min_y&#10;&#10;        screen_width = p2.get_canvas_width()&#10;        screen_height = p2.get_canvas_height()&#10;&#10;        global camera&#10;        camera = Camera(player, map_width, map_height, screen_width, screen_height)&#10;&#10;        # 카메라에 실제 배경 범위의 중심점 정보 전달 (오프셋 계산용)&#10;        camera.map_offset_x = (min_x + max_x) / 2&#10;        camera.map_offset_y = (min_y + max_y) / 2&#10;&#10;        print(f&quot;[lobby_mode] Camera initialized for player at ({player.x}, {player.y})&quot;)&#10;        print(f&quot;[lobby_mode] Map size: {map_width:.1f} x {map_height:.1f}, Offset: ({camera.map_offset_x:.1f}, {camera.map_offset_y:.1f})&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Camera initialization failed: {ex}\033[0m&quot;)&#10;&#10;    print(&quot;[lobby_mode] Creating inventory overlay...&quot;)&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#10;    try:&#10;        inv = InventoryOverlay(player, world)&#10;        print(&quot;[lobby_mode] InventoryOverlay created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] InventoryOverlay init failed, creating minimal stub: {ex}\033[0m&quot;)&#10;&#10;        class _InvStub:&#10;            def __init__(self, player, world=None):&#10;                self.player = player&#10;                self.world = world&#10;                self.dragging = False&#10;                self.drag_from = None&#10;                self.drag_icon = None&#10;                self.drag_qty = 0&#10;            def handle_event(self, e):&#10;                return&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        inv = _InvStub(player, world)&#10;    world['ui'].append(inv)&#10;&#10;    print(&quot;[lobby_mode] Creating cursor...&quot;)&#10;    # cursor on top (safe fallback)&#10;    try:&#10;        cursor = Cursor(player)&#10;        print(&quot;[lobby_mode] Cursor created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Cursor init failed, using stub cursor: {ex}\033[0m&quot;)&#10;&#10;        class _CursorStub:&#10;            def __init__(self, player=None):&#10;                self.player = player&#10;                self.x = 0&#10;                self.y = 0&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;            def handle_event(self, e):&#10;                return&#10;&#10;        cursor = _CursorStub(player)&#10;    world['cursor'].append(cursor)&#10;&#10;    # expose world to __main__ for legacy code that looks up main.world&#10;    try:&#10;        import sys&#10;        main_mod = sys.modules.get('__main__')&#10;        if main_mod is not None:&#10;            setattr(main_mod, 'world', world)&#10;    except Exception:&#10;        print(&quot;\033[91m[lobby_mode] Failed to expose world to __main__\033[0m&quot;)&#10;&#10;&#10;def exit():&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#10;&#10;&#10;def handle_events():&#10;    import game_framework as app_framework&#10;&#10;    events = p2.get_events()&#10;    player = world.get('player')&#10;    portal_triggered = False&#10;&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            app_framework.quit()&#10;            return&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#10;            app_framework.quit()&#10;            return&#10;        # F키 입력 시 포탈 충돌 체크&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == p2.SDLK_f:&#10;            for obj in world['upper_ground']:&#10;                if isinstance(obj, EnterTreePortal) and player:&#10;                    if obj.check_player_collision(player):&#10;                        if not portal_triggered:&#10;                            from . import play_mode&#10;                            print('[lobby_mode] EnterTreePortal triggered: switching to play_mode')&#10;                            app_framework.change_state(play_mode)&#10;                            portal_triggered = True&#10;&#10;        # broadcast to entities -&gt; ui -&gt; cursor&#10;        for o in list(world['entities']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for entity\033[0m&quot;)&#10;        for o in list(world['ui']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for UI\033[0m&quot;)&#10;        for o in list(world['cursor']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for cursor\033[0m&quot;)&#10;&#10;&#10;def update():&#10;    global camera&#10;    # 카메라 업데이트 추가&#10;    if camera is not None:&#10;        camera.update()&#10;&#10;    # 일반 게임 업데이트&#10;    for layer_name in world_list:&#10;        new_list = []&#10;        for o in list(world[layer_name]):&#10;            try:&#10;                if hasattr(o, 'update'):&#10;                    alive = o.update()&#10;                    if alive is False:&#10;                        continue&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to update object\033[0m&quot;)&#10;&#10;            # mark_for_removal 플래그 확인&#10;            if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#10;                print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#10;                continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#10;&#10;            new_list.append(o)&#10;        world[layer_name][:] = new_list&#10;&#10;    # 충돌 검사 시스템&#10;    from .projectile import Projectile&#10;    player = world.get('player')&#10;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#10;    effects_to_remove = set()&#10;    projectiles_to_remove = set()&#10;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#10;    for effect in world['effects_front']:&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#10;            for entity in world['entities']:&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#10;                    if entity.check_collision_with_effect(effect):&#10;                        # 디버그: 충돌 정보 출력&#10;                        attacker_name = &quot;Player&quot;&#10;                        if hasattr(effect, 'owner'):&#10;                            attacker_name = effect.owner.__class__.__name__&#10;                        target_name = entity.__class__.__name__&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#10;                        pass&#10;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#10;    if player:&#10;        for projectile in world['effects_front']:&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#10;            if isinstance(projectile, Projectile):&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#10;                if not projectile.from_player:&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#10;                        if player.check_collision_with_projectile(projectile):&#10;                            # 디버그: 충돌 정보 출력&#10;                            attacker_name = &quot;Unknown&quot;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#10;                                attacker_name = projectile.owner.__class__.__name__&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#10;                            projectiles_to_remove.add(projectile)&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#10;                else:&#10;                    for entity in world['entities']:&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#10;                            if entity.check_collision_with_projectile(projectile):&#10;                                # 디버그: 충돌 정보 출력&#10;                                target_name = entity.__class__.__name__&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#10;                                projectiles_to_remove.add(projectile)&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#10;&#10;    # 충돌한 투사체 제거&#10;    if projectiles_to_remove:&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#10;&#10;    # 포탈 위에 텍스트 표시&#10;    for obj in world['upper_ground']:&#10;        if isinstance(obj, EnterTreePortal) and player:&#10;            if obj.check_player_collision(player):&#10;                obj.trigger = True&#10;            else:&#10;                obj.trigger = False&#10;&#10;def draw():&#10;    global camera&#10;    p2.clear_canvas()&#10;    # 하늘을 가장 먼저 그리기 (배경 뒤)&#10;    for obj in world['sky']:&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y'):&#10;            if camera is not None:&#10;                draw_x, draw_y = camera.apply(obj.x, obj.y)&#10;            else:&#10;                draw_x, draw_y = obj.x, obj.y&#10;            if hasattr(obj, 'draw'):&#10;                obj.draw(draw_x, draw_y)&#10;        else:&#10;            if hasattr(obj, 'draw'):&#10;                obj.draw()&#10;&#10;    # 나머지 레이어들 (배경, 벽, 엔티티 등)&#10;    for layer in ['ground', 'walls', 'upper_ground', 'entities', 'effects_back', 'effects_front', 'extra_bg', 'extras']:&#10;        for obj in world[layer]:&#10;            if hasattr(obj, 'x') and hasattr(obj, 'y'):&#10;                if camera is not None:&#10;                    draw_x, draw_y = camera.apply(obj.x, obj.y)&#10;                else:&#10;                    draw_x, draw_y = obj.x, obj.y&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw(draw_x, draw_y)&#10;            else:&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw()&#10;    # UI, cursor 등은 카메라 적용하지 않음&#10;    for obj in world['ui']:&#10;        if hasattr(obj, 'draw'):&#10;            obj.draw()&#10;    for obj in world['cursor']:&#10;        if hasattr(obj, 'draw'):&#10;            obj.draw()&#10;    p2.update_canvas()&#10;&#10;class LobbySky:&#10;    def __init__(self, path, x=0, y=0, scale=3):&#10;        self.image = p2.load_image(path)&#10;        self.scale = scale&#10;        self.x = x  # 화면 중심(0,0) 기준&#10;        self.y = y  # 화면 중심(0,0) 기준&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        self.image.draw(draw_x, draw_y, self.image.w * self.scale * 2,&#10;                        self.image.h * self.scale * 1.5)&#10;        # 디버그용 히트박스 (필요시 주석 처리)&#10;        # p2.draw_rectangle(draw_x - (self.image.w * self.scale) / 2,&#10;        #                   draw_y - (self.image.h * self.scale) / 2,&#10;        #                   draw_x + (self.image.w * self.scale) / 2,&#10;        #                   draw_y + (self.image.h * self.scale) / 2)&#10;&#10;&#10;class LobbyBackGround:&#10;    image = None&#10;    def __init__(self):&#10;        if LobbyBackGround.image is None:&#10;            LobbyBackGround.image = p2.load_image('resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png')&#10;        self.scale = 6.5&#10;        self.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;        self.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        LobbyBackGround.image.draw(draw_x, draw_y, LobbyBackGround.image.w * self.scale, LobbyBackGround.image.h * self.scale)&#10;        # p2.draw_rectangle(draw_x - (LobbyBackGround.image.w * self.scale) / 2,&#10;        #                   draw_y - (LobbyBackGround.image.h * self.scale) / 2,&#10;        #                   draw_x + (LobbyBackGround.image.w * self.scale) / 2,&#10;        #                   draw_y + (LobbyBackGround.image.h * self.scale) / 2)&#10;&#10;class EnterTreePortal:&#10;    # frame lists (class-level so images are loaded only once)&#10;    portalImagesBegin = []&#10;    portalImagesCycle = []&#10;    portalFXBegin = []&#10;    portalFXCycle = []&#10;    loaded = False&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # load images once (safe: catch missing files)&#10;        if not EnterTreePortal.loaded:&#10;            try:&#10;                for i in range(18):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Begin{i:02d}.png'&#10;                    EnterTreePortal.portalImagesBegin.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalImagesBegin = []&#10;            try:&#10;                # cycle uses a single image in original assets, but keep as list for consistency&#10;                EnterTreePortal.portalImagesCycle.append(p2.load_image('resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Cycle00.png'))&#10;            except Exception:&#10;                EnterTreePortal.portalImagesCycle = []&#10;            try:&#10;                for i in range(18):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Begin{i:02d}.png'&#10;                    EnterTreePortal.portalFXBegin.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalFXBegin = []&#10;            try:&#10;                for i in range(11):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Cycle{i:02d}.png'&#10;                    EnterTreePortal.portalFXCycle.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalFXCycle = []&#10;            EnterTreePortal.loaded = True&#10;&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;        # self.trigger_radius = 50  # 플레이어가 접근해야 하는 반경&#10;        self.trigger = False&#10;&#10;        # animation state&#10;        self.begin_animation_done = False&#10;        self.frame_idx = 0&#10;        self.fx_idx = 0&#10;        self.frame_dt = 0.0&#10;        self.fx_dt = 0.0&#10;        self.frame_duration = 0.06  # seconds per frame&#10;        self.fx_duration = 0.06&#10;        self.last_time = p2.get_time()&#10;&#10;    def update(self):&#10;        # advance animation based on time delta&#10;        now = p2.get_time()&#10;        dt = now - getattr(self, 'last_time', now)&#10;        self.last_time = now&#10;        # update portal image animation&#10;        self.frame_dt += dt&#10;        if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#10;            # play begin sequence once&#10;            if self.frame_dt &gt;= self.frame_duration:&#10;                steps = int(self.frame_dt / self.frame_duration)&#10;                self.frame_dt -= steps * self.frame_duration&#10;                self.frame_idx += steps&#10;                if self.frame_idx &gt;= len(EnterTreePortal.portalImagesBegin):&#10;                    # start cycle&#10;                    self.begin_animation_done = True&#10;                    self.frame_idx = 0&#10;        else:&#10;            # loop cycle frames&#10;            if EnterTreePortal.portalImagesCycle:&#10;                if self.frame_dt &gt;= self.frame_duration:&#10;                    steps = int(self.frame_dt / self.frame_duration)&#10;                    self.frame_dt -= steps * self.frame_duration&#10;                    self.frame_idx = (self.frame_idx + steps) % max(1, len(EnterTreePortal.portalImagesCycle))&#10;&#10;        # update FX animation: try to play begin and then cycle&#10;        self.fx_dt += dt&#10;        if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#10;            if self.fx_dt &gt;= self.fx_duration:&#10;                steps = int(self.fx_dt / self.fx_duration)&#10;                self.fx_dt -= steps * self.fx_duration&#10;                self.fx_idx += steps&#10;                # clamp fx_idx so it doesn't grow unbounded; allow it to loop during begin&#10;                if self.fx_idx &gt;= len(EnterTreePortal.portalFXBegin):&#10;                    self.fx_idx = 0&#10;        else:&#10;            if EnterTreePortal.portalFXCycle:&#10;                if self.fx_dt &gt;= self.fx_duration:&#10;                    steps = int(self.fx_dt / self.fx_duration)&#10;                    self.fx_dt -= steps * self.fx_duration&#10;                    self.fx_idx = (self.fx_idx + steps) % max(1, len(EnterTreePortal.portalFXCycle))&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw portal image (begin or cycle)&#10;        try:&#10;            if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#10;                img = EnterTreePortal.portalImagesBegin[min(self.frame_idx, len(EnterTreePortal.portalImagesBegin)-1)]&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;            elif EnterTreePortal.portalImagesCycle:&#10;                img = EnterTreePortal.portalImagesCycle[self.frame_idx % len(EnterTreePortal.portalImagesCycle)]&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;        except Exception:&#10;            # drawing failure should not crash the game&#10;            pass&#10;&#10;        # draw FX overlay&#10;        try:&#10;            if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#10;                fx = EnterTreePortal.portalFXBegin[self.fx_idx % len(EnterTreePortal.portalFXBegin)]&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#10;            elif EnterTreePortal.portalFXCycle:&#10;                fx = EnterTreePortal.portalFXCycle[self.fx_idx % len(EnterTreePortal.portalFXCycle)]&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#10;        except Exception:&#10;            pass&#10;&#10;        # 포탈 위에 텍스트 그리기&#10;        if self.trigger:&#10;            try:&#10;                # print(f'[lobby_mode] Drawing portal text at ({draw_x}, {draw_y})')&#10;                font = p2.load_font('resources/Fonts/pixelroborobo.otf', 20)&#10;                text = &quot;[F] 모험하기&quot;&#10;                font_size = 40&#10;                approx_width = int(len(text) * font_size * 0.4)&#10;                font.draw(draw_x - approx_width // 2, draw_y + 10 * self.scale, text, (255, 255, 0))&#10;            except Exception as ex:&#10;                print(f'[lobby_mode] 포탈 텍스트 그리기 실패: {ex}')&#10;&#10;    def check_player_collision(self, player):&#10;        # 플레이어와 포탈의 히트박스 충돌 검사&#10;        # 플레이어의 크기(w, h)는 기본값 32x32로 가정, 필요시 Player에서 가져올 것&#10;        px = getattr(player, 'x', 0)&#10;        py = getattr(player, 'y', 0)&#10;        pw = getattr(player, 'w', 32)&#10;        ph = getattr(player, 'h', 32)&#10;        # 포탈의 히트박스는 중심 기준, 크기는 이미지 크기 * scale * 0.5 (적당히 조정)&#10;        portal_w = 61 * self.scale&#10;        portal_h = 47 * self.scale&#10;        portal_x = self.x - portal_w / 2&#10;        portal_y = self.y - portal_h / 2&#10;        return (px &lt; portal_x + portal_w and px + pw &gt; portal_x and&#10;                py &lt; portal_y + portal_h and py + ph &gt; portal_y)&#10;&#10;class LobbyWall:&#10;    def __init__(self, x, y, w, h):&#10;        self.x = x&#10;        self.y = y&#10;        self.w = w&#10;        self.h = h&#10;&#10;&#10;    def check_collision(self, px, py, pw, ph):&#10;        # 플레이어와 벽의 사각형 충돌 검사&#10;        return (self.x &lt; px + pw and self.x + self.w &gt; px and&#10;                self.y &lt; py + ph and self.y + self.h &gt; py)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 카메라 적용 좌표로 벽 영역을 빨간색으로 표시&#10;        try:&#10;            # p2.draw_rectangle(draw_x, draw_y, draw_x + self.w, draw_y + self.h)&#10;            pass&#10;        except Exception as ex:&#10;            print(f'[LobbyWall] draw() 실패 at ({draw_x}, {draw_y}, {self.w}, {self.h}), Exception {ex}')&#10;&#10;def generate_walls_from_png(png_path, block_size=16, bg_x=None, bg_y=None, scale=1.0):&#10;    print(f&quot;[DEBUG] generate_walls_from_png 시작: {png_path}, block_size={block_size}, bg_x={bg_x}, bg_y={bg_y}, scale={scale}&quot;)&#10;    try:&#10;        img = Image.open(png_path).convert('RGBA')&#10;    except Exception as ex:&#10;        print(f&quot;[DEBUG] 이미지 열기 실패: {ex}&quot;)&#10;        return []&#10;    width, height = img.size&#10;    walls = []&#10;    pixels = img.load()&#10;    transparent_count = 0&#10;    # 배경 이미지의 화면 내 좌표계 기준 좌표 계산&#10;    if bg_x is None: bg_x = width * scale / 2&#10;    if bg_y is None: bg_y = height * scale / 2&#10;    screen_left = bg_x - (width * scale) / 2&#10;    screen_top = bg_y + (height * scale) / 2&#10;    for y in range(0, height, block_size):&#10;        for x in range(0, width, block_size):&#10;            is_transparent = False&#10;            for dy in range(block_size):&#10;                for dx in range(block_size):&#10;                    if x+dx &lt; width and y+dy &lt; height:&#10;                        _, _, _, alpha = pixels[x+dx, y+dy]&#10;                        if alpha == 0:&#10;                            is_transparent = True&#10;                            transparent_count += 1&#10;                            break&#10;                if is_transparent:&#10;                    break&#10;            if is_transparent:&#10;                # 이미지 좌표를 화면 좌표로 변환 (좌상단 기준)&#10;                wall_x_img = x&#10;                wall_y_img = height - y - block_size&#10;                wall_x_screen = screen_left + wall_x_img * scale&#10;                wall_y_screen = bg_y - (height * scale) / 2 + wall_y_img * scale&#10;                walls.append(LobbyWall(wall_x_screen, wall_y_screen, block_size * scale, block_size * scale))&#10;    print(f&quot;[DEBUG] 투명 픽셀 수: {transparent_count}, 생성된 벽 수: {len(walls)}&quot;)&#10;    return walls&#10;" />
              <option name="updatedContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#10;# minimal, compatible with existing game_logic modules&#10;import pico2d as p2&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#10;&#10;import game_framework&#10;from .player import Player&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar&#10;from .cursor import Cursor&#10;from .loading_screen import LoadingScreen&#10;from . import defeat_mode&#10;# 사용할 스테이지 모듈들을 import 합니다.&#10;from .stages import stage_1, stage_2&#10;from PIL import Image&#10;import math&#10;&#10;# world layers: keep same keys as original main.py&#10;world = {&#10;    'sky' : [],&#10;    'ground': [],&#10;    'upper_ground': [],&#10;    'walls': [],&#10;    'effects_back': [],&#10;    'entities': [],&#10;    'effects_front': [],&#10;    'ui': [],&#10;    'extra_bg': [],&#10;    'extras': [],&#10;    'cursor': []&#10;}&#10;world['bg'] = world['ground']&#10;world['player'] = world['entities']  # 플레이어 참조를 위한 키 추가&#10;world_list = ['sky', 'ground', 'upper_ground', 'walls', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']&#10;&#10;class Camera:&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#10;        self.target = target&#10;        self.x = target.x&#10;        self.y = target.y&#10;        self.map_width = map_width&#10;        self.map_height = map_height&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1)&#10;&#10;    def update(self):&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP)&#10;        target_x = self.target.x&#10;        target_y = self.target.y&#10;        self.x += (target_x - self.x) * self.smooth&#10;        self.y += (target_y - self.y) * self.smooth&#10;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#10;        min_x = -self.map_width/2&#10;        max_x = self.map_width/2&#10;        min_y = -self.map_height/2&#10;        max_y = self.map_height/2&#10;&#10;        self.x = max(min_x, min(self.x, max_x))&#10;        self.y = max(min_y, min(self.y, max_y))&#10;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#10;        if self.map_width &lt;= self.screen_width:&#10;            self.x = 0&#10;        if self.map_height &lt;= self.screen_height:&#10;            self.y = 0&#10;        # self.x, self.y는 맵 중심 기준 카메라 위치&#10;        # 화면 중앙이 (0,0)이 되도록 보정&#10;&#10;    def apply(self, obj_x, obj_y):&#10;        # 카메라 위치만큼 오브젝트 위치 보정 (화면 중앙 기준)&#10;        # obj_x, obj_y: 맵 중심(0,0) 기준 좌표&#10;        # 반환값: 화면에 그릴 좌표 (pico2d 기준, 화면 중앙이 0,0)&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#10;&#10;# Camera 객체를 전역으로 선언&#10;camera = None&#10;&#10;def calculate_background_bounds():&#10;    &quot;&quot;&quot;&#10;    sky와 ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#10;&#10;    Returns:&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#10;    &quot;&quot;&quot;&#10;    min_x = float('inf')&#10;    max_x = float('-inf')&#10;    min_y = float('inf')&#10;    max_y = float('-inf')&#10;&#10;    # sky와 ground 레이어의 모든 객체를 순회&#10;    for layer_name in ['sky', 'ground']:&#10;        for obj in world[layer_name]:&#10;            # 객체가 x, y, image, scale 속성을 가지고 있는지 확인&#10;            if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image') and hasattr(obj, 'scale'):&#10;                # 객체의 중심 좌표&#10;                obj_x = obj.x&#10;                obj_y = obj.y&#10;&#10;                # 이미지 크기 계산 (scale 적용)&#10;                img_width = obj.image.w * obj.scale&#10;                img_height = obj.image.h * obj.scale&#10;&#10;                # 객체의 경계 계산 (중심 기준이므로 절반씩)&#10;                obj_left = obj_x - img_width / 2&#10;                obj_right = obj_x + img_width / 2&#10;                obj_bottom = obj_y - img_height / 2&#10;                obj_top = obj_y + img_height / 2&#10;&#10;                # 최소/최대 값 업데이트&#10;                min_x = min(min_x, obj_left)&#10;                max_x = max(max_x, obj_right)&#10;                min_y = min(min_y, obj_bottom)&#10;                max_y = max(max_y, obj_top)&#10;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환&#10;    if min_x == float('inf') or max_x == float('-inf'):&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#10;        return (-800, 800, -600, 600)&#10;&#10;    print(f&quot;[lobby_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#10;    return (min_x, max_x, min_y, max_y)&#10;&#10;def enter():&#10;    global world, camera&#10;    print(&quot;[lobby_mode] Starting enter()...&quot;)&#10;&#10;    # clear existing&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#10;&#10;    # sky&#10;    print(&quot;[lobby_mode] Creating Sky...&quot;)&#10;    whiteBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/WhiteBG.png'&#10;    skyBackGroundPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloudBall_Gradation.png'&#10;    skyBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Back.png'&#10;    skyMidPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Mid.png'&#10;    skyFrontPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Front.png'&#10;    cloudPropPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Prop.png'&#10;    whiteBack = LobbySky(whiteBackPath, 0, 0, 6.5)&#10;    skyBackGround = LobbySky(skyBackGroundPath, 0, 0, 5.4)&#10;    skyBack = LobbySky(skyBackPath, 0, 200)&#10;    skyMid = LobbySky(skyMidPath, 0, 0)&#10;    skyFront = LobbySky(skyFrontPath, 0, -200)&#10;    cloudProp = LobbySky(cloudPropPath, 0, -400)&#10;&#10;    world['sky'].append(whiteBack)&#10;    world['sky'].append(skyBackGround)&#10;    world['sky'].append(skyBack)&#10;    world['sky'].append(skyMid)&#10;    world['sky'].append(skyFront)&#10;    world['sky'].append(cloudProp)&#10;&#10;    # background&#10;    print(&quot;[lobby_mode] Creating Background...&quot;)&#10;    bg = LobbyBackGround()&#10;    world['bg'].append(bg)&#10;&#10;    # 낭떠러지(투명 영역) 벽 자동 생성&#10;    try:&#10;        print(&quot;[DEBUG] wall_blocks 생성 시도 중...&quot;)&#10;        # 배경의 화면 위치와 스케일을 전달&#10;        wall_blocks = generate_walls_from_png(&#10;            'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png',&#10;            block_size=8,&#10;            bg_x=bg.x,&#10;            bg_y=bg.y,&#10;            scale=bg.scale&#10;        )&#10;        print(f&quot;[DEBUG] wall_blocks 반환: {len(wall_blocks)}개&quot;)&#10;        for wall in wall_blocks:&#10;            world['walls'].append(wall)&#10;            pass&#10;        print(f&quot;[lobby_mode] Generated {len(wall_blocks)} walls from PNG transparency.&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Wall generation from PNG failed: {ex}\033[0m&quot;)&#10;&#10;    # create portal to play mode&#10;    print(&quot;[lobby_mode] Creating EnterTreePortal...&quot;)&#10;    try:&#10;        # 백그라운드 이미지와 스케일에 맞춰 가로 중앙, 세로는 위에서 30% 아래에 배치&#10;        portal_x = bg.x&#10;        portal_y = bg.y + (bg.image.h * bg.scale) / 2 - (bg.image.h * bg.scale) * 0.3&#10;        enterTree = EnterTreePortal(portal_x, portal_y, scale=bg.scale)&#10;        world['upper_ground'].append(enterTree)&#10;        print(f&quot;[lobby_mode] EnterTreePortal created at ({portal_x}, {portal_y}) with scale {bg.scale}&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Failed to create EnterTreePortal: {ex}\033[0m&quot;)&#10;&#10;    print(&quot;[lobby_mode] Creating player...&quot;)&#10;    # create player (use fallback if heavy Player init fails)&#10;    try:&#10;        player = Player()&#10;        player.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;        player.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;        print(&quot;[lobby_mode] Player created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#10;        from .inventory import InventoryData, seed_debug_inventory&#10;&#10;        class _FallbackPlayer:&#10;            def __init__(self):&#10;                self.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;                self.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;                self.face_dir = 1&#10;                self.scale_factor = 1.0&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;                self.particles = []&#10;                self.attack_effects = []&#10;                self.inventory = InventoryData(cols=6, rows=5)&#10;                try:&#10;                    seed_debug_inventory(self.inventory)&#10;                except Exception:&#10;                    print(&quot;\033[91m[lobby_mode] seed_debug_inventory failed\033[0m&quot;)&#10;                    pass&#10;                self.inventory_open = False&#10;&#10;            def update(self):&#10;                return True&#10;&#10;            def rebuild_inventory_passives(self):&#10;                return&#10;&#10;            def consume_item_at(self, r, c):&#10;                return False&#10;&#10;        player = _FallbackPlayer()&#10;&#10;    print(&quot;[lobby_mode] Attaching world reference to player...&quot;)&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#10;    try:&#10;        player.world = world&#10;    except Exception:&#10;        print(&quot;\033[91m[lobby_mode] Failed to attach world to player\033[0m&quot;)&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#10;    world['entities'].append(player)&#10;&#10;    # Camera 초기화 (Player를 target으로 설정)&#10;    # sky와 ground 레이어의 실제 배경 범위를 계산하여 카메라 제한 범위로 사용&#10;    try:&#10;        # 배경 범위 계산 (sky와 ground 레이어의 모든 객체 고려)&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;&#10;        # 배경 전체 크기 계산&#10;        map_width = max_x - min_x&#10;        map_height = max_y - min_y&#10;&#10;        screen_width = p2.get_canvas_width()&#10;        screen_height = p2.get_canvas_height()&#10;&#10;        global camera&#10;        camera = Camera(player, map_width, map_height, screen_width, screen_height)&#10;&#10;        # 카메라에 실제 배경 범위의 중심점 정보 전달 (오프셋 계산용)&#10;        camera.map_offset_x = (min_x + max_x) / 2&#10;        camera.map_offset_y = (min_y + max_y) / 2&#10;&#10;        print(f&quot;[lobby_mode] Camera initialized for player at ({player.x}, {player.y})&quot;)&#10;        print(f&quot;[lobby_mode] Map size: {map_width:.1f} x {map_height:.1f}, Offset: ({camera.map_offset_x:.1f}, {camera.map_offset_y:.1f})&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Camera initialization failed: {ex}\033[0m&quot;)&#10;&#10;    print(&quot;[lobby_mode] Creating inventory overlay...&quot;)&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#10;    try:&#10;        inv = InventoryOverlay(player, world)&#10;        print(&quot;[lobby_mode] InventoryOverlay created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] InventoryOverlay init failed, creating minimal stub: {ex}\033[0m&quot;)&#10;&#10;        class _InvStub:&#10;            def __init__(self, player, world=None):&#10;                self.player = player&#10;                self.world = world&#10;                self.dragging = False&#10;                self.drag_from = None&#10;                self.drag_icon = None&#10;                self.drag_qty = 0&#10;            def handle_event(self, e):&#10;                return&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        inv = _InvStub(player, world)&#10;    world['ui'].append(inv)&#10;&#10;    print(&quot;[lobby_mode] Creating cursor...&quot;)&#10;    # cursor on top (safe fallback)&#10;    try:&#10;        cursor = Cursor(player)&#10;        print(&quot;[lobby_mode] Cursor created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Cursor init failed, using stub cursor: {ex}\033[0m&quot;)&#10;&#10;        class _CursorStub:&#10;            def __init__(self, player=None):&#10;                self.player = player&#10;                self.x = 0&#10;                self.y = 0&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;            def handle_event(self, e):&#10;                return&#10;&#10;        cursor = _CursorStub(player)&#10;    world['cursor'].append(cursor)&#10;&#10;    # expose world to __main__ for legacy code that looks up main.world&#10;    try:&#10;        import sys&#10;        main_mod = sys.modules.get('__main__')&#10;        if main_mod is not None:&#10;            setattr(main_mod, 'world', world)&#10;    except Exception:&#10;        print(&quot;\033[91m[lobby_mode] Failed to expose world to __main__\033[0m&quot;)&#10;&#10;&#10;def exit():&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#10;&#10;&#10;def handle_events():&#10;    import game_framework as app_framework&#10;&#10;    events = p2.get_events()&#10;    player = world.get('player')&#10;    portal_triggered = False&#10;&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            app_framework.quit()&#10;            return&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#10;            app_framework.quit()&#10;            return&#10;        # F키 입력 시 포탈 충돌 체크&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == p2.SDLK_f:&#10;            for obj in world['upper_ground']:&#10;                if isinstance(obj, EnterTreePortal) and player:&#10;                    if obj.check_player_collision(player):&#10;                        if not portal_triggered:&#10;                            from . import play_mode&#10;                            print('[lobby_mode] EnterTreePortal triggered: switching to play_mode')&#10;                            app_framework.change_state(play_mode)&#10;                            portal_triggered = True&#10;&#10;        # broadcast to entities -&gt; ui -&gt; cursor&#10;        for o in list(world['entities']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for entity\033[0m&quot;)&#10;        for o in list(world['ui']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for UI\033[0m&quot;)&#10;        for o in list(world['cursor']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for cursor\033[0m&quot;)&#10;&#10;&#10;def update():&#10;    global camera&#10;    # 카메라 업데이트 추가&#10;    if camera is not None:&#10;        camera.update()&#10;&#10;    # 일반 게임 업데이트&#10;    for layer_name in world_list:&#10;        new_list = []&#10;        for o in list(world[layer_name]):&#10;            try:&#10;                if hasattr(o, 'update'):&#10;                    alive = o.update()&#10;                    if alive is False:&#10;                        continue&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to update object\033[0m&quot;)&#10;&#10;            # mark_for_removal 플래그 확인&#10;            if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#10;                print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#10;                continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#10;&#10;            new_list.append(o)&#10;        world[layer_name][:] = new_list&#10;&#10;    # 충돌 검사 시스템&#10;    from .projectile import Projectile&#10;    player = world.get('player')&#10;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#10;    effects_to_remove = set()&#10;    projectiles_to_remove = set()&#10;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#10;    for effect in world['effects_front']:&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#10;            for entity in world['entities']:&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#10;                    if entity.check_collision_with_effect(effect):&#10;                        # 디버그: 충돌 정보 출력&#10;                        attacker_name = &quot;Player&quot;&#10;                        if hasattr(effect, 'owner'):&#10;                            attacker_name = effect.owner.__class__.__name__&#10;                        target_name = entity.__class__.__name__&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#10;                        pass&#10;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#10;    if player:&#10;        for projectile in world['effects_front']:&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#10;            if isinstance(projectile, Projectile):&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#10;                if not projectile.from_player:&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#10;                        if player.check_collision_with_projectile(projectile):&#10;                            # 디버그: 충돌 정보 출력&#10;                            attacker_name = &quot;Unknown&quot;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#10;                                attacker_name = projectile.owner.__class__.__name__&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#10;                            projectiles_to_remove.add(projectile)&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#10;                else:&#10;                    for entity in world['entities']:&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#10;                            if entity.check_collision_with_projectile(projectile):&#10;                                # 디버그: 충돌 정보 출력&#10;                                target_name = entity.__class__.__name__&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#10;                                projectiles_to_remove.add(projectile)&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#10;&#10;    # 충돌한 투사체 제거&#10;    if projectiles_to_remove:&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#10;&#10;    # 포탈 위에 텍스트 표시&#10;    for obj in world['upper_ground']:&#10;        if isinstance(obj, EnterTreePortal) and player:&#10;            if obj.check_player_collision(player):&#10;                obj.trigger = True&#10;            else:&#10;                obj.trigger = False&#10;&#10;def draw():&#10;    global camera&#10;    p2.clear_canvas()&#10;    # 하늘을 가장 먼저 그리기 (배경 뒤)&#10;    for obj in world['sky']:&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y'):&#10;            if camera is not None:&#10;                draw_x, draw_y = camera.apply(obj.x, obj.y)&#10;            else:&#10;                draw_x, draw_y = obj.x, obj.y&#10;            if hasattr(obj, 'draw'):&#10;                obj.draw(draw_x, draw_y)&#10;        else:&#10;            if hasattr(obj, 'draw'):&#10;                obj.draw()&#10;&#10;    # 나머지 레이어들 (배경, 벽, 엔티티 등)&#10;    for layer in ['ground', 'walls', 'upper_ground', 'entities', 'effects_back', 'effects_front', 'extra_bg', 'extras']:&#10;        for obj in world[layer]:&#10;            if hasattr(obj, 'x') and hasattr(obj, 'y'):&#10;                if camera is not None:&#10;                    draw_x, draw_y = camera.apply(obj.x, obj.y)&#10;                else:&#10;                    draw_x, draw_y = obj.x, obj.y&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw(draw_x, draw_y)&#10;            else:&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw()&#10;    # UI, cursor 등은 카메라 적용하지 않음&#10;    for obj in world['ui']:&#10;        if hasattr(obj, 'draw'):&#10;            obj.draw()&#10;    for obj in world['cursor']:&#10;        if hasattr(obj, 'draw'):&#10;            obj.draw()&#10;    p2.update_canvas()&#10;&#10;class LobbySky:&#10;    def __init__(self, path, x=0, y=0, scale=3):&#10;        self.image = p2.load_image(path)&#10;        self.scale = scale&#10;        self.x = x  # 화면 중심(0,0) 기준&#10;        self.y = y  # 화면 중심(0,0) 기준&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        self.image.draw(draw_x, draw_y, self.image.w * self.scale * 2,&#10;                        self.image.h * self.scale * 1.5)&#10;        # 디버그용 히트박스 (필요시 주석 처리)&#10;        # p2.draw_rectangle(draw_x - (self.image.w * self.scale) / 2,&#10;        #                   draw_y - (self.image.h * self.scale) / 2,&#10;        #                   draw_x + (self.image.w * self.scale) / 2,&#10;        #                   draw_y + (self.image.h * self.scale) / 2)&#10;&#10;&#10;class LobbyBackGround:&#10;    image = None&#10;    def __init__(self):&#10;        if LobbyBackGround.image is None:&#10;            LobbyBackGround.image = p2.load_image('resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png')&#10;        self.scale = 6.5&#10;        self.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;        self.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        LobbyBackGround.image.draw(draw_x, draw_y, LobbyBackGround.image.w * self.scale, LobbyBackGround.image.h * self.scale)&#10;        # p2.draw_rectangle(draw_x - (LobbyBackGround.image.w * self.scale) / 2,&#10;        #                   draw_y - (LobbyBackGround.image.h * self.scale) / 2,&#10;        #                   draw_x + (LobbyBackGround.image.w * self.scale) / 2,&#10;        #                   draw_y + (LobbyBackGround.image.h * self.scale) / 2)&#10;&#10;class EnterTreePortal:&#10;    # frame lists (class-level so images are loaded only once)&#10;    portalImagesBegin = []&#10;    portalImagesCycle = []&#10;    portalFXBegin = []&#10;    portalFXCycle = []&#10;    loaded = False&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # load images once (safe: catch missing files)&#10;        if not EnterTreePortal.loaded:&#10;            try:&#10;                for i in range(18):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Begin{i:02d}.png'&#10;                    EnterTreePortal.portalImagesBegin.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalImagesBegin = []&#10;            try:&#10;                # cycle uses a single image in original assets, but keep as list for consistency&#10;                EnterTreePortal.portalImagesCycle.append(p2.load_image('resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Cycle00.png'))&#10;            except Exception:&#10;                EnterTreePortal.portalImagesCycle = []&#10;            try:&#10;                for i in range(18):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Begin{i:02d}.png'&#10;                    EnterTreePortal.portalFXBegin.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalFXBegin = []&#10;            try:&#10;                for i in range(11):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Cycle{i:02d}.png'&#10;                    EnterTreePortal.portalFXCycle.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalFXCycle = []&#10;            EnterTreePortal.loaded = True&#10;&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;        # self.trigger_radius = 50  # 플레이어가 접근해야 하는 반경&#10;        self.trigger = False&#10;&#10;        # animation state&#10;        self.begin_animation_done = False&#10;        self.frame_idx = 0&#10;        self.fx_idx = 0&#10;        self.frame_dt = 0.0&#10;        self.fx_dt = 0.0&#10;        self.frame_duration = 0.06  # seconds per frame&#10;        self.fx_duration = 0.06&#10;        self.last_time = p2.get_time()&#10;&#10;    def update(self):&#10;        # advance animation based on time delta&#10;        now = p2.get_time()&#10;        dt = now - getattr(self, 'last_time', now)&#10;        self.last_time = now&#10;        # update portal image animation&#10;        self.frame_dt += dt&#10;        if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#10;            # play begin sequence once&#10;            if self.frame_dt &gt;= self.frame_duration:&#10;                steps = int(self.frame_dt / self.frame_duration)&#10;                self.frame_dt -= steps * self.frame_duration&#10;                self.frame_idx += steps&#10;                if self.frame_idx &gt;= len(EnterTreePortal.portalImagesBegin):&#10;                    # start cycle&#10;                    self.begin_animation_done = True&#10;                    self.frame_idx = 0&#10;        else:&#10;            # loop cycle frames&#10;            if EnterTreePortal.portalImagesCycle:&#10;                if self.frame_dt &gt;= self.frame_duration:&#10;                    steps = int(self.frame_dt / self.frame_duration)&#10;                    self.frame_dt -= steps * self.frame_duration&#10;                    self.frame_idx = (self.frame_idx + steps) % max(1, len(EnterTreePortal.portalImagesCycle))&#10;&#10;        # update FX animation: try to play begin and then cycle&#10;        self.fx_dt += dt&#10;        if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#10;            if self.fx_dt &gt;= self.fx_duration:&#10;                steps = int(self.fx_dt / self.fx_duration)&#10;                self.fx_dt -= steps * self.fx_duration&#10;                self.fx_idx += steps&#10;                # clamp fx_idx so it doesn't grow unbounded; allow it to loop during begin&#10;                if self.fx_idx &gt;= len(EnterTreePortal.portalFXBegin):&#10;                    self.fx_idx = 0&#10;        else:&#10;            if EnterTreePortal.portalFXCycle:&#10;                if self.fx_dt &gt;= self.fx_duration:&#10;                    steps = int(self.fx_dt / self.fx_duration)&#10;                    self.fx_dt -= steps * self.fx_duration&#10;                    self.fx_idx = (self.fx_idx + steps) % max(1, len(EnterTreePortal.portalFXCycle))&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw portal image (begin or cycle)&#10;        try:&#10;            if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#10;                img = EnterTreePortal.portalImagesBegin[min(self.frame_idx, len(EnterTreePortal.portalImagesBegin)-1)]&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;            elif EnterTreePortal.portalImagesCycle:&#10;                img = EnterTreePortal.portalImagesCycle[self.frame_idx % len(EnterTreePortal.portalImagesCycle)]&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;        except Exception:&#10;            # drawing failure should not crash the game&#10;            pass&#10;&#10;        # draw FX overlay&#10;        try:&#10;            if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#10;                fx = EnterTreePortal.portalFXBegin[self.fx_idx % len(EnterTreePortal.portalFXBegin)]&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#10;            elif EnterTreePortal.portalFXCycle:&#10;                fx = EnterTreePortal.portalFXCycle[self.fx_idx % len(EnterTreePortal.portalFXCycle)]&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#10;        except Exception:&#10;            pass&#10;&#10;        # 포탈 위에 텍스트 그리기&#10;        if self.trigger:&#10;            try:&#10;                # print(f'[lobby_mode] Drawing portal text at ({draw_x}, {draw_y})')&#10;                font = p2.load_font('resources/Fonts/pixelroborobo.otf', 20)&#10;                text = &quot;[F] 모험하기&quot;&#10;                font_size = 40&#10;                approx_width = int(len(text) * font_size * 0.4)&#10;                font.draw(draw_x - approx_width // 2, draw_y + 10 * self.scale, text, (255, 255, 0))&#10;            except Exception as ex:&#10;                print(f'[lobby_mode] 포탈 텍스트 그리기 실패: {ex}')&#10;&#10;    def check_player_collision(self, player):&#10;        # 플레이어와 포탈의 히트박스 충돌 검사&#10;        # 플레이어의 크기(w, h)는 기본값 32x32로 가정, 필요시 Player에서 가져올 것&#10;        px = getattr(player, 'x', 0)&#10;        py = getattr(player, 'y', 0)&#10;        pw = getattr(player, 'w', 32)&#10;        ph = getattr(player, 'h', 32)&#10;        # 포탈의 히트박스는 중심 기준, 크기는 이미지 크기 * scale * 0.5 (적당히 조정)&#10;        portal_w = 61 * self.scale&#10;        portal_h = 47 * self.scale&#10;        portal_x = self.x - portal_w / 2&#10;        portal_y = self.y - portal_h / 2&#10;        return (px &lt; portal_x + portal_w and px + pw &gt; portal_x and&#10;                py &lt; portal_y + portal_h and py + ph &gt; portal_y)&#10;&#10;class LobbyWall:&#10;    def __init__(self, x, y, w, h):&#10;        self.x = x&#10;        self.y = y&#10;        self.w = w&#10;        self.h = h&#10;&#10;&#10;    def check_collision(self, px, py, pw, ph):&#10;        # 플레이어와 벽의 사각형 충돌 검사&#10;        return (self.x &lt; px + pw and self.x + self.w &gt; px and&#10;                self.y &lt; py + ph and self.y + self.h &gt; py)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 카메라 적용 좌표로 벽 영역을 빨간색으로 표시&#10;        try:&#10;            # p2.draw_rectangle(draw_x, draw_y, draw_x + self.w, draw_y + self.h)&#10;            pass&#10;        except Exception as ex:&#10;            print(f'[LobbyWall] draw() 실패 at ({draw_x}, {draw_y}, {self.w}, {self.h}), Exception {ex}')&#10;&#10;def generate_walls_from_png(png_path, block_size=16, bg_x=None, bg_y=None, scale=1.0):&#10;    print(f&quot;[DEBUG] generate_walls_from_png 시작: {png_path}, block_size={block_size}, bg_x={bg_x}, bg_y={bg_y}, scale={scale}&quot;)&#10;    try:&#10;        img = Image.open(png_path).convert('RGBA')&#10;    except Exception as ex:&#10;        print(f&quot;[DEBUG] 이미지 열기 실패: {ex}&quot;)&#10;        return []&#10;    width, height = img.size&#10;    walls = []&#10;    pixels = img.load()&#10;    transparent_count = 0&#10;    # 배경 이미지의 화면 내 좌표계 기준 좌표 계산&#10;    if bg_x is None: bg_x = width * scale / 2&#10;    if bg_y is None: bg_y = height * scale / 2&#10;    screen_left = bg_x - (width * scale) / 2&#10;    screen_top = bg_y + (height * scale) / 2&#10;    for y in range(0, height, block_size):&#10;        for x in range(0, width, block_size):&#10;            is_transparent = False&#10;            for dy in range(block_size):&#10;                for dx in range(block_size):&#10;                    if x+dx &lt; width and y+dy &lt; height:&#10;                        _, _, _, alpha = pixels[x+dx, y+dy]&#10;                        if alpha == 0:&#10;                            is_transparent = True&#10;                            transparent_count += 1&#10;                            break&#10;                if is_transparent:&#10;                    break&#10;            if is_transparent:&#10;                # 이미지 좌표를 화면 좌표로 변환 (좌상단 기준)&#10;                wall_x_img = x&#10;                wall_y_img = height - y - block_size&#10;                wall_x_screen = screen_left + wall_x_img * scale&#10;                wall_y_screen = bg_y - (height * scale) / 2 + wall_y_img * scale&#10;                walls.append(LobbyWall(wall_x_screen, wall_y_screen, block_size * scale, block_size * scale))&#10;    print(f&quot;[DEBUG] 투명 픽셀 수: {transparent_count}, 생성된 벽 수: {len(walls)}&quot;)&#10;    return walls" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/map.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/map.py" />
              <option name="originalContent" value="# map.py&#10;# Room.txt 기반 간단한 맵 로더 및 타일 엔티티 빌더&#10;# 작성자: 자동 생성&#10;# 사용 가정(중요):&#10;# - Room.txt 파일은 섹션 단위(예: [ground], [upper_ground], [walls], [cliff], [props])의 텍스트로 존재하며,&#10;#   각 섹션 밑에는 콤마(,)로 구분된 정수 타일 인덱스 행들이 있음.&#10;#   예:&#10;#   [ground]&#10;#   1,1,1,0,0&#10;#   1,2,2,0,0&#10;#&#10;# - 0은 빈 타일(배치 없음)을 의미.&#10;# - props 섹션은 현재 무시합니다.&#10;#&#10;# 제공하는 기능:&#10;# - Map.load_from_room_txt(path): Room.txt 파싱&#10;# - Map.build_into_world(world, tile_size=32, origin=(0,0)): world의 레이어들에 타일 엔티티를 추가&#10;# - TileEntity: 최소한의 update()/draw() 인터페이스(프로젝트의 실제 렌더링 파이프라인에 맞춰 확장 가능)&#10;&#10;import os&#10;from typing import Dict, List, Tuple, Optional&#10;&#10;try:&#10;    from pico2d import draw_rectangle&#10;except Exception:&#10;    # pico2d가 없으면 draw_rectangle을 대체하는 더미 함수로 허용&#10;    def draw_rectangle(l, b, r, t):&#10;        # no-op in headless/static analysis&#10;        return&#10;&#10;&#10;SUPPORTED_SECTIONS = ['ground', 'upper_ground', 'walls', 'cliff', 'props']&#10;&#10;&#10;class TileEntity:&#10;    &quot;&quot;&quot;맵에 배치되는 간단한 타일 엔티티.&#10;    실제 프로젝트에서는 이미지(tileset)과 애니메이션, 충돌박스 등을 연결해서 사용하면 됩니다.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, tile_id: int, x: int, y: int, size: int, layer: str):&#10;        self.tile_id = int(tile_id)&#10;        self.x = int(x)&#10;        self.y = int(y)&#10;        self.size = int(size)&#10;        self.layer = layer&#10;&#10;    def update(self):&#10;        # 기본 타일은 고정이므로 True를 반환하여 계속 유지&#10;        return True&#10;&#10;    def draw(self):&#10;        # 디버그용 간단한 사각형 그리기 (pico2d가 있으면 보임)&#10;        l = self.x&#10;        b = self.y&#10;        r = self.x + self.size&#10;        t = self.y + self.size&#10;        draw_rectangle(l, b, r, t)&#10;&#10;&#10;class Map:&#10;    def __init__(self, tile_size: int = 32):&#10;        self.tile_size = int(tile_size)&#10;        # 각 섹션에 대해 2D 리스트(행 리스트)로 타일 인덱스를 보관&#10;        self.layers: Dict[str, List[List[int]]] = {s: [] for s in SUPPORTED_SECTIONS}&#10;        self.width = 0&#10;        self.height = 0&#10;&#10;    @staticmethod&#10;    def _normalize_section_name(name: str) -&gt; str:&#10;        return name.strip().lower()&#10;&#10;    def load_from_room_txt(self, path: str) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Room.txt 형식(간단한 INI 스타일)을 파싱하여 self.layers에 채웁니다.&#10;        빈 라인 또는 주석(//, ;, #)은 무시합니다.&#10;&#10;        변경: 토큰 구분자는 공백(whitespace)을 사용합니다. 라인 내의 ','는 공백으로 대체되어&#10;        기존 콤마 형식과도 호환됩니다. 토큰 '0' 및 'X'/'x'는 빈 타일(0)으로 처리됩니다.&#10;        &quot;&quot;&quot;&#10;        if not os.path.isfile(path):&#10;            raise FileNotFoundError(f&quot;Room file not found: {path}&quot;)&#10;&#10;        current = None&#10;        with open(path, 'r', encoding='utf-8') as f:&#10;            for raw_line in f:&#10;                line = raw_line.strip()&#10;                if not line:&#10;                    continue&#10;                if line.startswith('//') or line.startswith('#') or line.startswith(';'):&#10;                    continue&#10;                if line.startswith('[') and line.endswith(']'):&#10;                    sec = self._normalize_section_name(line[1:-1])&#10;                    if sec not in SUPPORTED_SECTIONS:&#10;                        # 새 섹션을 만드려 하지 말고 지원되는 섹션만 처리&#10;                        current = None&#10;                        continue&#10;                    current = sec&#10;                    # reset existing content for the section&#10;                    self.layers[current] = []&#10;                    continue&#10;&#10;                if current is None:&#10;                    # 섹션 밖의 데이터는 무시&#10;                    continue&#10;&#10;                # ',' 구분자를 공백으로 바꿔 공백 분할을 사용하여 유연하게 처리&#10;                normalized = line.replace(',', ' ')&#10;                parts = [p.strip() for p in normalized.split() if p.strip() != '']&#10;                if not parts:&#10;                    continue&#10;                row: List[int] = []&#10;                for p in parts:&#10;                    # '0' 과 'X' 또는 'x' 를 빈타일로 처리&#10;                    if p == '0' or p.lower() == 'x':&#10;                        row.append(0)&#10;                        continue&#10;                    try:&#10;                        row.append(int(p))&#10;                    except ValueError:&#10;                        # 숫자로 변환할 수 없는 토큰이 있으면 빈타일로 처리&#10;                        row.append(0)&#10;                self.layers[current].append(row)&#10;&#10;        # 맵 전체 크기 계산 (가장 큰 폭/높이 사용)&#10;        max_w = 0&#10;        max_h = 0&#10;        for sec in SUPPORTED_SECTIONS:&#10;            h = len(self.layers.get(sec, []))&#10;            if h &gt; max_h:&#10;                max_h = h&#10;            for row in self.layers.get(sec, []):&#10;                if len(row) &gt; max_w:&#10;                    max_w = len(row)&#10;        self.width = max_w&#10;        self.height = max_h&#10;&#10;    def build_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0), replace: bool = True) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        파싱된 레이어 데이터를 바탕으로 `world` 딕셔너리의 레이어 리스트에 TileEntity들을 추가합니다.&#10;        - world: main.py에서 사용되는 world 딕셔너리 (예: keys: 'ground','upper_ground','walls',...)&#10;        - tile_size: 맵의 타일 픽셀 크기 (기본은 Map.tile_size)&#10;        - origin: (x0,y0) 맵 원점 좌표 (왼쪽 하단 기준)&#10;        - replace: True이면 이 함수가 추가할 레이어(ground/upper_ground/walls)의 기존 리스트를 비우고 새로 채웁니다.&#10;&#10;        이 함수는 props 섹션은 현재 무시합니다.&#10;        &quot;&quot;&quot;&#10;        ts = int(tile_size) if tile_size is not None else self.tile_size&#10;        x0, y0 = origin&#10;&#10;        target_layers = ['ground', 'upper_ground', 'walls']&#10;        if replace:&#10;            for tl in target_layers:&#10;                if tl in world and isinstance(world[tl], list):&#10;                    world[tl].clear()&#10;&#10;        # 맵 데이터의 행렬은 텍스트 상에서는 보통 위에서 아래로 작성됨을 가정.&#10;        # 여기서는 텍스트 행(0)이 맵의 &quot;상단&quot;이라고 가정하고 화면 좌표로는 높이를 고려해 y를 계산합니다.&#10;        for sec in ['ground', 'upper_ground', 'walls', 'cliff']:&#10;            rows = self.layers.get(sec, [])&#10;            h = len(rows)&#10;            for row_idx, row in enumerate(rows):&#10;                # 텍스트의 첫 행 -&gt; 맵 상단이므로 y 계산&#10;                # 맵 상단을 origin_y + (height - 1 - row_idx) * ts 로 배치&#10;                for col_idx, tile_id in enumerate(row):&#10;                    if tile_id == 0:&#10;                        continue&#10;                    # compute position&#10;                    # bottom-left origin&#10;                    x = x0 + col_idx * ts&#10;                    y = y0 + (self.height - 1 - row_idx) * ts&#10;                    ent = TileEntity(tile_id=tile_id, x=x, y=y, size=ts, layer=sec)&#10;                    # 저장된 그리드 좌표를 붙여 두면 나중에 크기 변경 시 재계산에 사용 가능&#10;                    ent._grid_col = col_idx&#10;                    ent._grid_row = row_idx&#10;                    ent._map_height = self.height&#10;                    ent._origin = (x0, y0)&#10;                    # 월드에 맞는 레이어 키가 존재하면 append&#10;                    if sec == 'ground':&#10;                        world.setdefault('ground', []).append(ent)&#10;                    elif sec == 'upper_ground':&#10;                        world.setdefault('upper_ground', []).append(ent)&#10;                    elif sec == 'walls' or sec == 'cliff':&#10;                        # 벽/절벽은 충돌 처리용으로 walls 레이어에 넣음&#10;                        world.setdefault('walls', []).append(ent)&#10;                    else:&#10;                        # props 등은 현재 무시&#10;                        pass&#10;&#10;    def rebuild_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        편의 메서드: 기존 내용을 교체(replace=True)하여 다시 빌드합니다.&#10;        &quot;&quot;&quot;&#10;        self.build_into_world(world, tile_size=tile_size, origin=origin, replace=True)&#10;&#10;    def apply_tile_size_to_world(self, world: Dict[str, list], new_tile_size: int, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        기존에 world에 배치된 TileEntity들이 그리드 좌표를 가지고 있다면,&#10;        각 엔티티의 size와 x,y를 새 타일 크기에 맞게 in-place로 갱신합니다.&#10;        - world: 월드 딕셔너리&#10;        - new_tile_size: 적용할 새 타일 크기&#10;        - origin: 맵 원점&#10;&#10;        이 방법은 엔티티를 새로 생성하지 않으므로 외부 참조가 유지됩니다.&#10;        만약 엔티티에 그리드 좌표가 없다면 동작하지 않습니다(그럴 경우 재빌드 필요).&#10;        &quot;&quot;&quot;&#10;        ts = int(new_tile_size)&#10;        x0, y0 = origin&#10;        layers = ['ground', 'upper_ground', 'walls']&#10;        updated = 0&#10;        for layer in layers:&#10;            for ent in list(world.get(layer, [])):&#10;                # ent가 grid 정보(_grid_col/_grid_row/_map_height)를 가지고 있으면 위치 재계산&#10;                if hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height'):&#10;                    col = int(ent._grid_col)&#10;                    row = int(ent._grid_row)&#10;                    map_h = int(ent._map_height)&#10;                    ent.size = ts&#10;                    ent.x = x0 + col * ts&#10;                    ent.y = y0 + (map_h - 1 - row) * ts&#10;                    # update stored origin too&#10;                    ent._origin = (x0, y0)&#10;                    updated += 1&#10;                else:&#10;                    # grid 정보가 없으면 이 엔티티는 무시 (재빌드를 권장)&#10;                    continue&#10;        try:&#10;            print(f&quot;apply_tile_size_to_world: applied new_tile_size={ts}, updated_entities={updated}&quot;)&#10;        except Exception:&#10;            pass&#10;&#10;    def set_tile_size(self, new_tile_size: int, world: Optional[Dict[str, list]] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Map의 기본 타일 크기를 변경합니다. 만약 `world`를 전달하면 해당 월드에 대해&#10;        가능한 경우 in-place로 크기/위치를 갱신하고, grid 정보가 부족하면 재빌드를 수행합니다.&#10;        &quot;&quot;&quot;&#10;        self.tile_size = int(new_tile_size)&#10;        if world is not None:&#10;            # 먼저 시도: in-place 적용 (grid 좌표가 있는 경우)&#10;            # 검사: 모든 엔티티들이 grid 좌표를 가지고 있는지 확인&#10;            ok = True&#10;            total = 0&#10;            for layer in ['ground', 'upper_ground', 'walls']:&#10;                for ent in world.get(layer, []):&#10;                    total += 1&#10;                    if not (hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height')):&#10;                        ok = False&#10;                        break&#10;                if not ok:&#10;                    break&#10;            if ok:&#10;                try:&#10;                    self.apply_tile_size_to_world(world, self.tile_size, origin)&#10;                    print(f&quot;set_tile_size: in-place applied to {total} entities, new_tile_size={self.tile_size}&quot;)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91mset_tile_size: in-place apply failed: {e}\033[0m&quot;)&#10;            else:&#10;                # 일부 엔티티에 grid 정보가 없으면 안전하게 재빌드&#10;                try:&#10;                    self.rebuild_into_world(world, tile_size=self.tile_size, origin=origin)&#10;                    print(f&quot;set_tile_size: rebuilt world with new_tile_size={self.tile_size}&quot;)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91mset_tile_size: rebuild failed: {e}\033[0m&quot;)&#10;&#10;&#10;# 간단한 자기검증 스크립트&#10;if __name__ == '__main__':&#10;    # 간단한 Room 텍스트 샘플을 메모리로 만들고 파싱 테스트&#10;    sample = '''&#10;[ground]&#10;1,1,1,0,0&#10;1,2,2,0,0&#10;&#10;[upper_ground]&#10;0,0,3,3,0&#10;&#10;[walls]&#10;0,4,0,0,0&#10;'''&#10;    import tempfile&#10;&#10;    p = tempfile.gettempdir() + os.sep + 'sample_room.txt'&#10;    with open(p, 'w', encoding='utf-8') as f:&#10;        f.write(sample)&#10;&#10;    m = Map(tile_size=128)&#10;    m.load_from_room_txt(p)&#10;    print('width,height:', m.width, m.height)&#10;    world = {k: [] for k in ['ground', 'upper_ground', 'walls', 'effects_back', 'effects_front', 'ui', 'cursor']}&#10;    m.build_into_world(world, origin=(0, 0))&#10;    for k in world:&#10;        print(k, len(world[k]))&#10;" />
              <option name="updatedContent" value="# map.py&#13;&#10;# Room.txt 기반 간단한 맵 로더 및 타일 엔티티 빌더&#13;&#10;# 작성자: 자동 생성&#13;&#10;# 사용 가정(중요):&#13;&#10;# - Room.txt 파일은 섹션 단위(예: [ground], [upper_ground], [walls], [cliff], [props])의 텍스트로 존재하며,&#13;&#10;#   각 섹션 밑에는 콤마(,)로 구분된 정수 타일 인덱스 행들이 있음.&#13;&#10;#   예:&#13;&#10;#   [ground]&#13;&#10;#   1,1,1,0,0&#13;&#10;#   1,2,2,0,0&#13;&#10;#&#13;&#10;# - 0은 빈 타일(배치 없음)을 의미.&#13;&#10;# - props 섹션은 현재 무시합니다.&#13;&#10;#&#13;&#10;# 제공하는 기능:&#13;&#10;# - Map.load_from_room_txt(path): Room.txt 파싱&#13;&#10;# - Map.build_into_world(world, tile_size=32, origin=(0,0)): world의 레이어들에 타일 엔티티를 추가&#13;&#10;# - TileEntity: 최소한의 update()/draw() 인터페이스(프로젝트의 실제 렌더링 파이프라인에 맞춰 확장 가능)&#13;&#10;&#13;&#10;import os&#13;&#10;from typing import Dict, List, Tuple, Optional&#13;&#10;&#13;&#10;try:&#13;&#10;    from pico2d import draw_rectangle&#13;&#10;except Exception:&#13;&#10;    # pico2d가 없으면 draw_rectangle을 대체하는 더미 함수로 허용&#13;&#10;    def draw_rectangle(l, b, r, t):&#13;&#10;        # no-op in headless/static analysis&#13;&#10;        return&#13;&#10;&#13;&#10;&#13;&#10;SUPPORTED_SECTIONS = ['ground', 'upper_ground', 'walls', 'cliff', 'props']&#13;&#10;&#13;&#10;&#13;&#10;class TileEntity:&#13;&#10;    &quot;&quot;&quot;맵에 배치되는 간단한 타일 엔티티.&#13;&#10;    실제 프로젝트에서는 이미지(tileset)과 애니메이션, 충돌박스 등을 연결해서 사용하면 됩니다.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;&#13;&#10;    def __init__(self, tile_id: int, x: int, y: int, size: int, layer: str):&#13;&#10;        self.tile_id = int(tile_id)&#13;&#10;        self.x = int(x)&#13;&#10;        self.y = int(y)&#13;&#10;        self.size = int(size)&#13;&#10;        self.layer = layer&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        # 기본 타일은 고정이므로 True를 반환하여 계속 유지&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self):&#13;&#10;        # 디버그용 간단한 사각형 그리기 (pico2d가 있으면 보임)&#13;&#10;        l = self.x&#13;&#10;        b = self.y&#13;&#10;        r = self.x + self.size&#13;&#10;        t = self.y + self.size&#13;&#10;        draw_rectangle(l, b, r, t)&#13;&#10;&#13;&#10;&#13;&#10;class Map:&#13;&#10;    def __init__(self, tile_size: int = 32):&#13;&#10;        self.tile_size = int(tile_size)&#13;&#10;        # 각 섹션에 대해 2D 리스트(행 리스트)로 타일 인덱스를 보관&#13;&#10;        self.layers: Dict[str, List[List[int]]] = {s: [] for s in SUPPORTED_SECTIONS}&#13;&#10;        self.width = 0&#13;&#10;        self.height = 0&#13;&#10;&#13;&#10;    @staticmethod&#13;&#10;    def _normalize_section_name(name: str) -&gt; str:&#13;&#10;        return name.strip().lower()&#13;&#10;&#13;&#10;    def load_from_room_txt(self, path: str) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Room.txt 형식(간단한 INI 스타일)을 파싱하여 self.layers에 채웁니다.&#13;&#10;        빈 라인 또는 주석(//, ;, #)은 무시합니다.&#13;&#10;&#13;&#10;        변경: 토큰 구분자는 공백(whitespace)을 사용합니다. 라인 내의 ','는 공백으로 대체되어&#13;&#10;        기존 콤마 형식과도 호환됩니다. 토큰 '0' 및 'X'/'x'는 빈 타일(0)으로 처리됩니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not os.path.isfile(path):&#13;&#10;            raise FileNotFoundError(f&quot;Room file not found: {path}&quot;)&#13;&#10;&#13;&#10;        current = None&#13;&#10;        with open(path, 'r', encoding='utf-8') as f:&#13;&#10;            for raw_line in f:&#13;&#10;                line = raw_line.strip()&#13;&#10;                if not line:&#13;&#10;                    continue&#13;&#10;                if line.startswith('//') or line.startswith('#') or line.startswith(';'):&#13;&#10;                    continue&#13;&#10;                if line.startswith('[') and line.endswith(']'):&#13;&#10;                    sec = self._normalize_section_name(line[1:-1])&#13;&#10;                    if sec not in SUPPORTED_SECTIONS:&#13;&#10;                        # 새 섹션을 만드려 하지 말고 지원되는 섹션만 처리&#13;&#10;                        current = None&#13;&#10;                        continue&#13;&#10;                    current = sec&#13;&#10;                    # reset existing content for the section&#13;&#10;                    self.layers[current] = []&#13;&#10;                    continue&#13;&#10;&#13;&#10;                if current is None:&#13;&#10;                    # 섹션 밖의 데이터는 무시&#13;&#10;                    continue&#13;&#10;&#13;&#10;                # ',' 구분자를 공백으로 바꿔 공백 분할을 사용하여 유연하게 처리&#13;&#10;                normalized = line.replace(',', ' ')&#13;&#10;                parts = [p.strip() for p in normalized.split() if p.strip() != '']&#13;&#10;                if not parts:&#13;&#10;                    continue&#13;&#10;                row: List[int] = []&#13;&#10;                for p in parts:&#13;&#10;                    # '0' 과 'X' 또는 'x' 를 빈타일로 처리&#13;&#10;                    if p == '0' or p.lower() == 'x':&#13;&#10;                        row.append(0)&#13;&#10;                        continue&#13;&#10;                    try:&#13;&#10;                        row.append(int(p))&#13;&#10;                    except ValueError:&#13;&#10;                        # 숫자로 변환할 수 없는 토큰이 있으면 빈타일로 처리&#13;&#10;                        row.append(0)&#13;&#10;                self.layers[current].append(row)&#13;&#10;&#13;&#10;        # 맵 전체 크기 계산 (가장 큰 폭/높이 사용)&#13;&#10;        max_w = 0&#13;&#10;        max_h = 0&#13;&#10;        for sec in SUPPORTED_SECTIONS:&#13;&#10;            h = len(self.layers.get(sec, []))&#13;&#10;            if h &gt; max_h:&#13;&#10;                max_h = h&#13;&#10;            for row in self.layers.get(sec, []):&#13;&#10;                if len(row) &gt; max_w:&#13;&#10;                    max_w = len(row)&#13;&#10;        self.width = max_w&#13;&#10;        self.height = max_h&#13;&#10;&#13;&#10;    def build_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0), replace: bool = True) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        파싱된 레이어 데이터를 바탕으로 `world` 딕셔너리의 레이어 리스트에 TileEntity들을 추가합니다.&#13;&#10;        - world: main.py에서 사용되는 world 딕셔너리 (예: keys: 'ground','upper_ground','walls',...)&#13;&#10;        - tile_size: 맵의 타일 픽셀 크기 (기본은 Map.tile_size)&#13;&#10;        - origin: (x0,y0) 맵 원점 좌표 (왼쪽 하단 기준)&#13;&#10;        - replace: True이면 이 함수가 추가할 레이어(ground/upper_ground/walls)의 기존 리스트를 비우고 새로 채웁니다.&#13;&#10;&#13;&#10;        이 함수는 props 섹션은 현재 무시합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        ts = int(tile_size) if tile_size is not None else self.tile_size&#13;&#10;        x0, y0 = origin&#13;&#10;&#13;&#10;        target_layers = ['ground', 'upper_ground', 'walls']&#13;&#10;        if replace:&#13;&#10;            for tl in target_layers:&#13;&#10;                if tl in world and isinstance(world[tl], list):&#13;&#10;                    world[tl].clear()&#13;&#10;&#13;&#10;        # 맵 데이터의 행렬은 텍스트 상에서는 보통 위에서 아래로 작성됨을 가정.&#13;&#10;        # 여기서는 텍스트 행(0)이 맵의 &quot;상단&quot;이라고 가정하고 화면 좌표로는 높이를 고려해 y를 계산합니다.&#13;&#10;        for sec in ['ground', 'upper_ground', 'walls', 'cliff']:&#13;&#10;            rows = self.layers.get(sec, [])&#13;&#10;            h = len(rows)&#13;&#10;            for row_idx, row in enumerate(rows):&#13;&#10;                # 텍스트의 첫 행 -&gt; 맵 상단이므로 y 계산&#13;&#10;                # 맵 상단을 origin_y + (height - 1 - row_idx) * ts 로 배치&#13;&#10;                for col_idx, tile_id in enumerate(row):&#13;&#10;                    if tile_id == 0:&#13;&#10;                        continue&#13;&#10;                    # compute position&#13;&#10;                    # bottom-left origin&#13;&#10;                    x = x0 + col_idx * ts&#13;&#10;                    y = y0 + (self.height - 1 - row_idx) * ts&#13;&#10;                    ent = TileEntity(tile_id=tile_id, x=x, y=y, size=ts, layer=sec)&#13;&#10;                    # 저장된 그리드 좌표를 붙여 두면 나중에 크기 변경 시 재계산에 사용 가능&#13;&#10;                    ent._grid_col = col_idx&#13;&#10;                    ent._grid_row = row_idx&#13;&#10;                    ent._map_height = self.height&#13;&#10;                    ent._origin = (x0, y0)&#13;&#10;                    # 월드에 맞는 레이어 키가 존재하면 append&#13;&#10;                    if sec == 'ground':&#13;&#10;                        world.setdefault('ground', []).append(ent)&#13;&#10;                    elif sec == 'upper_ground':&#13;&#10;                        world.setdefault('upper_ground', []).append(ent)&#13;&#10;                    elif sec == 'walls' or sec == 'cliff':&#13;&#10;                        # 벽/절벽은 충돌 처리용으로 walls 레이어에 넣음&#13;&#10;                        world.setdefault('walls', []).append(ent)&#13;&#10;                    else:&#13;&#10;                        # props 등은 현재 무시&#13;&#10;                        pass&#13;&#10;&#13;&#10;    def rebuild_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        편의 메서드: 기존 내용을 교체(replace=True)하여 다시 빌드합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.build_into_world(world, tile_size=tile_size, origin=origin, replace=True)&#13;&#10;&#13;&#10;    def apply_tile_size_to_world(self, world: Dict[str, list], new_tile_size: int, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        기존에 world에 배치된 TileEntity들이 그리드 좌표를 가지고 있다면,&#13;&#10;        각 엔티티의 size와 x,y를 새 타일 크기에 맞게 in-place로 갱신합니다.&#13;&#10;        - world: 월드 딕셔너리&#13;&#10;        - new_tile_size: 적용할 새 타일 크기&#13;&#10;        - origin: 맵 원점&#13;&#10;&#13;&#10;        이 방법은 엔티티를 새로 생성하지 않으므로 외부 참조가 유지됩니다.&#13;&#10;        만약 엔티티에 그리드 좌표가 없다면 동작하지 않습니다(그럴 경우 재빌드 필요).&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        ts = int(new_tile_size)&#13;&#10;        x0, y0 = origin&#13;&#10;        layers = ['ground', 'upper_ground', 'walls']&#13;&#10;        updated = 0&#13;&#10;        for layer in layers:&#13;&#10;            for ent in list(world.get(layer, [])):&#13;&#10;                # ent가 grid 정보(_grid_col/_grid_row/_map_height)를 가지고 있으면 위치 재계산&#13;&#10;                if hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height'):&#13;&#10;                    col = int(ent._grid_col)&#13;&#10;                    row = int(ent._grid_row)&#13;&#10;                    map_h = int(ent._map_height)&#13;&#10;                    ent.size = ts&#13;&#10;                    ent.x = x0 + col * ts&#13;&#10;                    ent.y = y0 + (map_h - 1 - row) * ts&#13;&#10;                    # update stored origin too&#13;&#10;                    ent._origin = (x0, y0)&#13;&#10;                    updated += 1&#13;&#10;                else:&#13;&#10;                    # grid 정보가 없으면 이 엔티티는 무시 (재빌드를 권장)&#13;&#10;                    continue&#13;&#10;        try:&#13;&#10;            print(f&quot;apply_tile_size_to_world: applied new_tile_size={ts}, updated_entities={updated}&quot;)&#13;&#10;        except Exception:&#13;&#10;            pass&#13;&#10;&#13;&#10;    def set_tile_size(self, new_tile_size: int, world: Optional[Dict[str, list]] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Map의 기본 타일 크기를 변경합니다. 만약 `world`를 전달하면 해당 월드에 대해&#13;&#10;        가능한 경우 in-place로 크기/위치를 갱신하고, grid 정보가 부족하면 재빌드를 수행합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.tile_size = int(new_tile_size)&#13;&#10;        if world is not None:&#13;&#10;            # 먼저 시도: in-place 적용 (grid 좌표가 있는 경우)&#13;&#10;            # 검사: 모든 엔티티들이 grid 좌표를 가지고 있는지 확인&#13;&#10;            ok = True&#13;&#10;            total = 0&#13;&#10;            for layer in ['ground', 'upper_ground', 'walls']:&#13;&#10;                for ent in world.get(layer, []):&#13;&#10;                    total += 1&#13;&#10;                    if not (hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height')):&#13;&#10;                        ok = False&#13;&#10;                        break&#13;&#10;                if not ok:&#13;&#10;                    break&#13;&#10;            if ok:&#13;&#10;                try:&#13;&#10;                    self.apply_tile_size_to_world(world, self.tile_size, origin)&#13;&#10;                    print(f&quot;set_tile_size: in-place applied to {total} entities, new_tile_size={self.tile_size}&quot;)&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91mset_tile_size: in-place apply failed: {e}\033[0m&quot;)&#13;&#10;            else:&#13;&#10;                # 일부 엔티티에 grid 정보가 없으면 안전하게 재빌드&#13;&#10;                try:&#13;&#10;                    self.rebuild_into_world(world, tile_size=self.tile_size, origin=origin)&#13;&#10;                    print(f&quot;set_tile_size: rebuilt world with new_tile_size={self.tile_size}&quot;)&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91mset_tile_size: rebuild failed: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;# 간단한 자기검증 스크립트&#13;&#10;if __name__ == '__main__':&#13;&#10;    # 간단한 Room 텍스트 샘플을 메모리로 만들고 파싱 테스트&#13;&#10;    sample = '''&#13;&#10;[ground]&#13;&#10;1,1,1,0,0&#13;&#10;1,2,2,0,0&#13;&#10;&#13;&#10;[upper_ground]&#13;&#10;0,0,3,3,0&#13;&#10;&#13;&#10;[walls]&#13;&#10;0,4,0,0,0&#13;&#10;'''&#13;&#10;    import tempfile&#13;&#10;&#13;&#10;    p = tempfile.gettempdir() + os.sep + 'sample_room.txt'&#13;&#10;    with open(p, 'w', encoding='utf-8') as f:&#13;&#10;        f.write(sample)&#13;&#10;&#13;&#10;    m = Map(tile_size=128)&#13;&#10;    m.load_from_room_txt(p)&#13;&#10;    print('width,height:', m.width, m.height)&#13;&#10;    world = {k: [] for k in ['ground', 'upper_ground', 'walls', 'effects_back', 'effects_front', 'ui', 'cursor']}&#13;&#10;    m.build_into_world(world, origin=(0, 0))&#13;&#10;    for k in world:&#13;&#10;        print(k, len(world[k]))" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/play_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/play_mode.py" />
              <option name="originalContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#10;# minimal, compatible with existing game_logic modules&#10;import pico2d as p2&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#10;&#10;import game_framework&#10;from .player import Player&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar&#10;from .cursor import Cursor&#10;from .loading_screen import LoadingScreen&#10;from . import defeat_mode&#10;# 사용할 스테이지 모듈들을 import 합니다.&#10;from .stages import stage_1, stage_2&#10;&#10;# world layers: keep same keys as original main.py&#10;world = {&#10;    'ground': [],&#10;    'upper_ground': [],&#10;    'walls': [],&#10;    'effects_back': [],&#10;    'entities': [],&#10;    'effects_front': [],&#10;    'ui': [],&#10;    'extra_bg': [],&#10;    'extras': [],&#10;    'cursor': []&#10;}&#10;world['bg'] = world['ground']&#10;&#10;# 스테이지 관리&#10;stages = [stage_1, stage_2] # 모든 스테이지 모듈을 리스트로 관리&#10;current_stage_index = 0&#10;is_stage_cleared = False&#10;&#10;# 로딩 화면 관리&#10;loading_screen = None&#10;is_loading = False&#10;next_stage_to_load = None&#10;&#10;&#10;class Camera:&#10;    &quot;&quot;&quot;&#10;    플레이어를 부드럽게 따라가는 카메라 클래스&#10;    맵의 경계를 넘지 않도록 제한하며, 화면 중앙을 (0,0)으로 하는 좌표계 사용&#10;    &quot;&quot;&quot;&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#10;        &quot;&quot;&quot;&#10;        카메라 초기화&#10;        Args:&#10;            target: 카메라가 따라갈 대상 (일반적으로 플레이어)&#10;            map_width: 맵의 전체 너비&#10;            map_height: 맵의 전체 높이&#10;            screen_width: 화면 너비&#10;            screen_height: 화면 높이&#10;        &quot;&quot;&quot;&#10;        self.target = target&#10;        self.x = target.x&#10;        self.y = target.y&#10;        self.map_width = map_width&#10;        self.map_height = map_height&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1, 낮을수록 부드럽고 느림)&#10;&#10;        # 맵 오프셋 (배경의 중심점, calculate_background_bounds에서 설정)&#10;        self.map_offset_x = 0&#10;        self.map_offset_y = 0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        카메라 위치 업데이트 - 타겟을 부드럽게 따라가며 맵 경계 내로 제한&#10;        &quot;&quot;&quot;&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP - Linear Interpolation)&#10;        target_x = self.target.x&#10;        target_y = self.target.y&#10;        self.x += (target_x - self.x) * self.smooth&#10;        self.y += (target_y - self.y) * self.smooth&#10;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#10;        min_x = -self.map_width/2&#10;        max_x = self.map_width/2&#10;        min_y = -self.map_height/2&#10;        max_y = self.map_height/2&#10;&#10;        self.x = max(min_x, min(self.x, max_x))&#10;        self.y = max(min_y, min(self.y, max_y))&#10;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#10;        if self.map_width &lt;= self.screen_width:&#10;            self.x = 0&#10;        if self.map_height &lt;= self.screen_height:&#10;            self.y = 0&#10;&#10;    def apply(self, obj_x, obj_y):&#10;        &quot;&quot;&quot;&#10;        카메라 위치에 따라 오브젝트의 화면 좌표 계산&#10;        Args:&#10;            obj_x: 오브젝트의 월드 x 좌표 (맵 중심 기준)&#10;            obj_y: 오브젝트의 월드 y 좌표 (맵 중심 기준)&#10;        Returns:&#10;            tuple: (draw_x, draw_y) - 화면에 그릴 좌표&#10;        &quot;&quot;&quot;&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#10;&#10;&#10;# Camera 객체를 전역으로 선언&#10;camera = None&#10;&#10;&#10;def calculate_background_bounds():&#10;    &quot;&quot;&quot;&#10;    ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#10;&#10;    Returns:&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#10;    &quot;&quot;&quot;&#10;    min_x = float('inf')&#10;    max_x = float('-inf')&#10;    min_y = float('inf')&#10;    max_y = float('-inf')&#10;&#10;    # ground 레이어의 모든 객체를 순회&#10;    for obj in world['ground']:&#10;        # 객체가 x, y, image 속성을 가지고 있는지 확인&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image'):&#10;            # 객체의 중심 좌표&#10;            obj_x = obj.x&#10;            obj_y = obj.y&#10;&#10;            # 이미지 크기 계산 (scale 속성이 있으면 적용)&#10;            scale = getattr(obj, 'scale', 1.0)&#10;            img_width = obj.image.w * scale&#10;            img_height = obj.image.h * scale&#10;&#10;            # 객체의 경계 계산 (중심 기준이므로 절반씩)&#10;            obj_left = obj_x - img_width / 2&#10;            obj_right = obj_x + img_width / 2&#10;            obj_bottom = obj_y - img_height / 2&#10;            obj_top = obj_y + img_height / 2&#10;&#10;            # 최소/최대 값 업데이트&#10;            min_x = min(min_x, obj_left)&#10;            max_x = max(max_x, obj_right)&#10;            min_y = min(min_y, obj_bottom)&#10;            max_y = max(max_y, obj_top)&#10;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환 (1280x720 화면 기준)&#10;    if min_x == float('inf') or max_x == float('-inf'):&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#10;        return (-640, 640, -360, 360)&#10;&#10;    print(f&quot;[play_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#10;    return (min_x, max_x, min_y, max_y)&#10;&#10;&#10;def change_stage(next_stage_index):&#10;    &quot;&quot;&quot;다음 스테이지로 변경하는 함수&quot;&quot;&quot;&#10;    global current_stage_index, loading_screen, is_loading, next_stage_to_load&#10;&#10;    # 다음 스테이지 인덱스 확인&#10;    if next_stage_index &gt;= len(stages):&#10;        # 모든 스테이지 클리어 시 게임 종료 또는 다른 모드로 전환&#10;        print(&quot;All stages cleared!&quot;)&#10;        game_framework.quit()&#10;        return&#10;&#10;    # 로딩 화면 시작 - 스테이지 모듈의 LOADING_SCREEN_INFO 사용&#10;    next_stage_module = stages[next_stage_index]&#10;    loading_info = getattr(next_stage_module, 'LOADING_SCREEN_INFO', None)&#10;&#10;    if loading_info:&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1} 로딩 화면 시작&quot;)&#10;        loading_screen = LoadingScreen(loading_info)&#10;        is_loading = True&#10;        next_stage_to_load = next_stage_index&#10;    else:&#10;        # LOADING_SCREEN_INFO가 없으면 로딩 화면 없이 바로 전환&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1}에 로딩 화면 정보 없음, 즉시 전환&quot;)&#10;        next_stage_to_load = next_stage_index&#10;        _complete_stage_change()&#10;&#10;def _complete_stage_change():&#10;    &quot;&quot;&quot;로딩이 완료된 후 실제 스테이지 전환을 수행&quot;&quot;&quot;&#10;    global current_stage_index, world, is_stage_cleared, loading_screen, is_loading, next_stage_to_load, camera&#10;&#10;    print(f&quot;[_complete_stage_change] 스테이지 {next_stage_to_load + 1} 로드 시작&quot;)&#10;&#10;    # 현재 스테이지의 몬스터, 배경 등 제거 (플레이어는 유지)&#10;    player = world.get('player')&#10;    world['entities'] = [player] if player else []&#10;    world['bg'].clear()&#10;    # 다른 레이어도 필요에 따라 초기화&#10;    world['effects_back'].clear()&#10;    world['effects_front'].clear()&#10;&#10;    # 다음 스테이지 인덱스로 변경&#10;    current_stage_index = next_stage_to_load&#10;&#10;    # 새 스테이지 로드&#10;    stages[current_stage_index].load(world)&#10;&#10;    # 플레이어 위치 설정 (스테이지에 PLAYER_START_POSITION이 있으면 사용)&#10;    if player:&#10;        next_stage_module = stages[current_stage_index]&#10;        player_start_pos = getattr(next_stage_module, 'PLAYER_START_POSITION', None)&#10;&#10;        if player_start_pos:&#10;            # 플레이어 위치를 새 스테이지 시작 위치로 설정&#10;            new_x = player_start_pos['x']&#10;            new_y = player_start_pos['y']&#10;            player.x = new_x&#10;            player.y = new_y&#10;            print(f&quot;[_complete_stage_change] 플레이어 위치 설정: ({player.x}, {player.y})&quot;)&#10;&#10;            # 카메라가 존재하면 카메라도 즉시 플레이어 위치로 동기화&#10;            # (부드러운 전환 없이 즉시 이동)&#10;            if camera is not None:&#10;                camera.x = new_x&#10;                camera.y = new_y&#10;                print(f&quot;[_complete_stage_change] 카메라 위치 동기화: ({camera.x}, {camera.y})&quot;)&#10;        else:&#10;            print(f&quot;[_complete_stage_change] 플레이어 시작 위치 정보 없음, 현재 위치 유지&quot;)&#10;&#10;    # 새 스테이지의 배경 범위를 다시 계산하여 카메라 범위 업데이트&#10;    if camera is not None:&#10;        try:&#10;            min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;            map_width = max_x - min_x&#10;            map_height = max_y - min_y&#10;&#10;            # 카메라의 맵 크기 및 오프셋 업데이트&#10;            camera.map_width = map_width&#10;            camera.map_height = map_height&#10;            camera.map_offset_x = (min_x + max_x) / 2&#10;            camera.map_offset_y = (min_y + max_y) / 2&#10;&#10;            print(f&quot;[_complete_stage_change] 카메라 맵 범위 업데이트: {map_width:.1f}x{map_height:.1f}&quot;)&#10;        except Exception as ex:&#10;            print(f&quot;\033[91m[_complete_stage_change] 카메라 범위 업데이트 실패: {ex}\033[0m&quot;)&#10;&#10;    is_stage_cleared = False&#10;&#10;    # 로딩 화면 종료&#10;    loading_screen = None&#10;    is_loading = False&#10;    next_stage_to_load = None&#10;&#10;    print(f&quot;[_complete_stage_change] Changed to Stage {current_stage_index + 1}&quot;)&#10;&#10;def enter(player=None):&#10;    global world, current_stage_index, is_stage_cleared&#10;    print(&quot;[play_mode] Starting enter()...&quot;)&#10;&#10;    # clear existing&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            pass&#10;&#10;    print(&quot;[play_mode] Creating player...&quot;)&#10;    # create player (use fallback if heavy Player init fails)&#10;    try:&#10;        if player == None:&#10;            player = Player()&#10;        print(&quot;[play_mode] Player created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[play_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#10;        from .inventory import InventoryData, seed_debug_inventory&#10;&#10;        class _FallbackPlayer:&#10;            def __init__(self):&#10;                self.x = 400&#10;                self.y = 300&#10;                self.face_dir = 1&#10;                self.scale_factor = 1.0&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;                self.particles = []&#10;                self.attack_effects = []&#10;                self.inventory = InventoryData(cols=6, rows=5)&#10;                try:&#10;                    seed_debug_inventory(self.inventory)&#10;                except Exception:&#10;                    pass&#10;                self.inventory_open = False&#10;&#10;            def update(self):&#10;                return True&#10;&#10;            def rebuild_inventory_passives(self):&#10;                return&#10;&#10;            def consume_item_at(self, r, c):&#10;                return False&#10;&#10;        player = _FallbackPlayer()&#10;&#10;    print(&quot;[play_mode] Attaching world reference to player...&quot;)&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#10;    try:&#10;        player.world = world&#10;    except Exception:&#10;        pass&#10;        pass&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#10;    world['entities'].append(player)&#10;&#10;    print(&quot;[play_mode] Creating inventory overlay...&quot;)&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#10;    try:&#10;        inv = InventoryOverlay(player, world)&#10;        print(&quot;[play_mode] InventoryOverlay created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] InventoryOverlay init failed, creating minimal stub:', ex)&#10;&#10;        class _InvStub:&#10;            def __init__(self, player, world=None):&#10;                self.player = player&#10;                self.world = world&#10;                self.dragging = False&#10;                self.drag_from = None&#10;                self.drag_icon = None&#10;                self.drag_qty = 0&#10;            def handle_event(self, e):&#10;                return&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        inv = _InvStub(player, world)&#10;    world['ui'].append(inv)&#10;&#10;    print(&quot;[play_mode] Creating health bar...&quot;)&#10;    # health bar UI 생성&#10;    try:&#10;        health_bar = HealthBar(player)&#10;        print(&quot;[play_mode] HealthBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] HealthBar init failed, using stub:', ex)&#10;&#10;        class _HealthBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        health_bar = _HealthBarStub(player)&#10;    world['ui'].append(health_bar)&#10;&#10;    print(&quot;[play_mode] Creating mana bar...&quot;)&#10;    # mana bar UI 생성&#10;    try:&#10;        mana_bar = ManaBar(player)&#10;        print(&quot;[play_mode] ManaBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] ManaBar init failed, using stub:', ex)&#10;&#10;        class _ManaBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        mana_bar = _ManaBarStub(player)&#10;    world['ui'].append(mana_bar)&#10;&#10;    print(&quot;[play_mode] Creating cursor...&quot;)&#10;    # cursor on top (safe fallback)&#10;    try:&#10;        cursor = Cursor(player)&#10;        print(&quot;[play_mode] Cursor created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] Cursor init failed, using stub cursor:', ex)&#10;&#10;        class _CursorStub:&#10;            def __init__(self, player=None):&#10;                self.player = player&#10;                self.x = 0&#10;                self.y = 0&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;            def handle_event(self, e):&#10;                return&#10;&#10;        cursor = _CursorStub(player)&#10;    world['cursor'].append(cursor)&#10;&#10;    # expose world to __main__ for legacy code that looks up main.world&#10;    try:&#10;        import sys&#10;        main_mod = sys.modules.get('__main__')&#10;        if main_mod is not None:&#10;            setattr(main_mod, 'world', world)&#10;    except Exception:&#10;        pass&#10;&#10;    # Camera 초기화 (Player를 target으로 설정)&#10;    # ground 레이어의 실제 배경 범위를 계산하여 카메라 제한 범위로 사용&#10;    try:&#10;        # 배경 범위 계산 (ground 레이어의 모든 객체 고려)&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;&#10;        # 배경 전체 크기 계산&#10;        map_width = max_x - min_x&#10;        map_height = max_y - min_y&#10;&#10;        screen_width = p2.get_canvas_width()&#10;        screen_height = p2.get_canvas_height()&#10;&#10;        global camera&#10;        camera = Camera(player, map_width, map_height, screen_width, screen_height)&#10;&#10;        # 카메라에 실제 배경 범위의 중심점 정보 전달 (오프셋 계산용)&#10;        camera.map_offset_x = (min_x + max_x) / 2&#10;        camera.map_offset_y = (min_y + max_y) / 2&#10;&#10;        print(f&quot;[play_mode] Camera initialized for player at ({player.x}, {player.y})&quot;)&#10;        print(f&quot;[play_mode] Map size: {map_width:.1f} x {map_height:.1f}, Offset: ({camera.map_offset_x:.1f}, {camera.map_offset_y:.1f})&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;[play_mode] Camera initialization failed: {ex}&quot;)&#10;&#10;    print(&quot;[play_mode] Loading first stage...&quot;)&#10;    # 첫 번째 스테이지 로드&#10;    current_stage_index = 0&#10;    is_stage_cleared = False&#10;    stages[current_stage_index].load(world)&#10;    print(f&quot;[play_mode] Entered play_mode, loaded Stage {current_stage_index + 1}&quot;)&#10;&#10;def exit():&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            pass&#10;&#10;&#10;def handle_events():&#10;    import game_framework as app_framework&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            app_framework.quit()&#10;            return&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#10;            app_framework.quit()&#10;            return&#10;        # broadcast to entities -&gt; ui -&gt; cursor&#10;        for o in list(world['entities']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                pass&#10;        for o in list(world['ui']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                pass&#10;        for o in list(world['cursor']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                pass&#10;&#10;&#10;def update():&#10;    global is_stage_cleared, loading_screen, is_loading, camera&#10;&#10;    # 로딩 중이면 로딩 화면만 업데이트&#10;    if is_loading and loading_screen:&#10;        loading_screen.update()&#10;&#10;        # 로딩이 완료되었으면 실제 스테이지 전환&#10;        if loading_screen.is_complete:&#10;            _complete_stage_change()&#10;            print(f'[play_mode] 스테이지 {current_stage_index + 1} 로딩 완료, 전환 완료')&#10;&#10;        return  # 로딩 중에는 게임 로직 업데이트 안 함&#10;&#10;    # 카메라 업데이트 추가&#10;    if camera is not None:&#10;        camera.update()&#10;&#10;    # 일반 게임 업데이트&#10;    for layer_name in ['bg', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']:&#10;        new_list = []&#10;        for o in list(world[layer_name]):&#10;            try:&#10;                if hasattr(o, 'update'):&#10;                    alive = o.update()&#10;                    if alive is False:&#10;                        continue&#10;&#10;                # mark_for_removal 플래그 확인&#10;                if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#10;                    print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#10;                    continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#10;&#10;                new_list.append(o)&#10;            except Exception:&#10;                try:&#10;                    new_list.append(o)&#10;                except Exception:&#10;                    pass&#10;        world[layer_name][:] = new_list&#10;&#10;    # 충돌 검사 시스템&#10;    from .projectile import Projectile&#10;    player = world.get('player')&#10;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#10;    effects_to_remove = set()&#10;    projectiles_to_remove = set()&#10;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#10;    for effect in world['effects_front']:&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#10;            for entity in world['entities']:&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#10;                    if entity.check_collision_with_effect(effect):&#10;                        # 디버그: 충돌 정보 출력&#10;                        attacker_name = &quot;Player&quot;&#10;                        if hasattr(effect, 'owner'):&#10;                            attacker_name = effect.owner.__class__.__name__&#10;                        target_name = entity.__class__.__name__&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#10;                        pass&#10;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#10;    if player:&#10;        for projectile in world['effects_front']:&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#10;            if isinstance(projectile, Projectile):&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#10;                if not projectile.from_player:&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#10;                        if player.check_collision_with_projectile(projectile):&#10;                            # 디버그: 충돌 정보 출력&#10;                            attacker_name = &quot;Unknown&quot;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#10;                                attacker_name = projectile.owner.__class__.__name__&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#10;                            projectiles_to_remove.add(projectile)&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#10;                else:&#10;                    for entity in world['entities']:&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#10;                            if entity.check_collision_with_projectile(projectile):&#10;                                # 디버그: 충돌 정보 출력&#10;                                target_name = entity.__class__.__name__&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#10;                                projectiles_to_remove.add(projectile)&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#10;&#10;    # 충돌한 투사체 제거&#10;    if projectiles_to_remove:&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#10;&#10;    # 스테이지 클리어 조건 확인 (몬스터가 모두 제거되었는지)&#10;    # 'entities' 레이어에 플레이어만 남아있는지 확인합니다.&#10;    if not is_stage_cleared and len(world['entities']) == 1 and world.get('player') in world['entities']:&#10;        # 이전에 몬스터가 1마리 이상 있었는지 확인하는 조건이 필요할 수 있습니다.&#10;        # 여기서는 간단히 몬스터가 없으면 클리어로 간주합니다.&#10;        print(&quot;Stage cleared!&quot;)&#10;        is_stage_cleared = True # 중복 호출 방지&#10;        change_stage(current_stage_index + 1)&#10;&#10;&#10;def draw():&#10;    global camera&#10;    p2.clear_canvas()&#10;&#10;    # 로딩 중이면 로딩 화면만 그리기&#10;    if is_loading and loading_screen:&#10;        loading_screen.draw()&#10;    else:&#10;        # 일반 게임 화면 그리기 (카메라 적용)&#10;        # 배경, 벽, 엔티티 등은 카메라 위치를 적용하여 그리기&#10;        for layer_name in ['bg', 'walls', 'upper_ground', 'effects_back', 'entities', 'effects_front', 'extra_bg', 'extras']:&#10;            for o in world[layer_name]:&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        # x, y 속성이 있는 객체는 카메라 좌표로 변환하여 그리기&#10;                        if hasattr(o, 'x') and hasattr(o, 'y'):&#10;                            if camera is not None:&#10;                                draw_x, draw_y = camera.apply(o.x, o.y)&#10;                            else:&#10;                                draw_x, draw_y = o.x, o.y&#10;                            o.draw(draw_x, draw_y)&#10;                        else:&#10;                            # x, y 속성이 없는 객체는 그대로 그리기&#10;                            o.draw()&#10;                except Exception:&#10;                    pass&#10;&#10;        # UI와 커서는 카메라 적용하지 않음 (고정 UI)&#10;        for o in world['ui']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception:&#10;                pass&#10;&#10;        for o in world['cursor']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception:&#10;                pass&#10;&#10;    p2.update_canvas()&#10;" />
              <option name="updatedContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#10;# minimal, compatible with existing game_logic modules&#10;import pico2d as p2&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#10;&#10;import game_framework&#10;from .player import Player&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar&#10;from .cursor import Cursor&#10;from .loading_screen import LoadingScreen&#10;from . import defeat_mode&#10;# 사용할 스테이지 모듈들을 import 합니다.&#10;from .stages import stage_1, stage_2&#10;&#10;# world layers: keep same keys as original main.py&#10;world = {&#10;    'ground': [],&#10;    'upper_ground': [],&#10;    'walls': [],&#10;    'effects_back': [],&#10;    'entities': [],&#10;    'effects_front': [],&#10;    'ui': [],&#10;    'extra_bg': [],&#10;    'extras': [],&#10;    'cursor': []&#10;}&#10;world['bg'] = world['ground']&#10;&#10;# 스테이지 관리&#10;stages = [stage_1, stage_2] # 모든 스테이지 모듈을 리스트로 관리&#10;current_stage_index = 0&#10;is_stage_cleared = False&#10;&#10;# 로딩 화면 관리&#10;loading_screen = None&#10;is_loading = False&#10;next_stage_to_load = None&#10;&#10;&#10;class Camera:&#10;    &quot;&quot;&quot;&#10;    플레이어를 부드럽게 따라가는 카메라 클래스&#10;    맵의 경계를 넘지 않도록 제한하며, 화면 중앙을 (0,0)으로 하는 좌표계 사용&#10;    &quot;&quot;&quot;&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#10;        &quot;&quot;&quot;&#10;        카메라 초기화&#10;        Args:&#10;            target: 카메라가 따라갈 대상 (일반적으로 플레이어)&#10;            map_width: 맵의 전체 너비&#10;            map_height: 맵의 전체 높이&#10;            screen_width: 화면 너비&#10;            screen_height: 화면 높이&#10;        &quot;&quot;&quot;&#10;        self.target = target&#10;        self.x = target.x&#10;        self.y = target.y&#10;        self.map_width = map_width&#10;        self.map_height = map_height&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1, 낮을수록 부드럽고 느림)&#10;&#10;        # 맵 오프셋 (배경의 중심점, calculate_background_bounds에서 설정)&#10;        self.map_offset_x = 0&#10;        self.map_offset_y = 0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        카메라 위치 업데이트 - 타겟을 부드럽게 따라가며 맵 경계 내로 제한&#10;        &quot;&quot;&quot;&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP - Linear Interpolation)&#10;        target_x = self.target.x&#10;        target_y = self.target.y&#10;        self.x += (target_x - self.x) * self.smooth&#10;        self.y += (target_y - self.y) * self.smooth&#10;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#10;        min_x = -self.map_width/2&#10;        max_x = self.map_width/2&#10;        min_y = -self.map_height/2&#10;        max_y = self.map_height/2&#10;&#10;        self.x = max(min_x, min(self.x, max_x))&#10;        self.y = max(min_y, min(self.y, max_y))&#10;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#10;        if self.map_width &lt;= self.screen_width:&#10;            self.x = 0&#10;        if self.map_height &lt;= self.screen_height:&#10;            self.y = 0&#10;&#10;    def apply(self, obj_x, obj_y):&#10;        &quot;&quot;&quot;&#10;        카메라 위치에 따라 오브젝트의 화면 좌표 계산&#10;        Args:&#10;            obj_x: 오브젝트의 월드 x 좌표 (맵 중심 기준)&#10;            obj_y: 오브젝트의 월드 y 좌표 (맵 중심 기준)&#10;        Returns:&#10;            tuple: (draw_x, draw_y) - 화면에 그릴 좌표&#10;        &quot;&quot;&quot;&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#10;&#10;&#10;# Camera 객체를 전역으로 선언&#10;camera = None&#10;&#10;&#10;def calculate_background_bounds():&#10;    &quot;&quot;&quot;&#10;    ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#10;&#10;    Returns:&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#10;    &quot;&quot;&quot;&#10;    min_x = float('inf')&#10;    max_x = float('-inf')&#10;    min_y = float('inf')&#10;    max_y = float('-inf')&#10;&#10;    # ground 레이어의 모든 객체를 순회&#10;    for obj in world['ground']:&#10;        # 객체가 x, y, image 속성을 가지고 있는지 확인&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image'):&#10;            # 객체의 중심 좌표&#10;            obj_x = obj.x&#10;            obj_y = obj.y&#10;&#10;            # 이미지 크기 계산 (scale 속성이 있으면 적용)&#10;            scale = getattr(obj, 'scale', 1.0)&#10;            img_width = obj.image.w * scale&#10;            img_height = obj.image.h * scale&#10;&#10;            # 객체의 경계 계산 (중심 기준이므로 절반씩)&#10;            obj_left = obj_x - img_width / 2&#10;            obj_right = obj_x + img_width / 2&#10;            obj_bottom = obj_y - img_height / 2&#10;            obj_top = obj_y + img_height / 2&#10;&#10;            # 최소/최대 값 업데이트&#10;            min_x = min(min_x, obj_left)&#10;            max_x = max(max_x, obj_right)&#10;            min_y = min(min_y, obj_bottom)&#10;            max_y = max(max_y, obj_top)&#10;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환 (1280x720 화면 기준)&#10;    if min_x == float('inf') or max_x == float('-inf'):&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#10;        return (-640, 640, -360, 360)&#10;&#10;    print(f&quot;[play_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#10;    return (min_x, max_x, min_y, max_y)&#10;&#10;&#10;def change_stage(next_stage_index):&#10;    &quot;&quot;&quot;다음 스테이지로 변경하는 함수&quot;&quot;&quot;&#10;    global current_stage_index, loading_screen, is_loading, next_stage_to_load&#10;&#10;    # 다음 스테이지 인덱스 확인&#10;    if next_stage_index &gt;= len(stages):&#10;        # 모든 스테이지 클리어 시 게임 종료 또는 다른 모드로 전환&#10;        print(&quot;All stages cleared!&quot;)&#10;        game_framework.quit()&#10;        return&#10;&#10;    # 로딩 화면 시작 - 스테이지 모듈의 LOADING_SCREEN_INFO 사용&#10;    next_stage_module = stages[next_stage_index]&#10;    loading_info = getattr(next_stage_module, 'LOADING_SCREEN_INFO', None)&#10;&#10;    if loading_info:&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1} 로딩 화면 시작&quot;)&#10;        loading_screen = LoadingScreen(loading_info)&#10;        is_loading = True&#10;        next_stage_to_load = next_stage_index&#10;    else:&#10;        # LOADING_SCREEN_INFO가 없으면 로딩 화면 없이 바로 전환&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1}에 로딩 화면 정보 없음, 즉시 전환&quot;)&#10;        next_stage_to_load = next_stage_index&#10;        _complete_stage_change()&#10;&#10;def _complete_stage_change():&#10;    &quot;&quot;&quot;로딩이 완료된 후 실제 스테이지 전환을 수행&quot;&quot;&quot;&#10;    global current_stage_index, world, is_stage_cleared, loading_screen, is_loading, next_stage_to_load, camera&#10;&#10;    print(f&quot;[_complete_stage_change] 스테이지 {next_stage_to_load + 1} 로드 시작&quot;)&#10;&#10;    # 현재 스테이지의 몬스터, 배경 등 제거 (플레이어는 유지)&#10;    player = world.get('player')&#10;    world['entities'] = [player] if player else []&#10;    world['bg'].clear()&#10;    # 다른 레이어도 필요에 따라 초기화&#10;    world['effects_back'].clear()&#10;    world['effects_front'].clear()&#10;&#10;    # 다음 스테이지 인덱스로 변경&#10;    current_stage_index = next_stage_to_load&#10;&#10;    # 새 스테이지 로드&#10;    stages[current_stage_index].load(world)&#10;&#10;    # 플레이어 위치 설정 (스테이지에 PLAYER_START_POSITION이 있으면 사용)&#10;    if player:&#10;        next_stage_module = stages[current_stage_index]&#10;        player_start_pos = getattr(next_stage_module, 'PLAYER_START_POSITION', None)&#10;&#10;        if player_start_pos:&#10;            # 플레이어 위치를 새 스테이지 시작 위치로 설정&#10;            new_x = player_start_pos['x']&#10;            new_y = player_start_pos['y']&#10;            player.x = new_x&#10;            player.y = new_y&#10;            print(f&quot;[_complete_stage_change] 플레이어 위치 설정: ({player.x}, {player.y})&quot;)&#10;&#10;            # 카메라가 존재하면 카메라도 즉시 플레이어 위치로 동기화&#10;            # (부드러운 전환 없이 즉시 이동)&#10;            if camera is not None:&#10;                camera.x = new_x&#10;                camera.y = new_y&#10;                print(f&quot;[_complete_stage_change] 카메라 위치 동기화: ({camera.x}, {camera.y})&quot;)&#10;        else:&#10;            print(f&quot;[_complete_stage_change] 플레이어 시작 위치 정보 없음, 현재 위치 유지&quot;)&#10;&#10;    # 새 스테이지의 배경 범위를 다시 계산하여 카메라 범위 업데이트&#10;    if camera is not None:&#10;        try:&#10;            min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;            map_width = max_x - min_x&#10;            map_height = max_y - min_y&#10;&#10;            # 카메라의 맵 크기 및 오프셋 업데이트&#10;            camera.map_width = map_width&#10;            camera.map_height = map_height&#10;            camera.map_offset_x = (min_x + max_x) / 2&#10;            camera.map_offset_y = (min_y + max_y) / 2&#10;&#10;            print(f&quot;[_complete_stage_change] 카메라 맵 범위 업데이트: {map_width:.1f}x{map_height:.1f}&quot;)&#10;        except Exception as ex:&#10;            print(f&quot;\033[91m[_complete_stage_change] 카메라 범위 업데이트 실패: {ex}\033[0m&quot;)&#10;&#10;    is_stage_cleared = False&#10;&#10;    # 로딩 화면 종료&#10;    loading_screen = None&#10;    is_loading = False&#10;    next_stage_to_load = None&#10;&#10;    print(f&quot;[_complete_stage_change] Changed to Stage {current_stage_index + 1}&quot;)&#10;&#10;def enter(player=None):&#10;    global world, current_stage_index, is_stage_cleared&#10;    print(&quot;[play_mode] Starting enter()...&quot;)&#10;&#10;    # clear existing&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            pass&#10;&#10;    print(&quot;[play_mode] Creating player...&quot;)&#10;    # create player (use fallback if heavy Player init fails)&#10;    try:&#10;        if player == None:&#10;            player = Player()&#10;        print(&quot;[play_mode] Player created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[play_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#10;        from .inventory import InventoryData, seed_debug_inventory&#10;&#10;        class _FallbackPlayer:&#10;            def __init__(self):&#10;                self.x = 400&#10;                self.y = 300&#10;                self.face_dir = 1&#10;                self.scale_factor = 1.0&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;                self.particles = []&#10;                self.attack_effects = []&#10;                self.inventory = InventoryData(cols=6, rows=5)&#10;                try:&#10;                    seed_debug_inventory(self.inventory)&#10;                except Exception:&#10;                    pass&#10;                self.inventory_open = False&#10;&#10;            def update(self):&#10;                return True&#10;&#10;            def rebuild_inventory_passives(self):&#10;                return&#10;&#10;            def consume_item_at(self, r, c):&#10;                return False&#10;&#10;        player = _FallbackPlayer()&#10;&#10;    print(&quot;[play_mode] Attaching world reference to player...&quot;)&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#10;    try:&#10;        player.world = world&#10;    except Exception:&#10;        pass&#10;        pass&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#10;    world['entities'].append(player)&#10;&#10;    print(&quot;[play_mode] Creating inventory overlay...&quot;)&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#10;    try:&#10;        inv = InventoryOverlay(player, world)&#10;        print(&quot;[play_mode] InventoryOverlay created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] InventoryOverlay init failed, creating minimal stub:', ex)&#10;&#10;        class _InvStub:&#10;            def __init__(self, player, world=None):&#10;                self.player = player&#10;                self.world = world&#10;                self.dragging = False&#10;                self.drag_from = None&#10;                self.drag_icon = None&#10;                self.drag_qty = 0&#10;            def handle_event(self, e):&#10;                return&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        inv = _InvStub(player, world)&#10;    world['ui'].append(inv)&#10;&#10;    print(&quot;[play_mode] Creating health bar...&quot;)&#10;    # health bar UI 생성&#10;    try:&#10;        health_bar = HealthBar(player)&#10;        print(&quot;[play_mode] HealthBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] HealthBar init failed, using stub:', ex)&#10;&#10;        class _HealthBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        health_bar = _HealthBarStub(player)&#10;    world['ui'].append(health_bar)&#10;&#10;    print(&quot;[play_mode] Creating mana bar...&quot;)&#10;    # mana bar UI 생성&#10;    try:&#10;        mana_bar = ManaBar(player)&#10;        print(&quot;[play_mode] ManaBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] ManaBar init failed, using stub:', ex)&#10;&#10;        class _ManaBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        mana_bar = _ManaBarStub(player)&#10;    world['ui'].append(mana_bar)&#10;&#10;    print(&quot;[play_mode] Creating cursor...&quot;)&#10;    # cursor on top (safe fallback)&#10;    try:&#10;        cursor = Cursor(player)&#10;        print(&quot;[play_mode] Cursor created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] Cursor init failed, using stub cursor:', ex)&#10;&#10;        class _CursorStub:&#10;            def __init__(self, player=None):&#10;                self.player = player&#10;                self.x = 0&#10;                self.y = 0&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;            def handle_event(self, e):&#10;                return&#10;&#10;        cursor = _CursorStub(player)&#10;    world['cursor'].append(cursor)&#10;&#10;    # expose world to __main__ for legacy code that looks up main.world&#10;    try:&#10;        import sys&#10;        main_mod = sys.modules.get('__main__')&#10;        if main_mod is not None:&#10;            setattr(main_mod, 'world', world)&#10;    except Exception:&#10;        pass&#10;&#10;    # Camera 초기화 (Player를 target으로 설정)&#10;    # ground 레이어의 실제 배경 범위를 계산하여 카메라 제한 범위로 사용&#10;    try:&#10;        # 배경 범위 계산 (ground 레이어의 모든 객체 고려)&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;&#10;        # 배경 전체 크기 계산&#10;        map_width = max_x - min_x&#10;        map_height = max_y - min_y&#10;&#10;        screen_width = p2.get_canvas_width()&#10;        screen_height = p2.get_canvas_height()&#10;&#10;        global camera&#10;        camera = Camera(player, map_width, map_height, screen_width, screen_height)&#10;&#10;        # 카메라에 실제 배경 범위의 중심점 정보 전달 (오프셋 계산용)&#10;        camera.map_offset_x = (min_x + max_x) / 2&#10;        camera.map_offset_y = (min_y + max_y) / 2&#10;&#10;        print(f&quot;[play_mode] Camera initialized for player at ({player.x}, {player.y})&quot;)&#10;        print(f&quot;[play_mode] Map size: {map_width:.1f} x {map_height:.1f}, Offset: ({camera.map_offset_x:.1f}, {camera.map_offset_y:.1f})&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;[play_mode] Camera initialization failed: {ex}&quot;)&#10;&#10;    print(&quot;[play_mode] Loading first stage...&quot;)&#10;    # 첫 번째 스테이지 로드&#10;    current_stage_index = 0&#10;    is_stage_cleared = False&#10;    stages[current_stage_index].load(world)&#10;    print(f&quot;[play_mode] Entered play_mode, loaded Stage {current_stage_index + 1}&quot;)&#10;&#10;def exit():&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            pass&#10;&#10;&#10;def handle_events():&#10;    import game_framework as app_framework&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            app_framework.quit()&#10;            return&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#10;            app_framework.quit()&#10;            return&#10;        # broadcast to entities -&gt; ui -&gt; cursor&#10;        for o in list(world['entities']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                pass&#10;        for o in list(world['ui']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                pass&#10;        for o in list(world['cursor']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                pass&#10;&#10;&#10;def update():&#10;    global is_stage_cleared, loading_screen, is_loading, camera&#10;&#10;    # 로딩 중이면 로딩 화면만 업데이트&#10;    if is_loading and loading_screen:&#10;        loading_screen.update()&#10;&#10;        # 로딩이 완료되었으면 실제 스테이지 전환&#10;        if loading_screen.is_complete:&#10;            _complete_stage_change()&#10;            print(f'[play_mode] 스테이지 {current_stage_index + 1} 로딩 완료, 전환 완료')&#10;&#10;        return  # 로딩 중에는 게임 로직 업데이트 안 함&#10;&#10;    # 카메라 업데이트 추가&#10;    if camera is not None:&#10;        camera.update()&#10;&#10;    # 일반 게임 업데이트&#10;    for layer_name in ['bg', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']:&#10;        new_list = []&#10;        for o in list(world[layer_name]):&#10;            try:&#10;                if hasattr(o, 'update'):&#10;                    alive = o.update()&#10;                    if alive is False:&#10;                        continue&#10;&#10;                # mark_for_removal 플래그 확인&#10;                if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#10;                    print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#10;                    continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#10;&#10;                new_list.append(o)&#10;            except Exception:&#10;                try:&#10;                    new_list.append(o)&#10;                except Exception:&#10;                    pass&#10;        world[layer_name][:] = new_list&#10;&#10;    # 충돌 검사 시스템&#10;    from .projectile import Projectile&#10;    player = world.get('player')&#10;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#10;    effects_to_remove = set()&#10;    projectiles_to_remove = set()&#10;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#10;    for effect in world['effects_front']:&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#10;            for entity in world['entities']:&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#10;                    if entity.check_collision_with_effect(effect):&#10;                        # 디버그: 충돌 정보 출력&#10;                        attacker_name = &quot;Player&quot;&#10;                        if hasattr(effect, 'owner'):&#10;                            attacker_name = effect.owner.__class__.__name__&#10;                        target_name = entity.__class__.__name__&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#10;                        pass&#10;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#10;    if player:&#10;        for projectile in world['effects_front']:&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#10;            if isinstance(projectile, Projectile):&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#10;                if not projectile.from_player:&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#10;                        if player.check_collision_with_projectile(projectile):&#10;                            # 디버그: 충돌 정보 출력&#10;                            attacker_name = &quot;Unknown&quot;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#10;                                attacker_name = projectile.owner.__class__.__name__&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#10;                            projectiles_to_remove.add(projectile)&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#10;                else:&#10;                    for entity in world['entities']:&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#10;                            if entity.check_collision_with_projectile(projectile):&#10;                                # 디버그: 충돌 정보 출력&#10;                                target_name = entity.__class__.__name__&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#10;                                projectiles_to_remove.add(projectile)&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#10;&#10;    # 충돌한 투사체 제거&#10;    if projectiles_to_remove:&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#10;&#10;    # 스테이지 클리어 조건 확인 (몬스터가 모두 제거되었는지)&#10;    # 'entities' 레이어에 플레이어만 남아있는지 확인합니다.&#10;    if not is_stage_cleared and len(world['entities']) == 1 and world.get('player') in world['entities']:&#10;        # 이전에 몬스터가 1마리 이상 있었는지 확인하는 조건이 필요할 수 있습니다.&#10;        # 여기서는 간단히 몬스터가 없으면 클리어로 간주합니다.&#10;        print(&quot;Stage cleared!&quot;)&#10;        is_stage_cleared = True # 중복 호출 방지&#10;        change_stage(current_stage_index + 1)&#10;&#10;&#10;def draw():&#10;    global camera&#10;    p2.clear_canvas()&#10;&#10;    # 로딩 중이면 로딩 화면만 그리기&#10;    if is_loading and loading_screen:&#10;        loading_screen.draw()&#10;    else:&#10;        # 일반 게임 화면 그리기 (카메라 적용)&#10;        # 배경, 벽, 엔티티 등은 카메라 위치를 적용하여 그리기&#10;        for layer_name in ['bg', 'walls', 'upper_ground', 'effects_back', 'entities', 'effects_front', 'extra_bg', 'extras']:&#10;            for o in world[layer_name]:&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        # x, y 속성이 있는 객체는 카메라 좌표로 변환하여 그리기&#10;                        if hasattr(o, 'x') and hasattr(o, 'y'):&#10;                            if camera is not None:&#10;                                draw_x, draw_y = camera.apply(o.x, o.y)&#10;                            else:&#10;                                draw_x, draw_y = o.x, o.y&#10;                            o.draw(draw_x, draw_y)&#10;                        else:&#10;                            # x, y 속성이 없는 객체는 그대로 그리기&#10;                            o.draw()&#10;                except Exception:&#10;                    pass&#10;&#10;        # UI와 커서는 카메라 적용하지 않음 (고정 UI)&#10;        for o in world['ui']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception:&#10;                pass&#10;&#10;        for o in world['cursor']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception:&#10;                pass&#10;&#10;    p2.update_canvas()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/player.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/player.py" />
              <option name="originalContent" value="# 패키지 내부 모듈을 직접 실행할 경우 친절한 안내 후 종료&#10;if __name__ == &quot;__main__&quot; and (__package__ is None or __package__ == &quot;&quot;):&#10;    import sys&#10;    print(&quot;이 모듈은 game_logic 패키지 내부 모듈입니다. 프로젝트 루트에서 main.py를 실행하세요.&quot;)&#10;    sys.exit(1)&#10;&#10;import ctypes&#10;import os&#10;import random&#10;import time&#10;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width, draw_rectangle&#10;from sdl2 import (SDL_KEYDOWN, SDL_KEYUP, SDLK_a, SDLK_d, SDLK_w, SDLK_s, SDLK_TAB, SDL_GetMouseState,&#10;                   SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT)&#10;&#10;from .equipment import EquipmentManager, Sword, Shield&#10;from .state_machine import StateMachine&#10;from . import framework&#10;# 인벤토리 데이터 모델 import&#10;from .inventory import InventoryData, seed_debug_inventory&#10;from .stats import PlayerStats, StatModifier&#10;&#10;def Akey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_a&#10;def Akey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_a&#10;def Dkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_d&#10;def Dkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_d&#10;def Wkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_w&#10;def Wkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_w&#10;def Skey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_s&#10;def Skey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_s&#10;&#10;&#10;# 커스텀 이벤트 정의&#10;def move_event(e):&#10;    return e[0] == 'MOVE'&#10;&#10;def stop_event(e):&#10;    return e[0] == 'STOP'&#10;&#10;# Tab 키 입력 검사용 predicate (StateMachine 매핑용)&#10;def Tab_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_TAB&#10;&#10;class Run:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix, path):&#10;            files = sorted([f for f in os.listdir(path)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(path, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#10;&#10;        # 파티클 리소스 로드&#10;        particle_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Run_Dust')&#10;        self.particle_frames = load_seq('RunDust_Ver2_', particle_folder)&#10;        self.particle_spawn_timer = 0.0&#10;        self.particle_spawn_interval = 0.15 # 파티클 생성 간격&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Move frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.06&#10;        self.moving_speed = 300 # 초당 픽셀&#10;&#10;    def enter(self, e):&#10;        # 파티클 타이머만 초기화&#10;        self.particle_spawn_timer = 0.0&#10;&#10;    def exit(self, e):&#10;        # 파티클을 제거하지 않고 그대로 둠&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 플레이어 애니메이션 및 위치 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;        # 현재 스탯 기반 이동 속도 사용&#10;        moving_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else self.moving_speed&#10;        dir_magnitude = (self.player.dir[0] ** 2 + self.player.dir[1] ** 2) ** 0.5&#10;        if dir_magnitude &gt; 0:&#10;            norm_dir_x = self.player.dir[0] / dir_magnitude&#10;            norm_dir_y = self.player.dir[1] / dir_magnitude&#10;            new_x = self.player.x + norm_dir_x * moving_speed * dt&#10;            new_y = self.player.y + norm_dir_y * moving_speed * dt&#10;&#10;            # 맵 경계 체크 (카메라/월드 좌표 기반)&#10;            # lobby_mode에서 맵 크기를 가져와 경계 체크&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                # 배경 오브젝트에서 맵 크기 계산&#10;                if world['bg']:&#10;                    bg = world['bg'][0]&#10;                    map_width = bg.image.w * bg.scale&#10;                    map_height = bg.image.h * bg.scale&#10;                    # 맵의 중심이 (0, 0)이므로 경계는 ±map_width/2, ±map_height/2&#10;                    map_left = -map_width / 2&#10;                    map_right = map_width / 2&#10;                    map_bottom = -map_height / 2&#10;                    map_top = map_height / 2&#10;&#10;                    # 플레이어가 맵 경계를 벗어나지 않도록 제한&#10;                    if new_x &lt; map_left:&#10;                        new_x = map_left&#10;                    elif new_x &gt; map_right:&#10;                        new_x = map_right&#10;                    if new_y &lt; map_bottom:&#10;                        new_y = map_bottom&#10;                    elif new_y &gt; map_top:&#10;                        new_y = map_top&#10;            except Exception:&#10;                # 맵 정보를 가져올 수 없으면 화면 경계로 폴백&#10;                if new_x &gt; get_canvas_width():&#10;                    new_x = get_canvas_width()&#10;                elif new_x &lt; 0:&#10;                    new_x = 0&#10;                if new_y &gt; get_canvas_height():&#10;                    new_y = get_canvas_height()&#10;                elif new_y &lt; 0:&#10;                    new_y = 0&#10;&#10;            # 벽 충돌 체크 (플레이어 크기 32x48)&#10;            collided = False&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                for wall in world['walls']:&#10;                    if wall.check_collision(new_x - 32//2, new_y - 48//2, 32, 48):&#10;                        collided = True&#10;                        break&#10;            except Exception:&#10;                pass&#10;            if not collided:&#10;                self.player.x = new_x&#10;                self.player.y = new_y&#10;&#10;&#10;        # 파티클 생성&#10;        self.particle_spawn_timer += dt&#10;        if self.particle_spawn_timer &gt;= self.particle_spawn_interval:&#10;            self.particle_spawn_timer -= self.particle_spawn_interval&#10;            # 플레이어 발밑에 파티클 생성 (월드 좌표 사용)&#10;            # y 오프셋을 줄여서 발 위치에 더 가깝게 배치&#10;            particle_x = self.player.x + random.uniform(-10, 10)&#10;            particle_y = self.player.y - 20 + random.uniform(-5, 5)  # -40에서 -20으로 조정&#10;            new_particle = VFX_Run_Particle(particle_x, particle_y, self.particle_frames, 0.05, 2.0)&#10;            self.player.particles.append(new_particle)&#10;&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 파티클은 Player에서 그림&#10;&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;        # camera 가져오기&#10;        camera = None&#10;        try:&#10;            import game_logic.lobby_mode as lobby&#10;            camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            pass&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;class Idle:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix):&#10;            files = sorted([f for f in os.listdir(folder)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(folder, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Idle_Lower')&#10;        self.upper_frames = load_seq('Player_Adventurer_Idle_Upper')&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Idle frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.12&#10;&#10;    def enter(self, e):&#10;        self.player.dir = [0, 0]&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.frame_time_acc += dt&#10;        while self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;&#10;        # camera 가져오기 - play_mode 우선, lobby_mode로 폴백&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            print(f&quot;\033[91m[player Idle] 카메라 가져오기 실패\033[0m&quot;)&#10;&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;&#10;class Inventory:&#10;    &quot;&quot;&quot;인벤토리 상태: enter에서 이미지 로드, draw에서 중앙 오른쪽에 표시 (시뮬레이션 정지 없음)&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.image = None&#10;        self.scale = 1.0&#10;        self.prev_state = None  # 이전 상태 저장용&#10;&#10;    def enter(self, e):&#10;        # 현재 상태를 이전 상태로 저장 (복귀용)&#10;        self.prev_state = self.player.state_machine.cur_state&#10;&#10;        # 이미지 지연 로드(오버레이에서도 사용 가능하도록 유지하되, 여기서는 그리지 않음)&#10;        if self.image is None:&#10;            img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Inventory', 'InventoryBase_New1.png')&#10;            try:&#10;                self.image = load_image(img_path)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load inventory image: {img_path}, {ex}\033[0m&quot;)&#10;                self.image = None&#10;&#10;        # 인벤토리 표시 플래그만 설정 (이동은 유지)&#10;        self.player.inventory_open = True&#10;&#10;    def exit(self, e):&#10;        # 표시 플래그만 해제&#10;        self.player.inventory_open = False&#10;&#10;    def do(self):&#10;        # 현재 키 상태에 따라 Idle/Run의 do를 동적으로 실행&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.do()&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 현재 키 상태에 따라 Idle/Run의 draw를 먼저 실행&#10;        # active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        # active_state.draw(draw_x, draw_y)&#10;        # 인벤토리 이미지를 화면 오른쪽에 표시 (카메라 스크롤 영향 없음)&#10;        # if self.image:&#10;        #     canvas_w = get_canvas_width()&#10;        #     canvas_h = get_canvas_height()&#10;        #     inv_x = canvas_w - self.image.w * self.scale // 2 - 20&#10;        #     inv_y = canvas_h // 2&#10;        #     self.image.draw(inv_x, inv_y, self.image.w * self.scale, self.image.h * self.scale)&#10;        pass&#10;&#10;class Death:&#10;    &quot;&quot;&quot;플레이어 사망 상태&quot;&quot;&quot;&#10;    image = None&#10;    hit_fx_images = None  # PlayerHitFX 이미지들&#10;    heart_hit_images = None  # HeartHit 이미지들&#10;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.world = getattr(player, 'world', None)  # play_mode에서 할당된 world 참조&#10;&#10;        if Death.image is None:&#10;            try:&#10;                Death.image = load_image('resources/Texture_organize/Player_character/Adventurer/Player_Adventurer_Down00.png')&#10;                print(f&quot;[Player Death] Loaded Down00 image&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] Failed to load image: {e}\033[0m&quot;)&#10;                Death.image = None&#10;&#10;        # PlayerHitFX 이미지 로드 (1 ~ 9)&#10;        if Death.hit_fx_images is None:&#10;            Death.hit_fx_images = []&#10;            try:&#10;                for i in range(1, 10):  # PlayerHitFX01 ~ PlayerHitFX09&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Die_Animation', f'PlayerHitFX0{i}.png')&#10;                    img = load_image(img_path)&#10;                    Death.hit_fx_images.append(img)&#10;                print(f&quot;[Player Death] PlayerHitFX 이미지 로드 완료: {len(Death.hit_fx_images)}개&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] PlayerHitFX 이미지 로드 실패: {e}\033[0m&quot;)&#10;                Death.hit_fx_images = []&#10;&#10;        # HeartHit 이미지 로드 (0 ~ 8)&#10;        if Death.heart_hit_images is None:&#10;            Death.heart_hit_images = []&#10;            try:&#10;                for i in range(9):  # HeartHit0_0 ~ HeartHit8_0&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Hit_verdict', f'HeartHit{i}_0.png')&#10;                    img = load_image(img_path)&#10;                    Death.heart_hit_images.append(img)&#10;                print(f&quot;[Player Death] HeartHit 이미지 로드 완료: {len(Death.heart_hit_images)}개&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] HeartHit 이미지 로드 실패: {e}\033[0m&quot;)&#10;                Death.heart_hit_images = []&#10;&#10;        self.death_timer = 0.0&#10;        self.death_conversion = 2.0  # 2초 후 변환&#10;        self.death_duration = 6.0  # 6초 후 종료&#10;        self.game_over_conversion_triggered = False&#10;        self.game_over_triggered = False&#10;        self.player_transform = False&#10;&#10;        # 넉백 관련 변수 (강한 넉백)&#10;        self.knockback_dx = 0&#10;        self.knockback_dy = 0&#10;        self.knockback_speed = 400  # 강한 넉백&#10;        self.knockback_duration = 0.5  # 0.5초 동안&#10;        self.knockback_timer = 0.0&#10;&#10;        # 애니메이션 관련 변수&#10;        self.hit_fx_frame = 0&#10;        self.hit_fx_time = 0.0&#10;        self.hit_fx_duration = 0.08  # 각 프레임당 0.08초&#10;&#10;        self.heart_hit_frame = 0&#10;        self.heart_hit_time = 0.0&#10;        self.heart_hit_duration = 0.1  # 각 프레임당 0.1초&#10;&#10;        # 사망 모드용 배경 이미지 클래스&#10;        class BGimage:&#10;            &quot;&quot;&quot;사망 모드용 배경 이미지 클래스&quot;&quot;&quot;&#10;&#10;            def __init__(self, image_path):&#10;                try:&#10;                    self.image = load_image(image_path)&#10;                except Exception as e:&#10;                    print(f&quot;[Defeat Mode BG] 이미지 로드 실패: {e}&quot;)&#10;                    self.image = None&#10;&#10;                self.alpha = 0.0 # 투명도 초기값&#10;&#10;            def do(self):&#10;                pass&#10;&#10;            def update(self):&#10;                # 점진적으로 투명도 증가 / 3초 동안 완전 불투명&#10;                if self.alpha &lt; 1.0:&#10;                    self.alpha += framework.get_delta_time() / 3.0 * 2  # 3초에 걸쳐 1.0 도달&#10;                    if self.alpha &gt; 1.0:&#10;                        self.alpha = 1.0&#10;&#10;            def draw(self):&#10;                if self.image:&#10;                    canvas_w = get_canvas_width()&#10;                    canvas_h = get_canvas_height()&#10;                    self.image.opacify(self.alpha)&#10;                    self.image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)&#10;                    self.image.opacify(1.0)&#10;&#10;        # 배경 이미지 인스턴스 생성&#10;        self.BG = BGimage('resources/Texture_organize/UI/Stage_Loading/BlackBG.png')&#10;&#10;    def enter(self, e):&#10;        self.death_timer = 0.0&#10;        self.game_over_triggered = False&#10;        self.knockback_timer = 0.0&#10;&#10;        # 애니메이션 초기화&#10;        self.hit_fx_frame = 0&#10;        self.hit_fx_time = 0.0&#10;        self.heart_hit_frame = 0&#10;        self.heart_hit_time = 0.0&#10;&#10;        # 플레이어 무장 해제&#10;        self.player.equipment_manager.unequip_all()&#10;&#10;        # 넉백 방향 계산&#10;        if e and len(e) &gt; 1 and e[1] is not None:&#10;            attacker = e[1]&#10;            attacker_x = attacker.x if hasattr(attacker, 'x') else self.player.x&#10;            attacker_y = attacker.y if hasattr(attacker, 'y') else self.player.y&#10;&#10;            if hasattr(attacker, 'owner') and attacker.owner:&#10;                attacker_x = attacker.owner.x&#10;                attacker_y = attacker.owner.y&#10;&#10;            import math&#10;            dx = self.player.x - attacker_x&#10;            dy = self.player.y - attacker_y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            if distance &gt; 0:&#10;                self.knockback_dx = dx / distance&#10;                self.knockback_dy = dy / distance&#10;            else:&#10;                self.knockback_dx = 1.0&#10;                self.knockback_dy = 0.0&#10;        else:&#10;            self.knockback_dx = 1.0&#10;            self.knockback_dy = 0.0&#10;&#10;        print(f&quot;[Player Death State] 사망 상태 시작 (5초 후 게임 종료) - 넉백 적용&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.death_timer += dt&#10;&#10;        # 넉백 효과 적용 (사망 시에도 밀려남)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            # 부드러운 감속&#10;            current_speed = self.knockback_speed * (1.0 - progress) ** 1.5&#10;            self.player.x += self.knockback_dx * current_speed * dt&#10;            self.player.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;&#10;        # PlayerHitFX 애니메이션 업데이트&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#10;            self.hit_fx_time += dt&#10;            if self.hit_fx_time &gt;= self.hit_fx_duration:&#10;                self.hit_fx_time -= self.hit_fx_duration&#10;                self.hit_fx_frame += 1&#10;&#10;        # HeartHit 애니메이션 업데이트&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#10;            self.heart_hit_time += dt&#10;            if self.heart_hit_time &gt;= self.heart_hit_duration:&#10;                self.heart_hit_time -= self.heart_hit_duration&#10;                self.heart_hit_frame += 1&#10;&#10;        # 2초 후 사망 이미지로 전환(변환처리)&#10;        if self.death_timer &gt;= self.death_conversion and not self.game_over_conversion_triggered:&#10;            self.game_over_conversion_triggered = True&#10;            self.player_transform = True&#10;            # 사망 애니메이션 시작 위치 저장&#10;            self.death_start_x = self.player.x&#10;            self.death_start_y = self.player.y&#10;            from .play_mode import world&#10;            world['extra_bg'].append(self.BG)&#10;            world['extras'].append(self.player)&#10;            if self.player in self.world['entities']:&#10;                world['entities'].remove(self.player)&#10;&#10;        # 5초 후 게임 종료&#10;        if self.death_timer &gt;= self.death_duration and not self.game_over_triggered:&#10;            self.game_over_triggered = True&#10;            print(f&quot;[Player Death State] 5초 경과, 패배 모드로 전환&quot;)&#10;            import game_framework&#10;            from . import defeat_mode&#10;            game_framework.change_state(defeat_mode, self.player)&#10;&#10;        # 플레이어 사망시 중앙으로 서서히 이동 (3초 동안)&#10;        if self.player_transform:&#10;            target_x = get_canvas_width() // 2&#10;            target_y = get_canvas_height() // 2&#10;            move_duration = 3.0&#10;            progress = min((self.death_timer - self.death_conversion) / move_duration, 1.0)&#10;            # 선형 보간으로 위치 계산&#10;            self.player.x = self.death_start_x + (target_x - self.death_start_x) * progress&#10;            self.player.y = self.death_start_y + (target_y - self.death_start_y) * progress&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 플레이어 사망 이미지 (바닥에 누운 모습)&#10;        if Death.image is not None:&#10;            Death.image.draw(draw_x, draw_y,&#10;                           Death.image.w * self.player.scale_factor,&#10;                           Death.image.h * self.player.scale_factor)&#10;&#10;        # PlayerHitFX 이펙트 (플레이어 위치에 크게)&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#10;            hit_fx_img = Death.hit_fx_images[self.hit_fx_frame]&#10;            scale = 3.0&#10;            hit_fx_img.draw(&#10;                draw_x,&#10;                draw_y,&#10;                hit_fx_img.w * scale,&#10;                hit_fx_img.h * scale&#10;            )&#10;&#10;        # HeartHit 이펙트 (화면 중앙 상단에 크게)&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#10;            heart_hit_img = Death.heart_hit_images[self.heart_hit_frame]&#10;            canvas_w = get_canvas_width()&#10;            canvas_h = get_canvas_height()&#10;            scale = 3.0&#10;            heart_hit_img.draw(&#10;                draw_x,&#10;                draw_y,&#10;                heart_hit_img.w * scale,&#10;                heart_hit_img.h * scale&#10;            )&#10;&#10;&#10;# 사망 이벤트 predicate&#10;def die(e):&#10;    return e[0] == 'DIE'&#10;&#10;&#10;class Player:&#10;    def __init__(self):&#10;        self.x = get_canvas_width() // 2&#10;        self.y = get_canvas_height() // 2&#10;        self.frame = 0&#10;        self.dir = [0, 0]  # x, y 방향 벡터&#10;        self.face_dir = 1&#10;        self.scale_factor = 3.0&#10;        self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;        self.moving = False # 이동 상태 플래그&#10;        self.particles = [] # 파티클 리스트를 Player로 이동&#10;        self.attack_effects = [] # 공격 이펙트 리스트&#10;&#10;        # 플레이어 히트박스 변수&#10;        self.collision_width = 15 * self.scale_factor&#10;        self.collision_height = 15 * self.scale_factor&#10;&#10;        # 무적시간 관련 변수&#10;        self.invincible = False  # 무적 상태인지&#10;        self.invincible_timer = 0.0  # 무적 시간 타이머&#10;        self.invincible_duration = 0.3  # 무적 시간 지속 시간 (0.3초)&#10;&#10;        # 넉백 관련 변수 (방패 방어 시 사용)&#10;        self.knockback_dx = 0.0&#10;        self.knockback_dy = 0.0&#10;        self.knockback_speed = 0.0&#10;        self.knockback_duration = 0.0&#10;        self.knockback_timer = 0.0&#10;&#10;        # 인벤토리 데이터 생성 및 디버그 아이템 채우기&#10;        self.inventory = InventoryData(cols=6, rows=5)&#10;        try:&#10;            seed_debug_inventory(self.inventory)&#10;        except Exception as ex:&#10;            print('[Player] 디버그 인벤토리 시드 실패:', ex)&#10;&#10;        # 스탯 시스템&#10;        self.stats = PlayerStats()&#10;        # 인벤토리 패시브 적용&#10;        try:&#10;            self.rebuild_inventory_passives()&#10;        except Exception as ex:&#10;            print('[Player] 패시브 재구성 실패:', ex)&#10;&#10;        # 장비 매니저 초기화&#10;        self.equipment_manager = EquipmentManager(self)&#10;&#10;        # 기본 무기 장착 (Tier1 검과 방패)&#10;        sword_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Sword_Tier1.png')&#10;        shield_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Shield_Tier1.png')&#10;&#10;        self.sword = Sword(self, sword_path, scale=3.0)&#10;        self.shield = Shield(self, shield_path, scale=3.0)&#10;&#10;        self.equipment_manager.equip(self.sword)&#10;        self.equipment_manager.equip(self.shield)&#10;&#10;        # 상태 정의&#10;        self.IDLE = Idle(self)&#10;        self.RUN = Run(self)&#10;        self.INVENTORY = Inventory(self)&#10;        self.DEATH = Death(self)&#10;&#10;        # 전투 플래그(전투중엔 인벤토리 안 염)&#10;        self.in_combat = False&#10;        self.inventory_open = False&#10;&#10;        # 상태 전환에 대한 매핑&#10;        self.state_machine = StateMachine(&#10;            self.IDLE,&#10;            {&#10;                self.IDLE: {move_event: self.RUN, Tab_down: self.INVENTORY, die: self.DEATH},&#10;                self.RUN: {stop_event: self.IDLE, Tab_down: self.INVENTORY, die: self.DEATH},&#10;                self.INVENTORY: {Tab_down: None, die: self.DEATH},&#10;                self.DEATH: {},  # 사망 상태에서는 전환 없음&#10;            }&#10;        )&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 넉백 효과 적용 (방패 방어 시)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            current_speed = self.knockback_speed * (1.0 - progress)&#10;            self.x += self.knockback_dx * current_speed * dt&#10;            self.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;&#10;        # 무적시간 업데이트&#10;        if self.invincible:&#10;            self.invincible_timer -= dt&#10;            if self.invincible_timer &lt;= 0:&#10;                self.invincible = False&#10;                self.invincible_timer = 0.0&#10;&#10;        self.state_machine.update()&#10;&#10;        # 스탯 버프 업데이트(소비형 지속시간 관리)&#10;        if hasattr(self, 'stats'):&#10;            self.stats.update()&#10;&#10;        # 파티클 업데이트 (상태와 무관하게 항상 실행)&#10;        for p in self.particles:&#10;            p.update()&#10;        self.particles = [p for p in self.particles if p.life &gt; 0]&#10;&#10;        # 공격 이펙트 업데이트&#10;        for effect in self.attack_effects:&#10;            effect.update()&#10;        self.attack_effects = [e for e in self.attack_effects if e.life &gt; 0]&#10;&#10;        # 장비 업데이트&#10;        self.equipment_manager.update()&#10;&#10;    # 인벤토리 패시브 재적용&#10;    def rebuild_inventory_passives(self):&#10;        prefix = 'passive:'&#10;        self.stats.clear_by_prefix(prefix)&#10;        # 모든 슬롯 순회&#10;        try:&#10;            for r in range(self.inventory.rows):&#10;                for c in range(self.inventory.cols):&#10;                    slot = self.inventory.get_slot(r, c)&#10;                    if slot.is_empty():&#10;                        continue&#10;                    item = slot.item&#10;                    if getattr(item, 'passive', None):&#10;                        # 수량만큼 배수 적용(스택형 패시브 고려)&#10;                        qty = max(1, slot.quantity)&#10;                        values = {k: v * qty for k, v in item.passive.items()}&#10;                        mod_id = f'{prefix}{item.id}:{r},{c}'&#10;                        self.stats.add_modifier(StatModifier(mod_id, values, duration=None))&#10;        except Exception as ex:&#10;            print(f&quot;\033[91m[Player] 패시브 적용 중 오류: {ex}\033[0m&quot;)&#10;&#10;    # 소비형 아이템 사용 처리&#10;    def consume_item_at(self, r: int, c: int):&#10;        try:&#10;            slot = self.inventory.get_slot(r, c)&#10;        except Exception as ex:&#10;            print('[Player] 소비 실패: 잘못된 슬롯', ex)&#10;            return False&#10;        if slot.is_empty() or not getattr(slot.item, 'consumable', None):&#10;            return False&#10;        item = slot.item&#10;        values = dict(item.consumable)&#10;        duration = item.consume_duration&#10;        mod_id = f'consumable:{item.id}:{r},{c}:{int(time.time()*1000)%100000}'&#10;        self.stats.add_modifier(StatModifier(mod_id, values, duration=duration))&#10;        # 1개 소모&#10;        self.inventory.remove_from(r, c, 1)&#10;        # 아이템의 이펙트 재생(있다면)&#10;        vfx_fn = (getattr(item, 'on_consume_vfx', None)&#10;                  or getattr(item, '_play_consume_vfx', None)&#10;                  or getattr(item, 'consume_effect', None))&#10;        if callable(vfx_fn):&#10;            try:&#10;                # prefer self.world (assigned by play_mode) so VFX are appended to the correct world dict&#10;                vfx_world = getattr(self, 'world', None)&#10;                # debug log&#10;                try:&#10;                    print(f&quot;[Player] triggering vfx for {getattr(item, 'name', item.id if hasattr(item,'id') else 'Unknown')} world={'set' if vfx_world is not None else 'None'})&quot;)&#10;                except Exception:&#10;                    pass&#10;                vfx_fn(self, world=vfx_world, x=getattr(self, 'x', None), y=getattr(self, 'y', None))&#10;            except Exception as ex:&#10;                print(f'[Player] 아이템 소비 이펙트 오류 ({item.name}):', ex)&#10;        # 패시브 재적용(수량 변화로 인한 패시브 변경 가능성 고려)&#10;        self.rebuild_inventory_passives()&#10;        print(f&quot;[Player] 소비: {item.name} -&gt; {values} ({duration}s)&quot;)&#10;        return True&#10;&#10;    # 신규: 입력 처리 - 상태머신과 장비 매니저로 이벤트 전달, 이동 벡터 관리&#10;    def handle_event(self, event):&#10;        try:&#10;            from sdl2 import SDL_KEYDOWN, SDL_KEYUP, SDLK_w, SDLK_a, SDLK_s, SDLK_d&#10;        except Exception:&#10;            SDL_KEYDOWN = SDL_KEYUP = None&#10;            SDLK_w = SDLK_a = SDLK_s = SDLK_d = None&#10;&#10;        # 1) 장비 매니저에 항상 전달(매니저 내부에서 인벤토리 오픈시 무시 처리)&#10;        try:&#10;            if hasattr(self, 'equipment_manager') and hasattr(self.equipment_manager, 'handle_event'):&#10;                self.equipment_manager.handle_event(event)&#10;        except Exception as ex:&#10;            print('[Player] equipment_manager.handle_event 오류:', ex)&#10;&#10;        # 2) 상태머신으로 원본 입력 이벤트 전달(Tab 매핑 등 predicates가 처리)&#10;        try:&#10;            if hasattr(self, 'state_machine') and hasattr(self.state_machine, 'handle_state_event'):&#10;                self.state_machine.handle_state_event(('INPUT', event))&#10;        except Exception as ex:&#10;            print('[Player] state_machine 입력 이벤트 처리 오류:', ex)&#10;&#10;        # 3) WASD 이동 상태 관리 -&gt; MOVE/STOP 이벤트 생성&#10;        moved_before = any(self.keys_down.values())&#10;        try:&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = True&#10;                    self.dir[1] = 1&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = True&#10;                    self.dir[1] = -1&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = True&#10;                    self.dir[0] = -1&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = True&#10;                    self.dir[0] = 1&#10;            elif SDL_KEYUP is not None and event.type == SDL_KEYUP:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;&#10;        except Exception as ex:&#10;            print('[Player] 이동 입력 처리 오류:', ex)&#10;&#10;        moved_after = any(self.keys_down.values())&#10;        try:&#10;            if not moved_before and moved_after:&#10;                # 시작 이동&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('MOVE', None))&#10;            elif moved_before and not moved_after:&#10;                # 이동 종료&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('STOP', None))&#10;        except Exception as ex:&#10;            print('[Player] MOVE/STOP 이벤트 처리 오류:', ex)&#10;&#10;    # 신규: 렌더링 - 장비/플레이어/이펙트 순서대로 그리기&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표이므로 그대로 사용&#10;&#10;        # 디버그 로그 - 카메라 정보 포함&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except:&#10;            pass&#10;&#10;        # if camera is not None:&#10;        #     print(f'[Player] draw at screen ({draw_x:.1f}, {draw_y:.1f}), '&#10;        #           f'world ({self.x:.1f}, {self.y:.1f}), '&#10;        #           f'camera ({camera.x:.1f}, {camera.y:.1f})')&#10;        # else:&#10;        #     print(f'[Player] draw at ({draw_x:.1f}, {draw_y:.1f}), world ({self.x:.1f}, {self.y:.1f}) (NO CAMERA)')&#10;&#10;        # 1) 장비(뒤쪽) 그리기&#10;        if hasattr(self, 'equipment_manager'):&#10;            self.equipment_manager.draw_back(draw_x, draw_y)&#10;&#10;        # 2) 현재 상태 스프라이트(Idle/Run/Inventory)&#10;        try:&#10;            if hasattr(self, 'state_machine'):&#10;                self.state_machine.draw(draw_x, draw_y)&#10;        except Exception:&#10;            pass&#10;&#10;        # 3) 장비(앞쪽) 그리기&#10;        if hasattr(self, 'equipment_manager'):&#10;            self.equipment_manager.draw_front(draw_x, draw_y)&#10;&#10;        # 4) 파티클/공격 이펙트 (카메라 적용)&#10;        try:&#10;            # 위에서 이미 가져온 camera 사용&#10;            for p in getattr(self, 'particles', []):&#10;                if hasattr(p, 'draw'):&#10;                    if camera is not None:&#10;                        particle_draw_x, particle_draw_y = camera.apply(p.x, p.y)&#10;                        p.draw(particle_draw_x, particle_draw_y)&#10;                    else:&#10;                        p.draw(p.x, p.y)&#10;            for e in getattr(self, 'attack_effects', []):&#10;                if hasattr(e, 'draw'):&#10;                    if camera is not None:&#10;                        effect_draw_x, effect_draw_y = camera.apply(e.x, e.y)&#10;                        e.draw(effect_draw_x, effect_draw_y)&#10;                    else:&#10;                        e.draw(e.x, e.y)&#10;        except Exception:&#10;            pass&#10;&#10;        # 화면에 표시되는 히트박스 (카메라 적용된 좌표 사용)&#10;        player_left = draw_x - self.collision_width / 2&#10;        player_right = draw_x + self.collision_width / 2&#10;        player_bottom = draw_y - self.collision_height / 2&#10;        player_top = draw_y + self.collision_height / 2&#10;        draw_rectangle(player_left, player_bottom, player_right, player_top)&#10;&#10;    def check_collision_with_projectile(self, projectile):&#10;        &quot;&quot;&quot;몬스터 발사체와의 충돌 감지&#10;&#10;        Args:&#10;            projectile: Projectile을 상속받은 발사체 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 먼저 방패로 방어할 수 있는지 체크&#10;        if hasattr(self, 'shield') and self.shield:&#10;            if self.shield.check_projectile_block(projectile):&#10;                # 방패로 막았으면 투사체를 제거하고 충돌 처리 종료&#10;                return True&#10;&#10;        # 무적 상태이면 충돌 무시&#10;        if hasattr(self, 'invincible') and self.invincible:&#10;            return False&#10;&#10;        # 발사체 크기 (Projectile의 get_collision_box 메서드 사용)&#10;        if hasattr(projectile, 'get_collision_box'):&#10;            projectile_width, projectile_height = projectile.get_collision_box()&#10;        else:&#10;            projectile_width = 30&#10;            projectile_height = 30&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        player_left = self.x - self.collision_width / 2&#10;        player_right = self.x + self.collision_width / 2&#10;        player_bottom = self.y - self.collision_height / 2&#10;        player_top = self.y + self.collision_height / 2&#10;&#10;        proj_left = projectile.x - projectile_width / 2&#10;        proj_right = projectile.x + projectile_width / 2&#10;        proj_bottom = projectile.y - projectile_height / 2&#10;        proj_top = projectile.y + projectile_height / 2&#10;&#10;        # 충돌 검사&#10;        if (player_left &lt; proj_right and player_right &gt; proj_left and&#10;            player_bottom &lt; proj_top and player_top &gt; proj_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(projectile)&#10;            return True&#10;&#10;        return False&#10;&#10;    def on_hit(self, attacker):&#10;        &quot;&quot;&quot;피격 시 호출되는 메서드&#10;&#10;        Args:&#10;            attacker: 공격한 객체 (투사체, 이펙트 등)&#10;        &quot;&quot;&quot;&#10;        # 무적 상태라면 무시&#10;        if self.invincible:&#10;            print(f&quot;[Player] 무적 상태로 피격 무시 (남은 무적시간: {self.invincible_timer:.2f}초)&quot;)&#10;            return&#10;&#10;        # 사망 상태면 무시&#10;        if isinstance(self.state_machine.cur_state, Death):&#10;            return&#10;&#10;        # 무적시간 활성화&#10;        self.invincible = True&#10;        self.invincible_timer = self.invincible_duration&#10;&#10;        # 데미지 계산&#10;        damage = 0&#10;        if hasattr(attacker, 'damage'):&#10;            damage = attacker.damage&#10;        elif hasattr(attacker, 'owner') and hasattr(attacker.owner, 'stats'):&#10;            # 공격자의 스탯에서 데미지 가져오기&#10;            damage = attacker.owner.stats.get('attack_damage')&#10;        else:&#10;            damage = 10.0  # 기본 데미지&#10;&#10;        # 방어력 적산&#10;        defense = self.stats.get('defense') if hasattr(self, 'stats') else 0&#10;        final_damage = max(1.0, damage - defense)&#10;&#10;        # 넉백 효과 적용 (공격자로부터 밀려나는 방향)&#10;        import math&#10;        knockback_distance = 100.0  # 넉백 거리&#10;        knockback_duration = 0.3  # 넉백 지속 시간 (초)&#10;&#10;        # 공격자의 위치 파악&#10;        attacker_x = attacker.x if hasattr(attacker, 'x') else self.x&#10;        attacker_y = attacker.y if hasattr(attacker, 'y') else self.y&#10;&#10;        # 넉백 방향 계산 (공격자 -&gt; 플레이어 방향)&#10;        dx = self.x - attacker_x&#10;        dy = self.y - attacker_y&#10;        distance = math.sqrt(dx * dx + dy * dy)&#10;&#10;        if distance &gt; 0:&#10;            # 정규화된 방향 벡터&#10;            self.knockback_dx = dx / distance&#10;            self.knockback_dy = dy / distance&#10;        else:&#10;            # 공격자와 위치가 같으면 랜덤 방향&#10;            angle = random.uniform(0, 2 * math.pi)&#10;            self.knockback_dx = math.cos(angle)&#10;            self.knockback_dy = math.sin(angle)&#10;&#10;        self.knockback_speed = knockback_distance / knockback_duration&#10;        self.knockback_duration = knockback_duration&#10;        self.knockback_timer = 0.0&#10;&#10;        # 체력 감소&#10;        if hasattr(self, 'stats'):&#10;            current_health = self.stats.get('health')&#10;            max_health = self.stats.get('max_health')&#10;            new_health = max(0, current_health - final_damage)&#10;            self.stats.set_base('health', new_health)&#10;&#10;            # 피격 정보 출력&#10;            attacker_name = attacker.__class__.__name__&#10;            DebugPrint = True&#10;            if DebugPrint:&#10;                print(f&quot;\n{'='*60}&quot;)&#10;                print(f&quot;[Player 피격]&quot;)&#10;                print(f&quot;  공격자: {attacker_name}&quot;)&#10;                print(f&quot;  원본 데미지: {damage:.1f}&quot;)&#10;                print(f&quot;  방어력: {defense:.1f}&quot;)&#10;                print(f&quot;  최종 데미지: {final_damage:.1f}&quot;)&#10;                print(f&quot;  체력 변화: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})&quot;)&#10;                print(f&quot;  체력 비율: {(new_health/max_health)*100:.1f}%&quot;)&#10;                print(f&quot;  무적시간: {self.invincible_duration}초 활성화&quot;)&#10;                print(f&quot;  넉백: 거리 {knockback_distance:.1f}px, 지속시간 {knockback_duration:.2f}초&quot;)&#10;&#10;            # 체력이 0 이하면 사망 상태로 전환&#10;            if new_health &lt;= 0:&#10;                print(f&quot;  &gt;&gt;&gt; Player 체력 0 - 사망 상태로 전환&quot;)&#10;                print(f&quot;{'='*60}\n&quot;)&#10;                self.state_machine.handle_state_event(('DIE', attacker))&#10;                return  # 사망 시 이펙트 생성하지 않음&#10;            else:&#10;                print(f&quot;{'='*60}\n&quot;)&#10;        else:&#10;            attacker_name = attacker.__class__.__name__&#10;            print(f&quot;[Player] 피격당함! 공격자: {attacker_name} (스탯 시스템 없음)&quot;)&#10;&#10;        # 피격 이펙트 재생 - Wound Particle 생성 (4개)&#10;        for i in range(4):&#10;            # 랜덤한 방향으로 파티클 발사&#10;            angle = random.uniform(0, 2 * math.pi)&#10;            speed = random.uniform(80, 150)  # 속도 랜덤&#10;            vx = math.cos(angle) * speed&#10;            vy = math.sin(angle) * speed + random.uniform(50, 100) # 위쪽으로 약간 더 많이&#10;&#10;            # 플레이어 위치에서 약간 랜덤한 오프셋&#10;            offset_x = random.uniform(-10, 10)&#10;            offset_y = random.uniform(-10, 10)&#10;&#10;            wound_particle = VFX_Wound_Particle(&#10;                self.x + offset_x,&#10;                self.y + offset_y,&#10;                vx, vy,&#10;                scale=3.0&#10;            )&#10;            self.particles.append(wound_particle)&#10;&#10;        print(f&quot;[Player] 피격 이펙트 생성 완료 (Wound Particle x4)&quot;)&#10;&#10;        # TODO: 추후 추가 가능&#10;        # - 피격 사운드&#10;&#10;    def on_death(self):&#10;        &quot;&quot;&quot;사망 처리 - 상태 머신을 통해 Death 상태로 전환&quot;&quot;&quot;&#10;        print(&quot;[Player] on_death 호출 - Death 상태로 전환&quot;)&#10;        self.state_machine.handle_state_event(('DIE', None))&#10;&#10;class VFX_Run_Particle:&#10;    def __init__(self, x, y, frames, frame_duration, scale):&#10;        self.x, self.y = x, y&#10;        self.frames = frames&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = frame_duration&#10;        self.scale_factor = scale&#10;        self.life = len(frames) * frame_duration&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt; 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.frames)&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.draw(draw_x, draw_y, image.w * self.scale_factor, image.h * self.scale_factor)&#10;&#10;&#10;class VFX_Wound_Particle:&#10;    &quot;&quot;&quot;피격 시 출혈 파티클 이펙트 (개별 이미지 파일 사용)&quot;&quot;&quot;&#10;    _frames = None  # 클래스 변수로 이미지 프레임 공유&#10;&#10;    def __init__(self, x, y, vx, vy, scale=3.0):&#10;        # 이미지 프레임 로드 (최초 1회만)&#10;        if VFX_Wound_Particle._frames is None:&#10;            VFX_Wound_Particle._frames = []&#10;            wound_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Wound_Particle')&#10;            try:&#10;                for i in range(5):  # WoundParticle_0 ~ WoundParticle_4&#10;                    img_path = os.path.join(wound_folder, f'WoundParticle_{i}.png')&#10;                    frame = load_image(img_path)&#10;                    VFX_Wound_Particle._frames.append(frame)&#10;                print(f&quot;[WoundParticle] 이미지 로드 완료: {len(VFX_Wound_Particle._frames)}개 프레임&quot;)&#10;            except Exception as ex:&#10;                print(f&quot;[WoundParticle] 이미지 로드 실패: {ex}&quot;)&#10;                VFX_Wound_Particle._frames = []&#10;&#10;        self.x = x&#10;        self.y = y&#10;        self.vx = vx  # x 방향 속도&#10;        self.vy = vy  # y 방향 속도&#10;        self.scale_factor = scale&#10;&#10;        # 애니메이션 설정&#10;        self.total_frames = 5  # 총 프레임 수&#10;        self.current_frame = 0&#10;        self.frame_duration = 0.08  # 각 프레임당 0.08초&#10;        self.frame_time_acc = 0.0&#10;        self.life = self.total_frames * self.frame_duration  # 총 수명&#10;&#10;        # 중력 효과&#10;        self.gravity = 200.0  # 픽셀/초^2&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 수명 감소&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False&#10;&#10;        # 물리 업데이트&#10;        self.x += self.vx * dt&#10;        self.y += self.vy * dt&#10;        self.vy -= self.gravity * dt  # 중력 적용&#10;&#10;        # 애니메이션 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.current_frame += 1&#10;            if self.current_frame &gt;= self.total_frames:&#10;                self.current_frame = self.total_frames - 1  # 마지막 프레임 유지&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if not VFX_Wound_Particle._frames or len(VFX_Wound_Particle._frames) == 0:&#10;            return&#10;&#10;        if self.current_frame &lt; len(VFX_Wound_Particle._frames):&#10;            image = VFX_Wound_Particle._frames[self.current_frame]&#10;            image.draw(&#10;                draw_x, draw_y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;&#10;&#10;# VFX 전역 배율 설정: 전체 이펙트 크기와 거리(범위)를 일괄 조정&#10;VFX_GLOBAL_SCALE_MULT = 0.7   # 이펙트 크기 0.7배&#10;VFX_GLOBAL_RANGE_MULT = 0.8   # 이펙트 거리 0.8배&#10;&#10;class VFX_Tier1_Sword_Swing:&#10;    &quot;&quot;&quot;검 공격 이펙트 VFX&quot;&quot;&quot;&#10;    def __init__(self, x, y, angle, flip, scale=4.5, range_factor=60, variant=1, owner=None):&#10;        import math&#10;&#10;        # 공격자 정보 저장&#10;        self.owner = owner&#10;&#10;        # 데미지 설정 (owner의 스탯에서 가져오거나 기본값 사용)&#10;        if owner and hasattr(owner, 'stats'):&#10;            self.damage = owner.stats.get('attack_damage')&#10;        else:&#10;            self.damage = 20.0  # 기본 데미지&#10;&#10;        # 전역 배율을 적용한 range_factor/scale 사용&#10;        range_factor = range_factor * VFX_GLOBAL_RANGE_MULT&#10;        scale = scale * VFX_GLOBAL_SCALE_MULT&#10;&#10;        # 받은 위치에서 angle 방향으로 range_factor만큼 떨어진 위치 계산&#10;        temp_x = range_factor * math.cos(angle)&#10;        temp_y = range_factor * math.sin(angle)&#10;&#10;        self.x = x + temp_x&#10;        self.y = y + temp_y&#10;&#10;        # 각도 조정: 마우스가 오른쪽(0도~90도, 270도~360도)일 때 -90도, 왼쪽일 때 +90도&#10;        angle_deg = math.degrees(angle) % 360&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽&#10;            self.angle = angle + math.radians(90)&#10;        else:  # 오른쪽&#10;            self.angle = angle - math.radians(90)&#10;&#10;        self.flip = flip&#10;        self.scale_factor = scale&#10;&#10;        # 이펙트 이미지 로드&#10;        fx_folder = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Swing_FX')&#10;        if variant == 1:&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;        elif variant == 2:&#10;            # 콤보 전용 스프라이트&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_1.png'))&#10;            ]&#10;        elif variant == 3:&#10;            # Heavy swing (3스테이지) - 여러 프레임&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_1.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_2.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_3.png'))&#10;            ]&#10;        else:&#10;            # 안전망: 기본으로 variant 1 사용&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.05  # 각 프레임당 0.05초&#10;        self.life = len(self.frames) * self.frame_duration  # 총 수명&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame += 1&#10;            if self.frame &gt;= len(self.frames):&#10;                self.frame = len(self.frames) - 1  # 마지막 프레임 유지&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.clip_composite_draw(&#10;                0, 0, image.w, image.h,&#10;                self.angle, self.flip,&#10;                draw_x, draw_y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;" />
              <option name="updatedContent" value="# 패키지 내부 모듈을 직접 실행할 경우 친절한 안내 후 종료&#10;if __name__ == &quot;__main__&quot; and (__package__ is None or __package__ == &quot;&quot;):&#10;    import sys&#10;    print(&quot;이 모듈은 game_logic 패키지 내부 모듈입니다. 프로젝트 루트에서 main.py를 실행하세요.&quot;)&#10;    sys.exit(1)&#10;&#10;import ctypes&#10;import os&#10;import random&#10;import time&#10;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width, draw_rectangle&#10;from sdl2 import (SDL_KEYDOWN, SDL_KEYUP, SDLK_a, SDLK_d, SDLK_w, SDLK_s, SDLK_TAB, SDL_GetMouseState,&#10;                   SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT)&#10;&#10;from .equipment import EquipmentManager, Sword, Shield&#10;from .state_machine import StateMachine&#10;from . import framework&#10;# 인벤토리 데이터 모델 import&#10;from .inventory import InventoryData, seed_debug_inventory&#10;from .stats import PlayerStats, StatModifier&#10;&#10;def Akey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_a&#10;def Akey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_a&#10;def Dkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_d&#10;def Dkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_d&#10;def Wkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_w&#10;def Wkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_w&#10;def Skey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_s&#10;def Skey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_s&#10;&#10;&#10;# 커스텀 이벤트 정의&#10;def move_event(e):&#10;    return e[0] == 'MOVE'&#10;&#10;def stop_event(e):&#10;    return e[0] == 'STOP'&#10;&#10;# Tab 키 입력 검사용 predicate (StateMachine 매핑용)&#10;def Tab_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_TAB&#10;&#10;class Run:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix, path):&#10;            files = sorted([f for f in os.listdir(path)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(path, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#10;&#10;        # 파티클 리소스 로드&#10;        particle_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Run_Dust')&#10;        self.particle_frames = load_seq('RunDust_Ver2_', particle_folder)&#10;        self.particle_spawn_timer = 0.0&#10;        self.particle_spawn_interval = 0.15 # 파티클 생성 간격&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Move frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.06&#10;        self.moving_speed = 300 # 초당 픽셀&#10;&#10;    def enter(self, e):&#10;        # 파티클 타이머만 초기화&#10;        self.particle_spawn_timer = 0.0&#10;&#10;    def exit(self, e):&#10;        # 파티클을 제거하지 않고 그대로 둠&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 플레이어 애니메이션 및 위치 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;        # 현재 스탯 기반 이동 속도 사용&#10;        moving_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else self.moving_speed&#10;        dir_magnitude = (self.player.dir[0] ** 2 + self.player.dir[1] ** 2) ** 0.5&#10;        if dir_magnitude &gt; 0:&#10;            norm_dir_x = self.player.dir[0] / dir_magnitude&#10;            norm_dir_y = self.player.dir[1] / dir_magnitude&#10;            new_x = self.player.x + norm_dir_x * moving_speed * dt&#10;            new_y = self.player.y + norm_dir_y * moving_speed * dt&#10;&#10;            # 맵 경계 체크 (카메라/월드 좌표 기반)&#10;            # lobby_mode에서 맵 크기를 가져와 경계 체크&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                # 배경 오브젝트에서 맵 크기 계산&#10;                if world['bg']:&#10;                    bg = world['bg'][0]&#10;                    map_width = bg.image.w * bg.scale&#10;                    map_height = bg.image.h * bg.scale&#10;                    # 맵의 중심이 (0, 0)이므로 경계는 ±map_width/2, ±map_height/2&#10;                    map_left = -map_width / 2&#10;                    map_right = map_width / 2&#10;                    map_bottom = -map_height / 2&#10;                    map_top = map_height / 2&#10;&#10;                    # 플레이어가 맵 경계를 벗어나지 않도록 제한&#10;                    if new_x &lt; map_left:&#10;                        new_x = map_left&#10;                    elif new_x &gt; map_right:&#10;                        new_x = map_right&#10;                    if new_y &lt; map_bottom:&#10;                        new_y = map_bottom&#10;                    elif new_y &gt; map_top:&#10;                        new_y = map_top&#10;            except Exception:&#10;                # 맵 정보를 가져올 수 없으면 화면 경계로 폴백&#10;                if new_x &gt; get_canvas_width():&#10;                    new_x = get_canvas_width()&#10;                elif new_x &lt; 0:&#10;                    new_x = 0&#10;                if new_y &gt; get_canvas_height():&#10;                    new_y = get_canvas_height()&#10;                elif new_y &lt; 0:&#10;                    new_y = 0&#10;&#10;            # 벽 충돌 체크 (플레이어 크기 32x48)&#10;            collided = False&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                for wall in world['walls']:&#10;                    if wall.check_collision(new_x - 32//2, new_y - 48//2, 32, 48):&#10;                        collided = True&#10;                        break&#10;            except Exception:&#10;                pass&#10;            if not collided:&#10;                self.player.x = new_x&#10;                self.player.y = new_y&#10;&#10;&#10;        # 파티클 생성&#10;        self.particle_spawn_timer += dt&#10;        if self.particle_spawn_timer &gt;= self.particle_spawn_interval:&#10;            self.particle_spawn_timer -= self.particle_spawn_interval&#10;            # 플레이어 발밑에 파티클 생성 (월드 좌표 사용)&#10;            # y 오프셋을 줄여서 발 위치에 더 가깝게 배치&#10;            particle_x = self.player.x + random.uniform(-10, 10)&#10;            particle_y = self.player.y - 20 + random.uniform(-5, 5)  # -40에서 -20으로 조정&#10;            new_particle = VFX_Run_Particle(particle_x, particle_y, self.particle_frames, 0.05, 2.0)&#10;            self.player.particles.append(new_particle)&#10;&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 파티클은 Player에서 그림&#10;&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;        # camera 가져오기&#10;        camera = None&#10;        try:&#10;            import game_logic.lobby_mode as lobby&#10;            camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            pass&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;class Idle:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix):&#10;            files = sorted([f for f in os.listdir(folder)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(folder, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Idle_Lower')&#10;        self.upper_frames = load_seq('Player_Adventurer_Idle_Upper')&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Idle frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.12&#10;&#10;    def enter(self, e):&#10;        self.player.dir = [0, 0]&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.frame_time_acc += dt&#10;        while self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;&#10;        # camera 가져오기 - play_mode 우선, lobby_mode로 폴백&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            print(f&quot;\033[91m[player Idle] 카메라 가져오기 실패\033[0m&quot;)&#10;&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;&#10;class Inventory:&#10;    &quot;&quot;&quot;인벤토리 상태: enter에서 이미지 로드, draw에서 중앙 오른쪽에 표시 (시뮬레이션 정지 없음)&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.image = None&#10;        self.scale = 1.0&#10;        self.prev_state = None  # 이전 상태 저장용&#10;&#10;    def enter(self, e):&#10;        # 현재 상태를 이전 상태로 저장 (복귀용)&#10;        self.prev_state = self.player.state_machine.cur_state&#10;&#10;        # 이미지 지연 로드(오버레이에서도 사용 가능하도록 유지하되, 여기서는 그리지 않음)&#10;        if self.image is None:&#10;            img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Inventory', 'InventoryBase_New1.png')&#10;            try:&#10;                self.image = load_image(img_path)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load inventory image: {img_path}, {ex}\033[0m&quot;)&#10;                self.image = None&#10;&#10;        # 인벤토리 표시 플래그만 설정 (이동은 유지)&#10;        self.player.inventory_open = True&#10;&#10;    def exit(self, e):&#10;        # 표시 플래그만 해제&#10;        self.player.inventory_open = False&#10;&#10;    def do(self):&#10;        # 현재 키 상태에 따라 Idle/Run의 do를 동적으로 실행&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.do()&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 현재 키 상태에 따라 Idle/Run의 draw를 먼저 실행&#10;        # active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        # active_state.draw(draw_x, draw_y)&#10;        # 인벤토리 이미지를 화면 오른쪽에 표시 (카메라 스크롤 영향 없음)&#10;        # if self.image:&#10;        #     canvas_w = get_canvas_width()&#10;        #     canvas_h = get_canvas_height()&#10;        #     inv_x = canvas_w - self.image.w * self.scale // 2 - 20&#10;        #     inv_y = canvas_h // 2&#10;        #     self.image.draw(inv_x, inv_y, self.image.w * self.scale, self.image.h * self.scale)&#10;        pass&#10;&#10;class Death:&#10;    &quot;&quot;&quot;플레이어 사망 상태&quot;&quot;&quot;&#10;    image = None&#10;    hit_fx_images = None  # PlayerHitFX 이미지들&#10;    heart_hit_images = None  # HeartHit 이미지들&#10;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.world = getattr(player, 'world', None)  # play_mode에서 할당된 world 참조&#10;&#10;        if Death.image is None:&#10;            try:&#10;                Death.image = load_image('resources/Texture_organize/Player_character/Adventurer/Player_Adventurer_Down00.png')&#10;                print(f&quot;[Player Death] Loaded Down00 image&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] Failed to load image: {e}\033[0m&quot;)&#10;                Death.image = None&#10;&#10;        # PlayerHitFX 이미지 로드 (1 ~ 9)&#10;        if Death.hit_fx_images is None:&#10;            Death.hit_fx_images = []&#10;            try:&#10;                for i in range(1, 10):  # PlayerHitFX01 ~ PlayerHitFX09&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Die_Animation', f'PlayerHitFX0{i}.png')&#10;                    img = load_image(img_path)&#10;                    Death.hit_fx_images.append(img)&#10;                print(f&quot;[Player Death] PlayerHitFX 이미지 로드 완료: {len(Death.hit_fx_images)}개&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] PlayerHitFX 이미지 로드 실패: {e}\033[0m&quot;)&#10;                Death.hit_fx_images = []&#10;&#10;        # HeartHit 이미지 로드 (0 ~ 8)&#10;        if Death.heart_hit_images is None:&#10;            Death.heart_hit_images = []&#10;            try:&#10;                for i in range(9):  # HeartHit0_0 ~ HeartHit8_0&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Hit_verdict', f'HeartHit{i}_0.png')&#10;                    img = load_image(img_path)&#10;                    Death.heart_hit_images.append(img)&#10;                print(f&quot;[Player Death] HeartHit 이미지 로드 완료: {len(Death.heart_hit_images)}개&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] HeartHit 이미지 로드 실패: {e}\033[0m&quot;)&#10;                Death.heart_hit_images = []&#10;&#10;        self.death_timer = 0.0&#10;        self.death_conversion = 2.0  # 2초 후 변환&#10;        self.death_duration = 6.0  # 6초 후 종료&#10;        self.game_over_conversion_triggered = False&#10;        self.game_over_triggered = False&#10;        self.player_transform = False&#10;&#10;        # 넉백 관련 변수 (강한 넉백)&#10;        self.knockback_dx = 0&#10;        self.knockback_dy = 0&#10;        self.knockback_speed = 400  # 강한 넉백&#10;        self.knockback_duration = 0.5  # 0.5초 동안&#10;        self.knockback_timer = 0.0&#10;&#10;        # 애니메이션 관련 변수&#10;        self.hit_fx_frame = 0&#10;        self.hit_fx_time = 0.0&#10;        self.hit_fx_duration = 0.08  # 각 프레임당 0.08초&#10;&#10;        self.heart_hit_frame = 0&#10;        self.heart_hit_time = 0.0&#10;        self.heart_hit_duration = 0.1  # 각 프레임당 0.1초&#10;&#10;        # 사망 모드용 배경 이미지 클래스&#10;        class BGimage:&#10;            &quot;&quot;&quot;사망 모드용 배경 이미지 클래스&quot;&quot;&quot;&#10;&#10;            def __init__(self, image_path):&#10;                try:&#10;                    self.image = load_image(image_path)&#10;                except Exception as e:&#10;                    print(f&quot;[Defeat Mode BG] 이미지 로드 실패: {e}&quot;)&#10;                    self.image = None&#10;&#10;                self.alpha = 0.0 # 투명도 초기값&#10;&#10;            def do(self):&#10;                pass&#10;&#10;            def update(self):&#10;                # 점진적으로 투명도 증가 / 3초 동안 완전 불투명&#10;                if self.alpha &lt; 1.0:&#10;                    self.alpha += framework.get_delta_time() / 3.0 * 2  # 3초에 걸쳐 1.0 도달&#10;                    if self.alpha &gt; 1.0:&#10;                        self.alpha = 1.0&#10;&#10;            def draw(self):&#10;                if self.image:&#10;                    canvas_w = get_canvas_width()&#10;                    canvas_h = get_canvas_height()&#10;                    self.image.opacify(self.alpha)&#10;                    self.image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)&#10;                    self.image.opacify(1.0)&#10;&#10;        # 배경 이미지 인스턴스 생성&#10;        self.BG = BGimage('resources/Texture_organize/UI/Stage_Loading/BlackBG.png')&#10;&#10;    def enter(self, e):&#10;        self.death_timer = 0.0&#10;        self.game_over_triggered = False&#10;        self.knockback_timer = 0.0&#10;&#10;        # 애니메이션 초기화&#10;        self.hit_fx_frame = 0&#10;        self.hit_fx_time = 0.0&#10;        self.heart_hit_frame = 0&#10;        self.heart_hit_time = 0.0&#10;&#10;        # 플레이어 무장 해제&#10;        self.player.equipment_manager.unequip_all()&#10;&#10;        # 넉백 방향 계산&#10;        if e and len(e) &gt; 1 and e[1] is not None:&#10;            attacker = e[1]&#10;            attacker_x = attacker.x if hasattr(attacker, 'x') else self.player.x&#10;            attacker_y = attacker.y if hasattr(attacker, 'y') else self.player.y&#10;&#10;            if hasattr(attacker, 'owner') and attacker.owner:&#10;                attacker_x = attacker.owner.x&#10;                attacker_y = attacker.owner.y&#10;&#10;            import math&#10;            dx = self.player.x - attacker_x&#10;            dy = self.player.y - attacker_y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            if distance &gt; 0:&#10;                self.knockback_dx = dx / distance&#10;                self.knockback_dy = dy / distance&#10;            else:&#10;                self.knockback_dx = 1.0&#10;                self.knockback_dy = 0.0&#10;        else:&#10;            self.knockback_dx = 1.0&#10;            self.knockback_dy = 0.0&#10;&#10;        print(f&quot;[Player Death State] 사망 상태 시작 (5초 후 게임 종료) - 넉백 적용&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.death_timer += dt&#10;&#10;        # 넉백 효과 적용 (사망 시에도 밀려남)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            # 부드러운 감속&#10;            current_speed = self.knockback_speed * (1.0 - progress) ** 1.5&#10;            self.player.x += self.knockback_dx * current_speed * dt&#10;            self.player.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;&#10;        # PlayerHitFX 애니메이션 업데이트&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#10;            self.hit_fx_time += dt&#10;            if self.hit_fx_time &gt;= self.hit_fx_duration:&#10;                self.hit_fx_time -= self.hit_fx_duration&#10;                self.hit_fx_frame += 1&#10;&#10;        # HeartHit 애니메이션 업데이트&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#10;            self.heart_hit_time += dt&#10;            if self.heart_hit_time &gt;= self.heart_hit_duration:&#10;                self.heart_hit_time -= self.heart_hit_duration&#10;                self.heart_hit_frame += 1&#10;&#10;        # 2초 후 사망 이미지로 전환(변환처리)&#10;        if self.death_timer &gt;= self.death_conversion and not self.game_over_conversion_triggered:&#10;            self.game_over_conversion_triggered = True&#10;            self.player_transform = True&#10;            # 사망 애니메이션 시작 위치 저장&#10;            self.death_start_x = self.player.x&#10;            self.death_start_y = self.player.y&#10;            from .play_mode import world&#10;            world['extra_bg'].append(self.BG)&#10;            world['extras'].append(self.player)&#10;            if self.player in self.world['entities']:&#10;                world['entities'].remove(self.player)&#10;&#10;        # 5초 후 게임 종료&#10;        if self.death_timer &gt;= self.death_duration and not self.game_over_triggered:&#10;            self.game_over_triggered = True&#10;            print(f&quot;[Player Death State] 5초 경과, 패배 모드로 전환&quot;)&#10;            import game_framework&#10;            from . import defeat_mode&#10;            game_framework.change_state(defeat_mode, self.player)&#10;&#10;        # 플레이어 사망시 중앙으로 서서히 이동 (3초 동안)&#10;        if self.player_transform:&#10;            target_x = get_canvas_width() // 2&#10;            target_y = get_canvas_height() // 2&#10;            move_duration = 3.0&#10;            progress = min((self.death_timer - self.death_conversion) / move_duration, 1.0)&#10;            # 선형 보간으로 위치 계산&#10;            self.player.x = self.death_start_x + (target_x - self.death_start_x) * progress&#10;            self.player.y = self.death_start_y + (target_y - self.death_start_y) * progress&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 플레이어 사망 이미지 (바닥에 누운 모습)&#10;        if Death.image is not None:&#10;            Death.image.draw(draw_x, draw_y,&#10;                           Death.image.w * self.player.scale_factor,&#10;                           Death.image.h * self.player.scale_factor)&#10;&#10;        # PlayerHitFX 이펙트 (플레이어 위치에 크게)&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#10;            hit_fx_img = Death.hit_fx_images[self.hit_fx_frame]&#10;            scale = 3.0&#10;            hit_fx_img.draw(&#10;                draw_x,&#10;                draw_y,&#10;                hit_fx_img.w * scale,&#10;                hit_fx_img.h * scale&#10;            )&#10;&#10;        # HeartHit 이펙트 (화면 중앙 상단에 크게)&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#10;            heart_hit_img = Death.heart_hit_images[self.heart_hit_frame]&#10;            canvas_w = get_canvas_width()&#10;            canvas_h = get_canvas_height()&#10;            scale = 3.0&#10;            heart_hit_img.draw(&#10;                draw_x,&#10;                draw_y,&#10;                heart_hit_img.w * scale,&#10;                heart_hit_img.h * scale&#10;            )&#10;&#10;&#10;# 사망 이벤트 predicate&#10;def die(e):&#10;    return e[0] == 'DIE'&#10;&#10;&#10;class Player:&#10;    def __init__(self):&#10;        self.x = get_canvas_width() // 2&#10;        self.y = get_canvas_height() // 2&#10;        self.frame = 0&#10;        self.dir = [0, 0]  # x, y 방향 벡터&#10;        self.face_dir = 1&#10;        self.scale_factor = 3.0&#10;        self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;        self.moving = False # 이동 상태 플래그&#10;        self.particles = [] # 파티클 리스트를 Player로 이동&#10;        self.attack_effects = [] # 공격 이펙트 리스트&#10;&#10;        # 플레이어 히트박스 변수&#10;        self.collision_width = 15 * self.scale_factor&#10;        self.collision_height = 15 * self.scale_factor&#10;&#10;        # 무적시간 관련 변수&#10;        self.invincible = False  # 무적 상태인지&#10;        self.invincible_timer = 0.0  # 무적 시간 타이머&#10;        self.invincible_duration = 0.3  # 무적 시간 지속 시간 (0.3초)&#10;&#10;        # 넉백 관련 변수 (방패 방어 시 사용)&#10;        self.knockback_dx = 0.0&#10;        self.knockback_dy = 0.0&#10;        self.knockback_speed = 0.0&#10;        self.knockback_duration = 0.0&#10;        self.knockback_timer = 0.0&#10;&#10;        # 인벤토리 데이터 생성 및 디버그 아이템 채우기&#10;        self.inventory = InventoryData(cols=6, rows=5)&#10;        try:&#10;            seed_debug_inventory(self.inventory)&#10;        except Exception as ex:&#10;            print('[Player] 디버그 인벤토리 시드 실패:', ex)&#10;&#10;        # 스탯 시스템&#10;        self.stats = PlayerStats()&#10;        # 인벤토리 패시브 적용&#10;        try:&#10;            self.rebuild_inventory_passives()&#10;        except Exception as ex:&#10;            print('[Player] 패시브 재구성 실패:', ex)&#10;&#10;        # 장비 매니저 초기화&#10;        self.equipment_manager = EquipmentManager(self)&#10;&#10;        # 기본 무기 장착 (Tier1 검과 방패)&#10;        sword_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Sword_Tier1.png')&#10;        shield_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Shield_Tier1.png')&#10;&#10;        self.sword = Sword(self, sword_path, scale=3.0)&#10;        self.shield = Shield(self, shield_path, scale=3.0)&#10;&#10;        self.equipment_manager.equip(self.sword)&#10;        self.equipment_manager.equip(self.shield)&#10;&#10;        # 상태 정의&#10;        self.IDLE = Idle(self)&#10;        self.RUN = Run(self)&#10;        self.INVENTORY = Inventory(self)&#10;        self.DEATH = Death(self)&#10;&#10;        # 전투 플래그(전투중엔 인벤토리 안 염)&#10;        self.in_combat = False&#10;        self.inventory_open = False&#10;&#10;        # 상태 전환에 대한 매핑&#10;        self.state_machine = StateMachine(&#10;            self.IDLE,&#10;            {&#10;                self.IDLE: {move_event: self.RUN, Tab_down: self.INVENTORY, die: self.DEATH},&#10;                self.RUN: {stop_event: self.IDLE, Tab_down: self.INVENTORY, die: self.DEATH},&#10;                self.INVENTORY: {Tab_down: None, die: self.DEATH},&#10;                self.DEATH: {},  # 사망 상태에서는 전환 없음&#10;            }&#10;        )&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 넉백 효과 적용 (방패 방어 시)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            current_speed = self.knockback_speed * (1.0 - progress)&#10;            self.x += self.knockback_dx * current_speed * dt&#10;            self.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;&#10;        # 무적시간 업데이트&#10;        if self.invincible:&#10;            self.invincible_timer -= dt&#10;            if self.invincible_timer &lt;= 0:&#10;                self.invincible = False&#10;                self.invincible_timer = 0.0&#10;&#10;        self.state_machine.update()&#10;&#10;        # 스탯 버프 업데이트(소비형 지속시간 관리)&#10;        if hasattr(self, 'stats'):&#10;            self.stats.update()&#10;&#10;        # 파티클 업데이트 (상태와 무관하게 항상 실행)&#10;        for p in self.particles:&#10;            p.update()&#10;        self.particles = [p for p in self.particles if p.life &gt; 0]&#10;&#10;        # 공격 이펙트 업데이트&#10;        for effect in self.attack_effects:&#10;            effect.update()&#10;        self.attack_effects = [e for e in self.attack_effects if e.life &gt; 0]&#10;&#10;        # 장비 업데이트&#10;        self.equipment_manager.update()&#10;&#10;    # 인벤토리 패시브 재적용&#10;    def rebuild_inventory_passives(self):&#10;        prefix = 'passive:'&#10;        self.stats.clear_by_prefix(prefix)&#10;        # 모든 슬롯 순회&#10;        try:&#10;            for r in range(self.inventory.rows):&#10;                for c in range(self.inventory.cols):&#10;                    slot = self.inventory.get_slot(r, c)&#10;                    if slot.is_empty():&#10;                        continue&#10;                    item = slot.item&#10;                    if getattr(item, 'passive', None):&#10;                        # 수량만큼 배수 적용(스택형 패시브 고려)&#10;                        qty = max(1, slot.quantity)&#10;                        values = {k: v * qty for k, v in item.passive.items()}&#10;                        mod_id = f'{prefix}{item.id}:{r},{c}'&#10;                        self.stats.add_modifier(StatModifier(mod_id, values, duration=None))&#10;        except Exception as ex:&#10;            print(f&quot;\033[91m[Player] 패시브 적용 중 오류: {ex}\033[0m&quot;)&#10;&#10;    # 소비형 아이템 사용 처리&#10;    def consume_item_at(self, r: int, c: int):&#10;        try:&#10;            slot = self.inventory.get_slot(r, c)&#10;        except Exception as ex:&#10;            print('[Player] 소비 실패: 잘못된 슬롯', ex)&#10;            return False&#10;        if slot.is_empty() or not getattr(slot.item, 'consumable', None):&#10;            return False&#10;        item = slot.item&#10;        values = dict(item.consumable)&#10;        duration = item.consume_duration&#10;        mod_id = f'consumable:{item.id}:{r},{c}:{int(time.time()*1000)%100000}'&#10;        self.stats.add_modifier(StatModifier(mod_id, values, duration=duration))&#10;        # 1개 소모&#10;        self.inventory.remove_from(r, c, 1)&#10;        # 아이템의 이펙트 재생(있다면)&#10;        vfx_fn = (getattr(item, 'on_consume_vfx', None)&#10;                  or getattr(item, '_play_consume_vfx', None)&#10;                  or getattr(item, 'consume_effect', None))&#10;        if callable(vfx_fn):&#10;            try:&#10;                # prefer self.world (assigned by play_mode) so VFX are appended to the correct world dict&#10;                vfx_world = getattr(self, 'world', None)&#10;                # debug log&#10;                try:&#10;                    print(f&quot;[Player] triggering vfx for {getattr(item, 'name', item.id if hasattr(item,'id') else 'Unknown')} world={'set' if vfx_world is not None else 'None'})&quot;)&#10;                except Exception:&#10;                    pass&#10;                vfx_fn(self, world=vfx_world, x=getattr(self, 'x', None), y=getattr(self, 'y', None))&#10;            except Exception as ex:&#10;                print(f'[Player] 아이템 소비 이펙트 오류 ({item.name}):', ex)&#10;        # 패시브 재적용(수량 변화로 인한 패시브 변경 가능성 고려)&#10;        self.rebuild_inventory_passives()&#10;        print(f&quot;[Player] 소비: {item.name} -&gt; {values} ({duration}s)&quot;)&#10;        return True&#10;&#10;    # 신규: 입력 처리 - 상태머신과 장비 매니저로 이벤트 전달, 이동 벡터 관리&#10;    def handle_event(self, event):&#10;        try:&#10;            from sdl2 import SDL_KEYDOWN, SDL_KEYUP, SDLK_w, SDLK_a, SDLK_s, SDLK_d&#10;        except Exception:&#10;            SDL_KEYDOWN = SDL_KEYUP = None&#10;            SDLK_w = SDLK_a = SDLK_s = SDLK_d = None&#10;&#10;        # 1) 장비 매니저에 항상 전달(매니저 내부에서 인벤토리 오픈시 무시 처리)&#10;        try:&#10;            if hasattr(self, 'equipment_manager') and hasattr(self.equipment_manager, 'handle_event'):&#10;                self.equipment_manager.handle_event(event)&#10;        except Exception as ex:&#10;            print('[Player] equipment_manager.handle_event 오류:', ex)&#10;&#10;        # 2) 상태머신으로 원본 입력 이벤트 전달(Tab 매핑 등 predicates가 처리)&#10;        try:&#10;            if hasattr(self, 'state_machine') and hasattr(self.state_machine, 'handle_state_event'):&#10;                self.state_machine.handle_state_event(('INPUT', event))&#10;        except Exception as ex:&#10;            print('[Player] state_machine 입력 이벤트 처리 오류:', ex)&#10;&#10;        # 3) WASD 이동 상태 관리 -&gt; MOVE/STOP 이벤트 생성&#10;        moved_before = any(self.keys_down.values())&#10;        try:&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = True&#10;                    self.dir[1] = 1&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = True&#10;                    self.dir[1] = -1&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = True&#10;                    self.dir[0] = -1&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = True&#10;                    self.dir[0] = 1&#10;            elif SDL_KEYUP is not None and event.type == SDL_KEYUP:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;&#10;        except Exception as ex:&#10;            print('[Player] 이동 입력 처리 오류:', ex)&#10;&#10;        moved_after = any(self.keys_down.values())&#10;        try:&#10;            if not moved_before and moved_after:&#10;                # 시작 이동&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('MOVE', None))&#10;            elif moved_before and not moved_after:&#10;                # 이동 종료&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('STOP', None))&#10;        except Exception as ex:&#10;            print('[Player] MOVE/STOP 이벤트 처리 오류:', ex)&#10;&#10;    # 신규: 렌더링 - 장비/플레이어/이펙트 순서대로 그리기&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표이므로 그대로 사용&#10;&#10;        # 디버그 로그 - 카메라 정보 포함&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except:&#10;            pass&#10;&#10;        # if camera is not None:&#10;        #     print(f'[Player] draw at screen ({draw_x:.1f}, {draw_y:.1f}), '&#10;        #           f'world ({self.x:.1f}, {self.y:.1f}), '&#10;        #           f'camera ({camera.x:.1f}, {camera.y:.1f})')&#10;        # else:&#10;        #     print(f'[Player] draw at ({draw_x:.1f}, {draw_y:.1f}), world ({self.x:.1f}, {self.y:.1f}) (NO CAMERA)')&#10;&#10;        # 1) 장비(뒤쪽) 그리기&#10;        if hasattr(self, 'equipment_manager'):&#10;            self.equipment_manager.draw_back(draw_x, draw_y)&#10;&#10;        # 2) 현재 상태 스프라이트(Idle/Run/Inventory)&#10;        try:&#10;            if hasattr(self, 'state_machine'):&#10;                self.state_machine.draw(draw_x, draw_y)&#10;        except Exception:&#10;            pass&#10;&#10;        # 3) 장비(앞쪽) 그리기&#10;        if hasattr(self, 'equipment_manager'):&#10;            self.equipment_manager.draw_front(draw_x, draw_y)&#10;&#10;        # 4) 파티클/공격 이펙트 (카메라 적용)&#10;        try:&#10;            # 위에서 이미 가져온 camera 사용&#10;            for p in getattr(self, 'particles', []):&#10;                if hasattr(p, 'draw'):&#10;                    if camera is not None:&#10;                        particle_draw_x, particle_draw_y = camera.apply(p.x, p.y)&#10;                        p.draw(particle_draw_x, particle_draw_y)&#10;                    else:&#10;                        p.draw(p.x, p.y)&#10;            for e in getattr(self, 'attack_effects', []):&#10;                if hasattr(e, 'draw'):&#10;                    if camera is not None:&#10;                        effect_draw_x, effect_draw_y = camera.apply(e.x, e.y)&#10;                        e.draw(effect_draw_x, effect_draw_y)&#10;                    else:&#10;                        e.draw(e.x, e.y)&#10;        except Exception:&#10;            pass&#10;&#10;        # 화면에 표시되는 히트박스 (카메라 적용된 좌표 사용)&#10;        player_left = draw_x - self.collision_width / 2&#10;        player_right = draw_x + self.collision_width / 2&#10;        player_bottom = draw_y - self.collision_height / 2&#10;        player_top = draw_y + self.collision_height / 2&#10;        draw_rectangle(player_left, player_bottom, player_right, player_top)&#10;&#10;    def check_collision_with_projectile(self, projectile):&#10;        &quot;&quot;&quot;몬스터 발사체와의 충돌 감지&#10;&#10;        Args:&#10;            projectile: Projectile을 상속받은 발사체 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 먼저 방패로 방어할 수 있는지 체크&#10;        if hasattr(self, 'shield') and self.shield:&#10;            if self.shield.check_projectile_block(projectile):&#10;                # 방패로 막았으면 투사체를 제거하고 충돌 처리 종료&#10;                return True&#10;&#10;        # 무적 상태이면 충돌 무시&#10;        if hasattr(self, 'invincible') and self.invincible:&#10;            return False&#10;&#10;        # 발사체 크기 (Projectile의 get_collision_box 메서드 사용)&#10;        if hasattr(projectile, 'get_collision_box'):&#10;            projectile_width, projectile_height = projectile.get_collision_box()&#10;        else:&#10;            projectile_width = 30&#10;            projectile_height = 30&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        player_left = self.x - self.collision_width / 2&#10;        player_right = self.x + self.collision_width / 2&#10;        player_bottom = self.y - self.collision_height / 2&#10;        player_top = self.y + self.collision_height / 2&#10;&#10;        proj_left = projectile.x - projectile_width / 2&#10;        proj_right = projectile.x + projectile_width / 2&#10;        proj_bottom = projectile.y - projectile_height / 2&#10;        proj_top = projectile.y + projectile_height / 2&#10;&#10;        # 충돌 검사&#10;        if (player_left &lt; proj_right and player_right &gt; proj_left and&#10;            player_bottom &lt; proj_top and player_top &gt; proj_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(projectile)&#10;            return True&#10;&#10;        return False&#10;&#10;    def on_hit(self, attacker):&#10;        &quot;&quot;&quot;피격 시 호출되는 메서드&#10;&#10;        Args:&#10;            attacker: 공격한 객체 (투사체, 이펙트 등)&#10;        &quot;&quot;&quot;&#10;        # 무적 상태라면 무시&#10;        if self.invincible:&#10;            print(f&quot;[Player] 무적 상태로 피격 무시 (남은 무적시간: {self.invincible_timer:.2f}초)&quot;)&#10;            return&#10;&#10;        # 사망 상태면 무시&#10;        if isinstance(self.state_machine.cur_state, Death):&#10;            return&#10;&#10;        # 무적시간 활성화&#10;        self.invincible = True&#10;        self.invincible_timer = self.invincible_duration&#10;&#10;        # 데미지 계산&#10;        damage = 0&#10;        if hasattr(attacker, 'damage'):&#10;            damage = attacker.damage&#10;        elif hasattr(attacker, 'owner') and hasattr(attacker.owner, 'stats'):&#10;            # 공격자의 스탯에서 데미지 가져오기&#10;            damage = attacker.owner.stats.get('attack_damage')&#10;        else:&#10;            damage = 10.0  # 기본 데미지&#10;&#10;        # 방어력 적산&#10;        defense = self.stats.get('defense') if hasattr(self, 'stats') else 0&#10;        final_damage = max(1.0, damage - defense)&#10;&#10;        # 넉백 효과 적용 (공격자로부터 밀려나는 방향)&#10;        import math&#10;        knockback_distance = 100.0  # 넉백 거리&#10;        knockback_duration = 0.3  # 넉백 지속 시간 (초)&#10;&#10;        # 공격자의 위치 파악&#10;        attacker_x = attacker.x if hasattr(attacker, 'x') else self.x&#10;        attacker_y = attacker.y if hasattr(attacker, 'y') else self.y&#10;&#10;        # 넉백 방향 계산 (공격자 -&gt; 플레이어 방향)&#10;        dx = self.x - attacker_x&#10;        dy = self.y - attacker_y&#10;        distance = math.sqrt(dx * dx + dy * dy)&#10;&#10;        if distance &gt; 0:&#10;            # 정규화된 방향 벡터&#10;            self.knockback_dx = dx / distance&#10;            self.knockback_dy = dy / distance&#10;        else:&#10;            # 공격자와 위치가 같으면 랜덤 방향&#10;            angle = random.uniform(0, 2 * math.pi)&#10;            self.knockback_dx = math.cos(angle)&#10;            self.knockback_dy = math.sin(angle)&#10;&#10;        self.knockback_speed = knockback_distance / knockback_duration&#10;        self.knockback_duration = knockback_duration&#10;        self.knockback_timer = 0.0&#10;&#10;        # 체력 감소&#10;        if hasattr(self, 'stats'):&#10;            current_health = self.stats.get('health')&#10;            max_health = self.stats.get('max_health')&#10;            new_health = max(0, current_health - final_damage)&#10;            self.stats.set_base('health', new_health)&#10;&#10;            # 피격 정보 출력&#10;            attacker_name = attacker.__class__.__name__&#10;            DebugPrint = True&#10;            if DebugPrint:&#10;                print(f&quot;\n{'='*60}&quot;)&#10;                print(f&quot;[Player 피격]&quot;)&#10;                print(f&quot;  공격자: {attacker_name}&quot;)&#10;                print(f&quot;  원본 데미지: {damage:.1f}&quot;)&#10;                print(f&quot;  방어력: {defense:.1f}&quot;)&#10;                print(f&quot;  최종 데미지: {final_damage:.1f}&quot;)&#10;                print(f&quot;  체력 변화: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})&quot;)&#10;                print(f&quot;  체력 비율: {(new_health/max_health)*100:.1f}%&quot;)&#10;                print(f&quot;  무적시간: {self.invincible_duration}초 활성화&quot;)&#10;                print(f&quot;  넉백: 거리 {knockback_distance:.1f}px, 지속시간 {knockback_duration:.2f}초&quot;)&#10;&#10;            # 체력이 0 이하면 사망 상태로 전환&#10;            if new_health &lt;= 0:&#10;                print(f&quot;  &gt;&gt;&gt; Player 체력 0 - 사망 상태로 전환&quot;)&#10;                print(f&quot;{'='*60}\n&quot;)&#10;                self.state_machine.handle_state_event(('DIE', attacker))&#10;                return  # 사망 시 이펙트 생성하지 않음&#10;            else:&#10;                print(f&quot;{'='*60}\n&quot;)&#10;        else:&#10;            attacker_name = attacker.__class__.__name__&#10;            print(f&quot;[Player] 피격당함! 공격자: {attacker_name} (스탯 시스템 없음)&quot;)&#10;&#10;        # 피격 이펙트 재생 - Wound Particle 생성 (4개)&#10;        for i in range(4):&#10;            # 랜덤한 방향으로 파티클 발사&#10;            angle = random.uniform(0, 2 * math.pi)&#10;            speed = random.uniform(80, 150)  # 속도 랜덤&#10;            vx = math.cos(angle) * speed&#10;            vy = math.sin(angle) * speed + random.uniform(50, 100) # 위쪽으로 약간 더 많이&#10;&#10;            # 플레이어 위치에서 약간 랜덤한 오프셋&#10;            offset_x = random.uniform(-10, 10)&#10;            offset_y = random.uniform(-10, 10)&#10;&#10;            wound_particle = VFX_Wound_Particle(&#10;                self.x + offset_x,&#10;                self.y + offset_y,&#10;                vx, vy,&#10;                scale=3.0&#10;            )&#10;            self.particles.append(wound_particle)&#10;&#10;        print(f&quot;[Player] 피격 이펙트 생성 완료 (Wound Particle x4)&quot;)&#10;&#10;        # TODO: 추후 추가 가능&#10;        # - 피격 사운드&#10;&#10;    def on_death(self):&#10;        &quot;&quot;&quot;사망 처리 - 상태 머신을 통해 Death 상태로 전환&quot;&quot;&quot;&#10;        print(&quot;[Player] on_death 호출 - Death 상태로 전환&quot;)&#10;        self.state_machine.handle_state_event(('DIE', None))&#10;&#10;class VFX_Run_Particle:&#10;    def __init__(self, x, y, frames, frame_duration, scale):&#10;        self.x, self.y = x, y&#10;        self.frames = frames&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = frame_duration&#10;        self.scale_factor = scale&#10;        self.life = len(frames) * frame_duration&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt; 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.frames)&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.draw(draw_x, draw_y, image.w * self.scale_factor, image.h * self.scale_factor)&#10;&#10;&#10;class VFX_Wound_Particle:&#10;    &quot;&quot;&quot;피격 시 출혈 파티클 이펙트 (개별 이미지 파일 사용)&quot;&quot;&quot;&#10;    _frames = None  # 클래스 변수로 이미지 프레임 공유&#10;&#10;    def __init__(self, x, y, vx, vy, scale=3.0):&#10;        # 이미지 프레임 로드 (최초 1회만)&#10;        if VFX_Wound_Particle._frames is None:&#10;            VFX_Wound_Particle._frames = []&#10;            wound_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Wound_Particle')&#10;            try:&#10;                for i in range(5):  # WoundParticle_0 ~ WoundParticle_4&#10;                    img_path = os.path.join(wound_folder, f'WoundParticle_{i}.png')&#10;                    frame = load_image(img_path)&#10;                    VFX_Wound_Particle._frames.append(frame)&#10;                print(f&quot;[WoundParticle] 이미지 로드 완료: {len(VFX_Wound_Particle._frames)}개 프레임&quot;)&#10;            except Exception as ex:&#10;                print(f&quot;[WoundParticle] 이미지 로드 실패: {ex}&quot;)&#10;                VFX_Wound_Particle._frames = []&#10;&#10;        self.x = x&#10;        self.y = y&#10;        self.vx = vx  # x 방향 속도&#10;        self.vy = vy  # y 방향 속도&#10;        self.scale_factor = scale&#10;&#10;        # 애니메이션 설정&#10;        self.total_frames = 5  # 총 프레임 수&#10;        self.current_frame = 0&#10;        self.frame_duration = 0.08  # 각 프레임당 0.08초&#10;        self.frame_time_acc = 0.0&#10;        self.life = self.total_frames * self.frame_duration  # 총 수명&#10;&#10;        # 중력 효과&#10;        self.gravity = 200.0  # 픽셀/초^2&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 수명 감소&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False&#10;&#10;        # 물리 업데이트&#10;        self.x += self.vx * dt&#10;        self.y += self.vy * dt&#10;        self.vy -= self.gravity * dt  # 중력 적용&#10;&#10;        # 애니메이션 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.current_frame += 1&#10;            if self.current_frame &gt;= self.total_frames:&#10;                self.current_frame = self.total_frames - 1  # 마지막 프레임 유지&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if not VFX_Wound_Particle._frames or len(VFX_Wound_Particle._frames) == 0:&#10;            return&#10;&#10;        if self.current_frame &lt; len(VFX_Wound_Particle._frames):&#10;            image = VFX_Wound_Particle._frames[self.current_frame]&#10;            image.draw(&#10;                draw_x, draw_y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;&#10;&#10;# VFX 전역 배율 설정: 전체 이펙트 크기와 거리(범위)를 일괄 조정&#10;VFX_GLOBAL_SCALE_MULT = 0.7   # 이펙트 크기 0.7배&#10;VFX_GLOBAL_RANGE_MULT = 0.8   # 이펙트 거리 0.8배&#10;&#10;class VFX_Tier1_Sword_Swing:&#10;    &quot;&quot;&quot;검 공격 이펙트 VFX&quot;&quot;&quot;&#10;    def __init__(self, x, y, angle, flip, scale=4.5, range_factor=60, variant=1, owner=None):&#10;        import math&#10;&#10;        # 공격자 정보 저장&#10;        self.owner = owner&#10;&#10;        # 데미지 설정 (owner의 스탯에서 가져오거나 기본값 사용)&#10;        if owner and hasattr(owner, 'stats'):&#10;            self.damage = owner.stats.get('attack_damage')&#10;        else:&#10;            self.damage = 20.0  # 기본 데미지&#10;&#10;        # 전역 배율을 적용한 range_factor/scale 사용&#10;        range_factor = range_factor * VFX_GLOBAL_RANGE_MULT&#10;        scale = scale * VFX_GLOBAL_SCALE_MULT&#10;&#10;        # 받은 위치에서 angle 방향으로 range_factor만큼 떨어진 위치 계산&#10;        temp_x = range_factor * math.cos(angle)&#10;        temp_y = range_factor * math.sin(angle)&#10;&#10;        self.x = x + temp_x&#10;        self.y = y + temp_y&#10;&#10;        # 각도 조정: 마우스가 오른쪽(0도~90도, 270도~360도)일 때 -90도, 왼쪽일 때 +90도&#10;        angle_deg = math.degrees(angle) % 360&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽&#10;            self.angle = angle + math.radians(90)&#10;        else:  # 오른쪽&#10;            self.angle = angle - math.radians(90)&#10;&#10;        self.flip = flip&#10;        self.scale_factor = scale&#10;&#10;        # 이펙트 이미지 로드&#10;        fx_folder = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Swing_FX')&#10;        if variant == 1:&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;        elif variant == 2:&#10;            # 콤보 전용 스프라이트&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_1.png'))&#10;            ]&#10;        elif variant == 3:&#10;            # Heavy swing (3스테이지) - 여러 프레임&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_1.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_2.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_3.png'))&#10;            ]&#10;        else:&#10;            # 안전망: 기본으로 variant 1 사용&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.05  # 각 프레임당 0.05초&#10;        self.life = len(self.frames) * self.frame_duration  # 총 수명&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame += 1&#10;            if self.frame &gt;= len(self.frames):&#10;                self.frame = len(self.frames) - 1  # 마지막 프레임 유지&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.clip_composite_draw(&#10;                0, 0, image.w, image.h,&#10;                self.angle, self.flip,&#10;                draw_x, draw_y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/title_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/title_mode.py" />
              <option name="originalContent" value="# game_logic/title_mode.py&#10;&quot;&quot;&quot;타이틀 화면 모듈&quot;&quot;&quot;&#10;&#10;import pico2d as p2&#10;import ctypes&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE, SDLK_RETURN, SDLK_SPACE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_GetMouseState, SDL_MOUSEMOTION&#10;&#10;import game_framework&#10;from . import framework&#10;from .cursor import Cursor&#10;&#10;# 타이틀 화면 이미지&#10;title_image = None&#10;title_back_image = None&#10;&#10;# Tree 애니메이션&#10;tree_begin_images = []  # TreeBegin 애니메이션 (00~29)&#10;tree_loop_images = []   # Tree 루프 애니메이션 (00~15)&#10;animation_frame = 0&#10;animation_time = 0.0&#10;animation_fps = 12  # 초당 프레임 수&#10;is_begin_phase = True  # True: TreeBegin 재생 중, False: Tree 루프 재생 중&#10;&#10;# 스케일 팩터&#10;tree_scale = 3.0  # Tree 애니메이션 스케일&#10;title_scale = 3.0  # 타이틀 로고 스케일&#10;&#10;# 월드 레이어 (play_mode와 유사한 구조)&#10;world = {&#10;    'background': [],  # 배경 이미지&#10;    'tree_animation': [],  # Tree 애니메이션&#10;    'title': [],  # 타이틀 로고&#10;    'buttons': [],  # 메뉴 버튼들&#10;    'cursor': []  # 커서&#10;}&#10;&#10;# 배경 렌더러&#10;class BackgroundRenderer:&#10;    &quot;&quot;&quot;배경 이미지를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image):&#10;        self.image = image&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;            self.image.draw(center_x, center_y, canvas_width, canvas_height)&#10;&#10;# Tree 애니메이션 렌더러&#10;class TreeAnimationRenderer:&#10;    &quot;&quot;&quot;Tree 애니메이션을 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, begin_images, loop_images, scale):&#10;        self.begin_images = begin_images&#10;        self.loop_images = loop_images&#10;        self.scale = scale&#10;        self.current_frame = 0&#10;        self.animation_time = 0.0&#10;        self.animation_fps = 12&#10;        self.is_begin_phase = True&#10;&#10;    def update(self):&#10;        dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;        self.animation_time += dt&#10;&#10;        frame_time = 1.0 / self.animation_fps&#10;&#10;        if self.animation_time &gt;= frame_time:&#10;            self.animation_time -= frame_time&#10;&#10;            if self.is_begin_phase:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.begin_images):&#10;                    self.is_begin_phase = False&#10;                    self.current_frame = 0&#10;                    print(&quot;[title_mode] TreeBegin 완료, Tree 루프 시작&quot;)&#10;            else:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.loop_images):&#10;                    self.current_frame = 0&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        canvas_width = p2.get_canvas_width()&#10;        canvas_height = p2.get_canvas_height()&#10;        center_x = canvas_width // 2&#10;        center_y = canvas_height // 2&#10;&#10;        if self.is_begin_phase and self.begin_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.begin_images):&#10;                tree_img = self.begin_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;        elif not self.is_begin_phase and self.loop_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.loop_images):&#10;                tree_img = self.loop_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;&#10;# 타이틀 로고 렌더러&#10;class TitleRenderer:&#10;    &quot;&quot;&quot;타이틀 로고를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image, scale):&#10;        self.image = image&#10;        self.scale = scale&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;&#10;            title_width = int(self.image.w * self.scale)&#10;            title_height = int(self.image.h * self.scale)&#10;            self.image.draw(center_x, int(center_y * 0.7), title_width, title_height)&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False&#10;&#10;# 메뉴 버튼&#10;class MenuButton:&#10;    &quot;&quot;&quot;클릭 가능한 메뉴 버튼 클래스&quot;&quot;&quot;&#10;    _font = None  # 클래스 변수로 폰트 공유&#10;&#10;    def __init__(self, text, x, y, width, height, callback):&#10;        self.text = text&#10;        self.x = x  # 중심 x 좌표&#10;        self.y = y  # 중심 y 좌표&#10;        self.width = width&#10;        self.height = height&#10;        self.callback = callback&#10;        self.hovered = False&#10;&#10;        # 폰트 로드 (최초 1회만)&#10;        if MenuButton._font is None:&#10;            try:&#10;                from pico2d import load_font&#10;                import os&#10;                # 폰트 경로 후보 (한글 지원 폰트 우선)&#10;                font_candidates = [&#10;                    'resources/Fonts/pixelroborobo.otf',&#10;                ]&#10;                for font_path in font_candidates:&#10;                    try:&#10;                        MenuButton._font = load_font(font_path, 40)  # 버튼용 폰트 크기 40으로 증가&#10;                        print(f&quot;[MenuButton] 폰트 로드 성공: {font_path}&quot;)&#10;                        break&#10;                    except Exception:&#10;                        continue&#10;            except Exception as ex:&#10;                print(f&quot;[MenuButton] 폰트 로드 실패: {ex}&quot;)&#10;&#10;    def contains_point(self, px, py):&#10;        &quot;&quot;&quot;점이 버튼 내부에 있는지 확인&quot;&quot;&quot;&#10;        left = self.x - self.width // 2&#10;        right = self.x + self.width // 2&#10;        bottom = self.y - self.height // 2&#10;        top = self.y + self.height // 2&#10;        return left &lt;= px &lt;= right and bottom &lt;= py &lt;= top&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치에 따라 hover 상태 업데이트&quot;&quot;&quot;&#10;        # 마우스 위치 가져오기&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        mouse_x = mx_ptr.value&#10;        mouse_y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        self.hovered = self.contains_point(mouse_x, mouse_y)&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;버튼 그리기&quot;&quot;&quot;&#10;        # 버튼 배경 박스&#10;        if self.hovered:&#10;            # hover 상태: 밝은 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;        else:&#10;            # 일반 상태: 어두운 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;&#10;        # 텍스트 표시&#10;        if MenuButton._font:&#10;            # 텍스트 색상 (hover 상태에 따라 변경)&#10;            if self.hovered:&#10;                # hover 상태: 밝은 흰색&#10;                text_color = (255, 255, 150)&#10;                shadow_color = (0, 0, 0)&#10;            else:&#10;                # 일반 상태: 회색&#10;                text_color = (200, 200, 200)&#10;                shadow_color = (50, 50, 50)&#10;&#10;            # 그림자 효과 (가독성 향상)&#10;            MenuButton._font.draw(self.x - 2, self.y - 2, self.text, shadow_color)&#10;            MenuButton._font.draw(self.x - 1, self.y - 1, self.text, shadow_color)&#10;            # 실제 텍스트&#10;            MenuButton._font.draw(self.x, self.y, self.text, text_color)&#10;&#10;    def on_click(self):&#10;        &quot;&quot;&quot;버튼 클릭 시 콜백 실행&quot;&quot;&quot;&#10;        if self.callback:&#10;            self.callback()&#10;&#10;# 메뉴 버튼 리스트&#10;mouse_x, mouse_y = 0, 0&#10;&#10;def start_game():&#10;    &quot;&quot;&quot;게임 시작 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 시작&quot;)&#10;    import game_logic.play_mode as play_mode&#10;    import game_logic.lobby_mode as lobby_mode&#10;    game_framework.change_state(lobby_mode)&#10;&#10;def quit_game():&#10;    &quot;&quot;&quot;게임 종료 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 종료&quot;)&#10;    game_framework.quit()&#10;&#10;def enter():&#10;    &quot;&quot;&quot;타이틀 모드 진입&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images&#10;    global animation_frame, animation_time, is_begin_phase, world&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 진입&quot;)&#10;&#10;    # 월드 레이어 초기화&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    # 이미지 로드&#10;    title_back_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title_Back.png')&#10;    title_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title.png')&#10;&#10;    # Tree Begin 애니메이션 로드 (00~29)&#10;    tree_begin_images = []&#10;    for i in range(30):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_TreeBegin{i:02d}.png'&#10;        try:&#10;            img = p2.load_image(path)&#10;            tree_begin_images.append(img)&#10;        except Exception as e:&#10;            print(f&quot;[title_mode] TreeBegin 이미지 로드 실패: {path}, {e}&quot;)&#10;&#10;    print(f&quot;[title_mode] TreeBegin 이미지 {len(tree_begin_images)}개 로드 완료&quot;)&#10;&#10;    # Tree Loop 애니메이션 로드 (00~15)&#10;    tree_loop_images = []&#10;    for i in range(16):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_Tree{i:02d}.png'&#10;        try:&#10;            img = p2.load_image(path)&#10;            tree_loop_images.append(img)&#10;        except Exception as e:&#10;            print(f&quot;[title_mode] Tree 이미지 로드 실패: {path}, {e}&quot;)&#10;&#10;    print(f&quot;[title_mode] Tree 이미지 {len(tree_loop_images)}개 로드 완료&quot;)&#10;&#10;    # 월드 레이어에 객체 추가&#10;    # 1. 배경&#10;    world['background'].append(BackgroundRenderer(title_back_image))&#10;&#10;    # 2. Tree 애니메이션&#10;    tree_animator = TreeAnimationRenderer(tree_begin_images, tree_loop_images, tree_scale)&#10;    world['tree_animation'].append(tree_animator)&#10;&#10;    # 3. 타이틀 로고&#10;    world['title'].append(TitleRenderer(title_image, title_scale))&#10;&#10;    # 4. 메뉴 버튼 생성 (가로 정렬)&#10;    canvas_width = p2.get_canvas_width()&#10;    canvas_height = p2.get_canvas_height()&#10;    center_x = canvas_width // 2&#10;    button_y = canvas_height // 5.5  # 두 버튼 모두 같은 y 좌표&#10;    button_spacing = 220  # 버튼 간격(가로)&#10;    button_width = 200&#10;    button_height = 60&#10;&#10;    # 왼쪽: 시작, 오른쪽: 종료&#10;    world['buttons'].append(MenuButton(&quot;시작&quot;, center_x - button_spacing // 1.5, button_y, button_width, button_height, start_game))&#10;    world['buttons'].append(MenuButton(&quot;종료&quot;, center_x + button_spacing // 1.5, button_y, button_width, button_height, quit_game))&#10;&#10;    # 5. 커서&#10;    try:&#10;        cursor = TitleCursor()  # 타이틀 전용 커서 (인벤토리 커서 애니메이션 사용)&#10;        world['cursor'].append(cursor)&#10;        print(&quot;[title_mode] 타이틀 커서 생성 완료&quot;)&#10;    except Exception as ex:&#10;        print('[title_mode] 타이틀 커서 생성 실패:', ex)&#10;&#10;    print(&quot;[title_mode] 타이틀 이미지 로드 완료&quot;)&#10;&#10;def exit():&#10;    &quot;&quot;&quot;타이틀 모드 종료&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images, world&#10;&#10;    title_image = None&#10;    title_back_image = None&#10;    tree_begin_images = []&#10;    tree_loop_images = []&#10;&#10;    # 월드 레이어 정리&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 종료&quot;)&#10;&#10;def update():&#10;    &quot;&quot;&quot;타이틀 화면 업데이트&quot;&quot;&quot;&#10;    # 모든 레이어의 객체 업데이트&#10;    for layer_name in ['background', 'tree_animation', 'title', 'buttons', 'cursor']:&#10;        layer = world.get(layer_name, [])&#10;        new_list = []&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'update'):&#10;                    keep = obj.update()&#10;                    if keep is None or keep:&#10;                        new_list.append(obj)&#10;            except Exception as ex:&#10;                print(f'[title_mode] Update error in {layer_name}:', ex)&#10;                new_list.append(obj)&#10;        world[layer_name] = new_list&#10;&#10;def draw():&#10;    &quot;&quot;&quot;타이틀 화면 그리기&quot;&quot;&quot;&#10;    p2.clear_canvas()&#10;&#10;    # 레이어 순서대로 그리기&#10;    render_order = ['background', 'tree_animation', 'title', 'buttons', 'cursor']&#10;&#10;    for layer_name in render_order:&#10;        layer = world.get(layer_name, [])&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw()&#10;            except Exception as ex:&#10;                print(f'[title_mode] Draw error in {layer_name}:', ex)&#10;&#10;    p2.update_canvas()&#10;&#10;def handle_events():&#10;    &quot;&quot;&quot;이벤트 처리 (game_framework가 호출하는 함수)&quot;&quot;&quot;&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            game_framework.quit()&#10;        elif e.type == SDL_KEYDOWN:&#10;            if e.key == SDLK_ESCAPE:&#10;                game_framework.quit()&#10;            elif e.key == SDLK_RETURN or e.key == SDLK_SPACE:&#10;                # Enter 또는 Space 키를 누르면 게임 시작 (기존 동작 유지)&#10;                print(&quot;[title_mode] 게임 시작&quot;)&#10;                import game_logic.play_mode as play_mode&#10;                game_framework.change_state(play_mode)&#10;        elif e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                # 마우스 클릭 시 버튼 체크&#10;                for button in world.get('buttons', []):&#10;                    if button.hovered:&#10;                        button.on_click()&#10;                        break&#10;&#10;        # 커서에 이벤트 전달 (클릭 애니메이션 처리)&#10;        for cursor in world.get('cursor', []):&#10;            try:&#10;                if hasattr(cursor, 'handle_event'):&#10;                    cursor.handle_event(e)&#10;            except Exception:&#10;                pass&#10;&#10;def pause():&#10;    &quot;&quot;&quot;타이틀 모드 일시 정지&quot;&quot;&quot;&#10;    pass&#10;&#10;def resume():&#10;    &quot;&quot;&quot;타이틀 모드 재개&quot;&quot;&quot;&#10;    pass&#10;" />
              <option name="updatedContent" value="# game_logic/title_mode.py&#10;&quot;&quot;&quot;타이틀 화면 모듈&quot;&quot;&quot;&#10;&#10;import pico2d as p2&#10;import ctypes&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE, SDLK_RETURN, SDLK_SPACE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_GetMouseState, SDL_MOUSEMOTION&#10;&#10;import game_framework&#10;from . import framework&#10;from .cursor import Cursor&#10;&#10;# 타이틀 화면 이미지&#10;title_image = None&#10;title_back_image = None&#10;&#10;# Tree 애니메이션&#10;tree_begin_images = []  # TreeBegin 애니메이션 (00~29)&#10;tree_loop_images = []   # Tree 루프 애니메이션 (00~15)&#10;animation_frame = 0&#10;animation_time = 0.0&#10;animation_fps = 12  # 초당 프레임 수&#10;is_begin_phase = True  # True: TreeBegin 재생 중, False: Tree 루프 재생 중&#10;&#10;# 스케일 팩터&#10;tree_scale = 3.0  # Tree 애니메이션 스케일&#10;title_scale = 3.0  # 타이틀 로고 스케일&#10;&#10;# 월드 레이어 (play_mode와 유사한 구조)&#10;world = {&#10;    'background': [],  # 배경 이미지&#10;    'tree_animation': [],  # Tree 애니메이션&#10;    'title': [],  # 타이틀 로고&#10;    'buttons': [],  # 메뉴 버튼들&#10;    'cursor': []  # 커서&#10;}&#10;&#10;# 배경 렌더러&#10;class BackgroundRenderer:&#10;    &quot;&quot;&quot;배경 이미지를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image):&#10;        self.image = image&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;            self.image.draw(center_x, center_y, canvas_width, canvas_height)&#10;&#10;# Tree 애니메이션 렌더러&#10;class TreeAnimationRenderer:&#10;    &quot;&quot;&quot;Tree 애니메이션을 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, begin_images, loop_images, scale):&#10;        self.begin_images = begin_images&#10;        self.loop_images = loop_images&#10;        self.scale = scale&#10;        self.current_frame = 0&#10;        self.animation_time = 0.0&#10;        self.animation_fps = 12&#10;        self.is_begin_phase = True&#10;&#10;    def update(self):&#10;        dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;        self.animation_time += dt&#10;&#10;        frame_time = 1.0 / self.animation_fps&#10;&#10;        if self.animation_time &gt;= frame_time:&#10;            self.animation_time -= frame_time&#10;&#10;            if self.is_begin_phase:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.begin_images):&#10;                    self.is_begin_phase = False&#10;                    self.current_frame = 0&#10;                    print(&quot;[title_mode] TreeBegin 완료, Tree 루프 시작&quot;)&#10;            else:&#10;                self.current_frame += 1&#10;                if self.current_frame &gt;= len(self.loop_images):&#10;                    self.current_frame = 0&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        canvas_width = p2.get_canvas_width()&#10;        canvas_height = p2.get_canvas_height()&#10;        center_x = canvas_width // 2&#10;        center_y = canvas_height // 2&#10;&#10;        if self.is_begin_phase and self.begin_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.begin_images):&#10;                tree_img = self.begin_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;        elif not self.is_begin_phase and self.loop_images:&#10;            if 0 &lt;= self.current_frame &lt; len(self.loop_images):&#10;                tree_img = self.loop_images[self.current_frame]&#10;                tree_width = int(tree_img.w * self.scale)&#10;                tree_height = int(tree_img.h * self.scale)&#10;                tree_img.draw(center_x, int(center_y * 1.3), tree_width, tree_height)&#10;&#10;# 타이틀 로고 렌더러&#10;class TitleRenderer:&#10;    &quot;&quot;&quot;타이틀 로고를 렌더링하는 클래스&quot;&quot;&quot;&#10;    def __init__(self, image, scale):&#10;        self.image = image&#10;        self.scale = scale&#10;&#10;    def update(self):&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.image:&#10;            canvas_width = p2.get_canvas_width()&#10;            canvas_height = p2.get_canvas_height()&#10;            center_x = canvas_width // 2&#10;            center_y = canvas_height // 2&#10;&#10;            title_width = int(self.image.w * self.scale)&#10;            title_height = int(self.image.h * self.scale)&#10;            self.image.draw(center_x, int(center_y * 0.7), title_width, title_height)&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False&#10;&#10;# 메뉴 버튼&#10;class MenuButton:&#10;    &quot;&quot;&quot;클릭 가능한 메뉴 버튼 클래스&quot;&quot;&quot;&#10;    _font = None  # 클래스 변수로 폰트 공유&#10;&#10;    def __init__(self, text, x, y, width, height, callback):&#10;        self.text = text&#10;        self.x = x  # 중심 x 좌표&#10;        self.y = y  # 중심 y 좌표&#10;        self.width = width&#10;        self.height = height&#10;        self.callback = callback&#10;        self.hovered = False&#10;&#10;        # 폰트 로드 (최초 1회만)&#10;        if MenuButton._font is None:&#10;            try:&#10;                from pico2d import load_font&#10;                import os&#10;                # 폰트 경로 후보 (한글 지원 폰트 우선)&#10;                font_candidates = [&#10;                    'resources/Fonts/pixelroborobo.otf',&#10;                ]&#10;                for font_path in font_candidates:&#10;                    try:&#10;                        MenuButton._font = load_font(font_path, 40)  # 버튼용 폰트 크기 40으로 증가&#10;                        print(f&quot;[MenuButton] 폰트 로드 성공: {font_path}&quot;)&#10;                        break&#10;                    except Exception:&#10;                        continue&#10;            except Exception as ex:&#10;                print(f&quot;[MenuButton] 폰트 로드 실패: {ex}&quot;)&#10;&#10;    def contains_point(self, px, py):&#10;        &quot;&quot;&quot;점이 버튼 내부에 있는지 확인&quot;&quot;&quot;&#10;        left = self.x - self.width // 2&#10;        right = self.x + self.width // 2&#10;        bottom = self.y - self.height // 2&#10;        top = self.y + self.height // 2&#10;        return left &lt;= px &lt;= right and bottom &lt;= py &lt;= top&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치에 따라 hover 상태 업데이트&quot;&quot;&quot;&#10;        # 마우스 위치 가져오기&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        mouse_x = mx_ptr.value&#10;        mouse_y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        self.hovered = self.contains_point(mouse_x, mouse_y)&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;버튼 그리기&quot;&quot;&quot;&#10;        # 버튼 배경 박스&#10;        if self.hovered:&#10;            # hover 상태: 밝은 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;        else:&#10;            # 일반 상태: 어두운 테두리&#10;            # p2.draw_rectangle(&#10;            #     self.x - self.width // 2,&#10;            #     self.y - self.height // 2,&#10;            #     self.x + self.width // 2,&#10;            #     self.y + self.height // 2&#10;            # )&#10;            pass&#10;&#10;        # 텍스트 표시&#10;        if MenuButton._font:&#10;            # 텍스트 색상 (hover 상태에 따라 변경)&#10;            if self.hovered:&#10;                # hover 상태: 밝은 흰색&#10;                text_color = (255, 255, 150)&#10;                shadow_color = (0, 0, 0)&#10;            else:&#10;                # 일반 상태: 회색&#10;                text_color = (200, 200, 200)&#10;                shadow_color = (50, 50, 50)&#10;&#10;            # 그림자 효과 (가독성 향상)&#10;            MenuButton._font.draw(self.x - 2, self.y - 2, self.text, shadow_color)&#10;            MenuButton._font.draw(self.x - 1, self.y - 1, self.text, shadow_color)&#10;            # 실제 텍스트&#10;            MenuButton._font.draw(self.x, self.y, self.text, text_color)&#10;&#10;    def on_click(self):&#10;        &quot;&quot;&quot;버튼 클릭 시 콜백 실행&quot;&quot;&quot;&#10;        if self.callback:&#10;            self.callback()&#10;&#10;# 메뉴 버튼 리스트&#10;mouse_x, mouse_y = 0, 0&#10;&#10;def start_game():&#10;    &quot;&quot;&quot;게임 시작 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 시작&quot;)&#10;    import game_logic.play_mode as play_mode&#10;    import game_logic.lobby_mode as lobby_mode&#10;    game_framework.change_state(lobby_mode)&#10;&#10;def quit_game():&#10;    &quot;&quot;&quot;게임 종료 버튼 콜백&quot;&quot;&quot;&#10;    print(&quot;[title_mode] 게임 종료&quot;)&#10;    game_framework.quit()&#10;&#10;def enter():&#10;    &quot;&quot;&quot;타이틀 모드 진입&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images&#10;    global animation_frame, animation_time, is_begin_phase, world&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 진입&quot;)&#10;&#10;    # 월드 레이어 초기화&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    # 이미지 로드&#10;    title_back_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title_Back.png')&#10;    title_image = p2.load_image('resources/Texture_organize/IDK_2/Title/N_Title.png')&#10;&#10;    # Tree Begin 애니메이션 로드 (00~29)&#10;    tree_begin_images = []&#10;    for i in range(30):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_TreeBegin{i:02d}.png'&#10;        try:&#10;            img = p2.load_image(path)&#10;            tree_begin_images.append(img)&#10;        except Exception as e:&#10;            print(f&quot;[title_mode] TreeBegin 이미지 로드 실패: {path}, {e}&quot;)&#10;&#10;    print(f&quot;[title_mode] TreeBegin 이미지 {len(tree_begin_images)}개 로드 완료&quot;)&#10;&#10;    # Tree Loop 애니메이션 로드 (00~15)&#10;    tree_loop_images = []&#10;    for i in range(16):&#10;        path = f'resources/Texture_organize/IDK_2/Title/N_Title_Tree{i:02d}.png'&#10;        try:&#10;            img = p2.load_image(path)&#10;            tree_loop_images.append(img)&#10;        except Exception as e:&#10;            print(f&quot;[title_mode] Tree 이미지 로드 실패: {path}, {e}&quot;)&#10;&#10;    print(f&quot;[title_mode] Tree 이미지 {len(tree_loop_images)}개 로드 완료&quot;)&#10;&#10;    # 월드 레이어에 객체 추가&#10;    # 1. 배경&#10;    world['background'].append(BackgroundRenderer(title_back_image))&#10;&#10;    # 2. Tree 애니메이션&#10;    tree_animator = TreeAnimationRenderer(tree_begin_images, tree_loop_images, tree_scale)&#10;    world['tree_animation'].append(tree_animator)&#10;&#10;    # 3. 타이틀 로고&#10;    world['title'].append(TitleRenderer(title_image, title_scale))&#10;&#10;    # 4. 메뉴 버튼 생성 (가로 정렬)&#10;    canvas_width = p2.get_canvas_width()&#10;    canvas_height = p2.get_canvas_height()&#10;    center_x = canvas_width // 2&#10;    button_y = canvas_height // 5.5  # 두 버튼 모두 같은 y 좌표&#10;    button_spacing = 220  # 버튼 간격(가로)&#10;    button_width = 200&#10;    button_height = 60&#10;&#10;    # 왼쪽: 시작, 오른쪽: 종료&#10;    world['buttons'].append(MenuButton(&quot;시작&quot;, center_x - button_spacing // 1.5, button_y, button_width, button_height, start_game))&#10;    world['buttons'].append(MenuButton(&quot;종료&quot;, center_x + button_spacing // 1.5, button_y, button_width, button_height, quit_game))&#10;&#10;    # 5. 커서&#10;    try:&#10;        cursor = TitleCursor()  # 타이틀 전용 커서 (인벤토리 커서 애니메이션 사용)&#10;        world['cursor'].append(cursor)&#10;        print(&quot;[title_mode] 타이틀 커서 생성 완료&quot;)&#10;    except Exception as ex:&#10;        print('[title_mode] 타이틀 커서 생성 실패:', ex)&#10;&#10;    print(&quot;[title_mode] 타이틀 이미지 로드 완료&quot;)&#10;&#10;def exit():&#10;    &quot;&quot;&quot;타이틀 모드 종료&quot;&quot;&quot;&#10;    global title_image, title_back_image, tree_begin_images, tree_loop_images, world&#10;&#10;    title_image = None&#10;    title_back_image = None&#10;    tree_begin_images = []&#10;    tree_loop_images = []&#10;&#10;    # 월드 레이어 정리&#10;    for layer in world.values():&#10;        if isinstance(layer, list):&#10;            layer.clear()&#10;&#10;    print(&quot;[title_mode] 타이틀 화면 종료&quot;)&#10;&#10;def update():&#10;    &quot;&quot;&quot;타이틀 화면 업데이트&quot;&quot;&quot;&#10;    # 모든 레이어의 객체 업데이트&#10;    for layer_name in ['background', 'tree_animation', 'title', 'buttons', 'cursor']:&#10;        layer = world.get(layer_name, [])&#10;        new_list = []&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'update'):&#10;                    keep = obj.update()&#10;                    if keep is None or keep:&#10;                        new_list.append(obj)&#10;            except Exception as ex:&#10;                print(f'[title_mode] Update error in {layer_name}:', ex)&#10;                new_list.append(obj)&#10;        world[layer_name] = new_list&#10;&#10;def draw():&#10;    &quot;&quot;&quot;타이틀 화면 그리기&quot;&quot;&quot;&#10;    p2.clear_canvas()&#10;&#10;    # 레이어 순서대로 그리기&#10;    render_order = ['background', 'tree_animation', 'title', 'buttons', 'cursor']&#10;&#10;    for layer_name in render_order:&#10;        layer = world.get(layer_name, [])&#10;        for obj in layer:&#10;            try:&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw()&#10;            except Exception as ex:&#10;                print(f'[title_mode] Draw error in {layer_name}:', ex)&#10;&#10;    p2.update_canvas()&#10;&#10;def handle_events():&#10;    &quot;&quot;&quot;이벤트 처리 (game_framework가 호출하는 함수)&quot;&quot;&quot;&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            game_framework.quit()&#10;        elif e.type == SDL_KEYDOWN:&#10;            if e.key == SDLK_ESCAPE:&#10;                game_framework.quit()&#10;            elif e.key == SDLK_RETURN or e.key == SDLK_SPACE:&#10;                # Enter 또는 Space 키를 누르면 게임 시작 (기존 동작 유지)&#10;                print(&quot;[title_mode] 게임 시작&quot;)&#10;                import game_logic.play_mode as play_mode&#10;                game_framework.change_state(play_mode)&#10;        elif e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                # 마우스 클릭 시 버튼 체크&#10;                for button in world.get('buttons', []):&#10;                    if button.hovered:&#10;                        button.on_click()&#10;                        break&#10;&#10;        # 커서에 이벤트 전달 (클릭 애니메이션 처리)&#10;        for cursor in world.get('cursor', []):&#10;            try:&#10;                if hasattr(cursor, 'handle_event'):&#10;                    cursor.handle_event(e)&#10;            except Exception:&#10;                pass&#10;&#10;def pause():&#10;    &quot;&quot;&quot;타이틀 모드 일시 정지&quot;&quot;&quot;&#10;    pass&#10;&#10;def resume():&#10;    &quot;&quot;&quot;타이틀 모드 재개&quot;&quot;&quot;&#10;    pass" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>