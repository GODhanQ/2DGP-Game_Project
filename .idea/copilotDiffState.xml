<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game_logic/player.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/player.py" />
              <option name="originalContent" value="# 패키지 내부 모듈을 직접 실행할 경우 친절한 안내 후 종료&#10;if __name__ == &quot;__main__&quot; and (__package__ is None or __package__ == &quot;&quot;):&#10;    import sys&#10;    print(&quot;이 모듈은 game_logic 패키지 내부 모듈입니다. 프로젝트 루트에서 main.py를 실행하세요.&quot;)&#10;    sys.exit(1)&#10;&#10;import ctypes&#10;import os&#10;import random&#10;import time&#10;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import (SDL_KEYDOWN, SDL_KEYUP, SDLK_a, SDLK_d, SDLK_w, SDLK_s, SDLK_TAB, SDL_GetMouseState,&#10;                   SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT)&#10;&#10;from .equipment import EquipmentManager, Sword, Shield&#10;from .state_machine import StateMachine&#10;from . import framework&#10;# 인벤토리 데이터 모델 import&#10;from .inventory import InventoryData, seed_debug_inventory&#10;from .stats import PlayerStats, StatModifier&#10;&#10;def Akey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_a&#10;def Akey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_a&#10;def Dkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_d&#10;def Dkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_d&#10;def Wkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_w&#10;def Wkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_w&#10;def Skey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_s&#10;def Skey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_s&#10;&#10;&#10;# 커스텀 이벤트 정의&#10;def move_event(e):&#10;    return e[0] == 'MOVE'&#10;&#10;def stop_event(e):&#10;    return e[0] == 'STOP'&#10;&#10;# Tab 키 입력 검사용 predicate (StateMachine 매핑용)&#10;def Tab_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_TAB&#10;&#10;class Run:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix, path):&#10;            files = sorted([f for f in os.listdir(path)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(path, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#10;&#10;        # 파티클 리소스 로드&#10;        particle_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Run_Dust')&#10;        self.particle_frames = load_seq('RunDust_Ver2_', particle_folder)&#10;        self.particle_spawn_timer = 0.0&#10;        self.particle_spawn_interval = 0.15 # 파티클 생성 간격&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Move frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.06&#10;        self.moving_speed = 300 # 초당 픽셀&#10;&#10;    def enter(self, e):&#10;        # 파티클 타이머만 초기화&#10;        self.particle_spawn_timer = 0.0&#10;&#10;    def exit(self, e):&#10;        # 파티클을 제거하지 않고 그대로 둠&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 플레이어 애니메이션 및 위치 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;        # 현재 스탯 기반 이동 속도 사용&#10;        moving_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else self.moving_speed&#10;        dir_magnitude = (self.player.dir[0] ** 2 + self.player.dir[1] ** 2) ** 0.5&#10;        if dir_magnitude &gt; 0:&#10;            norm_dir_x = self.player.dir[0] / dir_magnitude&#10;            norm_dir_y = self.player.dir[1] / dir_magnitude&#10;            if self.player.x + norm_dir_x * moving_speed * dt &gt; get_canvas_width():&#10;                self.player.x = get_canvas_width()&#10;            elif self.player.x + norm_dir_x * moving_speed * dt &lt; 0:&#10;                self.player.x = 0&#10;            else: self.player.x += norm_dir_x * moving_speed * dt&#10;            if self.player.y + norm_dir_y * moving_speed * dt &gt; get_canvas_height():&#10;                self.player.y = get_canvas_height()&#10;            elif self.player.y + norm_dir_y * moving_speed * dt &lt; 0:&#10;                self.player.y = 0&#10;            else: self.player.y += norm_dir_y * moving_speed * dt&#10;&#10;&#10;        # 파티클 생성&#10;        self.particle_spawn_timer += dt&#10;        if self.particle_spawn_timer &gt;= self.particle_spawn_interval:&#10;            self.particle_spawn_timer -= self.particle_spawn_interval&#10;            # 플레이어 발밑에 파티클 생성 (y좌표 오프셋 조절)&#10;            particle_x = self.player.x + random.uniform(-10, 10)&#10;            particle_y = self.player.y - 40 + random.uniform(-5, 5)&#10;            new_particle = VFX_Run_Particle(particle_x, particle_y, self.particle_frames, 0.05, 2.0)&#10;            self.player.particles.append(new_particle)&#10;&#10;&#10;    def draw(self):&#10;        # 파티클은 Player에서 그림&#10;&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;&#10;        # 마우스 x좌표에 따라 face_dir 설정&#10;        if mx.value &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 위치 읽어 pico2d 좌표계로 변환&#10;        canvas_h = get_canvas_height()&#10;        mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스가 플레이어보다 위에 있으면 upper를 위에 그림&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,self.player.x, self.player.y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,self.player.x, self.player.y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,self.player.x, self.player.y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,self.player.x, self.player.y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;class Idle:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix):&#10;            files = sorted([f for f in os.listdir(folder)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(folder, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Idle_Lower')&#10;        self.upper_frames = load_seq('Player_Adventurer_Idle_Upper')&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Idle frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.12&#10;&#10;    def enter(self, e):&#10;        self.player.dir = [0, 0]&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.frame_time_acc += dt&#10;        while self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;    def draw(self):&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;&#10;        # 마우스 x좌표에 따라 face_dir 설정&#10;        if mx.value &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 위치 읽어 pico2d 좌표계로 변환&#10;        canvas_h = get_canvas_height()&#10;        mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스가 플레이어보다 위에 있으면 upper를 위에 그림&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,self.player.x, self.player.y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,self.player.x, self.player.y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,self.player.x, self.player.y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,self.player.x, self.player.y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;&#10;class Inventory:&#10;    &quot;&quot;&quot;인벤토리 상태: enter에서 이미지 로드, draw에서 중앙 오른쪽에 표시 (시뮬레이션 정지 없음)&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.image = None&#10;        self.scale = 1.0&#10;        self.prev_state = None  # 이전 상태 저장용&#10;&#10;    def enter(self, e):&#10;        # 현재 상태를 이전 상태로 저장 (복귀용)&#10;        self.prev_state = self.player.state_machine.cur_state&#10;&#10;        # 이미지 지연 로드(오버레이에서도 사용 가능하도록 유지하되, 여기서는 그리지 않음)&#10;        if self.image is None:&#10;            img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Inventory', 'InventoryBase_New1.png')&#10;            try:&#10;                self.image = load_image(img_path)&#10;            except Exception as ex:&#10;                print('Failed to load inventory image:', img_path, ex)&#10;                self.image = None&#10;&#10;        # 인벤토리 표시 플래그만 설정 (이동은 유지)&#10;        self.player.inventory_open = True&#10;&#10;    def exit(self, e):&#10;        # 표시 플래그만 해제&#10;        self.player.inventory_open = False&#10;&#10;    def do(self):&#10;        # 현재 키 상태에 따라 Idle/Run의 do를 동적으로 실행&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.do()&#10;&#10;    def draw(self):&#10;        # 현재 키 상태에 따라 Idle/Run의 draw를 먼저 실행&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.draw()&#10;        # 인벤토리 이미지는 별도의 UI 레이어(InventoryOverlay)에서 최상단으로 그림&#10;&#10;&#10;class Player:&#10;    def __init__(self):&#10;        self.x = get_canvas_width() // 2&#10;        self.y = get_canvas_height() // 2&#10;        self.frame = 0&#10;        self.dir = [0, 0]  # x, y 방향 벡터&#10;        self.face_dir = 1&#10;        self.scale_factor = 3.0&#10;        self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;        self.moving = False # 이동 상태 플래그&#10;        self.particles = [] # 파티클 리스트를 Player로 이동&#10;        self.attack_effects = [] # 공격 이펙트 리스트&#10;&#10;        # 인벤토리 데이터 생성 및 디버그 아이템 채우기&#10;        self.inventory = InventoryData(cols=6, rows=5)&#10;        try:&#10;            seed_debug_inventory(self.inventory)&#10;        except Exception as ex:&#10;            print('[Player] 디버그 인벤토리 시드 실패:', ex)&#10;&#10;        # 스탯 시스템&#10;        self.stats = PlayerStats()&#10;        # 인벤토리 패시브 적용&#10;        try:&#10;            self.rebuild_inventory_passives()&#10;        except Exception as ex:&#10;            print('[Player] 패시브 재구성 실패:', ex)&#10;&#10;        # 장비 매니저 초기화&#10;        self.equipment_manager = EquipmentManager(self)&#10;&#10;        # 기본 무기 장착 (Tier1 검과 방패)&#10;        sword_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Sword_Tier1.png')&#10;        shield_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Shield_Tier1.png')&#10;&#10;        self.sword = Sword(self, sword_path, scale=3.0)&#10;        self.shield = Shield(self, shield_path, scale=3.0)&#10;&#10;        self.equipment_manager.equip(self.sword)&#10;        self.equipment_manager.equip(self.shield)&#10;&#10;        # 상태 정의&#10;        self.IDLE = Idle(self)&#10;        self.RUN = Run(self)&#10;        self.INVENTORY = Inventory(self)&#10;&#10;        # 전투 플래그(전투중엔 인벤토리 안 염)&#10;        self.in_combat = False&#10;        self.inventory_open = False&#10;&#10;        # 상태 전환에 대한 매핑&#10;        self.state_machine = StateMachine(&#10;            self.IDLE,&#10;            {&#10;                self.IDLE: {move_event: self.RUN, Tab_down: self.INVENTORY},&#10;                self.RUN: {stop_event: self.IDLE, Tab_down: self.INVENTORY},&#10;                self.INVENTORY: {Tab_down: None},&#10;            }&#10;        )&#10;&#10;    def update(self):&#10;        self.state_machine.update()&#10;&#10;        # 스탯 버프 업데이트(소비형 지속시간 관리)&#10;        if hasattr(self, 'stats'):&#10;            self.stats.update()&#10;&#10;        # 파티클 업데이트 (상태와 무관하게 항상 실행)&#10;        for p in self.particles:&#10;            p.update()&#10;        self.particles = [p for p in self.particles if p.life &gt; 0]&#10;&#10;        # 공격 이펙트 업데이트&#10;        for effect in self.attack_effects:&#10;            effect.update()&#10;        self.attack_effects = [e for e in self.attack_effects if e.life &gt; 0]&#10;&#10;        # 장비 업데이트&#10;        self.equipment_manager.update()&#10;&#10;    # 인벤토리 패시브 재적용&#10;    def rebuild_inventory_passives(self):&#10;        prefix = 'passive:'&#10;        self.stats.clear_by_prefix(prefix)&#10;        # 모든 슬롯 순회&#10;        try:&#10;            for r in range(self.inventory.rows):&#10;                for c in range(self.inventory.cols):&#10;                    slot = self.inventory.get_slot(r, c)&#10;                    if slot.is_empty():&#10;                        continue&#10;                    item = slot.item&#10;                    if getattr(item, 'passive', None):&#10;                        # 수량만큼 배수 적용(스택형 패시브 고려)&#10;                        qty = max(1, slot.quantity)&#10;                        values = {k: v * qty for k, v in item.passive.items()}&#10;                        mod_id = f'{prefix}{item.id}:{r},{c}'&#10;                        self.stats.add_modifier(StatModifier(mod_id, values, duration=None))&#10;        except Exception as ex:&#10;            print('[Player] 패시브 적용 중 오류:', ex)&#10;&#10;    # 소비형 아이템 사용 처리&#10;    def consume_item_at(self, r: int, c: int):&#10;        try:&#10;            slot = self.inventory.get_slot(r, c)&#10;        except Exception as ex:&#10;            print('[Player] 소비 실패: 잘못된 슬롯', ex)&#10;            return False&#10;        if slot.is_empty() or not getattr(slot.item, 'consumable', None):&#10;            return False&#10;        item = slot.item&#10;        values = dict(item.consumable)&#10;        duration = item.consume_duration&#10;        mod_id = f'consumable:{item.id}:{r},{c}:{int(time.time()*1000)%100000}'&#10;        self.stats.add_modifier(StatModifier(mod_id, values, duration=duration))&#10;        # 1개 소모&#10;        self.inventory.remove_from(r, c, 1)&#10;        # 아이템의 이펙트 재생(있다면)&#10;        vfx_fn = (getattr(item, 'on_consume_vfx', None)&#10;                  or getattr(item, '_play_consume_vfx', None)&#10;                  or getattr(item, 'consume_effect', None))&#10;        if callable(vfx_fn):&#10;            try:&#10;                # prefer self.world (assigned by play_mode) so VFX are appended to the correct world dict&#10;                vfx_world = getattr(self, 'world', None)&#10;                # debug log&#10;                try:&#10;                    print(f&quot;[Player] triggering vfx for {getattr(item, 'name', item.id if hasattr(item,'id') else 'Unknown')} world={'set' if vfx_world is not None else 'None'})&quot;)&#10;                except Exception:&#10;                    pass&#10;                vfx_fn(self, world=vfx_world, x=getattr(self, 'x', None), y=getattr(self, 'y', None))&#10;            except Exception as ex:&#10;                print(f'[Player] 아이템 소비 이펙트 오류 ({item.name}):', ex)&#10;        # 패시브 재적용(수량 변화로 인한 패시브 변경 가능성 고려)&#10;        self.rebuild_inventory_passives()&#10;        print(f&quot;[Player] 소비: {item.name} -&gt; {values} ({duration}s)&quot;)&#10;        return True&#10;&#10;    # 신규: 입력 처리 - 상태머신과 장비 매니저로 이벤트 전달, 이동 벡터 관리&#10;    def handle_event(self, event):&#10;        try:&#10;            from sdl2 import SDL_KEYDOWN, SDL_KEYUP, SDLK_w, SDLK_a, SDLK_s, SDLK_d&#10;        except Exception:&#10;            SDL_KEYDOWN = SDL_KEYUP = None&#10;            SDLK_w = SDLK_a = SDLK_s = SDLK_d = None&#10;&#10;        # 1) 장비 매니저에 항상 전달(매니저 내부에서 인벤토리 오픈시 무시 처리)&#10;        try:&#10;            if hasattr(self, 'equipment_manager') and hasattr(self.equipment_manager, 'handle_event'):&#10;                self.equipment_manager.handle_event(event)&#10;        except Exception as ex:&#10;            print('[Player] equipment_manager.handle_event 오류:', ex)&#10;&#10;        # 2) 상태머신으로 원본 입력 이벤트 전달(Tab 매핑 등 predicates가 처리)&#10;        try:&#10;            if hasattr(self, 'state_machine') and hasattr(self.state_machine, 'handle_state_event'):&#10;                self.state_machine.handle_state_event(('INPUT', event))&#10;        except Exception as ex:&#10;            print('[Player] state_machine 입력 이벤트 처리 오류:', ex)&#10;&#10;        # 3) WASD 이동 상태 관리 -&gt; MOVE/STOP 이벤트 생성&#10;        moved_before = any(self.keys_down.values())&#10;        try:&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = True&#10;                    self.dir[1] = 1&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = True&#10;                    self.dir[1] = -1&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = True&#10;                    self.dir[0] = -1&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = True&#10;                    self.dir[0] = 1&#10;            elif SDL_KEYUP is not None and event.type == SDL_KEYUP:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = False&#10;                    self.dir[1] = -1 if self.keys_down['s'] else ( 1 if self.keys_down['w'] else 0)&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = False&#10;                    self.dir[0] = 1 if self.keys_down['d'] else ( -1 if self.keys_down['a'] else 0)&#10;        except Exception:&#10;            pass&#10;&#10;        moved_after = any(self.keys_down.values())&#10;        try:&#10;            if not moved_before and moved_after:&#10;                # 시작 이동&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('MOVE', None))&#10;            elif moved_before and not moved_after:&#10;                # 이동 종료&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('STOP', None))&#10;        except Exception as ex:&#10;            print('[Player] MOVE/STOP 이벤트 처리 오류:', ex)&#10;&#10;    # 신규: 렌더링 - 장비/플레이어/이펙트 순서대로 그리기&#10;    def draw(self):&#10;        # 1) 캐릭터 뒤 장비&#10;        try:&#10;            if hasattr(self, 'equipment_manager'):&#10;                self.equipment_manager.draw_back()&#10;        except Exception:&#10;            pass&#10;&#10;        # 2) 현재 상태 스프라이트(Idle/Run/Inventory)&#10;        try:&#10;            if hasattr(self, 'state_machine'):&#10;                self.state_machine.draw()&#10;        except Exception:&#10;            pass&#10;&#10;        # 3) 캐릭터 앞 장비(방패 등)&#10;        try:&#10;            if hasattr(self, 'equipment_manager'):&#10;                self.equipment_manager.draw_front()&#10;        except Exception:&#10;            pass&#10;&#10;        # 4) 파티클/공격 이펙트&#10;        try:&#10;            for p in getattr(self, 'particles', []):&#10;                if hasattr(p, 'draw'):&#10;                    p.draw()&#10;            for e in getattr(self, 'attack_effects', []):&#10;                if hasattr(e, 'draw'):&#10;                    e.draw()&#10;        except Exception:&#10;            pass&#10;&#10;class VFX_Run_Particle:&#10;    def __init__(self, x, y, frames, frame_duration, scale):&#10;        self.x, self.y = x, y&#10;        self.frames = frames&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = frame_duration&#10;        self.scale_factor = scale&#10;        self.life = len(frames) * frame_duration&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt; 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1)&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.draw(self.x, self.y + 20, image.w * self.scale_factor, image.h * self.scale_factor)&#10;&#10;&#10;# VFX 전역 배율 설정: 전체 이펙트 크기와 거리(범위)를 일괄 조정&#10;VFX_GLOBAL_SCALE_MULT = 0.7   # 이펙트 크기 0.7배&#10;VFX_GLOBAL_RANGE_MULT = 0.8   # 이펙트 거리 0.8배&#10;&#10;class VFX_Tier1_Sword_Swing:&#10;    &quot;&quot;&quot;검 공격 이펙트 VFX&quot;&quot;&quot;&#10;    def __init__(self, x, y, angle, flip, scale=4.5, range_factor=60, variant=1):&#10;        import math&#10;&#10;        # 전역 배율을 적용한 range_factor/scale 사용&#10;        range_factor = range_factor * VFX_GLOBAL_RANGE_MULT&#10;        scale = scale * VFX_GLOBAL_SCALE_MULT&#10;&#10;        # 받은 위치에서 angle 방향으로 range_factor만큼 떨어진 위치 계산&#10;        temp_x = range_factor * math.cos(angle)&#10;        temp_y = range_factor * math.sin(angle)&#10;&#10;        self.x = x + temp_x&#10;        self.y = y + temp_y&#10;        &#10;        # 각도 조정: 마우스가 오른쪽(0도~90도, 270도~360도)일 때 -90도, 왼쪽일 때 +90도&#10;        angle_deg = math.degrees(angle) % 360&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽&#10;            self.angle = angle + math.radians(90)&#10;        else:  # 오른쪽&#10;            self.angle = angle - math.radians(90)&#10;        &#10;        self.flip = flip&#10;        self.scale_factor = scale&#10;&#10;        # 이펙트 이미지 로드&#10;        fx_folder = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Swing_FX')&#10;        if variant == 1:&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;        elif variant == 2:&#10;            # 콤보 전용 스프라이트&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_1.png'))&#10;            ]&#10;        elif variant == 3:&#10;            # Heavy swing (3스테이지) - 여러 프레임&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_1.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_2.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_3.png'))&#10;            ]&#10;        else:&#10;            # 안전망: 기본으로 variant 1 사용&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.05  # 각 프레임당 0.05초&#10;        self.life = len(self.frames) * self.frame_duration  # 총 수명&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame += 1&#10;            if self.frame &gt;= len(self.frames):&#10;                self.frame = len(self.frames) - 1  # 마지막 프레임 유지&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.clip_composite_draw(&#10;                0, 0, image.w, image.h,&#10;                self.angle, self.flip,&#10;                self.x, self.y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;" />
              <option name="updatedContent" value="# 패키지 내부 모듈을 직접 실행할 경우 친절한 안내 후 종료&#10;if __name__ == &quot;__main__&quot; and (__package__ is None or __package__ == &quot;&quot;):&#10;    import sys&#10;    print(&quot;이 모듈은 game_logic 패키지 내부 모듈입니다. 프로젝트 루트에서 main.py를 실행하세요.&quot;)&#10;    sys.exit(1)&#10;&#10;import ctypes&#10;import os&#10;import random&#10;import time&#10;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import (SDL_KEYDOWN, SDL_KEYUP, SDLK_a, SDLK_d, SDLK_w, SDLK_s, SDLK_TAB, SDL_GetMouseState,&#10;                   SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT)&#10;&#10;from .equipment import EquipmentManager, Sword, Shield&#10;from .state_machine import StateMachine&#10;from . import framework&#10;# 인벤토리 데이터 모델 import&#10;from .inventory import InventoryData, seed_debug_inventory&#10;from .stats import PlayerStats, StatModifier&#10;&#10;def Akey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_a&#10;def Akey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_a&#10;def Dkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_d&#10;def Dkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_d&#10;def Wkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_w&#10;def Wkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_w&#10;def Skey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_s&#10;def Skey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_s&#10;&#10;&#10;# 커스텀 이벤트 정의&#10;def move_event(e):&#10;    return e[0] == 'MOVE'&#10;&#10;def stop_event(e):&#10;    return e[0] == 'STOP'&#10;&#10;# Tab 키 입력 검사용 predicate (StateMachine 매핑용)&#10;def Tab_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_TAB&#10;&#10;class Run:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix, path):&#10;            files = sorted([f for f in os.listdir(path)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(path, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#10;&#10;        # 파티클 리소스 로드&#10;        particle_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Run_Dust')&#10;        self.particle_frames = load_seq('RunDust_Ver2_', particle_folder)&#10;        self.particle_spawn_timer = 0.0&#10;        self.particle_spawn_interval = 0.15 # 파티클 생성 간격&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Move frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.06&#10;        self.moving_speed = 300 # 초당 픽셀&#10;&#10;    def enter(self, e):&#10;        # 파티클 타이머만 초기화&#10;        self.particle_spawn_timer = 0.0&#10;&#10;    def exit(self, e):&#10;        # 파티클을 제거하지 않고 그대로 둠&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 플레이어 애니메이션 및 위치 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;        # 현재 스탯 기반 이동 속도 사용&#10;        moving_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else self.moving_speed&#10;        dir_magnitude = (self.player.dir[0] ** 2 + self.player.dir[1] ** 2) ** 0.5&#10;        if dir_magnitude &gt; 0:&#10;            norm_dir_x = self.player.dir[0] / dir_magnitude&#10;            norm_dir_y = self.player.dir[1] / dir_magnitude&#10;            if self.player.x + norm_dir_x * moving_speed * dt &gt; get_canvas_width():&#10;                self.player.x = get_canvas_width()&#10;            elif self.player.x + norm_dir_x * moving_speed * dt &lt; 0:&#10;                self.player.x = 0&#10;            else: self.player.x += norm_dir_x * moving_speed * dt&#10;            if self.player.y + norm_dir_y * moving_speed * dt &gt; get_canvas_height():&#10;                self.player.y = get_canvas_height()&#10;            elif self.player.y + norm_dir_y * moving_speed * dt &lt; 0:&#10;                self.player.y = 0&#10;            else: self.player.y += norm_dir_y * moving_speed * dt&#10;&#10;&#10;        # 파티클 생성&#10;        self.particle_spawn_timer += dt&#10;        if self.particle_spawn_timer &gt;= self.particle_spawn_interval:&#10;            self.particle_spawn_timer -= self.particle_spawn_interval&#10;            # 플레이어 발밑에 파티클 생성 (y좌표 오프셋 조절)&#10;            particle_x = self.player.x + random.uniform(-10, 10)&#10;            particle_y = self.player.y - 40 + random.uniform(-5, 5)&#10;            new_particle = VFX_Run_Particle(particle_x, particle_y, self.particle_frames, 0.05, 2.0)&#10;            self.player.particles.append(new_particle)&#10;&#10;&#10;    def draw(self):&#10;        # 파티클은 Player에서 그림&#10;&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;&#10;        # 마우스 x좌표에 따라 face_dir 설정&#10;        if mx.value &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 위치 읽어 pico2d 좌표계로 변환&#10;        canvas_h = get_canvas_height()&#10;        mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스가 플레이어보다 위에 있으면 upper를 위에 그림&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,self.player.x, self.player.y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,self.player.x, self.player.y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,self.player.x, self.player.y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,self.player.x, self.player.y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;class Idle:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix):&#10;            files = sorted([f for f in os.listdir(folder)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(folder, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Idle_Lower')&#10;        self.upper_frames = load_seq('Player_Adventurer_Idle_Upper')&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Idle frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.12&#10;&#10;    def enter(self, e):&#10;        self.player.dir = [0, 0]&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.frame_time_acc += dt&#10;        while self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;    def draw(self):&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;&#10;        # 마우스 x좌표에 따라 face_dir 설정&#10;        if mx.value &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 위치 읽어 pico2d 좌표계로 변환&#10;        canvas_h = get_canvas_height()&#10;        mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스가 플레이어보다 위에 있으면 upper를 위에 그림&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,self.player.x, self.player.y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,self.player.x, self.player.y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,self.player.x, self.player.y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,self.player.x, self.player.y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;&#10;class Inventory:&#10;    &quot;&quot;&quot;인벤토리 상태: enter에서 이미지 로드, draw에서 중앙 오른쪽에 표시 (시뮬레이션 정지 없음)&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.image = None&#10;        self.scale = 1.0&#10;        self.prev_state = None  # 이전 상태 저장용&#10;&#10;    def enter(self, e):&#10;        # 현재 상태를 이전 상태로 저장 (복귀용)&#10;        self.prev_state = self.player.state_machine.cur_state&#10;&#10;        # 이미지 지연 로드(오버레이에서도 사용 가능하도록 유지하되, 여기서는 그리지 않음)&#10;        if self.image is None:&#10;            img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Inventory', 'InventoryBase_New1.png')&#10;            try:&#10;                self.image = load_image(img_path)&#10;            except Exception as ex:&#10;                print('Failed to load inventory image:', img_path, ex)&#10;                self.image = None&#10;&#10;        # 인벤토리 표시 플래그만 설정 (이동은 유지)&#10;        self.player.inventory_open = True&#10;&#10;    def exit(self, e):&#10;        # 표시 플래그만 해제&#10;        self.player.inventory_open = False&#10;&#10;    def do(self):&#10;        # 현재 키 상태에 따라 Idle/Run의 do를 동적으로 실행&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.do()&#10;&#10;    def draw(self):&#10;        # 현재 키 상태에 따라 Idle/Run의 draw를 먼저 실행&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.draw()&#10;        # 인벤토리 이미지는 별도의 UI 레이어(InventoryOverlay)에서 최상단으로 그림&#10;&#10;&#10;class Player:&#10;    def __init__(self):&#10;        self.x = get_canvas_width() // 2&#10;        self.y = get_canvas_height() // 2&#10;        self.frame = 0&#10;        self.dir = [0, 0]  # x, y 방향 벡터&#10;        self.face_dir = 1&#10;        self.scale_factor = 3.0&#10;        self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;        self.moving = False # 이동 상태 플래그&#10;        self.particles = [] # 파티클 리스트를 Player로 이동&#10;        self.attack_effects = [] # 공격 이펙트 리스트&#10;&#10;        # 인벤토리 데이터 생성 및 디버그 아이템 채우기&#10;        self.inventory = InventoryData(cols=6, rows=5)&#10;        try:&#10;            seed_debug_inventory(self.inventory)&#10;        except Exception as ex:&#10;            print('[Player] 디버그 인벤토리 시드 실패:', ex)&#10;&#10;        # 스탯 시스템&#10;        self.stats = PlayerStats()&#10;        # 인벤토리 패시브 적용&#10;        try:&#10;            self.rebuild_inventory_passives()&#10;        except Exception as ex:&#10;            print('[Player] 패시브 재구성 실패:', ex)&#10;&#10;        # 장비 매니저 초기화&#10;        self.equipment_manager = EquipmentManager(self)&#10;&#10;        # 기본 무기 장착 (Tier1 검과 방패)&#10;        sword_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Sword_Tier1.png')&#10;        shield_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Shield_Tier1.png')&#10;&#10;        self.sword = Sword(self, sword_path, scale=3.0)&#10;        self.shield = Shield(self, shield_path, scale=3.0)&#10;&#10;        self.equipment_manager.equip(self.sword)&#10;        self.equipment_manager.equip(self.shield)&#10;&#10;        # 상태 정의&#10;        self.IDLE = Idle(self)&#10;        self.RUN = Run(self)&#10;        self.INVENTORY = Inventory(self)&#10;&#10;        # 전투 플래그(전투중엔 인벤토리 안 염)&#10;        self.in_combat = False&#10;        self.inventory_open = False&#10;&#10;        # 상태 전환에 대한 매핑&#10;        self.state_machine = StateMachine(&#10;            self.IDLE,&#10;            {&#10;                self.IDLE: {move_event: self.RUN, Tab_down: self.INVENTORY},&#10;                self.RUN: {stop_event: self.IDLE, Tab_down: self.INVENTORY},&#10;                self.INVENTORY: {Tab_down: None},&#10;            }&#10;        )&#10;&#10;    def update(self):&#10;        self.state_machine.update()&#10;&#10;        # 스탯 버프 업데이트(소비형 지속시간 관리)&#10;        if hasattr(self, 'stats'):&#10;            self.stats.update()&#10;&#10;        # 파티클 업데이트 (상태와 무관하게 항상 실행)&#10;        for p in self.particles:&#10;            p.update()&#10;        self.particles = [p for p in self.particles if p.life &gt; 0]&#10;&#10;        # 공격 이펙트 업데이트&#10;        for effect in self.attack_effects:&#10;            effect.update()&#10;        self.attack_effects = [e for e in self.attack_effects if e.life &gt; 0]&#10;&#10;        # 장비 업데이트&#10;        self.equipment_manager.update()&#10;&#10;    # 인벤토리 패시브 재적용&#10;    def rebuild_inventory_passives(self):&#10;        prefix = 'passive:'&#10;        self.stats.clear_by_prefix(prefix)&#10;        # 모든 슬롯 순회&#10;        try:&#10;            for r in range(self.inventory.rows):&#10;                for c in range(self.inventory.cols):&#10;                    slot = self.inventory.get_slot(r, c)&#10;                    if slot.is_empty():&#10;                        continue&#10;                    item = slot.item&#10;                    if getattr(item, 'passive', None):&#10;                        # 수량만큼 배수 적용(스택형 패시브 고려)&#10;                        qty = max(1, slot.quantity)&#10;                        values = {k: v * qty for k, v in item.passive.items()}&#10;                        mod_id = f'{prefix}{item.id}:{r},{c}'&#10;                        self.stats.add_modifier(StatModifier(mod_id, values, duration=None))&#10;        except Exception as ex:&#10;            print('[Player] 패시브 적용 중 오류:', ex)&#10;&#10;    # 소비형 아이템 사용 처리&#10;    def consume_item_at(self, r: int, c: int):&#10;        try:&#10;            slot = self.inventory.get_slot(r, c)&#10;        except Exception as ex:&#10;            print('[Player] 소비 실패: 잘못된 슬롯', ex)&#10;            return False&#10;        if slot.is_empty() or not getattr(slot.item, 'consumable', None):&#10;            return False&#10;        item = slot.item&#10;        values = dict(item.consumable)&#10;        duration = item.consume_duration&#10;        mod_id = f'consumable:{item.id}:{r},{c}:{int(time.time()*1000)%100000}'&#10;        self.stats.add_modifier(StatModifier(mod_id, values, duration=duration))&#10;        # 1개 소모&#10;        self.inventory.remove_from(r, c, 1)&#10;        # 아이템의 이펙트 재생(있다면)&#10;        vfx_fn = (getattr(item, 'on_consume_vfx', None)&#10;                  or getattr(item, '_play_consume_vfx', None)&#10;                  or getattr(item, 'consume_effect', None))&#10;        if callable(vfx_fn):&#10;            try:&#10;                # prefer self.world (assigned by play_mode) so VFX are appended to the correct world dict&#10;                vfx_world = getattr(self, 'world', None)&#10;                # debug log&#10;                try:&#10;                    print(f&quot;[Player] triggering vfx for {getattr(item, 'name', item.id if hasattr(item,'id') else 'Unknown')} world={'set' if vfx_world is not None else 'None'})&quot;)&#10;                except Exception:&#10;                    pass&#10;                vfx_fn(self, world=vfx_world, x=getattr(self, 'x', None), y=getattr(self, 'y', None))&#10;            except Exception as ex:&#10;                print(f'[Player] 아이템 소비 이펙트 오류 ({item.name}):', ex)&#10;        # 패시브 재적용(수량 변화로 인한 패시브 변경 가능성 고려)&#10;        self.rebuild_inventory_passives()&#10;        print(f&quot;[Player] 소비: {item.name} -&gt; {values} ({duration}s)&quot;)&#10;        return True&#10;&#10;    # 신규: 입력 처리 - 상태머신과 장비 매니저로 이벤트 전달, 이동 벡터 관리&#10;    def handle_event(self, event):&#10;        try:&#10;            from sdl2 import SDL_KEYDOWN, SDL_KEYUP, SDLK_w, SDLK_a, SDLK_s, SDLK_d&#10;        except Exception:&#10;            SDL_KEYDOWN = SDL_KEYUP = None&#10;            SDLK_w = SDLK_a = SDLK_s = SDLK_d = None&#10;&#10;        # 1) 장비 매니저에 항상 전달(매니저 내부에서 인벤토리 오픈시 무시 처리)&#10;        try:&#10;            if hasattr(self, 'equipment_manager') and hasattr(self.equipment_manager, 'handle_event'):&#10;                self.equipment_manager.handle_event(event)&#10;        except Exception as ex:&#10;            print('[Player] equipment_manager.handle_event 오류:', ex)&#10;&#10;        # 2) 상태머신으로 원본 입력 이벤트 전달(Tab 매핑 등 predicates가 처리)&#10;        try:&#10;            if hasattr(self, 'state_machine') and hasattr(self.state_machine, 'handle_state_event'):&#10;                self.state_machine.handle_state_event(('INPUT', event))&#10;        except Exception as ex:&#10;            print('[Player] state_machine 입력 이벤트 처리 오류:', ex)&#10;&#10;        # 3) WASD 이동 상태 관리 -&gt; MOVE/STOP 이벤트 생성&#10;        moved_before = any(self.keys_down.values())&#10;        try:&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = True&#10;                    self.dir[1] = 1&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = True&#10;                    self.dir[1] = -1&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = True&#10;                    self.dir[0] = -1&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = True&#10;                    self.dir[0] = 1&#10;            elif SDL_KEYUP is not None and event.type == SDL_KEYUP:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = False&#10;                    self.dir[1] = -1 if self.keys_down['s'] else ( 1 if self.keys_down['w'] else 0)&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = False&#10;                    self.dir[0] = 1 if self.keys_down['d'] else ( -1 if self.keys_down['a'] else 0)&#10;        except Exception:&#10;            pass&#10;&#10;        moved_after = any(self.keys_down.values())&#10;        try:&#10;            if not moved_before and moved_after:&#10;                # 시작 이동&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('MOVE', None))&#10;            elif moved_before and not moved_after:&#10;                # 이동 종료&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('STOP', None))&#10;        except Exception as ex:&#10;            print('[Player] MOVE/STOP 이벤트 처리 오류:', ex)&#10;&#10;    # 신규: 렌더링 - 장비/플레이어/이펙트 순서대로 그리기&#10;    def draw(self):&#10;        # 1) 캐릭터 뒤 장비&#10;        try:&#10;            if hasattr(self, 'equipment_manager'):&#10;                self.equipment_manager.draw_back()&#10;        except Exception:&#10;            pass&#10;&#10;        # 2) 현재 상태 스프라이트(Idle/Run/Inventory)&#10;        try:&#10;            if hasattr(self, 'state_machine'):&#10;                self.state_machine.draw()&#10;        except Exception:&#10;            pass&#10;&#10;        # 3) 캐릭터 앞 장비(방패 등)&#10;        try:&#10;            if hasattr(self, 'equipment_manager'):&#10;                self.equipment_manager.draw_front()&#10;        except Exception:&#10;            pass&#10;&#10;        # 4) 파티클/공격 이펙트&#10;        try:&#10;            for p in getattr(self, 'particles', []):&#10;                if hasattr(p, 'draw'):&#10;                    p.draw()&#10;            for e in getattr(self, 'attack_effects', []):&#10;                if hasattr(e, 'draw'):&#10;                    e.draw()&#10;        except Exception:&#10;            pass&#10;&#10;class VFX_Run_Particle:&#10;    def __init__(self, x, y, frames, frame_duration, scale):&#10;        self.x, self.y = x, y&#10;        self.frames = frames&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = frame_duration&#10;        self.scale_factor = scale&#10;        self.life = len(frames) * frame_duration&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt; 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1)&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.draw(self.x, self.y + 20, image.w * self.scale_factor, image.h * self.scale_factor)&#10;&#10;&#10;# VFX 전역 배율 설정: 전체 이펙트 크기와 거리(범위)를 일괄 조정&#10;VFX_GLOBAL_SCALE_MULT = 0.7   # 이펙트 크기 0.7배&#10;VFX_GLOBAL_RANGE_MULT = 0.8   # 이펙트 거리 0.8배&#10;&#10;class VFX_Tier1_Sword_Swing:&#10;    &quot;&quot;&quot;검 공격 이펙트 VFX&quot;&quot;&quot;&#10;    def __init__(self, x, y, angle, flip, scale=4.5, range_factor=60, variant=1):&#10;        import math&#10;&#10;        # 전역 배율을 적용한 range_factor/scale 사용&#10;        range_factor = range_factor * VFX_GLOBAL_RANGE_MULT&#10;        scale = scale * VFX_GLOBAL_SCALE_MULT&#10;&#10;        # 받은 위치에서 angle 방향으로 range_factor만큼 떨어진 위치 계산&#10;        temp_x = range_factor * math.cos(angle)&#10;        temp_y = range_factor * math.sin(angle)&#10;&#10;        self.x = x + temp_x&#10;        self.y = y + temp_y&#10;        &#10;        # 각도 조정: 마우스가 오른쪽(0도~90도, 270도~360도)일 때 -90도, 왼쪽일 때 +90도&#10;        angle_deg = math.degrees(angle) % 360&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽&#10;            self.angle = angle + math.radians(90)&#10;        else:  # 오른쪽&#10;            self.angle = angle - math.radians(90)&#10;        &#10;        self.flip = flip&#10;        self.scale_factor = scale&#10;&#10;        # 이펙트 이미지 로드&#10;        fx_folder = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Swing_FX')&#10;        if variant == 1:&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;        elif variant == 2:&#10;            # 콤보 전용 스프라이트&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_1.png'))&#10;            ]&#10;        elif variant == 3:&#10;            # Heavy swing (3스테이지) - 여러 프레임&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_1.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_2.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_3.png'))&#10;            ]&#10;        else:&#10;            # 안전망: 기본으로 variant 1 사용&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.05  # 각 프레임당 0.05초&#10;        self.life = len(self.frames) * self.frame_duration  # 총 수명&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame += 1&#10;            if self.frame &gt;= len(self.frames):&#10;                self.frame = len(self.frames) - 1  # 마지막 프레임 유지&#10;        return True&#10;&#10;    def draw(self):&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.clip_composite_draw(&#10;                0, 0, image.w, image.h,&#10;                self.angle, self.flip,&#10;                self.x, self.y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>