<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game_logic/items.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/items.py" />
              <option name="originalContent" value="# 패키지 내부 모듈. 공용 아이템 팩토리와 샘플 세트 제공&#10;from .inventory import Item&#10;&#10;# 개별 아이템 팩토리 (파일 경로는 Item 폴더 상대 경로)&#10;&#10;class lantern:&#10;    def __new__(cls):&#10;        return Item.from_filename('Lantern.png', '랜턴',&#10;                                  description='어둠을 밝히는 낡은 랜턴')&#10;&#10;&#10;class magic_glasses:&#10;    def __new__(cls):&#10;        return Item.from_filename('MagicGlasses.png', '마법 안경',&#10;                                  description='치명타 확률 +20%',&#10;                                  passive={'crit_chance': 20.0})  # 치명타 확률 20% 증가&#10;&#10;class rabbit_guard_helm:&#10;    def __new__(cls):&#10;        return Item.from_filename('RabbitGuardHelm.png', '토끼 수호자 투구',&#10;                                  description='방어력 +5',&#10;                                  passive={'defense': 5.0})&#10;&#10;class carrot:&#10;    def __new__(cls):&#10;        return Item.from_filename('Carrot.png', '당근',&#10;                                  description='8초간 이동속도 +50 (쿨타임 3초)',&#10;                                  consumable={'move_speed': 50.0}, consume_duration=8.0,&#10;                                  cooldown=3.0)  # 3초 쿨타임&#10;&#10;class amber:&#10;    def __new__(cls):&#10;        return Item.from_filename('Amber.png', '호박보석',&#10;                                  description='공격력 +2',&#10;                                  passive={'attack_damage': 2.0})&#10;&#10;class ruby:&#10;    def __new__(cls):&#10;        return Item.from_filename('Ruby.png', '루비',&#10;                                  description='공격력 +3',&#10;                                  passive={'attack_damage': 3.0})&#10;&#10;class white_bread:&#10;    def __new__(cls):&#10;        return Item.from_filename('WhiteCrustedBread.png', '하얀 빵',&#10;                                  description='10초간 마나 +20 (쿨타임 5초)',&#10;                                  consumable={'mana': 20.0}, consume_duration=10.0,&#10;                                  cooldown=5.0)  # 5초 쿨타임&#10;&#10;class potion_red0:&#10;    def __new__(cls):&#10;        item = Item.from_filename('Potion/Item_RedPotion0.png', '빨간 포션',&#10;                                  description='15초간 체력 +10 회복 (쿨타임 5초)',&#10;                                  consumable={'health': 10.0}, consume_duration=15.0,&#10;                                  cooldown=5.0)  # 2초 쿨타임&#10;&#10;        # VFX 리소스 경로&#10;        item.consume_vfx_path = r'resources\Texture_organize\VFX\Potion_Common'&#10;        # VFX 시각 크기 배율(기본 1.0 -&gt; 2.0으로 키움)&#10;        item.consume_vfx_scale = 2.0&#10;&#10;        # 소비 시 호출 가능한 안전한 콜백 (consumer는 플레이어 엔티티)&#10;        def _play_consume_vfx(consumer, world=None, x=None, y=None):&#10;            import sys&#10;            import os&#10;&#10;            # debug&#10;            try:&#10;                print(f&quot;[items._play_consume_vfx] called for item {getattr(item,'name', getattr(item,'id', 'Unknown'))}, world_set={bool(world)}&quot;)&#10;            except Exception:&#10;                pass&#10;&#10;            # 안전한 world 조회 (폴백)&#10;            w = world&#10;            if w is None:&#10;                main_mod = sys.modules.get('__main__')&#10;                if main_mod:&#10;                    w = getattr(main_mod, 'world', None)&#10;            if not w:&#10;                print(&quot;\033[91m[items._play_consume_vfx] no world available, aborting VFX\033[0m&quot;)&#10;                return&#10;&#10;            # 위치 결정&#10;            px = x if x is not None else getattr(consumer, 'x', None)&#10;            py = y if y is not None else getattr(consumer, 'y', None)&#10;&#10;            # 경로 확인&#10;            vfx_folder = getattr(item, 'consume_vfx_path', None)&#10;            if not vfx_folder:&#10;                print(&quot;\033[91m[items._play_consume_vfx] item has no consume_vfx_path\033[0m&quot;)&#10;                return&#10;            # normalize folder path&#10;            vfx_folder = os.path.normpath(vfx_folder)&#10;&#10;            print(f&quot;[items._play_consume_vfx] vfx_folder={vfx_folder} px={px} py={py}&quot;)&#10;&#10;            # 기본 옵션&#10;            frame_time = getattr(item, 'consume_vfx_frame_time', 0.06)&#10;&#10;            # 가능한 파일명 접두사(백/프론트)와 프레임 수&#10;            back_prefixes = ['Potionl_Back_FX', 'Potionl_Back_FX00']&#10;            front_prefixes = ['Potion_Front_FX', 'Potion_Front_FX00', 'Potion_Front_FX0']&#10;            back_frames = getattr(item, 'consume_vfx_back_frames', 8)&#10;            front_frames = getattr(item, 'consume_vfx_front_frames', 4)&#10;&#10;            # 우선 world.spawn_vfx API가 있다면 사용 (지원하면 더 간단)&#10;            spawn = getattr(w, 'spawn_vfx', None)&#10;            if callable(spawn):&#10;                print('[items._play_consume_vfx] using world.spawn_vfx API')&#10;                try:&#10;                    # spawn a back effect (if files exist)&#10;                    for bp in back_prefixes:&#10;                        try:&#10;                            spawn(os.path.join(vfx_folder, bp), px, py, frames=back_frames, frame_time=frame_time, layer='effects_back', loop=False)&#10;                            print(f'[items._play_consume_vfx] spawned back with prefix {bp}')&#10;                            break&#10;                        except Exception:&#10;                            print(f&quot;\033[91m[items._play_consume_vfx] spawn back failed for prefix {bp}\033[0m&quot;)&#10;                            continue&#10;                except Exception:&#10;                    pass&#10;                try:&#10;                    for fp in front_prefixes:&#10;                        try:&#10;                            spawn(os.path.join(vfx_folder, fp), px, py, frames=front_frames, frame_time=frame_time, layer='effects_front', loop=False)&#10;                            print(f'[items._play_consume_vfx] spawned front with prefix {fp}')&#10;                            break&#10;                        except Exception:&#10;                            print(f&quot;\033[91m[items._play_consume_vfx] spawn front failed for prefix {fp}\033[0m&quot;)&#10;                            continue&#10;                except Exception:&#10;                    pass&#10;                return&#10;&#10;            # fallback: create AnimatedVFX and append to world layers&#10;            try:&#10;                from .vfx import AnimatedVFX&#10;            except Exception:&#10;                AnimatedVFX = None&#10;&#10;            # candidate layer names to try for back/front&#10;            back_layer_candidates = ['effects_back', 'effects.back', 'vfx_back', 'back_effects', 'effects_back_layer', 'effects_back']&#10;            front_layer_candidates = ['effects_front', 'effects.front', 'vfx_front', 'front_effects', 'effects_front_layer', 'effects_front']&#10;&#10;            # helper to find or create layer list&#10;            def _find_layer(lst_candidates):&#10;                for name in lst_candidates:&#10;                    if name in w and isinstance(w[name], list):&#10;                        return name&#10;                # if none found, create the first candidate key as empty list&#10;                name = lst_candidates[0]&#10;                try:&#10;                    w.setdefault(name, [])&#10;                    return name&#10;                except Exception:&#10;                    return None&#10;&#10;            back_layer = _find_layer(back_layer_candidates)&#10;            front_layer = _find_layer(front_layer_candidates)&#10;&#10;            # create and append back VFX&#10;            if AnimatedVFX is not None and back_layer is not None:&#10;                # try prefixes until frames load&#10;                for bp in back_prefixes:&#10;                    try:&#10;                        # pass bp unchanged; AnimatedVFX will look for bp00, bp01 ...&#10;                        vfx = AnimatedVFX(vfx_folder, bp, back_frames, frame_time, px, py, scale=getattr(item, 'consume_vfx_scale', 1.0), life=back_frames*frame_time)&#10;                        # debug&#10;                        print(f'[items._play_consume_vfx] created AnimatedVFX for back prefix {bp} frames_loaded={getattr(vfx, &quot;frames_count&quot;, 0)}')&#10;                        # only append if frames loaded&#10;                        if getattr(vfx, 'frames_count', 0) &gt; 0:&#10;                            w[back_layer].append(vfx)&#10;                            print(f'[items._play_consume_vfx] appended back vfx to layer {back_layer}')&#10;                            break&#10;                    except Exception as ex:&#10;                        print(f&quot;\033[91m[items._play_consume_vfx] back prefix {bp} failed: {ex}\033[0m&quot;)&#10;                        continue&#10;&#10;            # create and append front VFX&#10;            if AnimatedVFX is not None and front_layer is not None:&#10;                for fp in front_prefixes:&#10;                    try:&#10;                        vfx = AnimatedVFX(vfx_folder, fp, front_frames, frame_time, px, py, scale=getattr(item, 'consume_vfx_scale', 1.0), life=front_frames*frame_time)&#10;                        print(f'[items._play_consume_vfx] created AnimatedVFX for front prefix {fp} frames_loaded={getattr(vfx, &quot;frames_count&quot;, 0)}')&#10;                        if getattr(vfx, 'frames_count', 0) &gt; 0:&#10;                            w[front_layer].append(vfx)&#10;                            print(f'[items._play_consume_vfx] appended front vfx to layer {front_layer}')&#10;                            break&#10;                    except Exception as ex:&#10;                        print(f&quot;\033[91m[items._play_consume_vfx] front prefix {fp} failed: {ex}\033[0m&quot;)&#10;                        continue&#10;&#10;            # 마지막 폴백: world에 'vfx' 리스트 추가&#10;            try:&#10;                if 'vfx' not in w:&#10;                    w['vfx'] = []&#10;                # if nothing added and AnimatedVFX available, add a combined short effect&#10;                if AnimatedVFX is not None and (front_layer is None and back_layer is None):&#10;                    try:&#10;                        v = AnimatedVFX(vfx_folder, front_prefixes[0], front_frames, frame_time, px, py, scale=getattr(item, 'consume_vfx_scale', 1.0))&#10;                        if getattr(v, 'frames_count', 0) &gt; 0:&#10;                            w['vfx'].append(v)&#10;                            print('[items._play_consume_vfx] appended fallback vfx to w[vfx]')&#10;                    except Exception:&#10;                        pass&#10;            except Exception:&#10;                pass&#10;&#10;        item.on_consume_vfx = _play_consume_vfx&#10;        return item&#10;&#10;&#10;&#10;# 디버그용 샘플 목록 생성기&#10;&#10;def sample_debug_list():&#10;    &quot;&quot;&quot;디버그 시드에 사용할 (Item, qty) 리스트를 반환&quot;&quot;&quot;&#10;    return [&#10;        (lantern(), 1),&#10;        (magic_glasses(), 1),&#10;        (rabbit_guard_helm(), 1),&#10;        (carrot(), 3),&#10;        (amber(), 1),&#10;        (ruby(), 1),&#10;        (white_bread(), 1),&#10;        (potion_red0(), 15),&#10;    ]&#10;&#10;&#10;# 몬스터 아이템 드롭 시스템&#10;&#10;def drop_item(world, item_factory, qty, x, y, drop_chance=1.0):&#10;    &quot;&quot;&quot;&#10;    몬스터가 아이템을 드롭하는 헬퍼 함수&#10;    &#10;    Args:&#10;        world: 게임 월드 딕셔너리&#10;        item_factory: 아이템 팩토리 클래스 (예: potion_red0)&#10;        qty: 드롭할 아이템 수량&#10;        x, y: 드롭 위치 (픽셀 좌표)&#10;        drop_chance: 드롭 확률 (0.0 ~ 1.0, 기본값 1.0 = 100%)&#10;    &#10;    Returns:&#10;        bool: 아이템이 드롭되었으면 True, 아니면 False&#10;    &quot;&quot;&quot;&#10;    import random&#10;    from .item_entity import WorldItem&#10;    &#10;    # 확률 체크&#10;    if random.random() &gt; drop_chance:&#10;        return False&#10;    &#10;    try:&#10;        # 아이템 생성&#10;        item = item_factory()&#10;        &#10;        # WorldItem 엔티티 생성&#10;        world_item = WorldItem(item, qty, x, y, scale=0.5, world=world, pickup_radius=60)&#10;        &#10;        # 월드의 entities 리스트에 추가&#10;        if 'entities' in world and isinstance(world['entities'], list):&#10;            world['entities'].append(world_item)&#10;            print(f&quot;[ItemDrop] {getattr(item, 'name', 'Unknown')} x{qty} 드롭 성공 at ({x}, {y})&quot;)&#10;            return True&#10;        else:&#10;            print(f&quot;\033[91m[ItemDrop] world에 entities 리스트가 없습니다\033[0m&quot;)&#10;            return False&#10;            &#10;    except Exception as e:&#10;        print(f&quot;\033[91m[ItemDrop] 아이템 드롭 실패: {e}\033[0m&quot;)&#10;        return False" />
              <option name="updatedContent" value="# 패키지 내부 모듈. 공용 아이템 팩토리와 샘플 세트 제공&#10;from .inventory import Item&#10;&#10;# 개별 아이템 팩토리 (파일 경로는 Item 폴더 상대 경로)&#10;&#10;class lantern:&#10;    def __new__(cls):&#10;        return Item.from_filename('Lantern.png', '랜턴',&#10;                                  description='어둠을 밝히는 낡은 랜턴')&#10;&#10;&#10;class magic_glasses:&#10;    def __new__(cls):&#10;        return Item.from_filename('MagicGlasses.png', '마법 안경',&#10;                                  description='치명타 확률 +20%',&#10;                                  passive={'crit_chance': 20.0})  # 치명타 확률 20% 증가&#10;&#10;class rabbit_guard_helm:&#10;    def __new__(cls):&#10;        return Item.from_filename('RabbitGuardHelm.png', '토끼 수호자 투구',&#10;                                  description='방어력 +5',&#10;                                  passive={'defense': 5.0})&#10;&#10;class carrot:&#10;    def __new__(cls):&#10;        return Item.from_filename('Carrot.png', '당근',&#10;                                  description='8초간 이동속도 +50 (쿨타임 3초)',&#10;                                  consumable={'move_speed': 50.0}, consume_duration=8.0,&#10;                                  cooldown=3.0)  # 3초 쿨타임&#10;&#10;class amber:&#10;    def __new__(cls):&#10;        return Item.from_filename('Amber.png', '호박보석',&#10;                                  description='공격력 +2',&#10;                                  passive={'attack_damage': 2.0})&#10;&#10;class ruby:&#10;    def __new__(cls):&#10;        return Item.from_filename('Ruby.png', '루비',&#10;                                  description='공격력 +3',&#10;                                  passive={'attack_damage': 3.0})&#10;&#10;class white_bread:&#10;    def __new__(cls):&#10;        return Item.from_filename('WhiteCrustedBread.png', '하얀 빵',&#10;                                  description='10초간 마나 +20 (쿨타임 5초)',&#10;                                  consumable={'mana': 20.0}, consume_duration=10.0,&#10;                                  cooldown=5.0)  # 5초 쿨타임&#10;&#10;class potion_red0:&#10;    def __new__(cls):&#10;        item = Item.from_filename('Potion/Item_RedPotion0.png', '빨간 포션',&#10;                                  description='15초간 체력 +10 회복 (쿨타임 5초)',&#10;                                  consumable={'health': 10.0}, consume_duration=15.0,&#10;                                  cooldown=5.0)  # 2초 쿨타임&#10;&#10;        # VFX 리소스 경로&#10;        item.consume_vfx_path = r'resources\Texture_organize\VFX\Potion_Common'&#10;        # VFX 시각 크기 배율(기본 1.0 -&gt; 2.0으로 키움)&#10;        item.consume_vfx_scale = 2.0&#10;&#10;        # 소비 시 호출 가능한 안전한 콜백 (consumer는 플레이어 엔티티)&#10;        def _play_consume_vfx(consumer, world=None, x=None, y=None):&#10;            import sys&#10;            import os&#10;&#10;            # debug&#10;            try:&#10;                print(f&quot;[items._play_consume_vfx] called for item {getattr(item,'name', getattr(item,'id', 'Unknown'))}, world_set={bool(world)}&quot;)&#10;            except Exception:&#10;                pass&#10;&#10;            # 안전한 world 조회 (폴백)&#10;            w = world&#10;            if w is None:&#10;                main_mod = sys.modules.get('__main__')&#10;                if main_mod:&#10;                    w = getattr(main_mod, 'world', None)&#10;            if not w:&#10;                print(&quot;\033[91m[items._play_consume_vfx] no world available, aborting VFX\033[0m&quot;)&#10;                return&#10;&#10;            # 위치 결정&#10;            px = x if x is not None else getattr(consumer, 'x', None)&#10;            py = y if y is not None else getattr(consumer, 'y', None)&#10;&#10;            # 경로 확인&#10;            vfx_folder = getattr(item, 'consume_vfx_path', None)&#10;            if not vfx_folder:&#10;                print(&quot;\033[91m[items._play_consume_vfx] item has no consume_vfx_path\033[0m&quot;)&#10;                return&#10;            # normalize folder path&#10;            vfx_folder = os.path.normpath(vfx_folder)&#10;&#10;            print(f&quot;[items._play_consume_vfx] vfx_folder={vfx_folder} px={px} py={py}&quot;)&#10;&#10;            # 기본 옵션&#10;            frame_time = getattr(item, 'consume_vfx_frame_time', 0.06)&#10;&#10;            # 가능한 파일명 접두사(백/프론트)와 프레임 수&#10;            back_prefixes = ['Potionl_Back_FX', 'Potionl_Back_FX00']&#10;            front_prefixes = ['Potion_Front_FX', 'Potion_Front_FX00', 'Potion_Front_FX0']&#10;            back_frames = getattr(item, 'consume_vfx_back_frames', 8)&#10;            front_frames = getattr(item, 'consume_vfx_front_frames', 4)&#10;&#10;            # 우선 world.spawn_vfx API가 있다면 사용 (지원하면 더 간단)&#10;            spawn = getattr(w, 'spawn_vfx', None)&#10;            if callable(spawn):&#10;                print('[items._play_consume_vfx] using world.spawn_vfx API')&#10;                try:&#10;                    # spawn a back effect (if files exist)&#10;                    for bp in back_prefixes:&#10;                        try:&#10;                            spawn(os.path.join(vfx_folder, bp), px, py, frames=back_frames, frame_time=frame_time, layer='effects_back', loop=False)&#10;                            print(f'[items._play_consume_vfx] spawned back with prefix {bp}')&#10;                            break&#10;                        except Exception:&#10;                            print(f&quot;\033[91m[items._play_consume_vfx] spawn back failed for prefix {bp}\033[0m&quot;)&#10;                            continue&#10;                except Exception:&#10;                    pass&#10;                try:&#10;                    for fp in front_prefixes:&#10;                        try:&#10;                            spawn(os.path.join(vfx_folder, fp), px, py, frames=front_frames, frame_time=frame_time, layer='effects_front', loop=False)&#10;                            print(f'[items._play_consume_vfx] spawned front with prefix {fp}')&#10;                            break&#10;                        except Exception:&#10;                            print(f&quot;\033[91m[items._play_consume_vfx] spawn front failed for prefix {fp}\033[0m&quot;)&#10;                            continue&#10;                except Exception:&#10;                    pass&#10;                return&#10;&#10;            # fallback: create AnimatedVFX and append to world layers&#10;            try:&#10;                from .vfx import AnimatedVFX&#10;            except Exception:&#10;                AnimatedVFX = None&#10;&#10;            # candidate layer names to try for back/front&#10;            back_layer_candidates = ['effects_back', 'effects.back', 'vfx_back', 'back_effects', 'effects_back_layer', 'effects_back']&#10;            front_layer_candidates = ['effects_front', 'effects.front', 'vfx_front', 'front_effects', 'effects_front_layer', 'effects_front']&#10;&#10;            # helper to find or create layer list&#10;            def _find_layer(lst_candidates):&#10;                for name in lst_candidates:&#10;                    if name in w and isinstance(w[name], list):&#10;                        return name&#10;                # if none found, create the first candidate key as empty list&#10;                name = lst_candidates[0]&#10;                try:&#10;                    w.setdefault(name, [])&#10;                    return name&#10;                except Exception:&#10;                    return None&#10;&#10;            back_layer = _find_layer(back_layer_candidates)&#10;            front_layer = _find_layer(front_layer_candidates)&#10;&#10;            # create and append back VFX&#10;            if AnimatedVFX is not None and back_layer is not None:&#10;                # try prefixes until frames load&#10;                for bp in back_prefixes:&#10;                    try:&#10;                        # pass bp unchanged; AnimatedVFX will look for bp00, bp01 ...&#10;                        vfx = AnimatedVFX(vfx_folder, bp, back_frames, frame_time, px, py, scale=getattr(item, 'consume_vfx_scale', 1.0), life=back_frames*frame_time)&#10;                        # debug&#10;                        print(f'[items._play_consume_vfx] created AnimatedVFX for back prefix {bp} frames_loaded={getattr(vfx, &quot;frames_count&quot;, 0)}')&#10;                        # only append if frames loaded&#10;                        if getattr(vfx, 'frames_count', 0) &gt; 0:&#10;                            w[back_layer].append(vfx)&#10;                            print(f'[items._play_consume_vfx] appended back vfx to layer {back_layer}')&#10;                            break&#10;                    except Exception as ex:&#10;                        print(f&quot;\033[91m[items._play_consume_vfx] back prefix {bp} failed: {ex}\033[0m&quot;)&#10;                        continue&#10;&#10;            # create and append front VFX&#10;            if AnimatedVFX is not None and front_layer is not None:&#10;                for fp in front_prefixes:&#10;                    try:&#10;                        vfx = AnimatedVFX(vfx_folder, fp, front_frames, frame_time, px, py, scale=getattr(item, 'consume_vfx_scale', 1.0), life=front_frames*frame_time)&#10;                        print(f'[items._play_consume_vfx] created AnimatedVFX for front prefix {fp} frames_loaded={getattr(vfx, &quot;frames_count&quot;, 0)}')&#10;                        if getattr(vfx, 'frames_count', 0) &gt; 0:&#10;                            w[front_layer].append(vfx)&#10;                            print(f'[items._play_consume_vfx] appended front vfx to layer {front_layer}')&#10;                            break&#10;                    except Exception as ex:&#10;                        print(f&quot;\033[91m[items._play_consume_vfx] front prefix {fp} failed: {ex}\033[0m&quot;)&#10;                        continue&#10;&#10;            # 마지막 폴백: world에 'vfx' 리스트 추가&#10;            try:&#10;                if 'vfx' not in w:&#10;                    w['vfx'] = []&#10;                # if nothing added and AnimatedVFX available, add a combined short effect&#10;                if AnimatedVFX is not None and (front_layer is None and back_layer is None):&#10;                    try:&#10;                        v = AnimatedVFX(vfx_folder, front_prefixes[0], front_frames, frame_time, px, py, scale=getattr(item, 'consume_vfx_scale', 1.0))&#10;                        if getattr(v, 'frames_count', 0) &gt; 0:&#10;                            w['vfx'].append(v)&#10;                            print('[items._play_consume_vfx] appended fallback vfx to w[vfx]')&#10;                    except Exception:&#10;                        pass&#10;            except Exception:&#10;                pass&#10;&#10;        item.on_consume_vfx = _play_consume_vfx&#10;        return item&#10;&#10;&#10;&#10;# 디버그용 샘플 목록 생성기&#10;&#10;def sample_debug_list():&#10;    &quot;&quot;&quot;디버그 시드에 사용할 (Item, qty) 리스트를 반환&quot;&quot;&quot;&#10;    return [&#10;        (lantern(), 1),&#10;        (magic_glasses(), 1),&#10;        (rabbit_guard_helm(), 1),&#10;        (carrot(), 3),&#10;        (amber(), 1),&#10;        (ruby(), 1),&#10;        (white_bread(), 1),&#10;        (potion_red0(), 15),&#10;    ]&#10;&#10;&#10;# 몬스터 아이템 드롭 시스템&#10;&#10;def drop_item(world, item_factory, qty, x, y, drop_chance=1.0):&#10;    &quot;&quot;&quot;&#10;    몬스터가 아이템을 드롭하는 헬퍼 함수&#10;    &#10;    Args:&#10;        world: 게임 월드 딕셔너리&#10;        item_factory: 아이템 팩토리 클래스 (예: potion_red0)&#10;        qty: 드롭할 아이템 수량&#10;        x, y: 드롭 위치 (픽셀 좌표)&#10;        drop_chance: 드롭 확률 (0.0 ~ 1.0, 기본값 1.0 = 100%)&#10;    &#10;    Returns:&#10;        bool: 아이템이 드롭되었으면 True, 아니면 False&#10;    &quot;&quot;&quot;&#10;    import random&#10;    from .item_entity import WorldItem&#10;    &#10;    # 확률 체크&#10;    if random.random() &gt; drop_chance:&#10;        return False&#10;    &#10;    try:&#10;        # 아이템 생성&#10;        item = item_factory()&#10;        &#10;        # WorldItem 엔티티 생성&#10;        world_item = WorldItem(item, qty, x, y, scale=0.5, world=world, pickup_radius=60)&#10;        &#10;        # 월드의 entities 리스트에 추가&#10;        if 'entities' in world and isinstance(world['entities'], list):&#10;            world['entities'].append(world_item)&#10;            print(f&quot;[ItemDrop] {getattr(item, 'name', 'Unknown')} x{qty} 드롭 성공 at ({x}, {y})&quot;)&#10;            return True&#10;        else:&#10;            print(f&quot;\033[91m[ItemDrop] world에 entities 리스트가 없습니다\033[0m&quot;)&#10;            return False&#10;            &#10;    except Exception as e:&#10;        print(f&quot;\033[91m[ItemDrop] 아이템 드롭 실패: {e}\033[0m&quot;)&#10;        return False" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/lobby_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/lobby_mode.py" />
              <option name="originalContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#10;# minimal, compatible with existing game_logic modules&#10;import pico2d as p2&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#10;&#10;import game_framework&#10;from .player import Player&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar, BuffIndicatorUI&#10;from .cursor import Cursor&#10;from .loading_screen import LoadingScreen&#10;from . import defeat_mode&#10;# 사용할 스테이지 모듈들을 import 합니다.&#10;from .stages import stage_1, stage_2&#10;from PIL import Image&#10;import math&#10;&#10;# world layers: keep same keys as original main.py&#10;world = {&#10;    'sky' : [],&#10;    'ground': [],&#10;    'upper_ground': [],&#10;    'walls': [],&#10;    'effects_back': [],&#10;    'entities': [],&#10;    'effects_front': [],&#10;    'ui': [],&#10;    'extra_bg': [],&#10;    'extras': [],&#10;    'cursor': []&#10;}&#10;world['bg'] = world['ground']&#10;world['player'] = world['entities']  # 플레이어 참조를 위한 키 추가&#10;world_list = ['sky', 'ground', 'upper_ground', 'walls', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']&#10;&#10;class Camera:&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#10;        self.target = target&#10;        self.x = target.x&#10;        self.y = target.y&#10;        self.map_width = map_width&#10;        self.map_height = map_height&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1)&#10;&#10;    def update(self):&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP)&#10;        target_x = self.target.x&#10;        target_y = self.target.y&#10;        self.x += (target_x - self.x) * self.smooth&#10;        self.y += (target_y - self.y) * self.smooth&#10;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#10;        min_x = -self.map_width/2&#10;        max_x = self.map_width/2&#10;        min_y = -self.map_height/2&#10;        max_y = self.map_height/2&#10;&#10;        self.x = max(min_x, min(self.x, max_x))&#10;        self.y = max(min_y, min(self.y, max_y))&#10;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#10;        if self.map_width &lt;= self.screen_width:&#10;            self.x = 0&#10;        if self.map_height &lt;= self.screen_height:&#10;            self.y = 0&#10;        # self.x, self.y는 맵 중심 기준 카메라 위치&#10;        # 화면 중앙이 (0,0)이 되도록 보정&#10;&#10;    def apply(self, obj_x, obj_y):&#10;        # 카메라 위치만큼 오브젝트 위치 보정 (화면 중앙 기준)&#10;        # obj_x, obj_y: 맵 중심(0,0) 기준 좌표&#10;        # 반환값: 화면에 그릴 좌표 (pico2d 기준, 화면 중앙이 0,0)&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#10;&#10;# Camera 객체를 전역으로 선언&#10;camera = None&#10;&#10;def calculate_background_bounds():&#10;    &quot;&quot;&quot;&#10;    sky와 ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#10;&#10;    Returns:&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#10;    &quot;&quot;&quot;&#10;    min_x = float('inf')&#10;    max_x = float('-inf')&#10;    min_y = float('inf')&#10;    max_y = float('-inf')&#10;&#10;    # sky와 ground 레이어의 모든 객체를 순회&#10;    for layer_name in ['sky', 'ground']:&#10;        for obj in world[layer_name]:&#10;            # 객체가 x, y, image, scale 속성을 가지고 있는지 확인&#10;            if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image') and hasattr(obj, 'scale'):&#10;                # 객체의 중심 좌표&#10;                obj_x = obj.x&#10;                obj_y = obj.y&#10;&#10;                # 이미지 크기 계산 (scale 적용)&#10;                img_width = obj.image.w * obj.scale&#10;                img_height = obj.image.h * obj.scale&#10;&#10;                # 객체의 경계 계산 (중심 기준이므로 절반씩)&#10;                obj_left = obj_x - img_width / 2&#10;                obj_right = obj_x + img_width / 2&#10;                obj_bottom = obj_y - img_height / 2&#10;                obj_top = obj_y + img_height / 2&#10;&#10;                # 최소/최대 값 업데이트&#10;                min_x = min(min_x, obj_left)&#10;                max_x = max(max_x, obj_right)&#10;                min_y = min(min_y, obj_bottom)&#10;                max_y = max(max_y, obj_top)&#10;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환&#10;    if min_x == float('inf') or max_x == float('-inf'):&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#10;        return (-800, 800, -600, 600)&#10;&#10;    print(f&quot;[lobby_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#10;    return (min_x, max_x, min_y, max_y)&#10;&#10;def enter():&#10;    global world, camera&#10;    print(&quot;[lobby_mode] Starting enter()...&quot;)&#10;&#10;    # clear existing&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#10;&#10;    # sky&#10;    print(&quot;[lobby_mode] Creating Sky...&quot;)&#10;    whiteBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/WhiteBG.png'&#10;    skyBackGroundPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloudBall_Gradation.png'&#10;    skyBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Back.png'&#10;    skyMidPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Mid.png'&#10;    skyFrontPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Front.png'&#10;    cloudPropPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Prop.png'&#10;    whiteBack = LobbySky(whiteBackPath, 0, 0, 6.5)&#10;    skyBackGround = LobbySky(skyBackGroundPath, 0, 0, 5.4)&#10;    skyBack = LobbySky(skyBackPath, 0, 200)&#10;    skyMid = LobbySky(skyMidPath, 0, 0)&#10;    skyFront = LobbySky(skyFrontPath, 0, -200)&#10;    cloudProp = LobbySky(cloudPropPath, 0, -400)&#10;&#10;    world['sky'].append(whiteBack)&#10;    world['sky'].append(skyBackGround)&#10;    world['sky'].append(skyBack)&#10;    world['sky'].append(skyMid)&#10;    world['sky'].append(skyFront)&#10;    world['sky'].append(cloudProp)&#10;&#10;    # background&#10;    print(&quot;[lobby_mode] Creating Background...&quot;)&#10;    bg = LobbyBackGround()&#10;    world['bg'].append(bg)&#10;&#10;    # 낭떠러지(투명 영역) 벽 자동 생성&#10;    try:&#10;        print(&quot;[DEBUG] wall_blocks 생성 시도 중...&quot;)&#10;        # 배경의 화면 위치와 스케일을 전달&#10;        wall_blocks = generate_walls_from_png(&#10;            'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png',&#10;            block_size=8,&#10;            bg_x=bg.x,&#10;            bg_y=bg.y,&#10;            scale=bg.scale&#10;        )&#10;        print(f&quot;[DEBUG] wall_blocks 반환: {len(wall_blocks)}개&quot;)&#10;        for wall in wall_blocks:&#10;            world['walls'].append(wall)&#10;            pass&#10;        print(f&quot;[lobby_mode] Generated {len(wall_blocks)} walls from PNG transparency.&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Wall generation from PNG failed: {ex}\033[0m&quot;)&#10;&#10;    # create portal to play mode&#10;    print(&quot;[lobby_mode] Creating EnterTreePortal...&quot;)&#10;    try:&#10;        # 백그라운드 이미지와 스케일에 맞춰 가로 중앙, 세로는 위에서 30% 아래에 배치&#10;        portal_x = bg.x&#10;        portal_y = bg.y + (bg.image.h * bg.scale) / 2 - (bg.image.h * bg.scale) * 0.3&#10;        enterTree = EnterTreePortal(portal_x, portal_y, scale=bg.scale)&#10;        world['upper_ground'].append(enterTree)&#10;        print(f&quot;[lobby_mode] EnterTreePortal created at ({portal_x}, {portal_y}) with scale {bg.scale}&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Failed to create EnterTreePortal: {ex}\033[0m&quot;)&#10;&#10;    print(&quot;[lobby_mode] Creating player...&quot;)&#10;    # create player (use fallback if heavy Player init fails)&#10;    try:&#10;        player = Player()&#10;        player.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;        player.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;        print(&quot;[lobby_mode] Player created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#10;        from .inventory import InventoryData, seed_debug_inventory&#10;&#10;        class _FallbackPlayer:&#10;            def __init__(self):&#10;                self.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;                self.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;                self.face_dir = 1&#10;                self.scale_factor = 1.0&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;                self.particles = []&#10;                self.attack_effects = []&#10;                self.inventory = InventoryData(cols=6, rows=5)&#10;                try:&#10;                    seed_debug_inventory(self.inventory)&#10;                except Exception:&#10;                    print(&quot;\033[91m[lobby_mode] seed_debug_inventory failed\033[0m&quot;)&#10;                    pass&#10;                self.inventory_open = False&#10;&#10;            def update(self):&#10;                return True&#10;&#10;            def rebuild_inventory_passives(self):&#10;                return&#10;&#10;            def consume_item_at(self, r, c):&#10;                return False&#10;&#10;        player = _FallbackPlayer()&#10;&#10;    print(&quot;[lobby_mode] Attaching world reference to player...&quot;)&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#10;    try:&#10;        player.world = world&#10;    except Exception:&#10;        print(&quot;\033[91m[lobby_mode] Failed to attach world to player\033[0m&quot;)&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#10;    world['entities'].append(player)&#10;&#10;    # Camera 초기화 (Player를 target으로 설정)&#10;    # sky와 ground 레이어의 실제 배경 범위를 계산하여 카메라 제한 범위로 사용&#10;    try:&#10;        # 배경 범위 계산 (sky와 ground 레이어의 모든 객체 고려)&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;&#10;        # 배경 전체 크기 계산&#10;        map_width = max_x - min_x&#10;        map_height = max_y - min_y&#10;&#10;        screen_width = p2.get_canvas_width()&#10;        screen_height = p2.get_canvas_height()&#10;&#10;        global camera&#10;        camera = Camera(player, map_width, map_height, screen_width, screen_height)&#10;&#10;        # 카메라에 실제 배경 범위의 중심점 정보 전달 (오프셋 계산용)&#10;        camera.map_offset_x = (min_x + max_x) / 2&#10;        camera.map_offset_y = (min_y + max_y) / 2&#10;&#10;        print(f&quot;[lobby_mode] Camera initialized for player at ({player.x}, {player.y})&quot;)&#10;        print(f&quot;[lobby_mode] Map size: {map_width:.1f} x {map_height:.1f}, Offset: ({camera.map_offset_x:.1f}, {camera.map_offset_y:.1f})&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Camera initialization failed: {ex}\033[0m&quot;)&#10;&#10;    print(&quot;[lobby_mode] Creating inventory overlay...&quot;)&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#10;    try:&#10;        inv = InventoryOverlay(player, world)&#10;        print(&quot;[lobby_mode] InventoryOverlay created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] InventoryOverlay init failed, creating minimal stub: {ex}\033[0m&quot;)&#10;&#10;        class _InvStub:&#10;            def __init__(self, player, world=None):&#10;                self.player = player&#10;                self.world = world&#10;                self.dragging = False&#10;                self.drag_from = None&#10;                self.drag_icon = None&#10;                self.drag_qty = 0&#10;            def handle_event(self, e):&#10;                return&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        inv = _InvStub(player, world)&#10;    world['ui'].append(inv)&#10;&#10;    print(&quot;[lobby_mode] Creating cursor...&quot;)&#10;    # cursor on top (safe fallback)&#10;    try:&#10;        cursor = Cursor(player)&#10;        print(&quot;[lobby_mode] Cursor created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[lobby_mode] Cursor init failed, using stub cursor: {ex}\033[0m&quot;)&#10;&#10;        class _CursorStub:&#10;            def __init__(self, player=None):&#10;                self.player = player&#10;                self.x = 0&#10;                self.y = 0&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;            def handle_event(self, e):&#10;                return&#10;&#10;        cursor = _CursorStub(player)&#10;    world['cursor'].append(cursor)&#10;&#10;    # expose world to __main__ for legacy code that looks up main.world&#10;    try:&#10;        import sys&#10;        main_mod = sys.modules.get('__main__')&#10;        if main_mod is not None:&#10;            setattr(main_mod, 'world', world)&#10;    except Exception:&#10;        print(&quot;\033[91m[lobby_mode] Failed to expose world to __main__\033[0m&quot;)&#10;&#10;&#10;def exit():&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#10;&#10;&#10;def handle_events():&#10;    import game_framework as app_framework&#10;&#10;    events = p2.get_events()&#10;    player = world.get('player')&#10;    portal_triggered = False&#10;&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            app_framework.quit()&#10;            return&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#10;            app_framework.quit()&#10;            return&#10;        # F키 입력 시 포탈 충돌 체크&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == p2.SDLK_f:&#10;            for obj in world['upper_ground']:&#10;                if isinstance(obj, EnterTreePortal) and player:&#10;                    if obj.check_player_collision(player):&#10;                        if not portal_triggered:&#10;                            from . import play_mode&#10;                            print('[lobby_mode] EnterTreePortal triggered: switching to play_mode')&#10;                            app_framework.change_state(play_mode)&#10;                            portal_triggered = True&#10;&#10;        # broadcast to entities -&gt; ui -&gt; cursor&#10;        for o in list(world['entities']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for entity\033[0m&quot;)&#10;        for o in list(world['ui']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for UI\033[0m&quot;)&#10;        for o in list(world['cursor']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for cursor\033[0m&quot;)&#10;&#10;&#10;def update():&#10;    global camera&#10;    # 카메라 업데이트 추가&#10;    if camera is not None:&#10;        camera.update()&#10;&#10;    # 일반 게임 업데이트&#10;    for layer_name in world_list:&#10;        new_list = []&#10;        for o in list(world[layer_name]):&#10;            try:&#10;                if hasattr(o, 'update'):&#10;                    alive = o.update()&#10;                    if alive is False:&#10;                        continue&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[lobby_mode] Failed to update object : {ex}\033[0m&quot;)&#10;&#10;            # mark_for_removal 플래그 확인&#10;            if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#10;                print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#10;                continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#10;&#10;            new_list.append(o)&#10;        world[layer_name][:] = new_list&#10;&#10;    # 충돌 검사 시스템&#10;    from .projectile import Projectile&#10;    player = world.get('player')&#10;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#10;    effects_to_remove = set()&#10;    projectiles_to_remove = set()&#10;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#10;    for effect in world['effects_front']:&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#10;            for entity in world['entities']:&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#10;                    if entity.check_collision_with_effect(effect):&#10;                        # 디버그: 충돌 정보 출력&#10;                        attacker_name = &quot;Player&quot;&#10;                        if hasattr(effect, 'owner'):&#10;                            attacker_name = effect.owner.__class__.__name__&#10;                        target_name = entity.__class__.__name__&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#10;                        pass&#10;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#10;    if player:&#10;        for projectile in world['effects_front']:&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#10;            if isinstance(projectile, Projectile):&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#10;                if not projectile.from_player:&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#10;                        if player.check_collision_with_projectile(projectile):&#10;                            # 디버그: 충돌 정보 출력&#10;                            attacker_name = &quot;Unknown&quot;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#10;                                attacker_name = projectile.owner.__class__.__name__&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#10;                            projectiles_to_remove.add(projectile)&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#10;                else:&#10;                    for entity in world['entities']:&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#10;                            if entity.check_collision_with_projectile(projectile):&#10;                                # 디버그: 충돌 정보 출력&#10;                                target_name = entity.__class__.__name__&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#10;                                projectiles_to_remove.add(projectile)&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#10;&#10;    # 충돌한 투사체 제거&#10;    if projectiles_to_remove:&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#10;&#10;    # 포탈 위에 텍스트 표시&#10;    for obj in world['upper_ground']:&#10;        if isinstance(obj, EnterTreePortal) and player:&#10;            if obj.check_player_collision(player):&#10;                obj.trigger = True&#10;            else:&#10;                obj.trigger = False&#10;&#10;def draw():&#10;    global camera&#10;    p2.clear_canvas()&#10;&#10;    from .equipment import ShieldRangeEffect&#10;&#10;    # 하늘을 가장 먼저 그리기 (배경 뒤)&#10;    for obj in world['sky']:&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y'):&#10;            if camera is not None:&#10;                draw_x, draw_y = camera.apply(obj.x, obj.y)&#10;            else:&#10;                draw_x, draw_y = obj.x, obj.y&#10;            if hasattr(obj, 'draw'):&#10;                obj.draw(draw_x, draw_y)&#10;        else:&#10;            if hasattr(obj, 'draw'):&#10;                obj.draw()&#10;&#10;    # 나머지 레이어들 (배경, 벽, 엔티티 등)&#10;    for layer in ['ground', 'walls', 'upper_ground', 'entities', 'effects_back', 'effects_front', 'extra_bg', 'extras']:&#10;        for obj in world[layer]:&#10;            # ShieldRangeEffect는 특별 처리 (플레이어 위치 기준)&#10;            if isinstance(obj, ShieldRangeEffect):&#10;                if hasattr(obj, 'player') and obj.player:&#10;                    if camera is not None:&#10;                        draw_x, draw_y = camera.apply(obj.player.x, obj.player.y)&#10;                    else:&#10;                        draw_x, draw_y = obj.player.x, obj.player.y&#10;                    if hasattr(obj, 'draw'):&#10;                        obj.draw(draw_x, draw_y)&#10;            elif hasattr(obj, 'x') and hasattr(obj, 'y'):&#10;                if camera is not None:&#10;                    draw_x, draw_y = camera.apply(obj.x, obj.y)&#10;                else:&#10;                    draw_x, draw_y = obj.x, obj.y&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw(draw_x, draw_y)&#10;            else:&#10;                if hasattr(obj, 'draw'):&#10;                    obj.draw()&#10;    # UI, cursor 등은 카메라 적용하지 않음&#10;    for obj in world['ui']:&#10;        if hasattr(obj, 'draw'):&#10;            obj.draw()&#10;    for obj in world['cursor']:&#10;        if hasattr(obj, 'draw'):&#10;            obj.draw()&#10;    p2.update_canvas()&#10;&#10;class LobbySky:&#10;    def __init__(self, path, x=0, y=0, scale=3):&#10;        self.image = p2.load_image(path)&#10;        self.scale = scale&#10;        self.x = x  # 화면 중심(0,0) 기준&#10;        self.y = y  # 화면 중심(0,0) 기준&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        self.image.draw(draw_x, draw_y, self.image.w * self.scale * 2,&#10;                        self.image.h * self.scale * 1.5)&#10;        # 디버그용 히트박스 (필요시 주석 처리)&#10;        # p2.draw_rectangle(draw_x - (self.image.w * self.scale) / 2,&#10;        #                   draw_y - (self.image.h * self.scale) / 2,&#10;        #                   draw_x + (self.image.w * self.scale) / 2,&#10;        #                   draw_y + (self.image.h * self.scale) / 2)&#10;&#10;&#10;class LobbyBackGround:&#10;    image = None&#10;    def __init__(self):&#10;        if LobbyBackGround.image is None:&#10;            LobbyBackGround.image = p2.load_image('resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png')&#10;        self.scale = 6.5&#10;        self.x = 0  # 화면 중심(0,0)으로 위치 보정&#10;        self.y = 0  # 화면 중심(0,0)으로 위치 보정&#10;&#10;    def update(self):&#10;        pass&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        LobbyBackGround.image.draw(draw_x, draw_y, LobbyBackGround.image.w * self.scale, LobbyBackGround.image.h * self.scale)&#10;        # p2.draw_rectangle(draw_x - (LobbyBackGround.image.w * self.scale) / 2,&#10;        #                   draw_y - (LobbyBackGround.image.h * self.scale) / 2,&#10;        #                   draw_x + (LobbyBackGround.image.w * self.scale) / 2,&#10;        #                   draw_y + (LobbyBackGround.image.h * self.scale) / 2)&#10;&#10;class EnterTreePortal:&#10;    # frame lists (class-level so images are loaded only once)&#10;    portalImagesBegin = []&#10;    portalImagesCycle = []&#10;    portalFXBegin = []&#10;    portalFXCycle = []&#10;    loaded = False&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # load images once (safe: catch missing files)&#10;        if not EnterTreePortal.loaded:&#10;            try:&#10;                for i in range(18):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Begin{i:02d}.png'&#10;                    EnterTreePortal.portalImagesBegin.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalImagesBegin = []&#10;            try:&#10;                # cycle uses a single image in original assets, but keep as list for consistency&#10;                EnterTreePortal.portalImagesCycle.append(p2.load_image('resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Cycle00.png'))&#10;            except Exception:&#10;                EnterTreePortal.portalImagesCycle = []&#10;            try:&#10;                for i in range(18):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Begin{i:02d}.png'&#10;                    EnterTreePortal.portalFXBegin.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalFXBegin = []&#10;            try:&#10;                for i in range(11):&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Cycle{i:02d}.png'&#10;                    EnterTreePortal.portalFXCycle.append(p2.load_image(path))&#10;            except Exception:&#10;                EnterTreePortal.portalFXCycle = []&#10;            EnterTreePortal.loaded = True&#10;&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;        # self.trigger_radius = 50  # 플레이어가 접근해야 하는 반경&#10;        self.trigger = False&#10;&#10;        # animation state&#10;        self.begin_animation_done = False&#10;        self.frame_idx = 0&#10;        self.fx_idx = 0&#10;        self.frame_dt = 0.0&#10;        self.fx_dt = 0.0&#10;        self.frame_duration = 0.06  # seconds per frame&#10;        self.fx_duration = 0.06&#10;        self.last_time = p2.get_time()&#10;&#10;    def update(self):&#10;        # advance animation based on time delta&#10;        now = p2.get_time()&#10;        dt = now - getattr(self, 'last_time', now)&#10;        self.last_time = now&#10;        # update portal image animation&#10;        self.frame_dt += dt&#10;        if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#10;            # play begin sequence once&#10;            if self.frame_dt &gt;= self.frame_duration:&#10;                steps = int(self.frame_dt / self.frame_duration)&#10;                self.frame_dt -= steps * self.frame_duration&#10;                self.frame_idx += steps&#10;                if self.frame_idx &gt;= len(EnterTreePortal.portalImagesBegin):&#10;                    # start cycle&#10;                    self.begin_animation_done = True&#10;                    self.frame_idx = 0&#10;        else:&#10;            # loop cycle frames&#10;            if EnterTreePortal.portalImagesCycle:&#10;                if self.frame_dt &gt;= self.frame_duration:&#10;                    steps = int(self.frame_dt / self.frame_duration)&#10;                    self.frame_dt -= steps * self.frame_duration&#10;                    self.frame_idx = (self.frame_idx + steps) % max(1, len(EnterTreePortal.portalImagesCycle))&#10;&#10;        # update FX animation: try to play begin and then cycle&#10;        self.fx_dt += dt&#10;        if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#10;            if self.fx_dt &gt;= self.fx_duration:&#10;                steps = int(self.fx_dt / self.fx_duration)&#10;                self.fx_dt -= steps * self.fx_duration&#10;                self.fx_idx += steps&#10;                # clamp fx_idx so it doesn't grow unbounded; allow it to loop during begin&#10;                if self.fx_idx &gt;= len(EnterTreePortal.portalFXBegin):&#10;                    self.fx_idx = 0&#10;        else:&#10;            if EnterTreePortal.portalFXCycle:&#10;                if self.fx_dt &gt;= self.fx_duration:&#10;                    steps = int(self.fx_dt / self.fx_duration)&#10;                    self.fx_dt -= steps * self.fx_duration&#10;                    self.fx_idx = (self.fx_idx + steps) % max(1, len(EnterTreePortal.portalFXCycle))&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw portal image (begin or cycle)&#10;        try:&#10;            if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#10;                img = EnterTreePortal.portalImagesBegin[min(self.frame_idx, len(EnterTreePortal.portalImagesBegin)-1)]&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;            elif EnterTreePortal.portalImagesCycle:&#10;                img = EnterTreePortal.portalImagesCycle[self.frame_idx % len(EnterTreePortal.portalImagesCycle)]&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;        except Exception:&#10;            # drawing failure should not crash the game&#10;            pass&#10;&#10;        # draw FX overlay&#10;        try:&#10;            if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#10;                fx = EnterTreePortal.portalFXBegin[self.fx_idx % len(EnterTreePortal.portalFXBegin)]&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#10;            elif EnterTreePortal.portalFXCycle:&#10;                fx = EnterTreePortal.portalFXCycle[self.fx_idx % len(EnterTreePortal.portalFXCycle)]&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#10;        except Exception:&#10;            pass&#10;&#10;        # 포탈 위에 텍스트 그리기&#10;        if self.trigger:&#10;            try:&#10;                # print(f'[lobby_mode] Drawing portal text at ({draw_x}, {draw_y})')&#10;                font = p2.load_font('resources/Fonts/pixelroborobo.otf', 20)&#10;                text = &quot;[F] 모험하기&quot;&#10;                font_size = 40&#10;                approx_width = int(len(text) * font_size * 0.4)&#10;                font.draw(draw_x - approx_width // 2, draw_y + 10 * self.scale, text, (255, 255, 0))&#10;            except Exception as ex:&#10;                print(f'[lobby_mode] 포탈 텍스트 그리기 실패: {ex}')&#10;&#10;    def check_player_collision(self, player):&#10;        # 플레이어와 포탈의 히트박스 충돌 검사&#10;        # 플레이어의 크기(w, h)는 기본값 32x32로 가정, 필요시 Player에서 가져올 것&#10;        px = getattr(player, 'x', 0)&#10;        py = getattr(player, 'y', 0)&#10;        pw = getattr(player, 'w', 32)&#10;        ph = getattr(player, 'h', 32)&#10;        # 포탈의 히트박스는 중심 기준, 크기는 이미지 크기 * scale * 0.5 (적당히 조정)&#10;        portal_w = 61 * self.scale&#10;        portal_h = 47 * self.scale&#10;        portal_x = self.x - portal_w / 2&#10;        portal_y = self.y - portal_h / 2&#10;        return (px &lt; portal_x + portal_w and px + pw &gt; portal_x and&#10;                py &lt; portal_y + portal_h and py + ph &gt; portal_y)&#10;&#10;class LobbyWall:&#10;    def __init__(self, x, y, w, h):&#10;        self.x = x&#10;        self.y = y&#10;        self.w = w&#10;        self.h = h&#10;&#10;&#10;    def check_collision(self, px, py, pw, ph):&#10;        # 플레이어와 벽의 사각형 충돌 검사&#10;        return (self.x &lt; px + pw and self.x + self.w &gt; px and&#10;                self.y &lt; py + ph and self.y + self.h &gt; py)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 카메라 적용 좌표로 벽 영역을 빨간색으로 표시&#10;        try:&#10;            # p2.draw_rectangle(draw_x, draw_y, draw_x + self.w, draw_y + self.h)&#10;            pass&#10;        except Exception as ex:&#10;            print(f'[LobbyWall] draw() 실패 at ({draw_x}, {draw_y}, {self.w}, {self.h}), Exception {ex}')&#10;&#10;def generate_walls_from_png(png_path, block_size=16, bg_x=None, bg_y=None, scale=1.0):&#10;    print(f&quot;[DEBUG] generate_walls_from_png 시작: {png_path}, block_size={block_size}, bg_x={bg_x}, bg_y={bg_y}, scale={scale}&quot;)&#10;    try:&#10;        img = Image.open(png_path).convert('RGBA')&#10;    except Exception as ex:&#10;        print(f&quot;[DEBUG] 이미지 열기 실패: {ex}&quot;)&#10;        return []&#10;    width, height = img.size&#10;    walls = []&#10;    pixels = img.load()&#10;    transparent_count = 0&#10;    # 배경 이미지의 화면 내 좌표계 기준 좌표 계산&#10;    if bg_x is None: bg_x = width * scale / 2&#10;    if bg_y is None: bg_y = height * scale / 2&#10;    screen_left = bg_x - (width * scale) / 2&#10;    screen_top = bg_y + (height * scale) / 2&#10;    for y in range(0, height, block_size):&#10;        for x in range(0, width, block_size):&#10;            is_transparent = False&#10;            for dy in range(block_size):&#10;                for dx in range(block_size):&#10;                    if x+dx &lt; width and y+dy &lt; height:&#10;                        _, _, _, alpha = pixels[x+dx, y+dy]&#10;                        if alpha == 0:&#10;                            is_transparent = True&#10;                            transparent_count += 1&#10;                            break&#10;                if is_transparent:&#10;                    break&#10;            if is_transparent:&#10;                # 이미지 좌표를 화면 좌표로 변환 (좌상단 기준)&#10;                wall_x_img = x&#10;                wall_y_img = height - y - block_size&#10;                wall_x_screen = screen_left + wall_x_img * scale&#10;                wall_y_screen = bg_y - (height * scale) / 2 + wall_y_img * scale&#10;                walls.append(LobbyWall(wall_x_screen, wall_y_screen, block_size * scale, block_size * scale))&#10;    print(f&quot;[DEBUG] 투명 픽셀 수: {transparent_count}, 생성된 벽 수: {len(walls)}&quot;)&#10;    return walls&#10;" />
              <option name="updatedContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#13;&#10;# minimal, compatible with existing game_logic modules&#13;&#10;import pico2d as p2&#13;&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#13;&#10;&#13;&#10;import game_framework&#13;&#10;from .player import Player&#13;&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar, BuffIndicatorUI&#13;&#10;from .cursor import Cursor&#13;&#10;from .loading_screen import LoadingScreen&#13;&#10;from . import defeat_mode&#13;&#10;# 사용할 스테이지 모듈들을 import 합니다.&#13;&#10;from .stages import stage_1, stage_2&#13;&#10;from PIL import Image&#13;&#10;import math&#13;&#10;&#13;&#10;# world layers: keep same keys as original main.py&#13;&#10;world = {&#13;&#10;    'sky' : [],&#13;&#10;    'ground': [],&#13;&#10;    'upper_ground': [],&#13;&#10;    'walls': [],&#13;&#10;    'effects_back': [],&#13;&#10;    'entities': [],&#13;&#10;    'effects_front': [],&#13;&#10;    'ui': [],&#13;&#10;    'extra_bg': [],&#13;&#10;    'extras': [],&#13;&#10;    'cursor': []&#13;&#10;}&#13;&#10;world['bg'] = world['ground']&#13;&#10;world['player'] = world['entities']  # 플레이어 참조를 위한 키 추가&#13;&#10;world_list = ['sky', 'ground', 'upper_ground', 'walls', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']&#13;&#10;&#13;&#10;class Camera:&#13;&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#13;&#10;        self.target = target&#13;&#10;        self.x = target.x&#13;&#10;        self.y = target.y&#13;&#10;        self.map_width = map_width&#13;&#10;        self.map_height = map_height&#13;&#10;        self.screen_width = screen_width&#13;&#10;        self.screen_height = screen_height&#13;&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1)&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP)&#13;&#10;        target_x = self.target.x&#13;&#10;        target_y = self.target.y&#13;&#10;        self.x += (target_x - self.x) * self.smooth&#13;&#10;        self.y += (target_y - self.y) * self.smooth&#13;&#10;&#13;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#13;&#10;        half_w = self.screen_width // 2&#13;&#10;        half_h = self.screen_height // 2&#13;&#10;&#13;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#13;&#10;        min_x = -self.map_width/2&#13;&#10;        max_x = self.map_width/2&#13;&#10;        min_y = -self.map_height/2&#13;&#10;        max_y = self.map_height/2&#13;&#10;&#13;&#10;        self.x = max(min_x, min(self.x, max_x))&#13;&#10;        self.y = max(min_y, min(self.y, max_y))&#13;&#10;&#13;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#13;&#10;        if self.map_width &lt;= self.screen_width:&#13;&#10;            self.x = 0&#13;&#10;        if self.map_height &lt;= self.screen_height:&#13;&#10;            self.y = 0&#13;&#10;        # self.x, self.y는 맵 중심 기준 카메라 위치&#13;&#10;        # 화면 중앙이 (0,0)이 되도록 보정&#13;&#10;&#13;&#10;    def apply(self, obj_x, obj_y):&#13;&#10;        # 카메라 위치만큼 오브젝트 위치 보정 (화면 중앙 기준)&#13;&#10;        # obj_x, obj_y: 맵 중심(0,0) 기준 좌표&#13;&#10;        # 반환값: 화면에 그릴 좌표 (pico2d 기준, 화면 중앙이 0,0)&#13;&#10;        half_w = self.screen_width // 2&#13;&#10;        half_h = self.screen_height // 2&#13;&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#13;&#10;&#13;&#10;# Camera 객체를 전역으로 선언&#13;&#10;camera = None&#13;&#10;&#13;&#10;def calculate_background_bounds():&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    sky와 ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#13;&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#13;&#10;&#13;&#10;    Returns:&#13;&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    min_x = float('inf')&#13;&#10;    max_x = float('-inf')&#13;&#10;    min_y = float('inf')&#13;&#10;    max_y = float('-inf')&#13;&#10;&#13;&#10;    # sky와 ground 레이어의 모든 객체를 순회&#13;&#10;    for layer_name in ['sky', 'ground']:&#13;&#10;        for obj in world[layer_name]:&#13;&#10;            # 객체가 x, y, image, scale 속성을 가지고 있는지 확인&#13;&#10;            if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image') and hasattr(obj, 'scale'):&#13;&#10;                # 객체의 중심 좌표&#13;&#10;                obj_x = obj.x&#13;&#10;                obj_y = obj.y&#13;&#10;&#13;&#10;                # 이미지 크기 계산 (scale 적용)&#13;&#10;                img_width = obj.image.w * obj.scale&#13;&#10;                img_height = obj.image.h * obj.scale&#13;&#10;&#13;&#10;                # 객체의 경계 계산 (중심 기준이므로 절반씩)&#13;&#10;                obj_left = obj_x - img_width / 2&#13;&#10;                obj_right = obj_x + img_width / 2&#13;&#10;                obj_bottom = obj_y - img_height / 2&#13;&#10;                obj_top = obj_y + img_height / 2&#13;&#10;&#13;&#10;                # 최소/최대 값 업데이트&#13;&#10;                min_x = min(min_x, obj_left)&#13;&#10;                max_x = max(max_x, obj_right)&#13;&#10;                min_y = min(min_y, obj_bottom)&#13;&#10;                max_y = max(max_y, obj_top)&#13;&#10;&#13;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환&#13;&#10;    if min_x == float('inf') or max_x == float('-inf'):&#13;&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#13;&#10;        return (-800, 800, -600, 600)&#13;&#10;&#13;&#10;    print(f&quot;[lobby_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#13;&#10;    return (min_x, max_x, min_y, max_y)&#13;&#10;&#13;&#10;def enter():&#13;&#10;    global world, camera&#13;&#10;    print(&quot;[lobby_mode] Starting enter()...&quot;)&#13;&#10;&#13;&#10;    # clear existing&#13;&#10;    for k in list(world.keys()):&#13;&#10;        try:&#13;&#10;            if isinstance(world[k], list):&#13;&#10;                world[k].clear()&#13;&#10;        except Exception:&#13;&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#13;&#10;&#13;&#10;    # sky&#13;&#10;    print(&quot;[lobby_mode] Creating Sky...&quot;)&#13;&#10;    whiteBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/WhiteBG.png'&#13;&#10;    skyBackGroundPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloudBall_Gradation.png'&#13;&#10;    skyBackPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Back.png'&#13;&#10;    skyMidPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Mid.png'&#13;&#10;    skyFrontPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Front.png'&#13;&#10;    cloudPropPath = 'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorldCloud_Prop.png'&#13;&#10;    whiteBack = LobbySky(whiteBackPath, 0, 0, 6.5)&#13;&#10;    skyBackGround = LobbySky(skyBackGroundPath, 0, 0, 5.4)&#13;&#10;    skyBack = LobbySky(skyBackPath, 0, 200)&#13;&#10;    skyMid = LobbySky(skyMidPath, 0, 0)&#13;&#10;    skyFront = LobbySky(skyFrontPath, 0, -200)&#13;&#10;    cloudProp = LobbySky(cloudPropPath, 0, -400)&#13;&#10;&#13;&#10;    world['sky'].append(whiteBack)&#13;&#10;    world['sky'].append(skyBackGround)&#13;&#10;    world['sky'].append(skyBack)&#13;&#10;    world['sky'].append(skyMid)&#13;&#10;    world['sky'].append(skyFront)&#13;&#10;    world['sky'].append(cloudProp)&#13;&#10;&#13;&#10;    # background&#13;&#10;    print(&quot;[lobby_mode] Creating Background...&quot;)&#13;&#10;    bg = LobbyBackGround()&#13;&#10;    world['bg'].append(bg)&#13;&#10;&#13;&#10;    # 낭떠러지(투명 영역) 벽 자동 생성&#13;&#10;    try:&#13;&#10;        print(&quot;[DEBUG] wall_blocks 생성 시도 중...&quot;)&#13;&#10;        # 배경의 화면 위치와 스케일을 전달&#13;&#10;        wall_blocks = generate_walls_from_png(&#13;&#10;            'resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png',&#13;&#10;            block_size=8,&#13;&#10;            bg_x=bg.x,&#13;&#10;            bg_y=bg.y,&#13;&#10;            scale=bg.scale&#13;&#10;        )&#13;&#10;        print(f&quot;[DEBUG] wall_blocks 반환: {len(wall_blocks)}개&quot;)&#13;&#10;        for wall in wall_blocks:&#13;&#10;            world['walls'].append(wall)&#13;&#10;            pass&#13;&#10;        print(f&quot;[lobby_mode] Generated {len(wall_blocks)} walls from PNG transparency.&quot;)&#13;&#10;    except Exception as ex:&#13;&#10;        print(f&quot;\033[91m[lobby_mode] Wall generation from PNG failed: {ex}\033[0m&quot;)&#13;&#10;&#13;&#10;    # create portal to play mode&#13;&#10;    print(&quot;[lobby_mode] Creating EnterTreePortal...&quot;)&#13;&#10;    try:&#13;&#10;        # 백그라운드 이미지와 스케일에 맞춰 가로 중앙, 세로는 위에서 30% 아래에 배치&#13;&#10;        portal_x = bg.x&#13;&#10;        portal_y = bg.y + (bg.image.h * bg.scale) / 2 - (bg.image.h * bg.scale) * 0.3&#13;&#10;        enterTree = EnterTreePortal(portal_x, portal_y, scale=bg.scale)&#13;&#10;        world['upper_ground'].append(enterTree)&#13;&#10;        print(f&quot;[lobby_mode] EnterTreePortal created at ({portal_x}, {portal_y}) with scale {bg.scale}&quot;)&#13;&#10;    except Exception as ex:&#13;&#10;        print(f&quot;\033[91m[lobby_mode] Failed to create EnterTreePortal: {ex}\033[0m&quot;)&#13;&#10;&#13;&#10;    print(&quot;[lobby_mode] Creating player...&quot;)&#13;&#10;    # create player (use fallback if heavy Player init fails)&#13;&#10;    try:&#13;&#10;        player = Player()&#13;&#10;        player.x = 0  # 화면 중심(0,0)으로 위치 보정&#13;&#10;        player.y = 0  # 화면 중심(0,0)으로 위치 보정&#13;&#10;        print(&quot;[lobby_mode] Player created successfully&quot;)&#13;&#10;    except Exception as ex:&#13;&#10;        print(f&quot;\033[91m[lobby_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#13;&#10;        from .inventory import InventoryData, seed_debug_inventory&#13;&#10;&#13;&#10;        class _FallbackPlayer:&#13;&#10;            def __init__(self):&#13;&#10;                self.x = 0  # 화면 중심(0,0)으로 위치 보정&#13;&#10;                self.y = 0  # 화면 중심(0,0)으로 위치 보정&#13;&#10;                self.face_dir = 1&#13;&#10;                self.scale_factor = 1.0&#13;&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#13;&#10;                self.particles = []&#13;&#10;                self.attack_effects = []&#13;&#10;                self.inventory = InventoryData(cols=6, rows=5)&#13;&#10;                try:&#13;&#10;                    seed_debug_inventory(self.inventory)&#13;&#10;                except Exception:&#13;&#10;                    print(&quot;\033[91m[lobby_mode] seed_debug_inventory failed\033[0m&quot;)&#13;&#10;                    pass&#13;&#10;                self.inventory_open = False&#13;&#10;&#13;&#10;            def update(self):&#13;&#10;                return True&#13;&#10;&#13;&#10;            def rebuild_inventory_passives(self):&#13;&#10;                return&#13;&#10;&#13;&#10;            def consume_item_at(self, r, c):&#13;&#10;                return False&#13;&#10;&#13;&#10;        player = _FallbackPlayer()&#13;&#10;&#13;&#10;    print(&quot;[lobby_mode] Attaching world reference to player...&quot;)&#13;&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#13;&#10;    try:&#13;&#10;        player.world = world&#13;&#10;    except Exception:&#13;&#10;        print(&quot;\033[91m[lobby_mode] Failed to attach world to player\033[0m&quot;)&#13;&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#13;&#10;    world['entities'].append(player)&#13;&#10;&#13;&#10;    # Camera 초기화 (Player를 target으로 설정)&#13;&#10;    # sky와 ground 레이어의 실제 배경 범위를 계산하여 카메라 제한 범위로 사용&#13;&#10;    try:&#13;&#10;        # 배경 범위 계산 (sky와 ground 레이어의 모든 객체 고려)&#13;&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#13;&#10;&#13;&#10;        # 배경 전체 크기 계산&#13;&#10;        map_width = max_x - min_x&#13;&#10;        map_height = max_y - min_y&#13;&#10;&#13;&#10;        screen_width = p2.get_canvas_width()&#13;&#10;        screen_height = p2.get_canvas_height()&#13;&#10;&#13;&#10;        global camera&#13;&#10;        camera = Camera(player, map_width, map_height, screen_width, screen_height)&#13;&#10;&#13;&#10;        # 카메라에 실제 배경 범위의 중심점 정보 전달 (오프셋 계산용)&#13;&#10;        camera.map_offset_x = (min_x + max_x) / 2&#13;&#10;        camera.map_offset_y = (min_y + max_y) / 2&#13;&#10;&#13;&#10;        print(f&quot;[lobby_mode] Camera initialized for player at ({player.x}, {player.y})&quot;)&#13;&#10;        print(f&quot;[lobby_mode] Map size: {map_width:.1f} x {map_height:.1f}, Offset: ({camera.map_offset_x:.1f}, {camera.map_offset_y:.1f})&quot;)&#13;&#10;    except Exception as ex:&#13;&#10;        print(f&quot;\033[91m[lobby_mode] Camera initialization failed: {ex}\033[0m&quot;)&#13;&#10;&#13;&#10;    print(&quot;[lobby_mode] Creating inventory overlay...&quot;)&#13;&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#13;&#10;    try:&#13;&#10;        inv = InventoryOverlay(player, world)&#13;&#10;        print(&quot;[lobby_mode] InventoryOverlay created successfully&quot;)&#13;&#10;    except Exception as ex:&#13;&#10;        print(f&quot;\033[91m[lobby_mode] InventoryOverlay init failed, creating minimal stub: {ex}\033[0m&quot;)&#13;&#10;&#13;&#10;        class _InvStub:&#13;&#10;            def __init__(self, player, world=None):&#13;&#10;                self.player = player&#13;&#10;                self.world = world&#13;&#10;                self.dragging = False&#13;&#10;                self.drag_from = None&#13;&#10;                self.drag_icon = None&#13;&#10;                self.drag_qty = 0&#13;&#10;            def handle_event(self, e):&#13;&#10;                return&#13;&#10;            def update(self):&#13;&#10;                return&#13;&#10;            def draw(self):&#13;&#10;                return&#13;&#10;&#13;&#10;        inv = _InvStub(player, world)&#13;&#10;    world['ui'].append(inv)&#13;&#10;&#13;&#10;    print(&quot;[lobby_mode] Creating cursor...&quot;)&#13;&#10;    # cursor on top (safe fallback)&#13;&#10;    try:&#13;&#10;        cursor = Cursor(player)&#13;&#10;        print(&quot;[lobby_mode] Cursor created successfully&quot;)&#13;&#10;    except Exception as ex:&#13;&#10;        print(f&quot;\033[91m[lobby_mode] Cursor init failed, using stub cursor: {ex}\033[0m&quot;)&#13;&#10;&#13;&#10;        class _CursorStub:&#13;&#10;            def __init__(self, player=None):&#13;&#10;                self.player = player&#13;&#10;                self.x = 0&#13;&#10;                self.y = 0&#13;&#10;            def update(self):&#13;&#10;                return&#13;&#10;            def draw(self):&#13;&#10;                return&#13;&#10;            def handle_event(self, e):&#13;&#10;                return&#13;&#10;&#13;&#10;        cursor = _CursorStub(player)&#13;&#10;    world['cursor'].append(cursor)&#13;&#10;&#13;&#10;    # expose world to __main__ for legacy code that looks up main.world&#13;&#10;    try:&#13;&#10;        import sys&#13;&#10;        main_mod = sys.modules.get('__main__')&#13;&#10;        if main_mod is not None:&#13;&#10;            setattr(main_mod, 'world', world)&#13;&#10;    except Exception:&#13;&#10;        print(&quot;\033[91m[lobby_mode] Failed to expose world to __main__\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;def exit():&#13;&#10;    for k in list(world.keys()):&#13;&#10;        try:&#13;&#10;            if isinstance(world[k], list):&#13;&#10;                world[k].clear()&#13;&#10;        except Exception:&#13;&#10;            print(&quot;\033[91m[lobby_mode] Failed to clear world layer\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;def handle_events():&#13;&#10;    import game_framework as app_framework&#13;&#10;&#13;&#10;    events = p2.get_events()&#13;&#10;    player = world.get('player')&#13;&#10;    portal_triggered = False&#13;&#10;&#13;&#10;    for e in events:&#13;&#10;        if e.type == SDL_QUIT:&#13;&#10;            app_framework.quit()&#13;&#10;            return&#13;&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#13;&#10;            app_framework.quit()&#13;&#10;            return&#13;&#10;        # F키 입력 시 포탈 충돌 체크&#13;&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == p2.SDLK_f:&#13;&#10;            for obj in world['upper_ground']:&#13;&#10;                if isinstance(obj, EnterTreePortal) and player:&#13;&#10;                    if obj.check_player_collision(player):&#13;&#10;                        if not portal_triggered:&#13;&#10;                            from . import play_mode&#13;&#10;                            print('[lobby_mode] EnterTreePortal triggered: switching to play_mode')&#13;&#10;                            app_framework.change_state(play_mode)&#13;&#10;                            portal_triggered = True&#13;&#10;&#13;&#10;        # broadcast to entities -&gt; ui -&gt; cursor&#13;&#10;        for o in list(world['entities']):&#13;&#10;            try:&#13;&#10;                if hasattr(o, 'handle_event'):&#13;&#10;                    o.handle_event(e)&#13;&#10;            except Exception:&#13;&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for entity\033[0m&quot;)&#13;&#10;        for o in list(world['ui']):&#13;&#10;            try:&#13;&#10;                if hasattr(o, 'handle_event'):&#13;&#10;                    o.handle_event(e)&#13;&#10;            except Exception:&#13;&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for UI\033[0m&quot;)&#13;&#10;        for o in list(world['cursor']):&#13;&#10;            try:&#13;&#10;                if hasattr(o, 'handle_event'):&#13;&#10;                    o.handle_event(e)&#13;&#10;            except Exception:&#13;&#10;                print(&quot;\033[91m[lobby_mode] Failed to handle event for cursor\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;def update():&#13;&#10;    global camera&#13;&#10;    # 카메라 업데이트 추가&#13;&#10;    if camera is not None:&#13;&#10;        camera.update()&#13;&#10;&#13;&#10;    # 일반 게임 업데이트&#13;&#10;    for layer_name in world_list:&#13;&#10;        new_list = []&#13;&#10;        for o in list(world[layer_name]):&#13;&#10;            try:&#13;&#10;                if hasattr(o, 'update'):&#13;&#10;                    alive = o.update()&#13;&#10;                    if alive is False:&#13;&#10;                        continue&#13;&#10;            except Exception as ex:&#13;&#10;                print(f&quot;\033[91m[lobby_mode] Failed to update object : {ex}\033[0m&quot;)&#13;&#10;&#13;&#10;            # mark_for_removal 플래그 확인&#13;&#10;            if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#13;&#10;                print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#13;&#10;                continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#13;&#10;&#13;&#10;            new_list.append(o)&#13;&#10;        world[layer_name][:] = new_list&#13;&#10;&#13;&#10;    # 충돌 검사 시스템&#13;&#10;    from .projectile import Projectile&#13;&#10;    player = world.get('player')&#13;&#10;&#13;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#13;&#10;    effects_to_remove = set()&#13;&#10;    projectiles_to_remove = set()&#13;&#10;&#13;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#13;&#10;    for effect in world['effects_front']:&#13;&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#13;&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#13;&#10;            for entity in world['entities']:&#13;&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#13;&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#13;&#10;                    if entity.check_collision_with_effect(effect):&#13;&#10;                        # 디버그: 충돌 정보 출력&#13;&#10;                        attacker_name = &quot;Player&quot;&#13;&#10;                        if hasattr(effect, 'owner'):&#13;&#10;                            attacker_name = effect.owner.__class__.__name__&#13;&#10;                        target_name = entity.__class__.__name__&#13;&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#13;&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#13;&#10;                        pass&#13;&#10;&#13;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#13;&#10;    if player:&#13;&#10;        for projectile in world['effects_front']:&#13;&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#13;&#10;            if isinstance(projectile, Projectile):&#13;&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#13;&#10;                if not projectile.from_player:&#13;&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#13;&#10;                        if player.check_collision_with_projectile(projectile):&#13;&#10;                            # 디버그: 충돌 정보 출력&#13;&#10;                            attacker_name = &quot;Unknown&quot;&#13;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#13;&#10;                                attacker_name = projectile.owner.__class__.__name__&#13;&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#13;&#10;                            projectiles_to_remove.add(projectile)&#13;&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#13;&#10;                else:&#13;&#10;                    for entity in world['entities']:&#13;&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#13;&#10;                            if entity.check_collision_with_projectile(projectile):&#13;&#10;                                # 디버그: 충돌 정보 출력&#13;&#10;                                target_name = entity.__class__.__name__&#13;&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#13;&#10;                                projectiles_to_remove.add(projectile)&#13;&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#13;&#10;&#13;&#10;    # 충돌한 투사체 제거&#13;&#10;    if projectiles_to_remove:&#13;&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#13;&#10;&#13;&#10;    # 포탈 위에 텍스트 표시&#13;&#10;    for obj in world['upper_ground']:&#13;&#10;        if isinstance(obj, EnterTreePortal) and player:&#13;&#10;            if obj.check_player_collision(player):&#13;&#10;                obj.trigger = True&#13;&#10;            else:&#13;&#10;                obj.trigger = False&#13;&#10;&#13;&#10;def draw():&#13;&#10;    global camera&#13;&#10;    p2.clear_canvas()&#13;&#10;&#13;&#10;    from .equipment import ShieldRangeEffect&#13;&#10;&#13;&#10;    # 하늘을 가장 먼저 그리기 (배경 뒤)&#13;&#10;    for obj in world['sky']:&#13;&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y'):&#13;&#10;            if camera is not None:&#13;&#10;                draw_x, draw_y = camera.apply(obj.x, obj.y)&#13;&#10;            else:&#13;&#10;                draw_x, draw_y = obj.x, obj.y&#13;&#10;            if hasattr(obj, 'draw'):&#13;&#10;                obj.draw(draw_x, draw_y)&#13;&#10;        else:&#13;&#10;            if hasattr(obj, 'draw'):&#13;&#10;                obj.draw()&#13;&#10;&#13;&#10;    # 나머지 레이어들 (배경, 벽, 엔티티 등)&#13;&#10;    for layer in ['ground', 'walls', 'upper_ground', 'entities', 'effects_back', 'effects_front', 'extra_bg', 'extras']:&#13;&#10;        for obj in world[layer]:&#13;&#10;            # ShieldRangeEffect는 특별 처리 (플레이어 위치 기준)&#13;&#10;            if isinstance(obj, ShieldRangeEffect):&#13;&#10;                if hasattr(obj, 'player') and obj.player:&#13;&#10;                    if camera is not None:&#13;&#10;                        draw_x, draw_y = camera.apply(obj.player.x, obj.player.y)&#13;&#10;                    else:&#13;&#10;                        draw_x, draw_y = obj.player.x, obj.player.y&#13;&#10;                    if hasattr(obj, 'draw'):&#13;&#10;                        obj.draw(draw_x, draw_y)&#13;&#10;            elif hasattr(obj, 'x') and hasattr(obj, 'y'):&#13;&#10;                if camera is not None:&#13;&#10;                    draw_x, draw_y = camera.apply(obj.x, obj.y)&#13;&#10;                else:&#13;&#10;                    draw_x, draw_y = obj.x, obj.y&#13;&#10;                if hasattr(obj, 'draw'):&#13;&#10;                    obj.draw(draw_x, draw_y)&#13;&#10;            else:&#13;&#10;                if hasattr(obj, 'draw'):&#13;&#10;                    obj.draw()&#13;&#10;    # UI, cursor 등은 카메라 적용하지 않음&#13;&#10;    for obj in world['ui']:&#13;&#10;        if hasattr(obj, 'draw'):&#13;&#10;            obj.draw()&#13;&#10;    for obj in world['cursor']:&#13;&#10;        if hasattr(obj, 'draw'):&#13;&#10;            obj.draw()&#13;&#10;    p2.update_canvas()&#13;&#10;&#13;&#10;class LobbySky:&#13;&#10;    def __init__(self, path, x=0, y=0, scale=3):&#13;&#10;        self.image = p2.load_image(path)&#13;&#10;        self.scale = scale&#13;&#10;        self.x = x  # 화면 중심(0,0) 기준&#13;&#10;        self.y = y  # 화면 중심(0,0) 기준&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        pass&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        self.image.draw(draw_x, draw_y, self.image.w * self.scale * 2,&#13;&#10;                        self.image.h * self.scale * 1.5)&#13;&#10;        # 디버그용 히트박스 (필요시 주석 처리)&#13;&#10;        # p2.draw_rectangle(draw_x - (self.image.w * self.scale) / 2,&#13;&#10;        #                   draw_y - (self.image.h * self.scale) / 2,&#13;&#10;        #                   draw_x + (self.image.w * self.scale) / 2,&#13;&#10;        #                   draw_y + (self.image.h * self.scale) / 2)&#13;&#10;&#13;&#10;&#13;&#10;class LobbyBackGround:&#13;&#10;    image = None&#13;&#10;    def __init__(self):&#13;&#10;        if LobbyBackGround.image is None:&#13;&#10;            LobbyBackGround.image = p2.load_image('resources/Texture_organize/Map/Dream_Tree/BackGround/DreamWorld0.png')&#13;&#10;        self.scale = 6.5&#13;&#10;        self.x = 0  # 화면 중심(0,0)으로 위치 보정&#13;&#10;        self.y = 0  # 화면 중심(0,0)으로 위치 보정&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        pass&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        LobbyBackGround.image.draw(draw_x, draw_y, LobbyBackGround.image.w * self.scale, LobbyBackGround.image.h * self.scale)&#13;&#10;        # p2.draw_rectangle(draw_x - (LobbyBackGround.image.w * self.scale) / 2,&#13;&#10;        #                   draw_y - (LobbyBackGround.image.h * self.scale) / 2,&#13;&#10;        #                   draw_x + (LobbyBackGround.image.w * self.scale) / 2,&#13;&#10;        #                   draw_y + (LobbyBackGround.image.h * self.scale) / 2)&#13;&#10;&#13;&#10;class EnterTreePortal:&#13;&#10;    # frame lists (class-level so images are loaded only once)&#13;&#10;    portalImagesBegin = []&#13;&#10;    portalImagesCycle = []&#13;&#10;    portalFXBegin = []&#13;&#10;    portalFXCycle = []&#13;&#10;    loaded = False&#13;&#10;&#13;&#10;    def __init__(self, x, y, scale=3.0):&#13;&#10;        # load images once (safe: catch missing files)&#13;&#10;        if not EnterTreePortal.loaded:&#13;&#10;            try:&#13;&#10;                for i in range(18):&#13;&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Begin{i:02d}.png'&#13;&#10;                    EnterTreePortal.portalImagesBegin.append(p2.load_image(path))&#13;&#10;            except Exception:&#13;&#10;                EnterTreePortal.portalImagesBegin = []&#13;&#10;            try:&#13;&#10;                # cycle uses a single image in original assets, but keep as list for consistency&#13;&#10;                EnterTreePortal.portalImagesCycle.append(p2.load_image('resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoor_Cycle00.png'))&#13;&#10;            except Exception:&#13;&#10;                EnterTreePortal.portalImagesCycle = []&#13;&#10;            try:&#13;&#10;                for i in range(18):&#13;&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Begin{i:02d}.png'&#13;&#10;                    EnterTreePortal.portalFXBegin.append(p2.load_image(path))&#13;&#10;            except Exception:&#13;&#10;                EnterTreePortal.portalFXBegin = []&#13;&#10;            try:&#13;&#10;                for i in range(11):&#13;&#10;                    path = f'resources/Texture_organize/Map/Dream_Tree/Dream_Door/DreamDoorFX_Cycle{i:02d}.png'&#13;&#10;                    EnterTreePortal.portalFXCycle.append(p2.load_image(path))&#13;&#10;            except Exception:&#13;&#10;                EnterTreePortal.portalFXCycle = []&#13;&#10;            EnterTreePortal.loaded = True&#13;&#10;&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;        # self.trigger_radius = 50  # 플레이어가 접근해야 하는 반경&#13;&#10;        self.trigger = False&#13;&#10;&#13;&#10;        # animation state&#13;&#10;        self.begin_animation_done = False&#13;&#10;        self.frame_idx = 0&#13;&#10;        self.fx_idx = 0&#13;&#10;        self.frame_dt = 0.0&#13;&#10;        self.fx_dt = 0.0&#13;&#10;        self.frame_duration = 0.06  # seconds per frame&#13;&#10;        self.fx_duration = 0.06&#13;&#10;        self.last_time = p2.get_time()&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        # advance animation based on time delta&#13;&#10;        now = p2.get_time()&#13;&#10;        dt = now - getattr(self, 'last_time', now)&#13;&#10;        self.last_time = now&#13;&#10;        # update portal image animation&#13;&#10;        self.frame_dt += dt&#13;&#10;        if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#13;&#10;            # play begin sequence once&#13;&#10;            if self.frame_dt &gt;= self.frame_duration:&#13;&#10;                steps = int(self.frame_dt / self.frame_duration)&#13;&#10;                self.frame_dt -= steps * self.frame_duration&#13;&#10;                self.frame_idx += steps&#13;&#10;                if self.frame_idx &gt;= len(EnterTreePortal.portalImagesBegin):&#13;&#10;                    # start cycle&#13;&#10;                    self.begin_animation_done = True&#13;&#10;                    self.frame_idx = 0&#13;&#10;        else:&#13;&#10;            # loop cycle frames&#13;&#10;            if EnterTreePortal.portalImagesCycle:&#13;&#10;                if self.frame_dt &gt;= self.frame_duration:&#13;&#10;                    steps = int(self.frame_dt / self.frame_duration)&#13;&#10;                    self.frame_dt -= steps * self.frame_duration&#13;&#10;                    self.frame_idx = (self.frame_idx + steps) % max(1, len(EnterTreePortal.portalImagesCycle))&#13;&#10;&#13;&#10;        # update FX animation: try to play begin and then cycle&#13;&#10;        self.fx_dt += dt&#13;&#10;        if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#13;&#10;            if self.fx_dt &gt;= self.fx_duration:&#13;&#10;                steps = int(self.fx_dt / self.fx_duration)&#13;&#10;                self.fx_dt -= steps * self.fx_duration&#13;&#10;                self.fx_idx += steps&#13;&#10;                # clamp fx_idx so it doesn't grow unbounded; allow it to loop during begin&#13;&#10;                if self.fx_idx &gt;= len(EnterTreePortal.portalFXBegin):&#13;&#10;                    self.fx_idx = 0&#13;&#10;        else:&#13;&#10;            if EnterTreePortal.portalFXCycle:&#13;&#10;                if self.fx_dt &gt;= self.fx_duration:&#13;&#10;                    steps = int(self.fx_dt / self.fx_duration)&#13;&#10;                    self.fx_dt -= steps * self.fx_duration&#13;&#10;                    self.fx_idx = (self.fx_idx + steps) % max(1, len(EnterTreePortal.portalFXCycle))&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        # draw portal image (begin or cycle)&#13;&#10;        try:&#13;&#10;            if not self.begin_animation_done and EnterTreePortal.portalImagesBegin:&#13;&#10;                img = EnterTreePortal.portalImagesBegin[min(self.frame_idx, len(EnterTreePortal.portalImagesBegin)-1)]&#13;&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#13;&#10;            elif EnterTreePortal.portalImagesCycle:&#13;&#10;                img = EnterTreePortal.portalImagesCycle[self.frame_idx % len(EnterTreePortal.portalImagesCycle)]&#13;&#10;                img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#13;&#10;        except Exception:&#13;&#10;            # drawing failure should not crash the game&#13;&#10;            pass&#13;&#10;&#13;&#10;        # draw FX overlay&#13;&#10;        try:&#13;&#10;            if not self.begin_animation_done and EnterTreePortal.portalFXBegin:&#13;&#10;                fx = EnterTreePortal.portalFXBegin[self.fx_idx % len(EnterTreePortal.portalFXBegin)]&#13;&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#13;&#10;            elif EnterTreePortal.portalFXCycle:&#13;&#10;                fx = EnterTreePortal.portalFXCycle[self.fx_idx % len(EnterTreePortal.portalFXCycle)]&#13;&#10;                fx.draw(draw_x, draw_y, fx.w * self.scale, fx.h * self.scale)&#13;&#10;        except Exception:&#13;&#10;            pass&#13;&#10;&#13;&#10;        # 포탈 위에 텍스트 그리기&#13;&#10;        if self.trigger:&#13;&#10;            try:&#13;&#10;                # print(f'[lobby_mode] Drawing portal text at ({draw_x}, {draw_y})')&#13;&#10;                font = p2.load_font('resources/Fonts/pixelroborobo.otf', 20)&#13;&#10;                text = &quot;[F] 모험하기&quot;&#13;&#10;                font_size = 40&#13;&#10;                approx_width = int(len(text) * font_size * 0.4)&#13;&#10;                font.draw(draw_x - approx_width // 2, draw_y + 10 * self.scale, text, (255, 255, 0))&#13;&#10;            except Exception as ex:&#13;&#10;                print(f'[lobby_mode] 포탈 텍스트 그리기 실패: {ex}')&#13;&#10;&#13;&#10;    def check_player_collision(self, player):&#13;&#10;        # 플레이어와 포탈의 히트박스 충돌 검사&#13;&#10;        # 플레이어의 크기(w, h)는 기본값 32x32로 가정, 필요시 Player에서 가져올 것&#13;&#10;        px = getattr(player, 'x', 0)&#13;&#10;        py = getattr(player, 'y', 0)&#13;&#10;        pw = getattr(player, 'w', 32)&#13;&#10;        ph = getattr(player, 'h', 32)&#13;&#10;        # 포탈의 히트박스는 중심 기준, 크기는 이미지 크기 * scale * 0.5 (적당히 조정)&#13;&#10;        portal_w = 61 * self.scale&#13;&#10;        portal_h = 47 * self.scale&#13;&#10;        portal_x = self.x - portal_w / 2&#13;&#10;        portal_y = self.y - portal_h / 2&#13;&#10;        return (px &lt; portal_x + portal_w and px + pw &gt; portal_x and&#13;&#10;                py &lt; portal_y + portal_h and py + ph &gt; portal_y)&#13;&#10;&#13;&#10;class LobbyWall:&#13;&#10;    def __init__(self, x, y, w, h):&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.w = w&#13;&#10;        self.h = h&#13;&#10;&#13;&#10;&#13;&#10;    def check_collision(self, px, py, pw, ph):&#13;&#10;        # 플레이어와 벽의 사각형 충돌 검사&#13;&#10;        return (self.x &lt; px + pw and self.x + self.w &gt; px and&#13;&#10;                self.y &lt; py + ph and self.y + self.h &gt; py)&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        # 카메라 적용 좌표로 벽 영역을 빨간색으로 표시&#13;&#10;        try:&#13;&#10;            # p2.draw_rectangle(draw_x, draw_y, draw_x + self.w, draw_y + self.h)&#13;&#10;            pass&#13;&#10;        except Exception as ex:&#13;&#10;            print(f'[LobbyWall] draw() 실패 at ({draw_x}, {draw_y}, {self.w}, {self.h}), Exception {ex}')&#13;&#10;&#13;&#10;def generate_walls_from_png(png_path, block_size=16, bg_x=None, bg_y=None, scale=1.0):&#13;&#10;    print(f&quot;[DEBUG] generate_walls_from_png 시작: {png_path}, block_size={block_size}, bg_x={bg_x}, bg_y={bg_y}, scale={scale}&quot;)&#13;&#10;    try:&#13;&#10;        img = Image.open(png_path).convert('RGBA')&#13;&#10;    except Exception as ex:&#13;&#10;        print(f&quot;[DEBUG] 이미지 열기 실패: {ex}&quot;)&#13;&#10;        return []&#13;&#10;    width, height = img.size&#13;&#10;    walls = []&#13;&#10;    pixels = img.load()&#13;&#10;    transparent_count = 0&#13;&#10;    # 배경 이미지의 화면 내 좌표계 기준 좌표 계산&#13;&#10;    if bg_x is None: bg_x = width * scale / 2&#13;&#10;    if bg_y is None: bg_y = height * scale / 2&#13;&#10;    screen_left = bg_x - (width * scale) / 2&#13;&#10;    screen_top = bg_y + (height * scale) / 2&#13;&#10;    for y in range(0, height, block_size):&#13;&#10;        for x in range(0, width, block_size):&#13;&#10;            is_transparent = False&#13;&#10;            for dy in range(block_size):&#13;&#10;                for dx in range(block_size):&#13;&#10;                    if x+dx &lt; width and y+dy &lt; height:&#13;&#10;                        _, _, _, alpha = pixels[x+dx, y+dy]&#13;&#10;                        if alpha == 0:&#13;&#10;                            is_transparent = True&#13;&#10;                            transparent_count += 1&#13;&#10;                            break&#13;&#10;                if is_transparent:&#13;&#10;                    break&#13;&#10;            if is_transparent:&#13;&#10;                # 이미지 좌표를 화면 좌표로 변환 (좌상단 기준)&#13;&#10;                wall_x_img = x&#13;&#10;                wall_y_img = height - y - block_size&#13;&#10;                wall_x_screen = screen_left + wall_x_img * scale&#13;&#10;                wall_y_screen = bg_y - (height * scale) / 2 + wall_y_img * scale&#13;&#10;                walls.append(LobbyWall(wall_x_screen, wall_y_screen, block_size * scale, block_size * scale))&#13;&#10;    print(f&quot;[DEBUG] 투명 픽셀 수: {transparent_count}, 생성된 벽 수: {len(walls)}&quot;)&#13;&#10;    return walls" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/monsters/cat_assassin.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/monsters/cat_assassin.py" />
              <option name="originalContent" value="import pico2d as p2&#10;import random&#10;import math&#10;&#10;import game_framework as framework&#10;from ..state_machine import StateMachine&#10;from ..projectile import Projectile&#10;from ..stats import CatAssassinStats&#10;from ..damage_indicator import DamageIndicator&#10;from ..ui_overlay import MonsterHealthBar&#10;&#10;# ========== Idle State ==========&#10;class Idle:&#10;    images = None&#10;&#10;    def __init__(self, cat):&#10;        self.cat = cat&#10;        self.detection_range = 300  # 플레이어 감지 범위 (픽셀)&#10;&#10;        if Idle.images is None:&#10;            Idle.images = []&#10;            try:&#10;                for i in range(6):  # Cat_Assassin_Idle0 ~ Idle5&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/character/Cat_Assassin_Idle{i}.png')&#10;                    Idle.images.append(img)&#10;                print(f&quot;[CatAssassin Idle] Loaded {len(Idle.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[CatAssassin Idle] Failed to load images: {e}\033[0m&quot;)&#10;                Idle.images = []&#10;&#10;        self.cat.frame = 0&#10;        self.cat.animation_speed = 10  # frames per second&#10;        self.cat.animation_time = 0&#10;&#10;    def enter(self, e):&#10;        self.cat.frame = 0&#10;        self.cat.animation_time = 0&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        # Update animation&#10;        self.cat.animation_time += framework.get_delta_time()&#10;        if self.cat.animation_time &gt;= 1.0 / self.cat.animation_speed:&#10;            self.cat.frame = (self.cat.frame + 1) % len(Idle.images)&#10;            self.cat.animation_time = 0&#10;&#10;        # AI: Check if player is nearby and chase&#10;        if self.cat.world and 'player' in self.cat.world:&#10;            player = self.cat.world['player']&#10;            dx = player.x - self.cat.x&#10;            dy = player.y - self.cat.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            # 감지 범위 내에 플레이어가 있으면 Chase 상태로 전환&#10;            if distance &lt;= self.detection_range:&#10;                self.cat.state_machine.handle_state_event(('DETECT_PLAYER', player))&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Idle.images and len(Idle.images) &gt; 0:&#10;            Idle.images[self.cat.frame].draw(draw_x, draw_y,&#10;                                             Idle.images[self.cat.frame].w * self.cat.scale,&#10;                                             Idle.images[self.cat.frame].h * self.cat.scale)&#10;&#10;# ========== Chase State (상위 상태) ==========&#10;class Chase:&#10;    &quot;&quot;&quot;플레이어를 추적하는 상태 - Run, Kiting, Attack 하위 상태를 가짐&quot;&quot;&quot;&#10;&#10;    def __init__(self, cat):&#10;        self.cat = cat&#10;        self.lose_range = 600  # 플레이어를 놓치는 거리&#10;        self.attack_range = 300  # 공격 범위&#10;        self.attack_range_exit = 350  # 공격 범위를 벗어나는 거리 (여유를 둠)&#10;        self.kiting_min_range = 250  # 너무 가까우면 후퇴할 거리&#10;&#10;        # 공격 쿨타임 관련&#10;        self.attack_cooldown = 2.0  # 공격 후 2초 대기&#10;        self.attack_cooldown_timer = 0.0  # 쿨타임 타이머&#10;        self.can_attack = False  # 공격 가능 여부 - 처음에는 False로 시작&#10;&#10;        # 하위 상태 머신 생성&#10;        self.RUN = Run(cat)&#10;        self.KITING = Kiting(cat, self)  # 새로운 Kiting 상태 추가&#10;        self.ATTACK = Attack(cat, self)  # Chase 상태 참조 전달&#10;&#10;        self.sub_state_machine = StateMachine(&#10;            self.RUN,&#10;            {&#10;                self.RUN: {in_attack_range: self.KITING},&#10;                self.KITING: {out_attack_range: self.RUN, ready_to_attack: self.ATTACK},&#10;                self.ATTACK: {attack_end: self.KITING},&#10;            }&#10;        )&#10;&#10;    def enter(self, e):&#10;        print(&quot;[Chase State] 추적 시작&quot;)&#10;        # 추적 시작 시 쿨타임 초기화&#10;        self.can_attack = False&#10;        self.attack_cooldown_timer = 0.0&#10;        # 하위 상태 머신을 Run 상태로 초기화 (이미 __init__에서 초기화됨)&#10;        # sub_state_machine의 cur_state는 이미 RUN으로 설정되어 있음&#10;        self.sub_state_machine.cur_state.enter(e)&#10;&#10;    def exit(self, e):&#10;        print(&quot;[Chase State] 추적 종료&quot;)&#10;        self.sub_state_machine.cur_state.exit(e)&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 공격 쿨타임 업데이트&#10;        if not self.can_attack:&#10;            self.attack_cooldown_timer += dt&#10;            if self.attack_cooldown_timer &gt;= self.attack_cooldown:&#10;                self.can_attack = True&#10;                self.attack_cooldown_timer = 0.0&#10;                print(&quot;[Chase State] 공격 쿨타임 완료 - 공격 가능&quot;)&#10;&#10;        # 플레이어와의 거리 체크&#10;        if self.cat.world and 'player' in self.cat.world:&#10;            player = self.cat.world['player']&#10;            dx = player.x - self.cat.x&#10;            dy = player.y - self.cat.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            # 플레이어를 놓쳤으면 Idle로 복귀&#10;            if distance &gt; self.lose_range:&#10;                self.cat.state_machine.handle_state_event(('LOSE_PLAYER', None))&#10;                return&#10;&#10;            # 현재 하위 상태 확인&#10;            current_sub_state = self.sub_state_machine.cur_state&#10;            current_state_name = current_sub_state.__class__.__name__&#10;&#10;            # 거리에 따른 상태 전환 (Hysteresis 적용)&#10;            if isinstance(current_sub_state, Run):&#10;                # Run 상태: attack_range 이하면 Kiting으로&#10;                if distance &lt;= self.attack_range:&#10;                    print(f&quot;[Chase State] 거리 {distance:.1f} - Kiting 상태로 전환&quot;)&#10;                    self.sub_state_machine.handle_state_event(('IN_ATTACK_RANGE', player))&#10;&#10;            elif isinstance(current_sub_state, Kiting):&#10;                # Kiting 상태: attack_range_exit 초과하면 Run으로, can_attack이면 Attack으로&#10;                if distance &gt; self.attack_range_exit:&#10;                    print(f&quot;[Chase State] 거리 {distance:.1f} &gt; {self.attack_range_exit} - Run 상태로 전환&quot;)&#10;                    self.sub_state_machine.handle_state_event(('OUT_ATTACK_RANGE', player))&#10;                elif self.can_attack:&#10;                    # 쿨타임 끝나고 공격 가능 - Attack 상태로&#10;                    print(f&quot;[Chase State] 거리 {distance:.1f} - 공격 준비! (can_attack: {self.can_attack})&quot;)&#10;                    self.sub_state_machine.handle_state_event(('READY_TO_ATTACK', player))&#10;                    # 공격 쿨타임 시작 (Attack 상태 진입 시점에 쿨타임 시작)&#10;                    self.can_attack = False&#10;                    print(f&quot;[Chase State] 공격 쿨타임 시작 - 다음 공격까지 {self.attack_cooldown}초&quot;)&#10;&#10;            elif isinstance(current_sub_state, Attack):&#10;                # Attack 상태는 애니메이션이 끝나면 자동으로 Kiting으로 복귀&#10;                pass&#10;&#10;        # 하위 상태 머신 업데이트&#10;        self.sub_state_machine.update()&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 하위 상태 머신의 draw 호출&#10;        self.sub_state_machine.draw(draw_x, draw_y)&#10;&#10;# ========== Run State (Chase의 하위 상태) ==========&#10;class Run:&#10;    images = None&#10;&#10;    def __init__(self, cat):&#10;        self.cat = cat&#10;&#10;        if Run.images is None:&#10;            Run.images = []&#10;            try:&#10;                for i in range(8):  # Cat_Assassin_Move0 ~ Move8&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/character/Cat_Assassin_Move{i}.png')&#10;                    Run.images.append(img)&#10;                print(f&quot;[CatAssassin Run] Loaded {len(Run.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[CatAssassin Run] Failed to load images: {e}\033[0m&quot;)&#10;                Run.images = []&#10;&#10;        # 랜덤 움직임 관련 변수&#10;        self.wander_angle = 0  # 현재 방향에서 벗어나는 각도&#10;        self.wander_change_timer = 0  # 방향 변경 타이머&#10;        self.wander_change_interval = 0.3  # 방향 변경 주기 (초)&#10;        self.wander_strength = 0.6  # 랜덤 움직임의 강도 (0~1)&#10;&#10;    def enter(self, e):&#10;        self.cat.frame = 0&#10;        self.cat.animation_time = 0&#10;        self.cat.animation_speed = 12&#10;        self.wander_angle = random.uniform(-math.pi/4, math.pi/4)  # -45도 ~ 45도&#10;        self.wander_change_timer = 0&#10;        print(&quot;[Run State] 달리기 시작&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 애니메이션 업데이트&#10;        self.cat.animation_time += dt&#10;        if self.cat.animation_time &gt;= 1.0 / self.cat.animation_speed:&#10;            if len(Run.images) &gt; 0:&#10;                self.cat.frame = (self.cat.frame + 1) % len(Run.images)&#10;            self.cat.animation_time = 0&#10;&#10;        # 플레이어 추적 with 랜덤 움직임&#10;        if self.cat.world and 'player' in self.cat.world:&#10;            player = self.cat.world['player']&#10;            dx = player.x - self.cat.x&#10;            dy = player.y - self.cat.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            # 방향 계산 (정규화)&#10;            if distance &gt; 0:&#10;                # 플레이어 방향으로의 기본 방향&#10;                base_dx = dx / distance&#10;                base_dy = dy / distance&#10;&#10;                # 랜덤 방향 변경 타이머 업데이트&#10;                self.wander_change_timer += dt&#10;                if self.wander_change_timer &gt;= self.wander_change_interval:&#10;                    # 랜덤 각도 변경 (-60도 ~ 60도)&#10;                    self.wander_angle = random.uniform(-math.pi/3, math.pi/3)&#10;                    self.wander_change_timer = 0&#10;&#10;                # 기본 방향의 각도 계산&#10;                base_angle = math.atan2(base_dy, base_dx)&#10;&#10;                # 랜덤 각도를 적용한 최종 각도&#10;                final_angle = base_angle + (self.wander_angle * self.wander_strength)&#10;&#10;                # 최종 이동 방향 벡터&#10;                move_dx = math.cos(final_angle)&#10;                move_dy = math.sin(final_angle)&#10;&#10;                # 새 위치 계산 (이동 전에 벽 충돌 체크용)&#10;                new_x = self.cat.x + move_dx * self.cat.speed * dt&#10;                new_y = self.cat.y + move_dy * self.cat.speed * dt&#10;&#10;                # 벽 충돌 체크 (몬스터 크기: 32x48 픽셀로 가정)&#10;                monster_width = 32&#10;                monster_height = 48&#10;                collided = False&#10;&#10;                # world의 walls 레이어에서 벽과 충돌 체크&#10;                if 'walls' in self.cat.world:&#10;                    for wall in self.cat.world['walls']:&#10;                        if hasattr(wall, 'check_collision'):&#10;                            # 몬스터의 바운딩 박스로 충돌 검사&#10;                            if wall.check_collision(&#10;                                new_x - monster_width // 2,&#10;                                new_y - monster_height // 2,&#10;                                monster_width,&#10;                                monster_height&#10;                            ):&#10;                                collided = True&#10;                                break&#10;&#10;                # 벽과 충돌하지 않았을 때만 위치 업데이트&#10;                if not collided:&#10;                    self.cat.x = new_x&#10;                    self.cat.y = new_y&#10;                # 충돌했을 때는 이동하지 않음 (벽에 막힘)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Run.images and len(Run.images) &gt; 0:&#10;            Run.images[self.cat.frame].draw(draw_x, draw_y,&#10;                                            Run.images[self.cat.frame].w * self.cat.scale,&#10;                                            Run.images[self.cat.frame].h * self.cat.scale)&#10;&#10;# ========== Kiting State (Chase의 하위 상태) ==========&#10;class Kiting:&#10;    &quot;&quot;&quot;공격 사거리 내에서 거리를 유지하며 조금씩 움직이는 상태&quot;&quot;&quot;&#10;&#10;    def __init__(self, cat, chase_state = None):&#10;        self.cat = cat&#10;        self.chase_state = chase_state  # Chase 상태에 대한 참조&#10;&#10;        # Run 이미지 사용 (Kiting은 빠르게 움직이므로)&#10;        # Run 클래스의 이미지를 공유&#10;&#10;        # 측면 이동 관련 변수&#10;        self.strafe_direction = random.choice([-1, 1])  # -1: 왼쪽, 1: 오른쪽&#10;        self.strafe_change_timer = 0&#10;        self.strafe_change_interval = 1.5  # 1.5초마다 방향 변경&#10;        self.strafe_speed_multiplier = 1.0  # 원래 속도의 1.0배&#10;&#10;    def enter(self, e):&#10;        self.cat.frame = 0&#10;        self.cat.animation_time = 0&#10;        self.cat.animation_speed = 12  # Run과 같은 빠른 애니메이션&#10;        self.strafe_direction = random.choice([-1, 1])&#10;        self.strafe_change_timer = 0&#10;        print(&quot;[Kiting State] 거리 유지하며 움직이기 시작&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 애니메이션 업데이트 (Run 이미지 사용)&#10;        self.cat.animation_time += dt&#10;        if self.cat.animation_time &gt;= 1.0 / self.cat.animation_speed:&#10;            if Run.images and len(Run.images) &gt; 0:&#10;                self.cat.frame = (self.cat.frame + 1) % len(Run.images)&#10;            self.cat.animation_time = 0&#10;&#10;        # 측면 이동 방향 변경 타이머&#10;        self.strafe_change_timer += dt&#10;        if self.strafe_change_timer &gt;= self.strafe_change_interval:&#10;            self.strafe_direction = random.choice([-1, 1])&#10;            self.strafe_change_timer = 0&#10;            print(f&quot;[Kiting State] 이동 방향 변경: {'왼쪽' if self.strafe_direction == -1 else '오른쪽'}&quot;)&#10;&#10;        # 플레이어와의 거리 체크 및 이동&#10;        if self.cat.world and 'player' in self.cat.world:&#10;            player = self.cat.world['player']&#10;            dx = player.x - self.cat.x&#10;            dy = player.y - self.cat.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            if distance &gt; 0:&#10;                # 플레이어 방향으로의 단위 벡터&#10;                to_player_x = dx / distance&#10;                to_player_y = dy / distance&#10;&#10;                # 기본 이동 속도 (1.0배)&#10;                base_speed = self.cat.speed * self.strafe_speed_multiplier&#10;&#10;                # 이동 벡터 계산&#10;                move_x = 0&#10;                move_y = 0&#10;&#10;                # 너무 가까우면 후퇴&#10;                if distance &lt; self.chase_state.kiting_min_range:&#10;                    # 후퇴 (플레이어 반대 방향으로) - 빠르게&#10;                    flee_dx = -to_player_x&#10;                    flee_dy = -to_player_y&#10;                    move_x = flee_dx * base_speed * dt&#10;                    move_y = flee_dy * base_speed * dt&#10;&#10;                elif distance &gt; self.chase_state.attack_range:&#10;                    # 너무 멀면 조금 다가가기 (적당한 속도로)&#10;                    move_x = to_player_x * base_speed * 0.5 * dt&#10;                    move_y = to_player_y * base_speed * 0.5 * dt&#10;&#10;                else:&#10;                    # 적정 거리 - 측면으로 이동 (strafing)&#10;                    # 플레이어를 향한 벡터에 수직인 벡터로 이동&#10;                    perpendicular_x = -to_player_y * self.strafe_direction&#10;                    perpendicular_y = to_player_x * self.strafe_direction&#10;&#10;                    move_x = perpendicular_x * base_speed * dt&#10;                    move_y = perpendicular_y * base_speed * dt&#10;&#10;                # 새 위치 계산 (벽 충돌 체크용)&#10;                new_x = self.cat.x + move_x&#10;                new_y = self.cat.y + move_y&#10;&#10;                # 벽 충돌 체크 (몬스터 크기: 32x48 픽셀로 가정)&#10;                monster_width = 32&#10;                monster_height = 48&#10;                collided = False&#10;&#10;                # world의 walls 레이어에서 벽과 충돌 체크&#10;                if 'walls' in self.cat.world:&#10;                    for wall in self.cat.world['walls']:&#10;                        if hasattr(wall, 'check_collision'):&#10;                            # 몬스터의 바운딩 박스로 충돌 검사&#10;                            if wall.check_collision(&#10;                                new_x - monster_width // 2,&#10;                                new_y - monster_height // 2,&#10;                                monster_width,&#10;                                monster_height&#10;                            ):&#10;                                collided = True&#10;                                break&#10;&#10;                # 벽과 충돌하지 않았을 때만 위치 업데이트&#10;                if not collided:&#10;                    self.cat.x = new_x&#10;                    self.cat.y = new_y&#10;                # 충돌했을 때는 이동하지 않음 (벽에 막힘)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # Run 이미지 사용&#10;        if Run.images and len(Run.images) &gt; 0:&#10;            Run.images[self.cat.frame].draw(draw_x, draw_y,&#10;                                            Run.images[self.cat.frame].w * self.cat.scale,&#10;                                            Run.images[self.cat.frame].h * self.cat.scale)&#10;&#10;# ========== Attack State (Chase의 하위 상태) ==========&#10;class Attack:&#10;    images = None&#10;&#10;    def __init__(self, cat, chase_state = None):&#10;        self.cat = cat&#10;        self.chase_state = chase_state  # Chase 상태에 대한 참조 (optional)&#10;&#10;        if Attack.images is None:&#10;            Attack.images = []&#10;            try:&#10;                for i in range(7):  # Cat_Assassin_Attack0 ~ Attack6&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/character/Cat_Assassin_Attack{i}.png')&#10;                    Attack.images.append(img)&#10;                print(f&quot;[CatAssassin Attack] Loaded {len(Attack.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[CatAssassin Attack] Failed to load images: {e}\033[0m&quot;)&#10;                Attack.images = []&#10;&#10;        self.animation_finished = False&#10;        self.projectile_spawned = False&#10;&#10;    def enter(self, e):&#10;        self.cat.frame = 0&#10;        self.cat.animation_time = 0&#10;        self.cat.animation_speed = 10  # 공격 애니메이션은 빠르게&#10;        self.animation_finished = False&#10;        self.projectile_spawned = False&#10;        print(&quot;[Attack State] 공격 시작&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 애니메이션 업데이트&#10;        self.cat.animation_time += dt&#10;        if self.cat.animation_time &gt;= 1.0 / self.cat.animation_speed:&#10;            self.cat.frame += 1&#10;            self.cat.animation_time = 0&#10;&#10;            # 공격 프레임 중간쯤에 수리검 발사 (프레임 3에서 발사)&#10;            if self.cat.frame == 3 and not self.projectile_spawned:&#10;                self.projectile_spawned = True&#10;                if self.cat.world and 'player' in self.cat.world:&#10;                    player = self.cat.world['player']&#10;                    self.cat.attack(player)&#10;&#10;            # 애니메이션이 끝나면 Run으로 복귀&#10;            if len(Attack.images) &gt; 0 and self.cat.frame &gt;= len(Attack.images):&#10;                if not self.animation_finished:&#10;                    self.animation_finished = True&#10;                    print(&quot;[Attack State] 공격 애니메이션 완료&quot;)&#10;                    # Chase 상태의 can_attack을 False로 설정 (쿨타임 시작)&#10;                    if self.chase_state:&#10;                        self.chase_state.can_attack = False&#10;&#10;                    self.cat.state_machine.cur_state.sub_state_machine.handle_state_event(('ATTACK_END', None))&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Attack.images and len(Attack.images) &gt; 0:&#10;            frame_idx = min(self.cat.frame, len(Attack.images) - 1)&#10;            Attack.images[frame_idx].draw(draw_x, draw_y,&#10;                                          Attack.images[frame_idx].w * self.cat.scale,&#10;                                          Attack.images[frame_idx].h * self.cat.scale)&#10;&#10;# ========== Hit State ==========&#10;class Hit:&#10;    images = None&#10;&#10;    def __init__(self, cat):&#10;        self.cat = cat&#10;&#10;        if Hit.images is None:&#10;            Hit.images = []&#10;            try:&#10;                for i in range(3):  # Cat_Assassin_Airborne0 ~ Airborne2&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/character/Cat_Assassin_Airborne{i}.png')&#10;                    Hit.images.append(img)&#10;                print(f&quot;[CatAssassin Hit] Loaded {len(Hit.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[CatAssassin Hit] Failed to load images: {e}\033[0m&quot;)&#10;                Hit.images = []&#10;&#10;        self.cat.animation_speed = 12  # 피격 애니메이션은 빠르게&#10;        self.animation_finished = False&#10;&#10;        # 넉백 관련 변수&#10;        self.knockback_dx = 0&#10;        self.knockback_dy = 0&#10;        self.knockback_speed = 200&#10;        self.knockback_duration = 0.2&#10;        self.knockback_timer = 0.0&#10;&#10;    def enter(self, e):&#10;        self.cat.frame = 0&#10;        self.cat.animation_time = 0&#10;        self.animation_finished = False&#10;        self.knockback_timer = 0.0&#10;&#10;        # 넉백 방향 계산&#10;        if e and len(e) &gt; 1 and e[1] is not None:&#10;            attacker = e[1]&#10;            attacker_x = attacker.x if hasattr(attacker, 'x') else self.cat.x&#10;            attacker_y = attacker.y if hasattr(attacker, 'y') else self.cat.y&#10;&#10;            if hasattr(attacker, 'owner') and attacker.owner:&#10;                attacker_x = attacker.owner.x&#10;                attacker_y = attacker.owner.y&#10;&#10;            dx = self.cat.x - attacker_x&#10;            dy = self.cat.y - attacker_y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            if distance &gt; 0:&#10;                self.knockback_dx = dx / distance&#10;                self.knockback_dy = dy / distance&#10;            else:&#10;                self.knockback_dx = 1.0&#10;                self.knockback_dy = 0.0&#10;        else:&#10;            self.knockback_dx = 1.0&#10;            self.knockback_dy = 0.0&#10;&#10;        print(f&quot;[CatAssassin Hit State] 피격 애니메이션 시작&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 넉백 효과 적용&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            current_speed = self.knockback_speed * (1.0 - progress)&#10;            self.cat.x += self.knockback_dx * current_speed * dt&#10;            self.cat.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;&#10;        # 애니메이션 업데이트&#10;        self.cat.animation_time += dt&#10;        if self.cat.animation_time &gt;= 1.0 / self.cat.animation_speed:&#10;            self.cat.frame += 1&#10;            self.cat.animation_time = 0&#10;&#10;            if len(Hit.images) &gt; 0 and self.cat.frame &gt;= len(Hit.images):&#10;                if not self.animation_finished:&#10;                    self.animation_finished = True&#10;                    print(f&quot;[CatAssassin Hit State] 피격 애니메이션 완료, Idle 복귀&quot;)&#10;                    self.cat.state_machine.handle_state_event(('HIT_END', None))&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Hit.images and len(Hit.images) &gt; 0:&#10;            frame_idx = min(self.cat.frame, len(Hit.images) - 1)&#10;            Hit.images[frame_idx].draw(draw_x, draw_y,&#10;                                       Hit.images[frame_idx].w * self.cat.scale,&#10;                                       Hit.images[frame_idx].h * self.cat.scale)&#10;&#10;# ========== Death State ==========&#10;class Death:&#10;    image = None&#10;&#10;    def __init__(self, cat):&#10;        self.cat = cat&#10;&#10;        if Death.image is None:&#10;            try:&#10;                Death.image = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/character/Cat_Assassin_Down0.png')&#10;                print(f&quot;[CatAssassin Death] Loaded Down0 image&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[CatAssassin Death] Failed to load image: {e}\033[0m&quot;)&#10;                Death.image = None&#10;&#10;        self.death_timer = 0.0&#10;        self.death_duration = 3.0&#10;        self.mark_for_removal = False&#10;&#10;        # 넉백 관련 변수 (일반 피격보다 강함)&#10;        self.knockback_dx = 0&#10;        self.knockback_dy = 0&#10;        self.knockback_speed = 350  # Hit의 200보다 크게 (1.75배)&#10;        self.knockback_duration = 0.4  # Hit의 0.2초보다 길게 (2배)&#10;        self.knockback_timer = 0.0&#10;&#10;    def enter(self, e):&#10;        self.death_timer = 0.0&#10;        self.mark_for_removal = False&#10;        self.knockback_timer = 0.0&#10;&#10;        # 넉백 방향 계산 (Hit State와 동일한 로직)&#10;        if e and len(e) &gt; 1 and e[1] is not None:&#10;            attacker = e[1]&#10;            attacker_x = attacker.x if hasattr(attacker, 'x') else self.cat.x&#10;            attacker_y = attacker.y if hasattr(attacker, 'y') else self.cat.y&#10;&#10;            if hasattr(attacker, 'owner') and attacker.owner:&#10;                attacker_x = attacker.owner.x&#10;                attacker_y = attacker.owner.y&#10;&#10;            dx = self.cat.x - attacker_x&#10;            dy = self.cat.y - attacker_y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            if distance &gt; 0:&#10;                self.knockback_dx = dx / distance&#10;                self.knockback_dy = dy / distance&#10;            else:&#10;                self.knockback_dx = 1.0&#10;                self.knockback_dy = 0.0&#10;        else:&#10;            self.knockback_dx = 1.0&#10;            self.knockback_dy = 0.0&#10;&#10;        print(f&quot;[CatAssassin Death State] 사망 상태 시작 (3초 후 제거) - 넉백 적용&quot;)&#10;        &#10;        # 아이템 드롭 처리 (30% 확률로 빨간 포션 드롭)&#10;        try:&#10;            from ..items import drop_item, potion_red0&#10;            if self.cat.world:&#10;                drop_item(self.cat.world, potion_red0, 1, self.cat.x, self.cat.y, drop_chance=0.3)&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[CatAssassin Death] 아이템 드롭 중 오류: {e}\033[0m&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.death_timer += dt&#10;&#10;        # 넉백 효과 적용 (사망 시에도 밀려남)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            # 더 부드러운 감속을 위해 제곱 사용&#10;            current_speed = self.knockback_speed * (1.0 - progress) ** 1.5&#10;            self.cat.x += self.knockback_dx * current_speed * dt&#10;            self.cat.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;&#10;        if self.death_timer &gt;= self.death_duration and not self.mark_for_removal:&#10;            self.mark_for_removal = True&#10;            self.cat.mark_for_removal = True&#10;            print(f&quot;[CatAssassin Death State] 3초 경과, 제거 표시 완료&quot;)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Death.image is not None:&#10;            Death.image.draw(draw_x, draw_y,&#10;                           Death.image.w * self.cat.scale,&#10;                           Death.image.h * self.cat.scale)&#10;&#10;# ========== Event Predicates ==========&#10;def detect_player(e):&#10;    return e[0] == 'DETECT_PLAYER'&#10;&#10;def lose_player(e):&#10;    return e[0] == 'LOSE_PLAYER'&#10;&#10;def in_attack_range(e):&#10;    return e[0] == 'IN_ATTACK_RANGE'&#10;&#10;def out_attack_range(e):&#10;    return e[0] == 'OUT_ATTACK_RANGE'&#10;&#10;def ready_to_attack(e):&#10;    return e[0] == 'READY_TO_ATTACK'&#10;&#10;def attack_end(e):&#10;    return e[0] == 'ATTACK_END'&#10;&#10;def take_hit(e):&#10;    return e[0] == 'TAKE_HIT'&#10;&#10;def hit_end(e):&#10;    return e[0] == 'HIT_END'&#10;&#10;def die(e):&#10;    return e[0] == 'DIE'&#10;&#10;# Shuriken (projectile)&#10;class Shuriken(Projectile):&#10;    &quot;&quot;&quot;수리검 발사체 - Projectile을 상속받음&quot;&quot;&quot;&#10;    images = None&#10;&#10;    def __init__(self, x, y, target_x, target_y, owner=None):&#10;        super().__init__(x, y, target_x, target_y, speed=400, from_player=False)&#10;&#10;        self.owner = owner&#10;        self.scale = 2.5&#10;&#10;        if owner and hasattr(owner, 'stats'):&#10;            self.damage = owner.stats.get('attack_damage')&#10;        else:&#10;            self.damage = 10.0&#10;&#10;        if Shuriken.images is None:&#10;            Shuriken.images = []&#10;            try:&#10;                for i in range(8):&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/FX/Cat_Assassin_Shuriken{i}.png')&#10;                    Shuriken.images.append(img)&#10;            except Exception as e:&#10;                print(f&quot;[Shuriken] Failed to load images: {e}&quot;)&#10;                Shuriken.images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 10&#10;&#10;        # 충돌 박스 크기 설정 (super가 아닌 self 사용)&#10;        self.collision_width = 10 * self.scale&#10;        self.collision_height = 10 * self.scale&#10;&#10;    def update(self):&#10;        if not super().update():&#10;            return False&#10;&#10;        self.animation_time += framework.get_delta_time()&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            if len(Shuriken.images) &gt; 0:&#10;                self.frame = (self.frame + 1) % len(Shuriken.images)&#10;            self.animation_time = 0&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Shuriken.images and len(Shuriken.images) &gt; 0:&#10;            Shuriken.images[self.frame].draw(&#10;                draw_x, draw_y,&#10;                Shuriken.images[self.frame].w * self.scale,&#10;                Shuriken.images[self.frame].h * self.scale&#10;            )&#10;&#10;# CatAssassin (monster)&#10;class CatAssassin:&#10;    def __init__(self, x = 800, y = 450):&#10;        self.x, self.y = x, y&#10;        self.speed = 100&#10;        self.scale = 3.0&#10;        self.world = None&#10;&#10;        self.mark_for_removal = False&#10;&#10;        self.attack_cooldown = 2.0&#10;        self.attack_timer = random.uniform(0, self.attack_cooldown)&#10;&#10;        # Animation variables&#10;        self.frame = 0&#10;        self.animation_speed = 10&#10;        self.animation_time = 0&#10;&#10;        # Collision box&#10;        self.collision_width = 15 * self.scale&#10;        self.collision_height = 15 * self.scale&#10;&#10;        # 무적시간 관련 변수&#10;        self.invincible = False&#10;        self.invincible_timer = 0.0&#10;        self.invincible_duration = 0.3&#10;&#10;        # 스탯 시스템&#10;        self.stats = CatAssassinStats()&#10;        self.health_bar = MonsterHealthBar(self)&#10;&#10;        # State machine setup with rules&#10;        self.IDLE = Idle(self)&#10;        self.CHASE = Chase(self)&#10;        self.HIT = Hit(self)&#10;        self.DEATH = Death(self)&#10;&#10;        self.state_machine = StateMachine(&#10;            self.IDLE,&#10;            {&#10;                self.IDLE: {detect_player: self.CHASE, take_hit: self.HIT, die: self.DEATH},&#10;                self.CHASE: {lose_player: self.IDLE, take_hit: self.HIT, die: self.DEATH},&#10;                self.HIT: {hit_end: self.IDLE, die: self.DEATH},&#10;                self.DEATH: {},&#10;            }&#10;        )&#10;&#10;    def update(self):&#10;        # 무적시간 업데이트&#10;        if self.invincible:&#10;            self.invincible_timer -= framework.get_delta_time()&#10;            if self.invincible_timer &lt;= 0:&#10;                self.invincible = False&#10;                self.invincible_timer = 0.0&#10;&#10;        self.state_machine.update()&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        self.state_machine.draw(draw_x, draw_y)&#10;&#10;        # 체력 바 그리기 (카메라 좌표 적용)&#10;        self.health_bar.draw(draw_x, draw_y)&#10;&#10;        # Debug: Draw collision box (카메라 좌표 적용)&#10;        # cat_left = draw_x - self.collision_width / 2&#10;        # cat_right = draw_x + self.collision_width / 2&#10;        # cat_bottom = draw_y - self.collision_height / 2&#10;        # cat_top = draw_y + self.collision_height / 2&#10;        # p2.draw_rectangle(cat_left, cat_bottom, cat_right, cat_top)&#10;&#10;    def attack(self, target):&#10;        &quot;&quot;&quot;타겟을 향해 수리검 발사 (월드 좌표 사용)&quot;&quot;&quot;&#10;        if self.world:&#10;            # Shuriken을 CatAssassin의 월드 좌표(self.x, self.y)에서 생성&#10;            # target의 월드 좌표(target.x, target.y)를 향해 발사&#10;&#10;            # 추가 수리검 생성 (총 5개, 중앙 + 4방향)&#10;            angle_offsets = [0.0, 22.5, -22.5, 45.0, -45.0]&#10;            for angle in angle_offsets:&#10;                rad = math.radians(angle)&#10;                dx = target.x - self.x&#10;                dy = target.y - self.y&#10;                distance = math.sqrt(dx**2 + dy**2)&#10;                if distance &gt; 0:&#10;                    dir_x = dx / distance&#10;                    dir_y = dy / distance&#10;                    # 회전 변환&#10;                    rotated_x = dir_x * math.cos(rad) - dir_y * math.sin(rad)&#10;                    rotated_y = dir_x * math.sin(rad) + dir_y * math.cos(rad)&#10;                    new_target_x = self.x + rotated_x * distance&#10;                    new_target_y = self.y + rotated_y * distance&#10;                    extra_shuriken = Shuriken(self.x, self.y, new_target_x, new_target_y, owner=self)&#10;                    self.world['effects_front'].append(extra_shuriken)&#10;&#10;            print(f&quot;[CatAssassin] 수리검 발사: 시작({int(self.x)}, {int(self.y)}) -&gt; 목표({int(target.x)}, {int(target.y)})&quot;)&#10;&#10;    def handle_event(self, e):&#10;        pass&#10;&#10;    def check_collision_with_effect(self, effect):&#10;        &quot;&quot;&quot;공격 이펙트와의 충돌 감지&#10;&#10;        Args:&#10;            effect: VFX_Tier1_Sword_Swing 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 무적 상태이면 충돌 무시&#10;        if self.invincible:&#10;            return False&#10;&#10;        # 이펙트의 크기 계산 (이펙트는 회전된 이미지이므로 대략적인 범위 사용)&#10;        if hasattr(effect, 'frames') and len(effect.frames) &gt; 0:&#10;            effect_img = effect.frames[min(effect.frame, len(effect.frames) - 1)]&#10;            effect_width = effect_img.w * effect.scale_factor&#10;            effect_height = effect_img.h * effect.scale_factor&#10;        else:&#10;            # 기본값&#10;            effect_width = 200&#10;            effect_height = 200&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        cat_left = self.x - self.collision_width / 2&#10;        cat_right = self.x + self.collision_width / 2&#10;        cat_bottom = self.y - self.collision_height / 2&#10;        cat_top = self.y + self.collision_height / 2&#10;&#10;        effect_left = effect.x - effect_width / 2&#10;        effect_right = effect.x + effect_width / 2&#10;        effect_bottom = effect.y - effect_height / 2&#10;        effect_top = effect.y + effect_height / 2&#10;        p2.draw_rectangle(effect_left, effect_bottom, effect_right, effect_top)&#10;&#10;        # 충돌 검사&#10;        if (cat_left &lt; effect_right and cat_right &gt; effect_left and&#10;            cat_bottom &lt; effect_top and cat_top &gt; effect_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(effect)&#10;            return True&#10;&#10;        return False&#10;&#10;    def check_collision_with_projectile(self, projectile):&#10;        &quot;&quot;&quot;플레이어 투사체와의 충돌 감지&#10;&#10;        Args:&#10;            projectile: Projectile을 상속받은 발사체 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 무적 상태이면 충돌 무시&#10;        if self.invincible:&#10;            return False&#10;&#10;        # 발사체 크기 (Projectile의 get_collision_box 메서드 사용)&#10;        if hasattr(projectile, 'get_collision_box'):&#10;            projectile_width, projectile_height = projectile.get_collision_box()&#10;        else:&#10;            projectile_width = 30&#10;            projectile_height = 30&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        cat_left = self.x - self.collision_width / 2&#10;        cat_right = self.x + self.collision_width / 2&#10;        cat_bottom = self.y - self.collision_height / 2&#10;        cat_top = self.y + self.collision_height / 2&#10;&#10;        proj_left = projectile.x - projectile_width / 2&#10;        proj_right = projectile.x + projectile_width / 2&#10;        proj_bottom = projectile.y - projectile_height / 2&#10;        proj_top = projectile.y + projectile_height / 2&#10;&#10;        # 충돌 검사&#10;        if (cat_left &lt; proj_right and cat_right &gt; proj_left and&#10;            cat_bottom &lt; proj_top and cat_top &gt; proj_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(projectile)&#10;            return True&#10;&#10;        return False&#10;&#10;    def on_hit(self, attacker):&#10;        &quot;&quot;&quot;피격 시 호출되는 메서드&#10;&#10;        Args:&#10;            attacker: 공격한 객체 (투사체, 이펙트 등)&#10;        &quot;&quot;&quot;&#10;        # 무적 상태라면 무시&#10;        if self.invincible:&#10;            print(f&quot;[CatAssassin] 무적 상태로 피격 무시 (남은 무적시간: {self.invincible_timer:.2f}초)&quot;)&#10;            return&#10;&#10;        # 사망 상태면 무시&#10;        if isinstance(self.state_machine.cur_state, Death):&#10;            return&#10;&#10;        # 무적시간 활성화&#10;        self.invincible = True&#10;        self.invincible_timer = self.invincible_duration&#10;&#10;        # 데미지 계산&#10;        damage = 0&#10;        if hasattr(attacker, 'damage'):&#10;            damage = attacker.damage&#10;        elif hasattr(attacker, 'owner') and hasattr(attacker.owner, 'stats'):&#10;            # 공격자의 스탯에서 데미지 가져오기&#10;            damage = attacker.owner.stats.get('attack_damage')&#10;        else:&#10;            damage = 10.0  # 기본 데미지&#10;&#10;        # 방어력 적산&#10;        defense = self.stats.get('defense')&#10;        final_damage = max(1.0, damage - defense)&#10;&#10;        # 체력 감소&#10;        current_health = self.stats.get('health')&#10;        max_health = self.stats.get('max_health')&#10;        new_health = max(0, current_health - final_damage)&#10;        self.stats.set_base('health', new_health)&#10;&#10;        # 데미지 인디케이터 생성 (월드에 추가)&#10;        if self.world and 'effects_front' in self.world:&#10;            try:&#10;                # 몬스터 위치 위쪽에 데미지 인디케이터 생성&#10;                damage_indicator = DamageIndicator(&#10;                    self.x,&#10;                    self.y + 30,  # 몬스터 위치보다 30 픽셀 위에 표시&#10;                    final_damage,&#10;                    duration=1.0,&#10;                    font_size=30&#10;                )&#10;                self.world['effects_front'].append(damage_indicator)&#10;                print(f&quot;[CatAssassin] 데미지 인디케이터 생성: {int(final_damage)} 데미지&quot;)&#10;            except Exception as e:&#10;                print(f&quot;[CatAssassin] 데미지 인디케이터 생성 실패: {e}&quot;)&#10;&#10;        # 피격 정보 출력 (디버그)&#10;        attacker_name = attacker.__class__.__name__&#10;        print(f&quot;\n{'=' * 60}&quot;)&#10;        print(f&quot;[CatAssassin 피격] at ({int(self.x)}, {int(self.y)})&quot;)&#10;        print(f&quot;  공격자: {attacker_name}&quot;)&#10;        print(f&quot;  원본 데미지: {damage:.1f}&quot;)&#10;        print(f&quot;  방어력: {defense:.1f}&quot;)&#10;        print(f&quot;  최종 데미지: {final_damage:.1f}&quot;)&#10;        print(f&quot;  체력 변화: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})&quot;)&#10;        print(f&quot;  체력 비율: {(new_health / max_health) * 100:.1f}%&quot;)&#10;        print(f&quot;  무적시간: {self.invincible_duration}초 활성화&quot;)&#10;&#10;        # 체력이 0 이하면 사망 상태로 전환&#10;        if new_health &lt;= 0:&#10;            print(f&quot;  &gt;&gt;&gt; CatAssassin 체력 0 - 사망 상태로 전환&quot;)&#10;            print(f&quot;{'=' * 60}\n&quot;)&#10;            self.state_machine.handle_state_event(('DIE', attacker))&#10;        else:&#10;            # 피격 상태로 전환 (공격자 정보를 함께 전달)&#10;            print(f&quot;  &gt;&gt;&gt; 피격 상태로 전환&quot;)&#10;            print(f&quot;{'=' * 60}\n&quot;)&#10;            self.state_machine.handle_state_event(('TAKE_HIT', attacker))&#10;&#10;    def on_death(self):&#10;        &quot;&quot;&quot;사망 처리 - 이제 상태 머신에서 처리하므로 deprecated&quot;&quot;&quot;&#10;        pass&#10;" />
              <option name="updatedContent" value="import pico2d as p2&#10;import random&#10;import math&#10;&#10;import game_framework as framework&#10;from ..state_machine import StateMachine&#10;from ..projectile import Projectile&#10;from ..stats import CatAssassinStats&#10;from ..damage_indicator import DamageIndicator&#10;from ..ui_overlay import MonsterHealthBar&#10;&#10;# ========== Idle State ==========&#10;class Idle:&#10;    images = None&#10;&#10;    def __init__(self, cat):&#10;        self.cat = cat&#10;        self.detection_range = 300  # 플레이어 감지 범위 (픽셀)&#10;&#10;        if Idle.images is None:&#10;            Idle.images = []&#10;            try:&#10;                for i in range(6):  # Cat_Assassin_Idle0 ~ Idle5&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/character/Cat_Assassin_Idle{i}.png')&#10;                    Idle.images.append(img)&#10;                print(f&quot;[CatAssassin Idle] Loaded {len(Idle.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[CatAssassin Idle] Failed to load images: {e}\033[0m&quot;)&#10;                Idle.images = []&#10;&#10;        self.cat.frame = 0&#10;        self.cat.animation_speed = 10  # frames per second&#10;        self.cat.animation_time = 0&#10;&#10;    def enter(self, e):&#10;        self.cat.frame = 0&#10;        self.cat.animation_time = 0&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        # Update animation&#10;        self.cat.animation_time += framework.get_delta_time()&#10;        if self.cat.animation_time &gt;= 1.0 / self.cat.animation_speed:&#10;            self.cat.frame = (self.cat.frame + 1) % len(Idle.images)&#10;            self.cat.animation_time = 0&#10;&#10;        # AI: Check if player is nearby and chase&#10;        if self.cat.world and 'player' in self.cat.world:&#10;            player = self.cat.world['player']&#10;            dx = player.x - self.cat.x&#10;            dy = player.y - self.cat.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            # 감지 범위 내에 플레이어가 있으면 Chase 상태로 전환&#10;            if distance &lt;= self.detection_range:&#10;                self.cat.state_machine.handle_state_event(('DETECT_PLAYER', player))&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Idle.images and len(Idle.images) &gt; 0:&#10;            Idle.images[self.cat.frame].draw(draw_x, draw_y,&#10;                                             Idle.images[self.cat.frame].w * self.cat.scale,&#10;                                             Idle.images[self.cat.frame].h * self.cat.scale)&#10;&#10;# ========== Chase State (상위 상태) ==========&#10;class Chase:&#10;    &quot;&quot;&quot;플레이어를 추적하는 상태 - Run, Kiting, Attack 하위 상태를 가짐&quot;&quot;&quot;&#10;&#10;    def __init__(self, cat):&#10;        self.cat = cat&#10;        self.lose_range = 600  # 플레이어를 놓치는 거리&#10;        self.attack_range = 300  # 공격 범위&#10;        self.attack_range_exit = 350  # 공격 범위를 벗어나는 거리 (여유를 둠)&#10;        self.kiting_min_range = 250  # 너무 가까우면 후퇴할 거리&#10;&#10;        # 공격 쿨타임 관련&#10;        self.attack_cooldown = 2.0  # 공격 후 2초 대기&#10;        self.attack_cooldown_timer = 0.0  # 쿨타임 타이머&#10;        self.can_attack = False  # 공격 가능 여부 - 처음에는 False로 시작&#10;&#10;        # 하위 상태 머신 생성&#10;        self.RUN = Run(cat)&#10;        self.KITING = Kiting(cat, self)  # 새로운 Kiting 상태 추가&#10;        self.ATTACK = Attack(cat, self)  # Chase 상태 참조 전달&#10;&#10;        self.sub_state_machine = StateMachine(&#10;            self.RUN,&#10;            {&#10;                self.RUN: {in_attack_range: self.KITING},&#10;                self.KITING: {out_attack_range: self.RUN, ready_to_attack: self.ATTACK},&#10;                self.ATTACK: {attack_end: self.KITING},&#10;            }&#10;        )&#10;&#10;    def enter(self, e):&#10;        print(&quot;[Chase State] 추적 시작&quot;)&#10;        # 추적 시작 시 쿨타임 초기화&#10;        self.can_attack = False&#10;        self.attack_cooldown_timer = 0.0&#10;        # 하위 상태 머신을 Run 상태로 초기화 (이미 __init__에서 초기화됨)&#10;        # sub_state_machine의 cur_state는 이미 RUN으로 설정되어 있음&#10;        self.sub_state_machine.cur_state.enter(e)&#10;&#10;    def exit(self, e):&#10;        print(&quot;[Chase State] 추적 종료&quot;)&#10;        self.sub_state_machine.cur_state.exit(e)&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 공격 쿨타임 업데이트&#10;        if not self.can_attack:&#10;            self.attack_cooldown_timer += dt&#10;            if self.attack_cooldown_timer &gt;= self.attack_cooldown:&#10;                self.can_attack = True&#10;                self.attack_cooldown_timer = 0.0&#10;                print(&quot;[Chase State] 공격 쿨타임 완료 - 공격 가능&quot;)&#10;&#10;        # 플레이어와의 거리 체크&#10;        if self.cat.world and 'player' in self.cat.world:&#10;            player = self.cat.world['player']&#10;            dx = player.x - self.cat.x&#10;            dy = player.y - self.cat.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            # 플레이어를 놓쳤으면 Idle로 복귀&#10;            if distance &gt; self.lose_range:&#10;                self.cat.state_machine.handle_state_event(('LOSE_PLAYER', None))&#10;                return&#10;&#10;            # 현재 하위 상태 확인&#10;            current_sub_state = self.sub_state_machine.cur_state&#10;            current_state_name = current_sub_state.__class__.__name__&#10;&#10;            # 거리에 따른 상태 전환 (Hysteresis 적용)&#10;            if isinstance(current_sub_state, Run):&#10;                # Run 상태: attack_range 이하면 Kiting으로&#10;                if distance &lt;= self.attack_range:&#10;                    print(f&quot;[Chase State] 거리 {distance:.1f} - Kiting 상태로 전환&quot;)&#10;                    self.sub_state_machine.handle_state_event(('IN_ATTACK_RANGE', player))&#10;&#10;            elif isinstance(current_sub_state, Kiting):&#10;                # Kiting 상태: attack_range_exit 초과하면 Run으로, can_attack이면 Attack으로&#10;                if distance &gt; self.attack_range_exit:&#10;                    print(f&quot;[Chase State] 거리 {distance:.1f} &gt; {self.attack_range_exit} - Run 상태로 전환&quot;)&#10;                    self.sub_state_machine.handle_state_event(('OUT_ATTACK_RANGE', player))&#10;                elif self.can_attack:&#10;                    # 쿨타임 끝나고 공격 가능 - Attack 상태로&#10;                    print(f&quot;[Chase State] 거리 {distance:.1f} - 공격 준비! (can_attack: {self.can_attack})&quot;)&#10;                    self.sub_state_machine.handle_state_event(('READY_TO_ATTACK', player))&#10;                    # 공격 쿨타임 시작 (Attack 상태 진입 시점에 쿨타임 시작)&#10;                    self.can_attack = False&#10;                    print(f&quot;[Chase State] 공격 쿨타임 시작 - 다음 공격까지 {self.attack_cooldown}초&quot;)&#10;&#10;            elif isinstance(current_sub_state, Attack):&#10;                # Attack 상태는 애니메이션이 끝나면 자동으로 Kiting으로 복귀&#10;                pass&#10;&#10;        # 하위 상태 머신 업데이트&#10;        self.sub_state_machine.update()&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 하위 상태 머신의 draw 호출&#10;        self.sub_state_machine.draw(draw_x, draw_y)&#10;&#10;# ========== Run State (Chase의 하위 상태) ==========&#10;class Run:&#10;    images = None&#10;&#10;    def __init__(self, cat):&#10;        self.cat = cat&#10;&#10;        if Run.images is None:&#10;            Run.images = []&#10;            try:&#10;                for i in range(8):  # Cat_Assassin_Move0 ~ Move8&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/character/Cat_Assassin_Move{i}.png')&#10;                    Run.images.append(img)&#10;                print(f&quot;[CatAssassin Run] Loaded {len(Run.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[CatAssassin Run] Failed to load images: {e}\033[0m&quot;)&#10;                Run.images = []&#10;&#10;        # 랜덤 움직임 관련 변수&#10;        self.wander_angle = 0  # 현재 방향에서 벗어나는 각도&#10;        self.wander_change_timer = 0  # 방향 변경 타이머&#10;        self.wander_change_interval = 0.3  # 방향 변경 주기 (초)&#10;        self.wander_strength = 0.6  # 랜덤 움직임의 강도 (0~1)&#10;&#10;    def enter(self, e):&#10;        self.cat.frame = 0&#10;        self.cat.animation_time = 0&#10;        self.cat.animation_speed = 12&#10;        self.wander_angle = random.uniform(-math.pi/4, math.pi/4)  # -45도 ~ 45도&#10;        self.wander_change_timer = 0&#10;        print(&quot;[Run State] 달리기 시작&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 애니메이션 업데이트&#10;        self.cat.animation_time += dt&#10;        if self.cat.animation_time &gt;= 1.0 / self.cat.animation_speed:&#10;            if len(Run.images) &gt; 0:&#10;                self.cat.frame = (self.cat.frame + 1) % len(Run.images)&#10;            self.cat.animation_time = 0&#10;&#10;        # 플레이어 추적 with 랜덤 움직임&#10;        if self.cat.world and 'player' in self.cat.world:&#10;            player = self.cat.world['player']&#10;            dx = player.x - self.cat.x&#10;            dy = player.y - self.cat.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            # 방향 계산 (정규화)&#10;            if distance &gt; 0:&#10;                # 플레이어 방향으로의 기본 방향&#10;                base_dx = dx / distance&#10;                base_dy = dy / distance&#10;&#10;                # 랜덤 방향 변경 타이머 업데이트&#10;                self.wander_change_timer += dt&#10;                if self.wander_change_timer &gt;= self.wander_change_interval:&#10;                    # 랜덤 각도 변경 (-60도 ~ 60도)&#10;                    self.wander_angle = random.uniform(-math.pi/3, math.pi/3)&#10;                    self.wander_change_timer = 0&#10;&#10;                # 기본 방향의 각도 계산&#10;                base_angle = math.atan2(base_dy, base_dx)&#10;&#10;                # 랜덤 각도를 적용한 최종 각도&#10;                final_angle = base_angle + (self.wander_angle * self.wander_strength)&#10;&#10;                # 최종 이동 방향 벡터&#10;                move_dx = math.cos(final_angle)&#10;                move_dy = math.sin(final_angle)&#10;&#10;                # 새 위치 계산 (이동 전에 벽 충돌 체크용)&#10;                new_x = self.cat.x + move_dx * self.cat.speed * dt&#10;                new_y = self.cat.y + move_dy * self.cat.speed * dt&#10;&#10;                # 벽 충돌 체크 (몬스터 크기: 32x48 픽셀로 가정)&#10;                monster_width = 32&#10;                monster_height = 48&#10;                collided = False&#10;&#10;                # world의 walls 레이어에서 벽과 충돌 체크&#10;                if 'walls' in self.cat.world:&#10;                    for wall in self.cat.world['walls']:&#10;                        if hasattr(wall, 'check_collision'):&#10;                            # 몬스터의 바운딩 박스로 충돌 검사&#10;                            if wall.check_collision(&#10;                                new_x - monster_width // 2,&#10;                                new_y - monster_height // 2,&#10;                                monster_width,&#10;                                monster_height&#10;                            ):&#10;                                collided = True&#10;                                break&#10;&#10;                # 벽과 충돌하지 않았을 때만 위치 업데이트&#10;                if not collided:&#10;                    self.cat.x = new_x&#10;                    self.cat.y = new_y&#10;                # 충돌했을 때는 이동하지 않음 (벽에 막힘)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Run.images and len(Run.images) &gt; 0:&#10;            Run.images[self.cat.frame].draw(draw_x, draw_y,&#10;                                            Run.images[self.cat.frame].w * self.cat.scale,&#10;                                            Run.images[self.cat.frame].h * self.cat.scale)&#10;&#10;# ========== Kiting State (Chase의 하위 상태) ==========&#10;class Kiting:&#10;    &quot;&quot;&quot;공격 사거리 내에서 거리를 유지하며 조금씩 움직이는 상태&quot;&quot;&quot;&#10;&#10;    def __init__(self, cat, chase_state = None):&#10;        self.cat = cat&#10;        self.chase_state = chase_state  # Chase 상태에 대한 참조&#10;&#10;        # Run 이미지 사용 (Kiting은 빠르게 움직이므로)&#10;        # Run 클래스의 이미지를 공유&#10;&#10;        # 측면 이동 관련 변수&#10;        self.strafe_direction = random.choice([-1, 1])  # -1: 왼쪽, 1: 오른쪽&#10;        self.strafe_change_timer = 0&#10;        self.strafe_change_interval = 1.5  # 1.5초마다 방향 변경&#10;        self.strafe_speed_multiplier = 1.0  # 원래 속도의 1.0배&#10;&#10;    def enter(self, e):&#10;        self.cat.frame = 0&#10;        self.cat.animation_time = 0&#10;        self.cat.animation_speed = 12  # Run과 같은 빠른 애니메이션&#10;        self.strafe_direction = random.choice([-1, 1])&#10;        self.strafe_change_timer = 0&#10;        print(&quot;[Kiting State] 거리 유지하며 움직이기 시작&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 애니메이션 업데이트 (Run 이미지 사용)&#10;        self.cat.animation_time += dt&#10;        if self.cat.animation_time &gt;= 1.0 / self.cat.animation_speed:&#10;            if Run.images and len(Run.images) &gt; 0:&#10;                self.cat.frame = (self.cat.frame + 1) % len(Run.images)&#10;            self.cat.animation_time = 0&#10;&#10;        # 측면 이동 방향 변경 타이머&#10;        self.strafe_change_timer += dt&#10;        if self.strafe_change_timer &gt;= self.strafe_change_interval:&#10;            self.strafe_direction = random.choice([-1, 1])&#10;            self.strafe_change_timer = 0&#10;            print(f&quot;[Kiting State] 이동 방향 변경: {'왼쪽' if self.strafe_direction == -1 else '오른쪽'}&quot;)&#10;&#10;        # 플레이어와의 거리 체크 및 이동&#10;        if self.cat.world and 'player' in self.cat.world:&#10;            player = self.cat.world['player']&#10;            dx = player.x - self.cat.x&#10;            dy = player.y - self.cat.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            if distance &gt; 0:&#10;                # 플레이어 방향으로의 단위 벡터&#10;                to_player_x = dx / distance&#10;                to_player_y = dy / distance&#10;&#10;                # 기본 이동 속도 (1.0배)&#10;                base_speed = self.cat.speed * self.strafe_speed_multiplier&#10;&#10;                # 이동 벡터 계산&#10;                move_x = 0&#10;                move_y = 0&#10;&#10;                # 너무 가까우면 후퇴&#10;                if distance &lt; self.chase_state.kiting_min_range:&#10;                    # 후퇴 (플레이어 반대 방향으로) - 빠르게&#10;                    flee_dx = -to_player_x&#10;                    flee_dy = -to_player_y&#10;                    move_x = flee_dx * base_speed * dt&#10;                    move_y = flee_dy * base_speed * dt&#10;&#10;                elif distance &gt; self.chase_state.attack_range:&#10;                    # 너무 멀면 조금 다가가기 (적당한 속도로)&#10;                    move_x = to_player_x * base_speed * 0.5 * dt&#10;                    move_y = to_player_y * base_speed * 0.5 * dt&#10;&#10;                else:&#10;                    # 적정 거리 - 측면으로 이동 (strafing)&#10;                    # 플레이어를 향한 벡터에 수직인 벡터로 이동&#10;                    perpendicular_x = -to_player_y * self.strafe_direction&#10;                    perpendicular_y = to_player_x * self.strafe_direction&#10;&#10;                    move_x = perpendicular_x * base_speed * dt&#10;                    move_y = perpendicular_y * base_speed * dt&#10;&#10;                # 새 위치 계산 (벽 충돌 체크용)&#10;                new_x = self.cat.x + move_x&#10;                new_y = self.cat.y + move_y&#10;&#10;                # 벽 충돌 체크 (몬스터 크기: 32x48 픽셀로 가정)&#10;                monster_width = 32&#10;                monster_height = 48&#10;                collided = False&#10;&#10;                # world의 walls 레이어에서 벽과 충돌 체크&#10;                if 'walls' in self.cat.world:&#10;                    for wall in self.cat.world['walls']:&#10;                        if hasattr(wall, 'check_collision'):&#10;                            # 몬스터의 바운딩 박스로 충돌 검사&#10;                            if wall.check_collision(&#10;                                new_x - monster_width // 2,&#10;                                new_y - monster_height // 2,&#10;                                monster_width,&#10;                                monster_height&#10;                            ):&#10;                                collided = True&#10;                                break&#10;&#10;                # 벽과 충돌하지 않았을 때만 위치 업데이트&#10;                if not collided:&#10;                    self.cat.x = new_x&#10;                    self.cat.y = new_y&#10;                # 충돌했을 때는 이동하지 않음 (벽에 막힘)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # Run 이미지 사용&#10;        if Run.images and len(Run.images) &gt; 0:&#10;            Run.images[self.cat.frame].draw(draw_x, draw_y,&#10;                                            Run.images[self.cat.frame].w * self.cat.scale,&#10;                                            Run.images[self.cat.frame].h * self.cat.scale)&#10;&#10;# ========== Attack State (Chase의 하위 상태) ==========&#10;class Attack:&#10;    images = None&#10;&#10;    def __init__(self, cat, chase_state = None):&#10;        self.cat = cat&#10;        self.chase_state = chase_state  # Chase 상태에 대한 참조 (optional)&#10;&#10;        if Attack.images is None:&#10;            Attack.images = []&#10;            try:&#10;                for i in range(7):  # Cat_Assassin_Attack0 ~ Attack6&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/character/Cat_Assassin_Attack{i}.png')&#10;                    Attack.images.append(img)&#10;                print(f&quot;[CatAssassin Attack] Loaded {len(Attack.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[CatAssassin Attack] Failed to load images: {e}\033[0m&quot;)&#10;                Attack.images = []&#10;&#10;        self.animation_finished = False&#10;        self.projectile_spawned = False&#10;&#10;    def enter(self, e):&#10;        self.cat.frame = 0&#10;        self.cat.animation_time = 0&#10;        self.cat.animation_speed = 10  # 공격 애니메이션은 빠르게&#10;        self.animation_finished = False&#10;        self.projectile_spawned = False&#10;        print(&quot;[Attack State] 공격 시작&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 애니메이션 업데이트&#10;        self.cat.animation_time += dt&#10;        if self.cat.animation_time &gt;= 1.0 / self.cat.animation_speed:&#10;            self.cat.frame += 1&#10;            self.cat.animation_time = 0&#10;&#10;            # 공격 프레임 중간쯤에 수리검 발사 (프레임 3에서 발사)&#10;            if self.cat.frame == 3 and not self.projectile_spawned:&#10;                self.projectile_spawned = True&#10;                if self.cat.world and 'player' in self.cat.world:&#10;                    player = self.cat.world['player']&#10;                    self.cat.attack(player)&#10;&#10;            # 애니메이션이 끝나면 Run으로 복귀&#10;            if len(Attack.images) &gt; 0 and self.cat.frame &gt;= len(Attack.images):&#10;                if not self.animation_finished:&#10;                    self.animation_finished = True&#10;                    print(&quot;[Attack State] 공격 애니메이션 완료&quot;)&#10;                    # Chase 상태의 can_attack을 False로 설정 (쿨타임 시작)&#10;                    if self.chase_state:&#10;                        self.chase_state.can_attack = False&#10;&#10;                    self.cat.state_machine.cur_state.sub_state_machine.handle_state_event(('ATTACK_END', None))&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Attack.images and len(Attack.images) &gt; 0:&#10;            frame_idx = min(self.cat.frame, len(Attack.images) - 1)&#10;            Attack.images[frame_idx].draw(draw_x, draw_y,&#10;                                          Attack.images[frame_idx].w * self.cat.scale,&#10;                                          Attack.images[frame_idx].h * self.cat.scale)&#10;&#10;# ========== Hit State ==========&#10;class Hit:&#10;    images = None&#10;&#10;    def __init__(self, cat):&#10;        self.cat = cat&#10;&#10;        if Hit.images is None:&#10;            Hit.images = []&#10;            try:&#10;                for i in range(3):  # Cat_Assassin_Airborne0 ~ Airborne2&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/character/Cat_Assassin_Airborne{i}.png')&#10;                    Hit.images.append(img)&#10;                print(f&quot;[CatAssassin Hit] Loaded {len(Hit.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[CatAssassin Hit] Failed to load images: {e}\033[0m&quot;)&#10;                Hit.images = []&#10;&#10;        self.cat.animation_speed = 12  # 피격 애니메이션은 빠르게&#10;        self.animation_finished = False&#10;&#10;        # 넉백 관련 변수&#10;        self.knockback_dx = 0&#10;        self.knockback_dy = 0&#10;        self.knockback_speed = 200&#10;        self.knockback_duration = 0.2&#10;        self.knockback_timer = 0.0&#10;&#10;    def enter(self, e):&#10;        self.cat.frame = 0&#10;        self.cat.animation_time = 0&#10;        self.animation_finished = False&#10;        self.knockback_timer = 0.0&#10;&#10;        # 넉백 방향 계산&#10;        if e and len(e) &gt; 1 and e[1] is not None:&#10;            attacker = e[1]&#10;            attacker_x = attacker.x if hasattr(attacker, 'x') else self.cat.x&#10;            attacker_y = attacker.y if hasattr(attacker, 'y') else self.cat.y&#10;&#10;            if hasattr(attacker, 'owner') and attacker.owner:&#10;                attacker_x = attacker.owner.x&#10;                attacker_y = attacker.owner.y&#10;&#10;            dx = self.cat.x - attacker_x&#10;            dy = self.cat.y - attacker_y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            if distance &gt; 0:&#10;                self.knockback_dx = dx / distance&#10;                self.knockback_dy = dy / distance&#10;            else:&#10;                self.knockback_dx = 1.0&#10;                self.knockback_dy = 0.0&#10;        else:&#10;            self.knockback_dx = 1.0&#10;            self.knockback_dy = 0.0&#10;&#10;        print(f&quot;[CatAssassin Hit State] 피격 애니메이션 시작&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 넉백 효과 적용&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            current_speed = self.knockback_speed * (1.0 - progress)&#10;            self.cat.x += self.knockback_dx * current_speed * dt&#10;            self.cat.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;&#10;        # 애니메이션 업데이트&#10;        self.cat.animation_time += dt&#10;        if self.cat.animation_time &gt;= 1.0 / self.cat.animation_speed:&#10;            self.cat.frame += 1&#10;            self.cat.animation_time = 0&#10;&#10;            if len(Hit.images) &gt; 0 and self.cat.frame &gt;= len(Hit.images):&#10;                if not self.animation_finished:&#10;                    self.animation_finished = True&#10;                    print(f&quot;[CatAssassin Hit State] 피격 애니메이션 완료, Idle 복귀&quot;)&#10;                    self.cat.state_machine.handle_state_event(('HIT_END', None))&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Hit.images and len(Hit.images) &gt; 0:&#10;            frame_idx = min(self.cat.frame, len(Hit.images) - 1)&#10;            Hit.images[frame_idx].draw(draw_x, draw_y,&#10;                                       Hit.images[frame_idx].w * self.cat.scale,&#10;                                       Hit.images[frame_idx].h * self.cat.scale)&#10;&#10;# ========== Death State ==========&#10;class Death:&#10;    image = None&#10;&#10;    def __init__(self, cat):&#10;        self.cat = cat&#10;&#10;        if Death.image is None:&#10;            try:&#10;                Death.image = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/character/Cat_Assassin_Down0.png')&#10;                print(f&quot;[CatAssassin Death] Loaded Down0 image&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[CatAssassin Death] Failed to load image: {e}\033[0m&quot;)&#10;                Death.image = None&#10;&#10;        self.death_timer = 0.0&#10;        self.death_duration = 3.0&#10;        self.mark_for_removal = False&#10;&#10;        # 넉백 관련 변수 (일반 피격보다 강함)&#10;        self.knockback_dx = 0&#10;        self.knockback_dy = 0&#10;        self.knockback_speed = 350  # Hit의 200보다 크게 (1.75배)&#10;        self.knockback_duration = 0.4  # Hit의 0.2초보다 길게 (2배)&#10;        self.knockback_timer = 0.0&#10;&#10;    def enter(self, e):&#10;        self.death_timer = 0.0&#10;        self.mark_for_removal = False&#10;        self.knockback_timer = 0.0&#10;&#10;        # 넉백 방향 계산 (Hit State와 동일한 로직)&#10;        if e and len(e) &gt; 1 and e[1] is not None:&#10;            attacker = e[1]&#10;            attacker_x = attacker.x if hasattr(attacker, 'x') else self.cat.x&#10;            attacker_y = attacker.y if hasattr(attacker, 'y') else self.cat.y&#10;&#10;            if hasattr(attacker, 'owner') and attacker.owner:&#10;                attacker_x = attacker.owner.x&#10;                attacker_y = attacker.owner.y&#10;&#10;            dx = self.cat.x - attacker_x&#10;            dy = self.cat.y - attacker_y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            if distance &gt; 0:&#10;                self.knockback_dx = dx / distance&#10;                self.knockback_dy = dy / distance&#10;            else:&#10;                self.knockback_dx = 1.0&#10;                self.knockback_dy = 0.0&#10;        else:&#10;            self.knockback_dx = 1.0&#10;            self.knockback_dy = 0.0&#10;&#10;        print(f&quot;[CatAssassin Death State] 사망 상태 시작 (3초 후 제거) - 넉백 적용&quot;)&#10;        &#10;        # 아이템 드롭 처리 (30% 확률로 빨간 포션 드롭)&#10;        try:&#10;            from ..items import drop_item, potion_red0&#10;            if self.cat.world:&#10;                drop_item(self.cat.world, potion_red0, 1, self.cat.x, self.cat.y, drop_chance=0.3)&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[CatAssassin Death] 아이템 드롭 중 오류: {e}\033[0m&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.death_timer += dt&#10;&#10;        # 넉백 효과 적용 (사망 시에도 밀려남)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            # 더 부드러운 감속을 위해 제곱 사용&#10;            current_speed = self.knockback_speed * (1.0 - progress) ** 1.5&#10;            self.cat.x += self.knockback_dx * current_speed * dt&#10;            self.cat.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;&#10;        if self.death_timer &gt;= self.death_duration and not self.mark_for_removal:&#10;            self.mark_for_removal = True&#10;            self.cat.mark_for_removal = True&#10;            print(f&quot;[CatAssassin Death State] 3초 경과, 제거 표시 완료&quot;)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Death.image is not None:&#10;            Death.image.draw(draw_x, draw_y,&#10;                           Death.image.w * self.cat.scale,&#10;                           Death.image.h * self.cat.scale)&#10;&#10;# ========== Event Predicates ==========&#10;def detect_player(e):&#10;    return e[0] == 'DETECT_PLAYER'&#10;&#10;def lose_player(e):&#10;    return e[0] == 'LOSE_PLAYER'&#10;&#10;def in_attack_range(e):&#10;    return e[0] == 'IN_ATTACK_RANGE'&#10;&#10;def out_attack_range(e):&#10;    return e[0] == 'OUT_ATTACK_RANGE'&#10;&#10;def ready_to_attack(e):&#10;    return e[0] == 'READY_TO_ATTACK'&#10;&#10;def attack_end(e):&#10;    return e[0] == 'ATTACK_END'&#10;&#10;def take_hit(e):&#10;    return e[0] == 'TAKE_HIT'&#10;&#10;def hit_end(e):&#10;    return e[0] == 'HIT_END'&#10;&#10;def die(e):&#10;    return e[0] == 'DIE'&#10;&#10;# Shuriken (projectile)&#10;class Shuriken(Projectile):&#10;    &quot;&quot;&quot;수리검 발사체 - Projectile을 상속받음&quot;&quot;&quot;&#10;    images = None&#10;&#10;    def __init__(self, x, y, target_x, target_y, owner=None):&#10;        super().__init__(x, y, target_x, target_y, speed=400, from_player=False)&#10;&#10;        self.owner = owner&#10;        self.scale = 2.5&#10;&#10;        if owner and hasattr(owner, 'stats'):&#10;            self.damage = owner.stats.get('attack_damage')&#10;        else:&#10;            self.damage = 10.0&#10;&#10;        if Shuriken.images is None:&#10;            Shuriken.images = []&#10;            try:&#10;                for i in range(8):&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest/Cat_Assassin/FX/Cat_Assassin_Shuriken{i}.png')&#10;                    Shuriken.images.append(img)&#10;            except Exception as e:&#10;                print(f&quot;[Shuriken] Failed to load images: {e}&quot;)&#10;                Shuriken.images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 10&#10;&#10;        # 충돌 박스 크기 설정 (super가 아닌 self 사용)&#10;        self.collision_width = 10 * self.scale&#10;        self.collision_height = 10 * self.scale&#10;&#10;    def update(self):&#10;        if not super().update():&#10;            return False&#10;&#10;        self.animation_time += framework.get_delta_time()&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            if len(Shuriken.images) &gt; 0:&#10;                self.frame = (self.frame + 1) % len(Shuriken.images)&#10;            self.animation_time = 0&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if Shuriken.images and len(Shuriken.images) &gt; 0:&#10;            Shuriken.images[self.frame].draw(&#10;                draw_x, draw_y,&#10;                Shuriken.images[self.frame].w * self.scale,&#10;                Shuriken.images[self.frame].h * self.scale&#10;            )&#10;&#10;# CatAssassin (monster)&#10;class CatAssassin:&#10;    def __init__(self, x = 800, y = 450):&#10;        self.x, self.y = x, y&#10;        self.speed = 100&#10;        self.scale = 3.0&#10;        self.world = None&#10;&#10;        self.mark_for_removal = False&#10;&#10;        self.attack_cooldown = 2.0&#10;        self.attack_timer = random.uniform(0, self.attack_cooldown)&#10;&#10;        # Animation variables&#10;        self.frame = 0&#10;        self.animation_speed = 10&#10;        self.animation_time = 0&#10;&#10;        # Collision box&#10;        self.collision_width = 15 * self.scale&#10;        self.collision_height = 15 * self.scale&#10;&#10;        # 무적시간 관련 변수&#10;        self.invincible = False&#10;        self.invincible_timer = 0.0&#10;        self.invincible_duration = 0.3&#10;&#10;        # 스탯 시스템&#10;        self.stats = CatAssassinStats()&#10;        self.health_bar = MonsterHealthBar(self)&#10;&#10;        # State machine setup with rules&#10;        self.IDLE = Idle(self)&#10;        self.CHASE = Chase(self)&#10;        self.HIT = Hit(self)&#10;        self.DEATH = Death(self)&#10;&#10;        self.state_machine = StateMachine(&#10;            self.IDLE,&#10;            {&#10;                self.IDLE: {detect_player: self.CHASE, take_hit: self.HIT, die: self.DEATH},&#10;                self.CHASE: {lose_player: self.IDLE, take_hit: self.HIT, die: self.DEATH},&#10;                self.HIT: {hit_end: self.IDLE, die: self.DEATH},&#10;                self.DEATH: {},&#10;            }&#10;        )&#10;&#10;    def update(self):&#10;        # 무적시간 업데이트&#10;        if self.invincible:&#10;            self.invincible_timer -= framework.get_delta_time()&#10;            if self.invincible_timer &lt;= 0:&#10;                self.invincible = False&#10;                self.invincible_timer = 0.0&#10;&#10;        self.state_machine.update()&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        self.state_machine.draw(draw_x, draw_y)&#10;&#10;        # 체력 바 그리기 (카메라 좌표 적용)&#10;        self.health_bar.draw(draw_x, draw_y)&#10;&#10;        # Debug: Draw collision box (카메라 좌표 적용)&#10;        # cat_left = draw_x - self.collision_width / 2&#10;        # cat_right = draw_x + self.collision_width / 2&#10;        # cat_bottom = draw_y - self.collision_height / 2&#10;        # cat_top = draw_y + self.collision_height / 2&#10;        # p2.draw_rectangle(cat_left, cat_bottom, cat_right, cat_top)&#10;&#10;    def attack(self, target):&#10;        &quot;&quot;&quot;타겟을 향해 수리검 발사 (월드 좌표 사용)&quot;&quot;&quot;&#10;        if self.world:&#10;            # Shuriken을 CatAssassin의 월드 좌표(self.x, self.y)에서 생성&#10;            # target의 월드 좌표(target.x, target.y)를 향해 발사&#10;&#10;            # 추가 수리검 생성 (총 5개, 중앙 + 4방향)&#10;            angle_offsets = [0.0, 22.5, -22.5, 45.0, -45.0]&#10;            for angle in angle_offsets:&#10;                rad = math.radians(angle)&#10;                dx = target.x - self.x&#10;                dy = target.y - self.y&#10;                distance = math.sqrt(dx**2 + dy**2)&#10;                if distance &gt; 0:&#10;                    dir_x = dx / distance&#10;                    dir_y = dy / distance&#10;                    # 회전 변환&#10;                    rotated_x = dir_x * math.cos(rad) - dir_y * math.sin(rad)&#10;                    rotated_y = dir_x * math.sin(rad) + dir_y * math.cos(rad)&#10;                    new_target_x = self.x + rotated_x * distance&#10;                    new_target_y = self.y + rotated_y * distance&#10;                    extra_shuriken = Shuriken(self.x, self.y, new_target_x, new_target_y, owner=self)&#10;                    self.world['effects_front'].append(extra_shuriken)&#10;&#10;            print(f&quot;[CatAssassin] 수리검 발사: 시작({int(self.x)}, {int(self.y)}) -&gt; 목표({int(target.x)}, {int(target.y)})&quot;)&#10;&#10;    def handle_event(self, e):&#10;        pass&#10;&#10;    def check_collision_with_effect(self, effect):&#10;        &quot;&quot;&quot;공격 이펙트와의 충돌 감지&#10;&#10;        Args:&#10;            effect: VFX_Tier1_Sword_Swing 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 무적 상태이면 충돌 무시&#10;        if self.invincible:&#10;            return False&#10;&#10;        # 이펙트의 크기 계산 (이펙트는 회전된 이미지이므로 대략적인 범위 사용)&#10;        if hasattr(effect, 'frames') and len(effect.frames) &gt; 0:&#10;            effect_img = effect.frames[min(effect.frame, len(effect.frames) - 1)]&#10;            effect_width = effect_img.w * effect.scale_factor&#10;            effect_height = effect_img.h * effect.scale_factor&#10;        else:&#10;            # 기본값&#10;            effect_width = 200&#10;            effect_height = 200&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        cat_left = self.x - self.collision_width / 2&#10;        cat_right = self.x + self.collision_width / 2&#10;        cat_bottom = self.y - self.collision_height / 2&#10;        cat_top = self.y + self.collision_height / 2&#10;&#10;        effect_left = effect.x - effect_width / 2&#10;        effect_right = effect.x + effect_width / 2&#10;        effect_bottom = effect.y - effect_height / 2&#10;        effect_top = effect.y + effect_height / 2&#10;        p2.draw_rectangle(effect_left, effect_bottom, effect_right, effect_top)&#10;&#10;        # 충돌 검사&#10;        if (cat_left &lt; effect_right and cat_right &gt; effect_left and&#10;            cat_bottom &lt; effect_top and cat_top &gt; effect_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(effect)&#10;            return True&#10;&#10;        return False&#10;&#10;    def check_collision_with_projectile(self, projectile):&#10;        &quot;&quot;&quot;플레이어 투사체와의 충돌 감지&#10;&#10;        Args:&#10;            projectile: Projectile을 상속받은 발사체 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 무적 상태이면 충돌 무시&#10;        if self.invincible:&#10;            return False&#10;&#10;        # 발사체 크기 (Projectile의 get_collision_box 메서드 사용)&#10;        if hasattr(projectile, 'get_collision_box'):&#10;            projectile_width, projectile_height = projectile.get_collision_box()&#10;        else:&#10;            projectile_width = 30&#10;            projectile_height = 30&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        cat_left = self.x - self.collision_width / 2&#10;        cat_right = self.x + self.collision_width / 2&#10;        cat_bottom = self.y - self.collision_height / 2&#10;        cat_top = self.y + self.collision_height / 2&#10;&#10;        proj_left = projectile.x - projectile_width / 2&#10;        proj_right = projectile.x + projectile_width / 2&#10;        proj_bottom = projectile.y - projectile_height / 2&#10;        proj_top = projectile.y + projectile_height / 2&#10;&#10;        # 충돌 검사&#10;        if (cat_left &lt; proj_right and cat_right &gt; proj_left and&#10;            cat_bottom &lt; proj_top and cat_top &gt; proj_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(projectile)&#10;            return True&#10;&#10;        return False&#10;&#10;    def on_hit(self, attacker):&#10;        &quot;&quot;&quot;피격 시 호출되는 메서드&#10;&#10;        Args:&#10;            attacker: 공격한 객체 (투사체, 이펙트 등)&#10;        &quot;&quot;&quot;&#10;        # 무적 상태라면 무시&#10;        if self.invincible:&#10;            print(f&quot;[CatAssassin] 무적 상태로 피격 무시 (남은 무적시간: {self.invincible_timer:.2f}초)&quot;)&#10;            return&#10;&#10;        # 사망 상태면 무시&#10;        if isinstance(self.state_machine.cur_state, Death):&#10;            return&#10;&#10;        # 무적시간 활성화&#10;        self.invincible = True&#10;        self.invincible_timer = self.invincible_duration&#10;&#10;        # 데미지 계산&#10;        damage = 0&#10;        if hasattr(attacker, 'damage'):&#10;            damage = attacker.damage&#10;        elif hasattr(attacker, 'owner') and hasattr(attacker.owner, 'stats'):&#10;            # 공격자의 스탯에서 데미지 가져오기&#10;            damage = attacker.owner.stats.get('attack_damage')&#10;        else:&#10;            damage = 10.0  # 기본 데미지&#10;&#10;        # 방어력 적산&#10;        defense = self.stats.get('defense')&#10;        final_damage = max(1.0, damage - defense)&#10;&#10;        # 체력 감소&#10;        current_health = self.stats.get('health')&#10;        max_health = self.stats.get('max_health')&#10;        new_health = max(0, current_health - final_damage)&#10;        self.stats.set_base('health', new_health)&#10;&#10;        # 데미지 인디케이터 생성 (월드에 추가)&#10;        if self.world and 'effects_front' in self.world:&#10;            try:&#10;                # 몬스터 위치 위쪽에 데미지 인디케이터 생성&#10;                damage_indicator = DamageIndicator(&#10;                    self.x,&#10;                    self.y + 30,  # 몬스터 위치보다 30 픽셀 위에 표시&#10;                    final_damage,&#10;                    duration=1.0,&#10;                    font_size=30&#10;                )&#10;                self.world['effects_front'].append(damage_indicator)&#10;                print(f&quot;[CatAssassin] 데미지 인디케이터 생성: {int(final_damage)} 데미지&quot;)&#10;            except Exception as e:&#10;                print(f&quot;[CatAssassin] 데미지 인디케이터 생성 실패: {e}&quot;)&#10;&#10;        # 피격 정보 출력 (디버그)&#10;        attacker_name = attacker.__class__.__name__&#10;        print(f&quot;\n{'=' * 60}&quot;)&#10;        print(f&quot;[CatAssassin 피격] at ({int(self.x)}, {int(self.y)})&quot;)&#10;        print(f&quot;  공격자: {attacker_name}&quot;)&#10;        print(f&quot;  원본 데미지: {damage:.1f}&quot;)&#10;        print(f&quot;  방어력: {defense:.1f}&quot;)&#10;        print(f&quot;  최종 데미지: {final_damage:.1f}&quot;)&#10;        print(f&quot;  체력 변화: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})&quot;)&#10;        print(f&quot;  체력 비율: {(new_health / max_health) * 100:.1f}%&quot;)&#10;        print(f&quot;  무적시간: {self.invincible_duration}초 활성화&quot;)&#10;&#10;        # 체력이 0 이하면 사망 상태로 전환&#10;        if new_health &lt;= 0:&#10;            print(f&quot;  &gt;&gt;&gt; CatAssassin 체력 0 - 사망 상태로 전환&quot;)&#10;            print(f&quot;{'=' * 60}\n&quot;)&#10;            self.state_machine.handle_state_event(('DIE', attacker))&#10;        else:&#10;            # 피격 상태로 전환 (공격자 정보를 함께 전달)&#10;            print(f&quot;  &gt;&gt;&gt; 피격 상태로 전환&quot;)&#10;            print(f&quot;{'=' * 60}\n&quot;)&#10;            self.state_machine.handle_state_event(('TAKE_HIT', attacker))&#10;&#10;    def on_death(self):&#10;        &quot;&quot;&quot;사망 처리 - 이제 상태 머신에서 처리하므로 deprecated&quot;&quot;&quot;&#10;        pass&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/play_mode.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/play_mode.py" />
              <option name="originalContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#10;# minimal, compatible with existing game_logic modules&#10;import pico2d as p2&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#10;from PIL import Image&#10;&#10;import game_framework&#10;from .player import Player&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar, DashBar, BuffIndicatorUI&#10;from .cursor import Cursor&#10;from .loading_screen import LoadingScreen&#10;from . import defeat_mode, victory_mode&#10;# 사용할 스테이지 모듈들을 import 합니다.&#10;from .stages import stage_1, stage_2, stage_3&#10;&#10;# world layers: keep same keys as original main.py&#10;world = {&#10;    'ground': [],&#10;    'upper_ground': [],&#10;    'walls': [],&#10;    'effects_back': [],&#10;    'entities': [],&#10;    'effects_front': [],&#10;    'ui': [],&#10;    'extra_bg': [],&#10;    'extras': [],&#10;    'cursor': []&#10;}&#10;world['bg'] = world['ground']&#10;&#10;# 스테이지 관리&#10;# stages = [stage_1, stage_2, stage_3]&#10;# stages = [stage_1]&#10;# stages = [stage_2]&#10;stages = [stage_3]&#10;current_stage_index = 0&#10;is_stage_cleared = False&#10;&#10;# 로딩 화면 관리&#10;loading_screen = None&#10;is_loading = False&#10;next_stage_to_load = None&#10;&#10;# 경과 시간 추적 (play_mode 진입 후 경과 시간)&#10;elapsed_time = 0.0&#10;&#10;# 승리 페이드인 효과 관련 변수&#10;is_fading_to_victory = False  # 승리 페이드인 진행 중 플래그&#10;victory_fade_elapsed = 0.0    # 페이드인 경과 시간&#10;victory_fade_duration = 3.0   # 페이드인 지속 시간 (3초)&#10;victory_fade_image = None     # 페이드인 이미지&#10;&#10;&#10;class Camera:&#10;    &quot;&quot;&quot;&#10;    플레이어를 부드럽게 따라가는 카메라 클래스&#10;    맵의 경계를 넘지 않도록 제한하며, 화면 중앙을 (0,0)으로 하는 좌표계 사용&#10;    &quot;&quot;&quot;&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#10;        &quot;&quot;&quot;&#10;        카메라 초기화&#10;        Args:&#10;            target: 카메라가 따라갈 대상 (일반적으로 플레이어)&#10;            map_width: 맵의 전체 너비&#10;            map_height: 맵의 전체 높이&#10;            screen_width: 화면 너비&#10;            screen_height: 화면 높이&#10;        &quot;&quot;&quot;&#10;        self.target = target&#10;        self.x = target.x&#10;        self.y = target.y&#10;        self.map_width = map_width&#10;        self.map_height = map_height&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1, 낮을수록 부드럽고 느림)&#10;&#10;        # 맵 오프셋 (배경의 중심점, calculate_background_bounds에서 설정)&#10;        self.map_offset_x = 0&#10;        self.map_offset_y = 0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        카메라 위치 업데이트 - 타겟을 부드럽게 따라가며 맵 경계 내로 제한&#10;        &quot;&quot;&quot;&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP - Linear Interpolation)&#10;        target_x = self.target.x&#10;        target_y = self.target.y&#10;        self.x += (target_x - self.x) * self.smooth&#10;        self.y += (target_y - self.y) * self.smooth&#10;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#10;        min_x = -self.map_width/2&#10;        max_x = self.map_width/2&#10;        min_y = -self.map_height/2&#10;        max_y = self.map_height/2&#10;&#10;        self.x = max(min_x, min(self.x, max_x))&#10;        self.y = max(min_y, min(self.y, max_y))&#10;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#10;        if self.map_width &lt;= self.screen_width:&#10;            self.x = 0&#10;        if self.map_height &lt;= self.screen_height:&#10;            self.y = 0&#10;&#10;    def apply(self, obj_x, obj_y):&#10;        &quot;&quot;&quot;&#10;        카메라 위치에 따라 오브젝트의 화면 좌표 계산&#10;        Args:&#10;            obj_x: 오브젝트의 월드 x 좌표 (맵 중심 기준)&#10;            obj_y: 오브젝트의 월드 y 좌표 (맵 중심 기준)&#10;        Returns:&#10;            tuple: (draw_x, draw_y) - 화면에 그릴 좌표&#10;        &quot;&quot;&quot;&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#10;&#10;&#10;# Camera 객체를 전역으로 선언&#10;camera = None&#10;&#10;&#10;def calculate_background_bounds():&#10;    &quot;&quot;&quot;&#10;    ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#10;&#10;    Returns:&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#10;    &quot;&quot;&quot;&#10;    min_x = float('inf')&#10;    max_x = float('-inf')&#10;    min_y = float('inf')&#10;    max_y = float('-inf')&#10;&#10;    # ground 레이어의 모든 객체를 순회&#10;    for obj in world['ground']:&#10;        # 객체가 x, y, image 속성을 가지고 있는지 확인&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image'):&#10;            # 객체의 중심 좌표&#10;            obj_x = obj.x&#10;            obj_y = obj.y&#10;&#10;            # 이미지 크기 계산 (scale 속성이 있으면 적용)&#10;            scale = getattr(obj, 'scale', 1.0)&#10;            img_width = obj.image.w * scale&#10;            img_height = obj.image.h * scale&#10;&#10;            # 객체의 경계 계산 (중심 기준이므로 절반씩)&#10;            obj_left = obj_x - img_width / 2&#10;            obj_right = obj_x + img_width / 2&#10;            obj_bottom = obj_y - img_height / 2&#10;            obj_top = obj_y + img_height / 2&#10;&#10;            # 최소/최대 값 업데이트&#10;            min_x = min(min_x, obj_left)&#10;            max_x = max(max_x, obj_right)&#10;            min_y = min(min_y, obj_bottom)&#10;            max_y = max(max_y, obj_top)&#10;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환 (1280x720 화면 기준)&#10;    if min_x == float('inf') or max_x == float('-inf'):&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#10;        return (-640, 640, -360, 360)&#10;&#10;    print(f&quot;[play_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#10;    return (min_x, max_x, min_y, max_y)&#10;&#10;&#10;def change_stage(next_stage_index):&#10;    &quot;&quot;&quot;다음 스테이지로 변경하는 함수&quot;&quot;&quot;&#10;    global current_stage_index, loading_screen, is_loading, next_stage_to_load, is_fading_to_victory, victory_fade_elapsed, victory_fade_image&#10;&#10;    # 다음 스테이지 인덱스 확인&#10;    if next_stage_index &gt;= len(stages):&#10;        # 모든 스테이지 클리어 시 페이드인 효과 시작&#10;        print(&quot;All stages cleared! Starting fade-in effect...&quot;)&#10;        is_fading_to_victory = True&#10;        victory_fade_elapsed = 0.0&#10;&#10;        # 플레이어를 entities에서 extras 레이어로 즉시 이동&#10;        player = world.get('player')&#10;        if player and player in world['entities']:&#10;            world['entities'].remove(player)&#10;            world['extras'].append(player)&#10;            print(&quot;[change_stage] 플레이어를 extras 레이어로 이동&quot;)&#10;&#10;        # 페이드인 이미지 로드&#10;        try:&#10;            victory_fade_image = p2.load_image('resources/Texture_organize/IDK_2/Square.png')&#10;            print(&quot;[change_stage] 승리 페이드인 이미지 로드 성공&quot;)&#10;        except Exception as ex:&#10;            print(f'\033[91m[change_stage] 승리 페이드인 이미지 로드 실패: {ex}\033[0m')&#10;            victory_fade_image = None&#10;&#10;        return&#10;&#10;    # 로딩 화면 시작 - 스테이지 모듈의 LOADING_SCREEN_INFO 사용&#10;    next_stage_module = stages[next_stage_index]&#10;    loading_info = getattr(next_stage_module, 'LOADING_SCREEN_INFO', None)&#10;&#10;    if loading_info:&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1} 로딩 화면 시작&quot;)&#10;        loading_screen = LoadingScreen(loading_info)&#10;        is_loading = True&#10;        next_stage_to_load = next_stage_index&#10;    else:&#10;        # LOADING_SCREEN_INFO가 없으면 로딩 화면 없이 바로 전환&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1}에 로딩 화면 정보 없음, 즉시 전환&quot;)&#10;        next_stage_to_load = next_stage_index&#10;        _complete_stage_change()&#10;&#10;&#10;class PlayModeWall:&#10;    &quot;&quot;&quot;플레이 모드에서 사용하는 벽 클래스 (투명 영역 감지용)&quot;&quot;&quot;&#10;    def __init__(self, x, y, w, h):&#10;        &quot;&quot;&quot;&#10;        벽 초기화&#10;        Args:&#10;            x: 벽의 월드 x 좌표 (맵 중심 기준)&#10;            y: 벽의 월드 y 좌표 (맵 중심 기준)&#10;            w: 벽의 너비&#10;            h: 벽의 높이&#10;        &quot;&quot;&quot;&#10;        self.x = x&#10;        self.y = y&#10;        self.w = w&#10;        self.h = h&#10;&#10;    def check_collision(self, px, py, pw, ph):&#10;        &quot;&quot;&quot;&#10;        플레이어와 벽의 충돌 검사&#10;        Args:&#10;            px: 플레이어 x 좌표&#10;            py: 플레이어 y 좌표&#10;            pw: 플레이어 너비&#10;            ph: 플레이어 높이&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        return (self.x &lt; px + pw and self.x + self.w &gt; px and&#10;                self.y &lt; py + ph and self.y + self.h &gt; py)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;벽은 업데이트가 필요 없음&quot;&quot;&quot;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        벽 디버깅용 그리기 (필요시 주석 해제)&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 x 좌표&#10;            draw_y: 카메라가 적용된 화면 y 좌표&#10;        &quot;&quot;&quot;&#10;        # 디버깅용: 벽을 빨간색으로 표시 (벽 위치 확인용)&#10;        # p2.draw_rectangle(draw_x - self.w/2, draw_y - self.h/2,&#10;        #                   draw_x + self.w/2, draw_y + self.h/2)&#10;        pass&#10;&#10;&#10;def generate_walls_from_png(png_path, block_size=8, map_x=0, map_y=0, map_scale=1.0):&#10;    &quot;&quot;&quot;&#10;    PNG 이미지의 투명 영역을 감지하여 벽 블록 생성&#10;    Args:&#10;        png_path: PNG 이미지 경로&#10;        block_size: 벽 블록의 기본 크기 (픽셀 단위, 스케일 적용 전)&#10;        map_x: 맵의 월드 x 좌표 (중심 기준)&#10;        map_y: 맵의 월드 y 좌표 (중심 기준)&#10;        map_scale: 맵의 스케일&#10;    Returns:&#10;        list: 생성된 PlayModeWall 객체 리스트&#10;    &quot;&quot;&quot;&#10;    print(f&quot;[generate_walls_from_png] 시작: {png_path}&quot;)&#10;    print(f&quot;  - block_size={block_size}, map_x={map_x}, map_y={map_y}, map_scale={map_scale}&quot;)&#10;&#10;    try:&#10;        img = Image.open(png_path).convert('RGBA')&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[generate_walls_from_png] 이미지 열기 실패: {ex}\033[0m&quot;)&#10;        return []&#10;&#10;    width, height = img.size&#10;    walls = []&#10;    pixels = img.load()&#10;    transparent_count = 0&#10;&#10;    # 맵 이미지의 좌상단 기준 좌표 계산 (맵 중심 기준)&#10;    map_left = map_x - (width * map_scale) / 2&#10;    map_bottom = map_y - (height * map_scale) / 2&#10;&#10;    print(f&quot;  - 이미지 크기: {width}x{height}&quot;)&#10;    print(f&quot;  - 맵 좌하단 좌표: ({map_left:.1f}, {map_bottom:.1f})&quot;)&#10;&#10;    # 이미지를 블록 단위로 순회&#10;    for y in range(0, height, block_size):&#10;        for x in range(0, width, block_size):&#10;            is_transparent = False&#10;            # 블록 내부의 픽셀들을 검사&#10;            for dy in range(block_size):&#10;                for dx in range(block_size):&#10;                    if x + dx &lt; width and y + dy &lt; height:&#10;                        _, _, _, alpha = pixels[x + dx, y + dy]&#10;                        if alpha == 0:  # 완전 투명&#10;                            is_transparent = True&#10;                            transparent_count += 1&#10;                            break&#10;                if is_transparent:&#10;                    break&#10;&#10;            # 투명 블록이면 벽 생성&#10;            if is_transparent:&#10;                # 이미지 좌표를 월드 좌표로 변환&#10;                # 이미지 좌표계: 좌상단 (0,0), 우하단 (width, height)&#10;                # 월드 좌표계: 맵 중심 (0,0)&#10;                wall_x_img = x&#10;                wall_y_img = height - y - block_size  # Y축 반전 (이미지는 위에서 아래로, 월드는 아래에서 위로)&#10;&#10;                # 월드 좌표로 변환&#10;                wall_x_world = map_left + wall_x_img * map_scale + (block_size * map_scale) / 2&#10;                wall_y_world = map_bottom + wall_y_img * map_scale + (block_size * map_scale) / 2&#10;&#10;                walls.append(PlayModeWall(&#10;                    wall_x_world,&#10;                    wall_y_world,&#10;                    block_size * map_scale,&#10;                    block_size * map_scale&#10;                ))&#10;&#10;    print(f&quot;  - 투명 픽셀 수: {transparent_count}, 생성된 벽 수: {len(walls)}&quot;)&#10;    return walls&#10;&#10;&#10;def _complete_stage_change():&#10;    &quot;&quot;&quot;로딩이 완료된 후 실제 스테이지 전환을 수행&quot;&quot;&quot;&#10;    global current_stage_index, world, is_stage_cleared, loading_screen, is_loading, next_stage_to_load, camera&#10;&#10;    print(f&quot;[_complete_stage_change] 스테이지 {next_stage_to_load + 1} 로드 시작&quot;)&#10;&#10;    # 현재 스테이지의 몬스터, 배경 등 제거 (플레이어는 유지)&#10;    player = world.get('player')&#10;    world['entities'] = [player] if player else []&#10;    world['bg'].clear()&#10;    world['walls'].clear()  # 벽도 초기화&#10;    # 다른 레이어도 필요에 따라 초기화&#10;    world['effects_back'].clear()&#10;    world['effects_front'].clear()&#10;&#10;    # 다음 스테이지 인덱스로 변경&#10;    current_stage_index = next_stage_to_load&#10;&#10;    # 새 스테이지 로드&#10;    stages[current_stage_index].load(world)&#10;&#10;    # 스테이지 맵에서 벽 생성 (ground 레이어의 첫 번째 객체가 맵이라고 가정)&#10;    try:&#10;        if world['ground'] and len(world['ground']) &gt; 0:&#10;            stage_map = world['ground'][1]&#10;            if hasattr(stage_map, 'image') and hasattr(stage_map, 'x') and hasattr(stage_map, 'y'):&#10;                # 맵 이미지의 경로 가져오기 (StageMap 객체에서)&#10;                next_stage_module = stages[current_stage_index]&#10;                stage_data = getattr(next_stage_module, 'stage_data', None)&#10;&#10;                if stage_data and 'stage_map' in stage_data:&#10;                    map_image_path = stage_data['stage_map']['image']&#10;                    map_scale = getattr(stage_map, 'scale', 1.0)&#10;&#10;                    print(f&quot;[_complete_stage_change] 맵 이미지에서 벽 생성 중...&quot;)&#10;                    wall_blocks = generate_walls_from_png(&#10;                        map_image_path,&#10;                        block_size=8,&#10;                        map_x=stage_map.x,&#10;                        map_y=stage_map.y,&#10;                        map_scale=map_scale&#10;                    )&#10;&#10;                    for wall in wall_blocks:&#10;                        world['walls'].append(wall)&#10;&#10;                    print(f&quot;[_complete_stage_change] {len(wall_blocks)}개의 벽 생성 완료&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[_complete_stage_change] 벽 생성 실패: {ex}\033[0m&quot;)&#10;&#10;    # 플레이어 위치 설정 (스테이지에 PLAYER_START_POSITION이 있으면 사용)&#10;    if player:&#10;        next_stage_module = stages[current_stage_index]&#10;        player_start_pos = getattr(next_stage_module, 'PLAYER_START_POSITION', None)&#10;&#10;        if player_start_pos:&#10;            # 플레이어 위치를 새 스테이지 시작 위치로 설정&#10;            new_x = player_start_pos['x']&#10;            new_y = player_start_pos['y']&#10;            player.x = new_x&#10;            player.y = new_y&#10;            print(f&quot;[_complete_stage_change] 플레이어 위치 설정: ({player.x}, {player.y})&quot;)&#10;        else:&#10;            print(f&quot;[_complete_stage_change] 플레이어 시작 위치 정보 없음, 현재 위치 유지&quot;)&#10;    else:&#10;        print(f'\033[91m[_complete_stage_change] 플레이어 객체 없음\033[0m')&#10;&#10;    # 카메라 초기화 또는 업데이트&#10;    try:&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;        map_width = max_x - min_x&#10;        map_height = max_y - min_y&#10;&#10;        screen_width = p2.get_canvas_width()&#10;        screen_height = p2.get_canvas_height()&#10;&#10;        # 카메라가 없으면 새로 생성 (첫 스테이지)&#10;        if camera is None and player:&#10;            print(f&quot;[_complete_stage_change] 카메라 생성 중...&quot;)&#10;            camera = Camera(player, map_width, map_height, screen_width, screen_height)&#10;            camera.map_offset_x = (min_x + max_x) / 2&#10;            camera.map_offset_y = (min_y + max_y) / 2&#10;            # 카메라를 플레이어 위치로 즉시 동기화&#10;            camera.x = player.x&#10;            camera.y = player.y&#10;            print(f&quot;[_complete_stage_change] 카메라 생성 완료: ({camera.x}, {camera.y})&quot;)&#10;        # 카메라가 이미 있으면 맵 크기만 업데이트&#10;        elif camera is not None:&#10;            camera.map_width = map_width&#10;            camera.map_height = map_height&#10;            camera.map_offset_x = (min_x + max_x) / 2&#10;            camera.map_offset_y = (min_y + max_y) / 2&#10;            # 카메라를 플레이어 위치로 즉시 동기화&#10;            if player:&#10;                camera.x = player.x&#10;                camera.y = player.y&#10;            print(f&quot;[_complete_stage_change] 카메라 업데이트 완료: 맵 크기 {map_width:.1f}x{map_height:.1f}&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[_complete_stage_change] 카메라 초기화/업데이트 실패: {ex}\033[0m&quot;)&#10;&#10;    is_stage_cleared = False&#10;&#10;    # 로딩 화면 종료&#10;    loading_screen = None&#10;    is_loading = False&#10;    next_stage_to_load = None&#10;&#10;    print(f&quot;[_complete_stage_change] Changed to Stage {current_stage_index + 1}&quot;)&#10;&#10;def enter(player=None):&#10;    global world, current_stage_index, is_stage_cleared, loading_screen, is_loading, next_stage_to_load, elapsed_time&#10;    print(&quot;[play_mode] Starting enter()...&quot;)&#10;&#10;    # 경과 시간 초기화&#10;    elapsed_time = 0.0&#10;&#10;    # clear existing&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(f'\033[91m[play_mode] Failed to clear world layer: {k}\033[0m')&#10;&#10;    print(&quot;[play_mode] Creating player...&quot;)&#10;    # create player (use fallback if heavy Player init fails)&#10;    try:&#10;        if player == None:&#10;            player = Player()&#10;        print(&quot;[play_mode] Player created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[play_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#10;        from .inventory import InventoryData, seed_debug_inventory&#10;&#10;        class _FallbackPlayer:&#10;            def __init__(self):&#10;                self.x = 0  # 맵 중심 기준 좌표&#10;                self.y = 0&#10;                self.face_dir = 1&#10;                self.scale_factor = 1.0&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;                self.particles = []&#10;                self.attack_effects = []&#10;                self.inventory = InventoryData(cols=6, rows=5)&#10;                try:&#10;                    seed_debug_inventory(self.inventory)&#10;                except Exception:&#10;                    pass&#10;                self.inventory_open = False&#10;&#10;            def update(self):&#10;                return True&#10;&#10;            def rebuild_inventory_passives(self):&#10;                return&#10;&#10;            def consume_item_at(self, r, c):&#10;                return False&#10;&#10;        player = _FallbackPlayer()&#10;&#10;    print(&quot;[play_mode] Attaching world reference to player...&quot;)&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#10;    try:&#10;        player.world = world&#10;    except Exception:&#10;        pass&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#10;    world['entities'].append(player)&#10;&#10;    print(&quot;[play_mode] Creating inventory overlay...&quot;)&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#10;    try:&#10;        inv = InventoryOverlay(player, world)&#10;        print(&quot;[play_mode] InventoryOverlay created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] InventoryOverlay init failed, creating minimal stub:', ex)&#10;&#10;        class _InvStub:&#10;            def __init__(self, player, world=None):&#10;                self.player = player&#10;                self.world = world&#10;                self.dragging = False&#10;                self.drag_from = None&#10;                self.drag_icon = None&#10;                self.drag_qty = 0&#10;            def handle_event(self, e):&#10;                return&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        inv = _InvStub(player, world)&#10;    world['ui'].append(inv)&#10;&#10;    print(&quot;[play_mode] Creating health bar...&quot;)&#10;    # health bar UI 생성&#10;    try:&#10;        health_bar = HealthBar(player)&#10;        print(&quot;[play_mode] HealthBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] HealthBar init failed, using stub:', ex)&#10;&#10;        class _HealthBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        health_bar = _HealthBarStub(player)&#10;    world['ui'].append(health_bar)&#10;&#10;    print(&quot;[play_mode] Creating mana bar...&quot;)&#10;    # mana bar UI 생성&#10;    try:&#10;        mana_bar = ManaBar(player)&#10;        print(&quot;[play_mode] ManaBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] ManaBar init failed, using stub:', ex)&#10;&#10;        class _ManaBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        mana_bar = _ManaBarStub(player)&#10;    world['ui'].append(mana_bar)&#10;&#10;    print(&quot;[play_mode] Creating dash bar...&quot;)&#10;    # dash bar UI 생성&#10;    try:&#10;        dash_bar = DashBar(player)&#10;        print(&quot;[play_mode] DashBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] DashBar init failed, using stub:', ex)&#10;&#10;        class _DashBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        dash_bar = _DashBarStub(player)&#10;    world['ui'].append(dash_bar)&#10;&#10;    print(&quot;[play_mode] Creating buff indicator...&quot;)&#10;    # buff indicator UI 생성&#10;    try:&#10;        buff_indicator = BuffIndicatorUI(player)&#10;        print(&quot;[play_mode] BuffIndicatorUI created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] BuffIndicatorUI init failed, using stub:', ex)&#10;&#10;        class _BuffIndicatorStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        buff_indicator = _BuffIndicatorStub(player)&#10;    world['ui'].append(buff_indicator)&#10;&#10;    print(&quot;[play_mode] Creating cursor...&quot;)&#10;    # cursor on top (safe fallback)&#10;    try:&#10;        cursor = Cursor(player)&#10;        print(&quot;[play_mode] Cursor created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] Cursor init failed, using stub cursor:', ex)&#10;&#10;        class _CursorStub:&#10;            def __init__(self, player=None):&#10;                self.player = player&#10;                self.x = 0&#10;                self.y = 0&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;            def handle_event(self, e):&#10;                return&#10;&#10;        cursor = _CursorStub(player)&#10;    world['cursor'].append(cursor)&#10;&#10;    # expose world to __main__ for legacy code that looks up main.world&#10;    try:&#10;        import sys&#10;        main_mod = sys.modules.get('__main__')&#10;        if main_mod is not None:&#10;            setattr(main_mod, 'world', world)&#10;    except Exception:&#10;        pass&#10;&#10;    print(&quot;[play_mode] Starting first stage with loading screen...&quot;)&#10;    # 첫 번째 스테이지를 로딩 화면과 함께 시작&#10;    current_stage_index = -1  # change_stage가 0으로 설정할 것임&#10;    is_stage_cleared = False&#10;&#10;    # change_stage 함수를 사용하여 로딩 화면과 함께 첫 스테이지 로드&#10;    change_stage(0)&#10;&#10;    print(f&quot;[play_mode] Entered play_mode, loading Stage 1 with loading screen&quot;)&#10;&#10;    # Camera 초기화는 _complete_stage_change에서 진행됨&#10;&#10;def exit():&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            pass&#10;&#10;&#10;def handle_events():&#10;    import game_framework as app_framework&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            print(&quot;[play_mode] SDL_QUIT event received, quitting application&quot;)&#10;            app_framework.quit()&#10;            return&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#10;            print(&quot;[play_mode] ESCAPE key pressed, quitting application&quot;)&#10;            app_framework.quit()&#10;            return&#10;&#10;        # 페이드인 중일 때는 플레이어 이동 이벤트만 무시하고 나머지는 처리&#10;        if is_fading_to_victory:&#10;            # extras 레이어의 플레이어는 이동 이벤트 무시 (하지만 다른 이벤트는 처리 가능)&#10;            # UI와 커서 이벤트는 처리 (인벤토리 조작 등)&#10;            for o in list(world['ui']):&#10;                try:&#10;                    if hasattr(o, 'handle_event'):&#10;                        o.handle_event(e)&#10;                except Exception:&#10;                    print(f'\033[91m[play_mode] handle_event error in ui {o.__class__.__name__}\033[0m')&#10;                    pass&#10;            for o in list(world['cursor']):&#10;                try:&#10;                    if hasattr(o, 'handle_event'):&#10;                        o.handle_event(e)&#10;                except Exception:&#10;                    print(f'\033[91m[play_mode] handle_event error in cursor {o.__class__.__name__}\033[0m')&#10;                    pass&#10;            # 페이드인 중에는 다음 이벤트로 넘어감 (entities와 extras의 이동 이벤트 무시)&#10;            continue&#10;&#10;        # 일반 게임 플레이 중에는 모든 이벤트 처리&#10;        # broadcast to entities -&gt; extras -&gt; ui -&gt; cursor&#10;        for o in list(world['entities']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in entity {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;        # extras 레이어의 객체들도 이벤트 처리&#10;        for o in list(world['extras']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in extras {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;        for o in list(world['ui']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in ui {o.__class__.__name__}\033[0m')&#10;                pass&#10;        for o in list(world['cursor']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in cursor {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;&#10;def update():&#10;    global is_stage_cleared, loading_screen, is_loading, camera, elapsed_time, is_fading_to_victory, victory_fade_elapsed&#10;&#10;    # 로딩 중이면 로딩 화면만 업데이트&#10;    if is_loading and loading_screen:&#10;        loading_screen.update()&#10;&#10;        # 로딩이 완료되었으면 실제 스테이지 전환&#10;        if loading_screen.is_complete:&#10;            _complete_stage_change()&#10;            print(f'[play_mode] 스테이지 {current_stage_index + 1} 로딩 완료, 전환 완료')&#10;&#10;        return  # 로딩 중에는 게임 로직 업데이트 안 함&#10;&#10;    # 승리 페이드인 중이면 페이드인 타이머만 업데이트&#10;    if is_fading_to_victory:&#10;        dt = game_framework.get_delta_time()&#10;        victory_fade_elapsed += dt&#10;&#10;        # 페이드인이 완료되면 victory_mode로 전환&#10;        if victory_fade_elapsed &gt;= victory_fade_duration:&#10;            print(&quot;[play_mode] 페이드인 완료, victory_mode로 전환&quot;)&#10;            player = world.get('player')&#10;            survival_time = elapsed_time&#10;            game_framework.change_state(victory_mode, player, survival_time)&#10;&#10;        return  # 페이드인 중에는 게임 로직 업데이트 안 함&#10;&#10;    # 경과 시간 누적 (로딩 중이 아닐 때만)&#10;    dt = game_framework.get_delta_time()&#10;    elapsed_time += dt&#10;&#10;    # 카메라 업데이트 추가&#10;    if camera is not None:&#10;        camera.update()&#10;&#10;    # 일반 게임 업데이트&#10;    for layer_name in ['bg', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']:&#10;        new_list = []&#10;        for o in list(world[layer_name]):&#10;            try:&#10;                if hasattr(o, 'update'):&#10;                    alive = o.update()&#10;                    if alive is False:&#10;                        continue&#10;&#10;                # mark_for_removal 플래그 확인&#10;                if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#10;                    print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#10;                    continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#10;&#10;                new_list.append(o)&#10;            except Exception:&#10;                try:&#10;                    new_list.append(o)&#10;                except Exception:&#10;                    print(f'\033[91m[play_mode] update error in layer {layer_name} object {o.__class__.__name__}\033[0m')&#10;                    pass&#10;        world[layer_name][:] = new_list&#10;&#10;    # 충돌 검사 시스템&#10;    player = world.get('player')&#10;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#10;    effects_to_remove = set()&#10;    projectiles_to_remove = set()&#10;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#10;    for effect in world['effects_front']:&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#10;            for entity in world['entities']:&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#10;                    if entity.check_collision_with_effect(effect):&#10;                        # 디버그: 충돌 정보 출력&#10;                        attacker_name = &quot;Player&quot;&#10;                        if hasattr(effect, 'owner'):&#10;                            attacker_name = effect.owner.__class__.__name__&#10;                        target_name = entity.__class__.__name__&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#10;                        pass&#10;&#10;    # 1-2. 몬스터 공격 이펙트와 플레이어 충돌 검사&#10;    # 피격 판정이 필요한 몬스터 공격 이펙트 클래스 리스트&#10;    from .projectile import Projectile&#10;    from .monsters.cat_theif import CatThiefSwingEffect  # CatThiefSwingEffect import 추가&#10;    from .monsters.Boss_Logic.panther_assassin_2pattern import PantherBladeSwingEffect  # PantherBladeSwingEffect import 추가&#10;    from .monsters.Boss_Logic.panther_assassin_3pattern import PantherCombo1SwingEffect&#10;    from .monsters.Boss_Logic.panther_assassin_3pattern import PantherCombo2SwingEffect&#10;&#10;&#10;    MONSTER_ATTACK_EFFECT_TYPES = [&#10;        CatThiefSwingEffect,&#10;        PantherBladeSwingEffect,&#10;        PantherCombo1SwingEffect,&#10;        PantherCombo2SwingEffect,&#10;    ]&#10;&#10;    if player:&#10;        for effect in world['effects_front']:&#10;            # 몬스터 공격 이펙트 타입 체크&#10;            for effect_type in MONSTER_ATTACK_EFFECT_TYPES:&#10;                if isinstance(effect, effect_type):&#10;                    # 이미 맞춘 플레이어는 다시 체크하지 않음 (중복 타격 방지)&#10;                    if not effect.has_hit_player:&#10;                        # 먼저 방패로 방어할 수 있는지 체크&#10;                        shield_blocked = False&#10;                        if hasattr(player, 'shield') and player.shield:&#10;                            if hasattr(player.shield, 'check_effect_block'):&#10;                                if player.shield.check_effect_block(effect):&#10;                                    # 방패로 막았으면 막은 것으로 판별, 이펙트는 지우지 않음&#10;                                    effect.has_hit_player = True&#10;                                    shield_blocked = True&#10;                                    print(f&quot;[COLLISION] Player가 방패로 {effect.__class__.__name__} 방어!&quot;)&#10;&#10;                        # 방패로 막지 못했을 때만 플레이어와 충돌 검사&#10;                        if not shield_blocked:&#10;                            if hasattr(player, 'check_collision_with_effect'):&#10;                                if player.check_collision_with_effect(effect):&#10;                                    # 충돌 시 플레이어 타격 처리&#10;                                    effect.has_hit_player = True&#10;                                    # 디버그: 충돌 정보 출력&#10;                                    attacker_name = &quot;Unknown&quot;&#10;                                    if hasattr(effect, 'owner') and effect.owner:&#10;                                        attacker_name = effect.owner.__class__.__name__&#10;                                    print(f&quot;[COLLISION] {attacker_name} {effect.__class__.__name__} -&gt; Player 피격!&quot;)&#10;&#10;                    # 해당 타입으로 확인되면 다른 타입 체크는 불필요&#10;                    break&#10;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#10;    if player:&#10;        for projectile in world['effects_front']:&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#10;            if isinstance(projectile, Projectile):&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#10;                if not projectile.from_player:&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#10;                        if player.check_collision_with_projectile(projectile):&#10;                            # 디버그: 충돌 정보 출력&#10;                            attacker_name = &quot;Unknown&quot;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#10;                                attacker_name = projectile.owner.__class__.__name__&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#10;                            projectiles_to_remove.add(projectile)&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#10;                else:&#10;                    for entity in world['entities']:&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#10;                            if entity.check_collision_with_projectile(projectile):&#10;                                # 디버그: 충돌 정보 출력&#10;                                target_name = entity.__class__.__name__&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#10;                                projectiles_to_remove.add(projectile)&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#10;&#10;    # 충돌한 투사체 제거&#10;    if projectiles_to_remove:&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#10;&#10;    # 스테이지 클리어 조건 확인 (몬스터가 모두 제거되었는지)&#10;    # 'entities' 레이어에 플레이어만 남아있는지 확인합니다.&#10;    if not is_stage_cleared and len(world['entities']) == 1 and world.get('player') in world['entities']:&#10;        # 이전에 몬스터가 1마리 이상 있었는지 확인하는 조건이 필요할 수 있습니다.&#10;        # 여기서는 간단히 몬스터가 없으면 클리어로 간주합니다.&#10;        print(&quot;Stage cleared!&quot;)&#10;        is_stage_cleared = True # 중복 호출 방지&#10;        change_stage(current_stage_index + 1)&#10;&#10;&#10;def draw():&#10;    global camera, victory_fade_image, victory_fade_elapsed, victory_fade_duration&#10;    p2.clear_canvas()&#10;&#10;    # 로딩 중이면 로딩 화면만 그리기&#10;    if is_loading and loading_screen:&#10;        loading_screen.draw()&#10;    else:&#10;        # 일반 게임 화면 그리기&#10;        # 1. FixedBackground 먼저 그리기 (카메라 영향 없음)&#10;        from .background import FixedBackground&#10;        from .equipment import ShieldRangeEffect&#10;&#10;        for o in world['bg']:&#10;            if isinstance(o, FixedBackground):&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        o.draw()  # FixedBackground는 인자 없이 호출&#10;                except Exception as ex:&#10;                    print(f'\033[91m[play_mode] FixedBackground 그리기 오류: {ex}\033[0m')&#10;                    pass&#10;&#10;        # 2. 나머지 객체들은 카메라 좌표 적용하여 그리기&#10;        for layer_name in ['bg', 'walls', 'upper_ground', 'effects_back', 'entities', 'effects_front', 'extra_bg', 'extras']:&#10;            for o in world[layer_name]:&#10;                # FixedBackground는 이미 그렸으므로 스킵&#10;                if isinstance(o, FixedBackground):&#10;                    continue&#10;&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        # ShieldRangeEffect는 특별 처리 (플레이어 위치 기준)&#10;                        if isinstance(o, ShieldRangeEffect):&#10;                            if hasattr(o, 'player') and o.player:&#10;                                if camera is not None:&#10;                                    draw_x, draw_y = camera.apply(o.player.x, o.player.y)&#10;                                else:&#10;                                    draw_x, draw_y = o.player.x, o.player.y&#10;                                o.draw(draw_x, draw_y)&#10;                        # x, y 속성이 있는 객체는 카메라 좌표로 변환하여 그리기&#10;                        elif hasattr(o, 'x') and hasattr(o, 'y'):&#10;                            if camera is not None:&#10;                                draw_x, draw_y = camera.apply(o.x, o.y)&#10;                            else:&#10;                                draw_x, draw_y = o.x, o.y&#10;                            o.draw(draw_x, draw_y)&#10;                        else:&#10;                            # x, y 속성이 없는 객체는 그대로 그리기&#10;                            o.draw()&#10;                except Exception as ex:&#10;                    print(f'\033[91m[play_mode] {layer_name} 레이어의 {o.__class__.__name__} 그리기 오류: {ex}\033[0m')&#10;                    pass&#10;&#10;        # 3. UI와 커서는 카메라 적용하지 않음 (고정 UI)&#10;        for o in world['ui']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[play_mode] UI 레이어의 {o.__class__.__name__} 그리기 오류 : {ex}\033[0m')&#10;                pass&#10;&#10;        for o in world['cursor']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[play_mode] Cursor 레이어의 {o.__class__.__name__} 그리기 오류 : {ex}\033[0m')&#10;                pass&#10;&#10;        # 4. 승리 페이드인 효과 그리기 (기존 화면 위에 오버레이)&#10;        if is_fading_to_victory and victory_fade_image:&#10;            canvas_w = p2.get_canvas_width()&#10;            canvas_h = p2.get_canvas_height()&#10;&#10;            # 페이드인 진행률 계산 (0.0 ~ 1.0)&#10;            fade_progress = min(victory_fade_elapsed / victory_fade_duration, 1.0)&#10;&#10;            # 이미지 투명도 설정 및 그리기&#10;            victory_fade_image.opacify(fade_progress)&#10;            victory_fade_image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)&#10;&#10;    p2.update_canvas()&#10;" />
              <option name="updatedContent" value="# game_logic.play_mode: play mode state that creates Player, InventoryOverlay, Cursor&#10;# minimal, compatible with existing game_logic modules&#10;import pico2d as p2&#10;from sdl2 import SDL_QUIT, SDL_KEYDOWN, SDLK_ESCAPE&#10;from PIL import Image&#10;&#10;import game_framework&#10;from .player import Player&#10;from .ui_overlay import InventoryOverlay, HealthBar, ManaBar, DashBar, BuffIndicatorUI&#10;from .cursor import Cursor&#10;from .loading_screen import LoadingScreen&#10;from . import defeat_mode, victory_mode&#10;# 사용할 스테이지 모듈들을 import 합니다.&#10;from .stages import stage_1, stage_2, stage_3&#10;&#10;# world layers: keep same keys as original main.py&#10;world = {&#10;    'ground': [],&#10;    'upper_ground': [],&#10;    'walls': [],&#10;    'effects_back': [],&#10;    'entities': [],&#10;    'effects_front': [],&#10;    'ui': [],&#10;    'extra_bg': [],&#10;    'extras': [],&#10;    'cursor': []&#10;}&#10;world['bg'] = world['ground']&#10;&#10;# 스테이지 관리&#10;# stages = [stage_1, stage_2, stage_3]&#10;# stages = [stage_1]&#10;# stages = [stage_2]&#10;stages = [stage_3]&#10;current_stage_index = 0&#10;is_stage_cleared = False&#10;&#10;# 로딩 화면 관리&#10;loading_screen = None&#10;is_loading = False&#10;next_stage_to_load = None&#10;&#10;# 경과 시간 추적 (play_mode 진입 후 경과 시간)&#10;elapsed_time = 0.0&#10;&#10;# 승리 페이드인 효과 관련 변수&#10;is_fading_to_victory = False  # 승리 페이드인 진행 중 플래그&#10;victory_fade_elapsed = 0.0    # 페이드인 경과 시간&#10;victory_fade_duration = 3.0   # 페이드인 지속 시간 (3초)&#10;victory_fade_image = None     # 페이드인 이미지&#10;&#10;&#10;class Camera:&#10;    &quot;&quot;&quot;&#10;    플레이어를 부드럽게 따라가는 카메라 클래스&#10;    맵의 경계를 넘지 않도록 제한하며, 화면 중앙을 (0,0)으로 하는 좌표계 사용&#10;    &quot;&quot;&quot;&#10;    def __init__(self, target, map_width, map_height, screen_width, screen_height):&#10;        &quot;&quot;&quot;&#10;        카메라 초기화&#10;        Args:&#10;            target: 카메라가 따라갈 대상 (일반적으로 플레이어)&#10;            map_width: 맵의 전체 너비&#10;            map_height: 맵의 전체 높이&#10;            screen_width: 화면 너비&#10;            screen_height: 화면 높이&#10;        &quot;&quot;&quot;&#10;        self.target = target&#10;        self.x = target.x&#10;        self.y = target.y&#10;        self.map_width = map_width&#10;        self.map_height = map_height&#10;        self.screen_width = screen_width&#10;        self.screen_height = screen_height&#10;        self.smooth = 0.1  # 부드러운 이동 정도 (0~1, 낮을수록 부드럽고 느림)&#10;&#10;        # 맵 오프셋 (배경의 중심점, calculate_background_bounds에서 설정)&#10;        self.map_offset_x = 0&#10;        self.map_offset_y = 0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        카메라 위치 업데이트 - 타겟을 부드럽게 따라가며 맵 경계 내로 제한&#10;        &quot;&quot;&quot;&#10;        # 플레이어 위치를 부드럽게 따라감 (LERP - Linear Interpolation)&#10;        target_x = self.target.x&#10;        target_y = self.target.y&#10;        self.x += (target_x - self.x) * self.smooth&#10;        self.y += (target_y - self.y) * self.smooth&#10;&#10;        # 화면의 중앙이 (0,0)이 되도록 카메라 위치 보정&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;&#10;        # 맵의 중심이 (0,0) 기준이므로, 카메라의 x, y가 -map_width/2 ~ map_width/2 범위로 제한&#10;        min_x = -self.map_width/2&#10;        max_x = self.map_width/2&#10;        min_y = -self.map_height/2&#10;        max_y = self.map_height/2&#10;&#10;        self.x = max(min_x, min(self.x, max_x))&#10;        self.y = max(min_y, min(self.y, max_y))&#10;&#10;        # 만약 맵이 화면보다 작으면 중앙에 고정&#10;        if self.map_width &lt;= self.screen_width:&#10;            self.x = 0&#10;        if self.map_height &lt;= self.screen_height:&#10;            self.y = 0&#10;&#10;    def apply(self, obj_x, obj_y):&#10;        &quot;&quot;&quot;&#10;        카메라 위치에 따라 오브젝트의 화면 좌표 계산&#10;        Args:&#10;            obj_x: 오브젝트의 월드 x 좌표 (맵 중심 기준)&#10;            obj_y: 오브젝트의 월드 y 좌표 (맵 중심 기준)&#10;        Returns:&#10;            tuple: (draw_x, draw_y) - 화면에 그릴 좌표&#10;        &quot;&quot;&quot;&#10;        half_w = self.screen_width // 2&#10;        half_h = self.screen_height // 2&#10;        return obj_x - self.x + half_w, obj_y - self.y + half_h&#10;&#10;&#10;# Camera 객체를 전역으로 선언&#10;camera = None&#10;&#10;&#10;def calculate_background_bounds():&#10;    &quot;&quot;&quot;&#10;    ground 레이어의 모든 배경 객체들의 실제 범위를 계산합니다.&#10;    모든 배경 이미지를 고려하여 최소/최대 x, y 좌표를 반환합니다.&#10;&#10;    Returns:&#10;        tuple: (min_x, max_x, min_y, max_y) - 배경이 존재하는 실제 영역의 경계&#10;    &quot;&quot;&quot;&#10;    min_x = float('inf')&#10;    max_x = float('-inf')&#10;    min_y = float('inf')&#10;    max_y = float('-inf')&#10;&#10;    # ground 레이어의 모든 객체를 순회&#10;    for obj in world['ground']:&#10;        # 객체가 x, y, image 속성을 가지고 있는지 확인&#10;        if hasattr(obj, 'x') and hasattr(obj, 'y') and hasattr(obj, 'image'):&#10;            # 객체의 중심 좌표&#10;            obj_x = obj.x&#10;            obj_y = obj.y&#10;&#10;            # 이미지 크기 계산 (scale 속성이 있으면 적용)&#10;            scale = getattr(obj, 'scale', 1.0)&#10;            img_width = obj.image.w * scale&#10;            img_height = obj.image.h * scale&#10;&#10;            # 객체의 경계 계산 (중심 기준이므로 절반씩)&#10;            obj_left = obj_x - img_width / 2&#10;            obj_right = obj_x + img_width / 2&#10;            obj_bottom = obj_y - img_height / 2&#10;            obj_top = obj_y + img_height / 2&#10;&#10;            # 최소/최대 값 업데이트&#10;            min_x = min(min_x, obj_left)&#10;            max_x = max(max_x, obj_right)&#10;            min_y = min(min_y, obj_bottom)&#10;            max_y = max(max_y, obj_top)&#10;&#10;    # 유효한 범위가 계산되지 않은 경우 기본값 반환 (1280x720 화면 기준)&#10;    if min_x == float('inf') or max_x == float('-inf'):&#10;        print(&quot;[WARNING] 배경 범위 계산 실패, 기본값 사용&quot;)&#10;        return (-640, 640, -360, 360)&#10;&#10;    print(f&quot;[play_mode] 계산된 배경 범위: X({min_x:.1f} ~ {max_x:.1f}), Y({min_y:.1f} ~ {max_y:.1f})&quot;)&#10;    return (min_x, max_x, min_y, max_y)&#10;&#10;&#10;def change_stage(next_stage_index):&#10;    &quot;&quot;&quot;다음 스테이지로 변경하는 함수&quot;&quot;&quot;&#10;    global current_stage_index, loading_screen, is_loading, next_stage_to_load, is_fading_to_victory, victory_fade_elapsed, victory_fade_image&#10;&#10;    # 다음 스테이지 인덱스 확인&#10;    if next_stage_index &gt;= len(stages):&#10;        # 모든 스테이지 클리어 시 페이드인 효과 시작&#10;        print(&quot;All stages cleared! Starting fade-in effect...&quot;)&#10;        is_fading_to_victory = True&#10;        victory_fade_elapsed = 0.0&#10;&#10;        # 플레이어를 entities에서 extras 레이어로 즉시 이동&#10;        player = world.get('player')&#10;        if player and player in world['entities']:&#10;            world['entities'].remove(player)&#10;            world['extras'].append(player)&#10;            print(&quot;[change_stage] 플레이어를 extras 레이어로 이동&quot;)&#10;&#10;        # 페이드인 이미지 로드&#10;        try:&#10;            victory_fade_image = p2.load_image('resources/Texture_organize/IDK_2/Square.png')&#10;            print(&quot;[change_stage] 승리 페이드인 이미지 로드 성공&quot;)&#10;        except Exception as ex:&#10;            print(f'\033[91m[change_stage] 승리 페이드인 이미지 로드 실패: {ex}\033[0m')&#10;            victory_fade_image = None&#10;&#10;        return&#10;&#10;    # 로딩 화면 시작 - 스테이지 모듈의 LOADING_SCREEN_INFO 사용&#10;    next_stage_module = stages[next_stage_index]&#10;    loading_info = getattr(next_stage_module, 'LOADING_SCREEN_INFO', None)&#10;&#10;    if loading_info:&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1} 로딩 화면 시작&quot;)&#10;        loading_screen = LoadingScreen(loading_info)&#10;        is_loading = True&#10;        next_stage_to_load = next_stage_index&#10;    else:&#10;        # LOADING_SCREEN_INFO가 없으면 로딩 화면 없이 바로 전환&#10;        print(f&quot;[change_stage] 스테이지 {next_stage_index + 1}에 로딩 화면 정보 없음, 즉시 전환&quot;)&#10;        next_stage_to_load = next_stage_index&#10;        _complete_stage_change()&#10;&#10;&#10;class PlayModeWall:&#10;    &quot;&quot;&quot;플레이 모드에서 사용하는 벽 클래스 (투명 영역 감지용)&quot;&quot;&quot;&#10;    def __init__(self, x, y, w, h):&#10;        &quot;&quot;&quot;&#10;        벽 초기화&#10;        Args:&#10;            x: 벽의 월드 x 좌표 (맵 중심 기준)&#10;            y: 벽의 월드 y 좌표 (맵 중심 기준)&#10;            w: 벽의 너비&#10;            h: 벽의 높이&#10;        &quot;&quot;&quot;&#10;        self.x = x&#10;        self.y = y&#10;        self.w = w&#10;        self.h = h&#10;&#10;    def check_collision(self, px, py, pw, ph):&#10;        &quot;&quot;&quot;&#10;        플레이어와 벽의 충돌 검사&#10;        Args:&#10;            px: 플레이어 x 좌표&#10;            py: 플레이어 y 좌표&#10;            pw: 플레이어 너비&#10;            ph: 플레이어 높이&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        return (self.x &lt; px + pw and self.x + self.w &gt; px and&#10;                self.y &lt; py + ph and self.y + self.h &gt; py)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;벽은 업데이트가 필요 없음&quot;&quot;&quot;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        벽 디버깅용 그리기 (필요시 주석 해제)&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 x 좌표&#10;            draw_y: 카메라가 적용된 화면 y 좌표&#10;        &quot;&quot;&quot;&#10;        # 디버깅용: 벽을 빨간색으로 표시 (벽 위치 확인용)&#10;        # p2.draw_rectangle(draw_x - self.w/2, draw_y - self.h/2,&#10;        #                   draw_x + self.w/2, draw_y + self.h/2)&#10;        pass&#10;&#10;&#10;def generate_walls_from_png(png_path, block_size=8, map_x=0, map_y=0, map_scale=1.0):&#10;    &quot;&quot;&quot;&#10;    PNG 이미지의 투명 영역을 감지하여 벽 블록 생성&#10;    Args:&#10;        png_path: PNG 이미지 경로&#10;        block_size: 벽 블록의 기본 크기 (픽셀 단위, 스케일 적용 전)&#10;        map_x: 맵의 월드 x 좌표 (중심 기준)&#10;        map_y: 맵의 월드 y 좌표 (중심 기준)&#10;        map_scale: 맵의 스케일&#10;    Returns:&#10;        list: 생성된 PlayModeWall 객체 리스트&#10;    &quot;&quot;&quot;&#10;    print(f&quot;[generate_walls_from_png] 시작: {png_path}&quot;)&#10;    print(f&quot;  - block_size={block_size}, map_x={map_x}, map_y={map_y}, map_scale={map_scale}&quot;)&#10;&#10;    try:&#10;        img = Image.open(png_path).convert('RGBA')&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[generate_walls_from_png] 이미지 열기 실패: {ex}\033[0m&quot;)&#10;        return []&#10;&#10;    width, height = img.size&#10;    walls = []&#10;    pixels = img.load()&#10;    transparent_count = 0&#10;&#10;    # 맵 이미지의 좌상단 기준 좌표 계산 (맵 중심 기준)&#10;    map_left = map_x - (width * map_scale) / 2&#10;    map_bottom = map_y - (height * map_scale) / 2&#10;&#10;    print(f&quot;  - 이미지 크기: {width}x{height}&quot;)&#10;    print(f&quot;  - 맵 좌하단 좌표: ({map_left:.1f}, {map_bottom:.1f})&quot;)&#10;&#10;    # 이미지를 블록 단위로 순회&#10;    for y in range(0, height, block_size):&#10;        for x in range(0, width, block_size):&#10;            is_transparent = False&#10;            # 블록 내부의 픽셀들을 검사&#10;            for dy in range(block_size):&#10;                for dx in range(block_size):&#10;                    if x + dx &lt; width and y + dy &lt; height:&#10;                        _, _, _, alpha = pixels[x + dx, y + dy]&#10;                        if alpha == 0:  # 완전 투명&#10;                            is_transparent = True&#10;                            transparent_count += 1&#10;                            break&#10;                if is_transparent:&#10;                    break&#10;&#10;            # 투명 블록이면 벽 생성&#10;            if is_transparent:&#10;                # 이미지 좌표를 월드 좌표로 변환&#10;                # 이미지 좌표계: 좌상단 (0,0), 우하단 (width, height)&#10;                # 월드 좌표계: 맵 중심 (0,0)&#10;                wall_x_img = x&#10;                wall_y_img = height - y - block_size  # Y축 반전 (이미지는 위에서 아래로, 월드는 아래에서 위로)&#10;&#10;                # 월드 좌표로 변환&#10;                wall_x_world = map_left + wall_x_img * map_scale + (block_size * map_scale) / 2&#10;                wall_y_world = map_bottom + wall_y_img * map_scale + (block_size * map_scale) / 2&#10;&#10;                walls.append(PlayModeWall(&#10;                    wall_x_world,&#10;                    wall_y_world,&#10;                    block_size * map_scale,&#10;                    block_size * map_scale&#10;                ))&#10;&#10;    print(f&quot;  - 투명 픽셀 수: {transparent_count}, 생성된 벽 수: {len(walls)}&quot;)&#10;    return walls&#10;&#10;&#10;def _complete_stage_change():&#10;    &quot;&quot;&quot;로딩이 완료된 후 실제 스테이지 전환을 수행&quot;&quot;&quot;&#10;    global current_stage_index, world, is_stage_cleared, loading_screen, is_loading, next_stage_to_load, camera&#10;&#10;    print(f&quot;[_complete_stage_change] 스테이지 {next_stage_to_load + 1} 로드 시작&quot;)&#10;&#10;    # 현재 스테이지의 몬스터, 배경 등 제거 (플레이어는 유지)&#10;    player = world.get('player')&#10;    world['entities'] = [player] if player else []&#10;    world['bg'].clear()&#10;    world['walls'].clear()  # 벽도 초기화&#10;    # 다른 레이어도 필요에 따라 초기화&#10;    world['effects_back'].clear()&#10;    world['effects_front'].clear()&#10;&#10;    # 다음 스테이지 인덱스로 변경&#10;    current_stage_index = next_stage_to_load&#10;&#10;    # 새 스테이지 로드&#10;    stages[current_stage_index].load(world)&#10;&#10;    # 스테이지 맵에서 벽 생성 (ground 레이어의 첫 번째 객체가 맵이라고 가정)&#10;    try:&#10;        if world['ground'] and len(world['ground']) &gt; 0:&#10;            stage_map = world['ground'][1]&#10;            if hasattr(stage_map, 'image') and hasattr(stage_map, 'x') and hasattr(stage_map, 'y'):&#10;                # 맵 이미지의 경로 가져오기 (StageMap 객체에서)&#10;                next_stage_module = stages[current_stage_index]&#10;                stage_data = getattr(next_stage_module, 'stage_data', None)&#10;&#10;                if stage_data and 'stage_map' in stage_data:&#10;                    map_image_path = stage_data['stage_map']['image']&#10;                    map_scale = getattr(stage_map, 'scale', 1.0)&#10;&#10;                    print(f&quot;[_complete_stage_change] 맵 이미지에서 벽 생성 중...&quot;)&#10;                    wall_blocks = generate_walls_from_png(&#10;                        map_image_path,&#10;                        block_size=8,&#10;                        map_x=stage_map.x,&#10;                        map_y=stage_map.y,&#10;                        map_scale=map_scale&#10;                    )&#10;&#10;                    for wall in wall_blocks:&#10;                        world['walls'].append(wall)&#10;&#10;                    print(f&quot;[_complete_stage_change] {len(wall_blocks)}개의 벽 생성 완료&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[_complete_stage_change] 벽 생성 실패: {ex}\033[0m&quot;)&#10;&#10;    # 플레이어 위치 설정 (스테이지에 PLAYER_START_POSITION이 있으면 사용)&#10;    if player:&#10;        next_stage_module = stages[current_stage_index]&#10;        player_start_pos = getattr(next_stage_module, 'PLAYER_START_POSITION', None)&#10;&#10;        if player_start_pos:&#10;            # 플레이어 위치를 새 스테이지 시작 위치로 설정&#10;            new_x = player_start_pos['x']&#10;            new_y = player_start_pos['y']&#10;            player.x = new_x&#10;            player.y = new_y&#10;            print(f&quot;[_complete_stage_change] 플레이어 위치 설정: ({player.x}, {player.y})&quot;)&#10;        else:&#10;            print(f&quot;[_complete_stage_change] 플레이어 시작 위치 정보 없음, 현재 위치 유지&quot;)&#10;    else:&#10;        print(f'\033[91m[_complete_stage_change] 플레이어 객체 없음\033[0m')&#10;&#10;    # 카메라 초기화 또는 업데이트&#10;    try:&#10;        min_x, max_x, min_y, max_y = calculate_background_bounds()&#10;        map_width = max_x - min_x&#10;        map_height = max_y - min_y&#10;&#10;        screen_width = p2.get_canvas_width()&#10;        screen_height = p2.get_canvas_height()&#10;&#10;        # 카메라가 없으면 새로 생성 (첫 스테이지)&#10;        if camera is None and player:&#10;            print(f&quot;[_complete_stage_change] 카메라 생성 중...&quot;)&#10;            camera = Camera(player, map_width, map_height, screen_width, screen_height)&#10;            camera.map_offset_x = (min_x + max_x) / 2&#10;            camera.map_offset_y = (min_y + max_y) / 2&#10;            # 카메라를 플레이어 위치로 즉시 동기화&#10;            camera.x = player.x&#10;            camera.y = player.y&#10;            print(f&quot;[_complete_stage_change] 카메라 생성 완료: ({camera.x}, {camera.y})&quot;)&#10;        # 카메라가 이미 있으면 맵 크기만 업데이트&#10;        elif camera is not None:&#10;            camera.map_width = map_width&#10;            camera.map_height = map_height&#10;            camera.map_offset_x = (min_x + max_x) / 2&#10;            camera.map_offset_y = (min_y + max_y) / 2&#10;            # 카메라를 플레이어 위치로 즉시 동기화&#10;            if player:&#10;                camera.x = player.x&#10;                camera.y = player.y&#10;            print(f&quot;[_complete_stage_change] 카메라 업데이트 완료: 맵 크기 {map_width:.1f}x{map_height:.1f}&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[_complete_stage_change] 카메라 초기화/업데이트 실패: {ex}\033[0m&quot;)&#10;&#10;    is_stage_cleared = False&#10;&#10;    # 로딩 화면 종료&#10;    loading_screen = None&#10;    is_loading = False&#10;    next_stage_to_load = None&#10;&#10;    print(f&quot;[_complete_stage_change] Changed to Stage {current_stage_index + 1}&quot;)&#10;&#10;def enter(player=None):&#10;    global world, current_stage_index, is_stage_cleared, loading_screen, is_loading, next_stage_to_load, elapsed_time&#10;    print(&quot;[play_mode] Starting enter()...&quot;)&#10;&#10;    # 경과 시간 초기화&#10;    elapsed_time = 0.0&#10;&#10;    # clear existing&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            print(f'\033[91m[play_mode] Failed to clear world layer: {k}\033[0m')&#10;&#10;    print(&quot;[play_mode] Creating player...&quot;)&#10;    # create player (use fallback if heavy Player init fails)&#10;    try:&#10;        if player == None:&#10;            player = Player()&#10;        print(&quot;[play_mode] Player created successfully&quot;)&#10;    except Exception as ex:&#10;        print(f&quot;\033[91m[play_mode] Player initialization failed, using lightweight fallback: {ex}\033[0m&quot;)&#10;        from .inventory import InventoryData, seed_debug_inventory&#10;&#10;        class _FallbackPlayer:&#10;            def __init__(self):&#10;                self.x = 0  # 맵 중심 기준 좌표&#10;                self.y = 0&#10;                self.face_dir = 1&#10;                self.scale_factor = 1.0&#10;                self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;                self.particles = []&#10;                self.attack_effects = []&#10;                self.inventory = InventoryData(cols=6, rows=5)&#10;                try:&#10;                    seed_debug_inventory(self.inventory)&#10;                except Exception:&#10;                    pass&#10;                self.inventory_open = False&#10;&#10;            def update(self):&#10;                return True&#10;&#10;            def rebuild_inventory_passives(self):&#10;                return&#10;&#10;            def consume_item_at(self, r, c):&#10;                return False&#10;&#10;        player = _FallbackPlayer()&#10;&#10;    print(&quot;[play_mode] Attaching world reference to player...&quot;)&#10;    # attach a reference to the current world so player and callbacks can access/modify it&#10;    try:&#10;        player.world = world&#10;    except Exception:&#10;        pass&#10;    world['player'] = player # 플레이어를 world에 명시적으로 저장&#10;    world['entities'].append(player)&#10;&#10;    print(&quot;[play_mode] Creating inventory overlay...&quot;)&#10;    # inventory overlay: pass world reference so InventoryOverlay can spawn WorldItem into this world&#10;    try:&#10;        inv = InventoryOverlay(player, world)&#10;        print(&quot;[play_mode] InventoryOverlay created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] InventoryOverlay init failed, creating minimal stub:', ex)&#10;&#10;        class _InvStub:&#10;            def __init__(self, player, world=None):&#10;                self.player = player&#10;                self.world = world&#10;                self.dragging = False&#10;                self.drag_from = None&#10;                self.drag_icon = None&#10;                self.drag_qty = 0&#10;            def handle_event(self, e):&#10;                return&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        inv = _InvStub(player, world)&#10;    world['ui'].append(inv)&#10;&#10;    print(&quot;[play_mode] Creating health bar...&quot;)&#10;    # health bar UI 생성&#10;    try:&#10;        health_bar = HealthBar(player)&#10;        print(&quot;[play_mode] HealthBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] HealthBar init failed, using stub:', ex)&#10;&#10;        class _HealthBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        health_bar = _HealthBarStub(player)&#10;    world['ui'].append(health_bar)&#10;&#10;    print(&quot;[play_mode] Creating mana bar...&quot;)&#10;    # mana bar UI 생성&#10;    try:&#10;        mana_bar = ManaBar(player)&#10;        print(&quot;[play_mode] ManaBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] ManaBar init failed, using stub:', ex)&#10;&#10;        class _ManaBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        mana_bar = _ManaBarStub(player)&#10;    world['ui'].append(mana_bar)&#10;&#10;    print(&quot;[play_mode] Creating dash bar...&quot;)&#10;    # dash bar UI 생성&#10;    try:&#10;        dash_bar = DashBar(player)&#10;        print(&quot;[play_mode] DashBar created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] DashBar init failed, using stub:', ex)&#10;&#10;        class _DashBarStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        dash_bar = _DashBarStub(player)&#10;    world['ui'].append(dash_bar)&#10;&#10;    print(&quot;[play_mode] Creating buff indicator...&quot;)&#10;    # buff indicator UI 생성&#10;    try:&#10;        buff_indicator = BuffIndicatorUI(player)&#10;        print(&quot;[play_mode] BuffIndicatorUI created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] BuffIndicatorUI init failed, using stub:', ex)&#10;&#10;        class _BuffIndicatorStub:&#10;            def __init__(self, player):&#10;                self.player = player&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;&#10;        buff_indicator = _BuffIndicatorStub(player)&#10;    world['ui'].append(buff_indicator)&#10;&#10;    print(&quot;[play_mode] Creating cursor...&quot;)&#10;    # cursor on top (safe fallback)&#10;    try:&#10;        cursor = Cursor(player)&#10;        print(&quot;[play_mode] Cursor created successfully&quot;)&#10;    except Exception as ex:&#10;        print('[play_mode] Cursor init failed, using stub cursor:', ex)&#10;&#10;        class _CursorStub:&#10;            def __init__(self, player=None):&#10;                self.player = player&#10;                self.x = 0&#10;                self.y = 0&#10;            def update(self):&#10;                return&#10;            def draw(self):&#10;                return&#10;            def handle_event(self, e):&#10;                return&#10;&#10;        cursor = _CursorStub(player)&#10;    world['cursor'].append(cursor)&#10;&#10;    # expose world to __main__ for legacy code that looks up main.world&#10;    try:&#10;        import sys&#10;        main_mod = sys.modules.get('__main__')&#10;        if main_mod is not None:&#10;            setattr(main_mod, 'world', world)&#10;    except Exception:&#10;        pass&#10;&#10;    print(&quot;[play_mode] Starting first stage with loading screen...&quot;)&#10;    # 첫 번째 스테이지를 로딩 화면과 함께 시작&#10;    current_stage_index = -1  # change_stage가 0으로 설정할 것임&#10;    is_stage_cleared = False&#10;&#10;    # change_stage 함수를 사용하여 로딩 화면과 함께 첫 스테이지 로드&#10;    change_stage(0)&#10;&#10;    print(f&quot;[play_mode] Entered play_mode, loading Stage 1 with loading screen&quot;)&#10;&#10;    # Camera 초기화는 _complete_stage_change에서 진행됨&#10;&#10;def exit():&#10;    for k in list(world.keys()):&#10;        try:&#10;            if isinstance(world[k], list):&#10;                world[k].clear()&#10;        except Exception:&#10;            pass&#10;&#10;&#10;def handle_events():&#10;    import game_framework as app_framework&#10;    events = p2.get_events()&#10;    for e in events:&#10;        if e.type == SDL_QUIT:&#10;            print(&quot;[play_mode] SDL_QUIT event received, quitting application&quot;)&#10;            app_framework.quit()&#10;            return&#10;        if e.type == SDL_KEYDOWN and getattr(e, 'key', None) == SDLK_ESCAPE:&#10;            print(&quot;[play_mode] ESCAPE key pressed, quitting application&quot;)&#10;            app_framework.quit()&#10;            return&#10;&#10;        # 페이드인 중일 때는 플레이어 이동 이벤트만 무시하고 나머지는 처리&#10;        if is_fading_to_victory:&#10;            # extras 레이어의 플레이어는 이동 이벤트 무시 (하지만 다른 이벤트는 처리 가능)&#10;            # UI와 커서 이벤트는 처리 (인벤토리 조작 등)&#10;            for o in list(world['ui']):&#10;                try:&#10;                    if hasattr(o, 'handle_event'):&#10;                        o.handle_event(e)&#10;                except Exception:&#10;                    print(f'\033[91m[play_mode] handle_event error in ui {o.__class__.__name__}\033[0m')&#10;                    pass&#10;            for o in list(world['cursor']):&#10;                try:&#10;                    if hasattr(o, 'handle_event'):&#10;                        o.handle_event(e)&#10;                except Exception:&#10;                    print(f'\033[91m[play_mode] handle_event error in cursor {o.__class__.__name__}\033[0m')&#10;                    pass&#10;            # 페이드인 중에는 다음 이벤트로 넘어감 (entities와 extras의 이동 이벤트 무시)&#10;            continue&#10;&#10;        # 일반 게임 플레이 중에는 모든 이벤트 처리&#10;        # broadcast to entities -&gt; extras -&gt; ui -&gt; cursor&#10;        for o in list(world['entities']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in entity {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;        # extras 레이어의 객체들도 이벤트 처리&#10;        for o in list(world['extras']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in extras {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;        for o in list(world['ui']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in ui {o.__class__.__name__}\033[0m')&#10;                pass&#10;        for o in list(world['cursor']):&#10;            try:&#10;                if hasattr(o, 'handle_event'):&#10;                    o.handle_event(e)&#10;            except Exception:&#10;                print(f'\033[91m[play_mode] handle_event error in cursor {o.__class__.__name__}\033[0m')&#10;                pass&#10;&#10;&#10;def update():&#10;    global is_stage_cleared, loading_screen, is_loading, camera, elapsed_time, is_fading_to_victory, victory_fade_elapsed&#10;&#10;    # 로딩 중이면 로딩 화면만 업데이트&#10;    if is_loading and loading_screen:&#10;        loading_screen.update()&#10;&#10;        # 로딩이 완료되었으면 실제 스테이지 전환&#10;        if loading_screen.is_complete:&#10;            _complete_stage_change()&#10;            print(f'[play_mode] 스테이지 {current_stage_index + 1} 로딩 완료, 전환 완료')&#10;&#10;        return  # 로딩 중에는 게임 로직 업데이트 안 함&#10;&#10;    # 승리 페이드인 중이면 페이드인 타이머만 업데이트&#10;    if is_fading_to_victory:&#10;        dt = game_framework.get_delta_time()&#10;        victory_fade_elapsed += dt&#10;&#10;        # 페이드인이 완료되면 victory_mode로 전환&#10;        if victory_fade_elapsed &gt;= victory_fade_duration:&#10;            print(&quot;[play_mode] 페이드인 완료, victory_mode로 전환&quot;)&#10;            player = world.get('player')&#10;            survival_time = elapsed_time&#10;            game_framework.change_state(victory_mode, player, survival_time)&#10;&#10;        return  # 페이드인 중에는 게임 로직 업데이트 안 함&#10;&#10;    # 경과 시간 누적 (로딩 중이 아닐 때만)&#10;    dt = game_framework.get_delta_time()&#10;    elapsed_time += dt&#10;&#10;    # 카메라 업데이트 추가&#10;    if camera is not None:&#10;        camera.update()&#10;&#10;    # 일반 게임 업데이트&#10;    for layer_name in ['bg', 'effects_back', 'entities', 'effects_front', 'ui', 'extra_bg', 'extras', 'cursor']:&#10;        new_list = []&#10;        for o in list(world[layer_name]):&#10;            try:&#10;                if hasattr(o, 'update'):&#10;                    alive = o.update()&#10;                    if alive is False:&#10;                        continue&#10;&#10;                # mark_for_removal 플래그 확인&#10;                if hasattr(o, 'mark_for_removal') and o.mark_for_removal:&#10;                    print(f&quot;[Update] {o.__class__.__name__} 제거됨&quot;)&#10;                    continue  # 제거 표시된 객체는 new_list에 추가하지 않음&#10;&#10;                new_list.append(o)&#10;            except Exception:&#10;                try:&#10;                    new_list.append(o)&#10;                except Exception:&#10;                    print(f'\033[91m[play_mode] update error in layer {layer_name} object {o.__class__.__name__}\033[0m')&#10;                    pass&#10;        world[layer_name][:] = new_list&#10;&#10;    # 충돌 검사 시스템&#10;    player = world.get('player')&#10;&#10;    # 충돌한 이펙트와 투사체를 추적하기 위한 집합&#10;    effects_to_remove = set()&#10;    projectiles_to_remove = set()&#10;&#10;    # 1. 플레이어 공격 이펙트와 몬스터 충돌 검사&#10;    for effect in world['effects_front']:&#10;        # VFX_Tier1_Sword_Swing 이펙트인지 확인 (플레이어 공격)&#10;        if hasattr(effect, 'frames') and hasattr(effect, 'scale_factor'):&#10;            for entity in world['entities']:&#10;                # 플레이어가 아닌 엔티티 (몬스터)인지 확인&#10;                if entity != player and hasattr(entity, 'check_collision_with_effect'):&#10;                    if entity.check_collision_with_effect(effect):&#10;                        # 디버그: 충돌 정보 출력&#10;                        attacker_name = &quot;Player&quot;&#10;                        if hasattr(effect, 'owner'):&#10;                            attacker_name = effect.owner.__class__.__name__&#10;                        target_name = entity.__class__.__name__&#10;                        print(f&quot;[COLLISION] {attacker_name} 공격 이펙트 -&gt; {target_name} 피격!&quot;)&#10;                        # 충돌 시 이펙트는 유지 (여러 적을 동시에 타격 가능)&#10;                        pass&#10;&#10;    # 1-2. 몬스터 공격 이펙트와 플레이어 충돌 검사&#10;    # 피격 판정이 필요한 몬스터 공격 이펙트 클래스 리스트&#10;    from .projectile import Projectile&#10;    from .monsters.cat_theif import CatThiefSwingEffect  # CatThiefSwingEffect import 추가&#10;    from .monsters.Boss_Logic.panther_assassin_2pattern import PantherBladeSwingEffect  # PantherBladeSwingEffect import 추가&#10;    from .monsters.Boss_Logic.panther_assassin_3pattern import PantherCombo1SwingEffect&#10;    from .monsters.Boss_Logic.panther_assassin_3pattern import PantherCombo2SwingEffect&#10;&#10;&#10;    MONSTER_ATTACK_EFFECT_TYPES = [&#10;        CatThiefSwingEffect,&#10;        PantherBladeSwingEffect,&#10;        PantherCombo1SwingEffect,&#10;        PantherCombo2SwingEffect,&#10;    ]&#10;&#10;    if player:&#10;        for effect in world['effects_front']:&#10;            # 몬스터 공격 이펙트 타입 체크&#10;            for effect_type in MONSTER_ATTACK_EFFECT_TYPES:&#10;                if isinstance(effect, effect_type):&#10;                    # 이미 맞춘 플레이어는 다시 체크하지 않음 (중복 타격 방지)&#10;                    if not effect.has_hit_player:&#10;                        # 먼저 방패로 방어할 수 있는지 체크&#10;                        shield_blocked = False&#10;                        if hasattr(player, 'shield') and player.shield:&#10;                            if hasattr(player.shield, 'check_effect_block'):&#10;                                if player.shield.check_effect_block(effect):&#10;                                    # 방패로 막았으면 막은 것으로 판별, 이펙트는 지우지 않음&#10;                                    effect.has_hit_player = True&#10;                                    shield_blocked = True&#10;                                    print(f&quot;[COLLISION] Player가 방패로 {effect.__class__.__name__} 방어!&quot;)&#10;&#10;                        # 방패로 막지 못했을 때만 플레이어와 충돌 검사&#10;                        if not shield_blocked:&#10;                            if hasattr(player, 'check_collision_with_effect'):&#10;                                if player.check_collision_with_effect(effect):&#10;                                    # 충돌 시 플레이어 타격 처리&#10;                                    effect.has_hit_player = True&#10;                                    # 디버그: 충돌 정보 출력&#10;                                    attacker_name = &quot;Unknown&quot;&#10;                                    if hasattr(effect, 'owner') and effect.owner:&#10;                                        attacker_name = effect.owner.__class__.__name__&#10;                                    print(f&quot;[COLLISION] {attacker_name} {effect.__class__.__name__} -&gt; Player 피격!&quot;)&#10;&#10;                    # 해당 타입으로 확인되면 다른 타입 체크는 불필요&#10;                    break&#10;&#10;    # 2. 투사체와 충돌 검사 (일반화된 Projectile 기반)&#10;    if player:&#10;        for projectile in world['effects_front']:&#10;            # Projectile 클래스를 상속받은 모든 투사체 체크&#10;            if isinstance(projectile, Projectile):&#10;                # 몬스터가 쏜 투사체는 플레이어와 충돌 검사&#10;                if not projectile.from_player:&#10;                    if hasattr(player, 'check_collision_with_projectile'):&#10;                        if player.check_collision_with_projectile(projectile):&#10;                            # 디버그: 충돌 정보 출력&#10;                            attacker_name = &quot;Unknown&quot;&#10;                            if hasattr(projectile, 'owner') and projectile.owner:&#10;                                attacker_name = projectile.owner.__class__.__name__&#10;                            print(f&quot;[COLLISION] {attacker_name} 투사체 -&gt; Player 피격!&quot;)&#10;                            projectiles_to_remove.add(projectile)&#10;                # 플레이어가 쏜 투사체는 몬스터와 충돌 검사&#10;                else:&#10;                    for entity in world['entities']:&#10;                        if entity != player and hasattr(entity, 'check_collision_with_projectile'):&#10;                            if entity.check_collision_with_projectile(projectile):&#10;                                # 디버그: 충돌 정보 출력&#10;                                target_name = entity.__class__.__name__&#10;                                print(f&quot;[COLLISION] Player 투사체 -&gt; {target_name} 피격!&quot;)&#10;                                projectiles_to_remove.add(projectile)&#10;                                break  # 하나의 적과 충돌하면 투사체 제거&#10;&#10;    # 충돌한 투사체 제거&#10;    if projectiles_to_remove:&#10;        world['effects_front'] = [obj for obj in world['effects_front'] if obj not in projectiles_to_remove]&#10;&#10;    # 스테이지 클리어 조건 확인 (몬스터가 모두 제거되었는지)&#10;    # 'entities' 레이어에 플레이어만 남아있는지 확인합니다.&#10;    if not is_stage_cleared and len(world['entities']) == 1 and world.get('player') in world['entities']:&#10;        # 이전에 몬스터가 1마리 이상 있었는지 확인하는 조건이 필요할 수 있습니다.&#10;        # 여기서는 간단히 몬스터가 없으면 클리어로 간주합니다.&#10;        print(&quot;Stage cleared!&quot;)&#10;        is_stage_cleared = True # 중복 호출 방지&#10;        change_stage(current_stage_index + 1)&#10;&#10;&#10;def draw():&#10;    global camera, victory_fade_image, victory_fade_elapsed, victory_fade_duration&#10;    p2.clear_canvas()&#10;&#10;    # 로딩 중이면 로딩 화면만 그리기&#10;    if is_loading and loading_screen:&#10;        loading_screen.draw()&#10;    else:&#10;        # 일반 게임 화면 그리기&#10;        # 1. FixedBackground 먼저 그리기 (카메라 영향 없음)&#10;        from .background import FixedBackground&#10;        from .equipment import ShieldRangeEffect&#10;&#10;        for o in world['bg']:&#10;            if isinstance(o, FixedBackground):&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        o.draw()  # FixedBackground는 인자 없이 호출&#10;                except Exception as ex:&#10;                    print(f'\033[91m[play_mode] FixedBackground 그리기 오류: {ex}\033[0m')&#10;                    pass&#10;&#10;        # 2. 나머지 객체들은 카메라 좌표 적용하여 그리기&#10;        for layer_name in ['bg', 'walls', 'upper_ground', 'effects_back', 'entities', 'effects_front', 'extra_bg', 'extras']:&#10;            for o in world[layer_name]:&#10;                # FixedBackground는 이미 그렸으므로 스킵&#10;                if isinstance(o, FixedBackground):&#10;                    continue&#10;&#10;                try:&#10;                    if hasattr(o, 'draw'):&#10;                        # ShieldRangeEffect는 특별 처리 (플레이어 위치 기준)&#10;                        if isinstance(o, ShieldRangeEffect):&#10;                            if hasattr(o, 'player') and o.player:&#10;                                if camera is not None:&#10;                                    draw_x, draw_y = camera.apply(o.player.x, o.player.y)&#10;                                else:&#10;                                    draw_x, draw_y = o.player.x, o.player.y&#10;                                o.draw(draw_x, draw_y)&#10;                        # x, y 속성이 있는 객체는 카메라 좌표로 변환하여 그리기&#10;                        elif hasattr(o, 'x') and hasattr(o, 'y'):&#10;                            if camera is not None:&#10;                                draw_x, draw_y = camera.apply(o.x, o.y)&#10;                            else:&#10;                                draw_x, draw_y = o.x, o.y&#10;                            o.draw(draw_x, draw_y)&#10;                        else:&#10;                            # x, y 속성이 없는 객체는 그대로 그리기&#10;                            o.draw()&#10;                except Exception as ex:&#10;                    print(f'\033[91m[play_mode] {layer_name} 레이어의 {o.__class__.__name__} 그리기 오류: {ex}\033[0m')&#10;                    pass&#10;&#10;        # 3. UI와 커서는 카메라 적용하지 않음 (고정 UI)&#10;        for o in world['ui']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[play_mode] UI 레이어의 {o.__class__.__name__} 그리기 오류 : {ex}\033[0m')&#10;                pass&#10;&#10;        for o in world['cursor']:&#10;            try:&#10;                if hasattr(o, 'draw'):&#10;                    o.draw()&#10;            except Exception as ex:&#10;                print(f'\033[91m[play_mode] Cursor 레이어의 {o.__class__.__name__} 그리기 오류 : {ex}\033[0m')&#10;                pass&#10;&#10;        # 4. 승리 페이드인 효과 그리기 (기존 화면 위에 오버레이)&#10;        if is_fading_to_victory and victory_fade_image:&#10;            canvas_w = p2.get_canvas_width()&#10;            canvas_h = p2.get_canvas_height()&#10;&#10;            # 페이드인 진행률 계산 (0.0 ~ 1.0)&#10;            fade_progress = min(victory_fade_elapsed / victory_fade_duration, 1.0)&#10;&#10;            # 이미지 투명도 설정 및 그리기&#10;            victory_fade_image.opacify(fade_progress)&#10;            victory_fade_image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)&#10;&#10;    p2.update_canvas()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/player.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/player.py" />
              <option name="originalContent" value="# 패키지 내부 모듈을 직접 실행할 경우 친절한 안내 후 종료&#10;if __name__ == &quot;__main__&quot; and (__package__ is None or __package__ == &quot;&quot;):&#10;    import sys&#10;    print(&quot;이 모듈은 game_logic 패키지 내부 모듈입니다. 프로젝트 루트에서 main.py를 실행하세요.&quot;)&#10;    sys.exit(1)&#10;&#10;import ctypes&#10;import os&#10;import random&#10;import time&#10;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width, draw_rectangle&#10;from sdl2 import (SDL_KEYDOWN, SDL_KEYUP, SDLK_a, SDLK_d, SDLK_w, SDLK_s, SDLK_TAB, SDLK_SPACE, SDL_GetMouseState,&#10;                   SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT)&#10;&#10;from .equipment import EquipmentManager, Sword, Shield&#10;from .state_machine import StateMachine&#10;import game_framework as framework&#10;# 인벤토리 데이터 모델 import&#10;from .inventory import InventoryData, seed_debug_inventory&#10;from .stats import PlayerStats, StatModifier&#10;from .damage_indicator import DamageIndicator&#10;&#10;def Akey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_a&#10;def Akey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_a&#10;def Dkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_d&#10;def Dkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_d&#10;def Wkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_w&#10;def Wkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_w&#10;def Skey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_s&#10;def Skey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_s&#10;&#10;# 스페이스바 입력 검사용 predicate&#10;def Space_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_SPACE&#10;&#10;# 커스텀 이벤트 정의&#10;def move_event(e):&#10;    return e[0] == 'MOVE'&#10;&#10;def stop_event(e):&#10;    return e[0] == 'STOP'&#10;&#10;# 대시 이벤트 정의&#10;def dash_event(e):&#10;    return e[0] == 'DASH'&#10;&#10;def dash_end_event(e):&#10;    return e[0] == 'DASH_END'&#10;&#10;# Tab 키 입력 검사용 predicate (StateMachine 매핑용)&#10;def Tab_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_TAB&#10;&#10;class Run:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix, path):&#10;            files = sorted([f for f in os.listdir(path)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(path, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#10;&#10;        # 파티클 리소스 로드&#10;        particle_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Run_Dust')&#10;        self.particle_frames = load_seq('RunDust_Ver2_', particle_folder)&#10;        self.particle_spawn_timer = 0.0&#10;        self.particle_spawn_interval = 0.15 # 파티클 생성 간격&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Move frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.06&#10;        self.moving_speed = 300 # 초당 픽셀&#10;&#10;    def enter(self, e):&#10;        # 파티클 타이머만 초기화&#10;        self.particle_spawn_timer = 0.0&#10;&#10;    def exit(self, e):&#10;        # 파티클을 제거하지 않고 그대로 둠&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 플레이어 애니메이션 및 위치 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;        # 현재 스탯 기반 이동 속도 사용&#10;        moving_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else self.moving_speed&#10;        dir_magnitude = (self.player.dir[0] ** 2 + self.player.dir[1] ** 2) ** 0.5&#10;        if dir_magnitude &gt; 0:&#10;            norm_dir_x = self.player.dir[0] / dir_magnitude&#10;            norm_dir_y = self.player.dir[1] / dir_magnitude&#10;            new_x = self.player.x + norm_dir_x * moving_speed * dt&#10;            new_y = self.player.y + norm_dir_y * moving_speed * dt&#10;&#10;            # 맵 경계 체크 (카메라/월드 좌표 기반)&#10;            # lobby_mode에서 맵 크기를 가져와 경계 체크&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                # 배경 오브젝트에서 맵 크기 계산&#10;                if world['bg']:&#10;                    bg = world['bg'][0]&#10;                    map_width = bg.image.w * bg.scale&#10;                    map_height = bg.image.h * bg.scale&#10;                    # 맵의 중심이 (0, 0)이므로 경계는 ±map_width/2, ±map_height/2&#10;                    map_left = -map_width / 2&#10;                    map_right = map_width / 2&#10;                    map_bottom = -map_height / 2&#10;                    map_top = map_height / 2&#10;&#10;                    # 플레이어가 맵 경계를 벗어나지 않도록 제한&#10;                    if new_x &lt; map_left:&#10;                        new_x = map_left&#10;                    elif new_x &gt; map_right:&#10;                        new_x = map_right&#10;                    if new_y &lt; map_bottom:&#10;                        new_y = map_bottom&#10;                    elif new_y &gt; map_top:&#10;                        new_y = map_top&#10;            except Exception:&#10;                # 맵 정보를 가져올 수 없으면 화면 경계로 폴백&#10;                if new_x &gt; get_canvas_width():&#10;                    new_x = get_canvas_width()&#10;                elif new_x &lt; 0:&#10;                    new_x = 0&#10;                if new_y &gt; get_canvas_height():&#10;                    new_y = get_canvas_height()&#10;                elif new_y &lt; 0:&#10;                    new_y = 0&#10;&#10;            # 벽 충돌 체크 (플레이어 크기 32x48)&#10;            collided = False&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                for wall in world['walls']:&#10;                    if wall.check_collision(new_x - 32//2, new_y - 48//2, 32, 48):&#10;                        collided = True&#10;                        break&#10;            except Exception:&#10;                pass&#10;            if not collided:&#10;                self.player.x = new_x&#10;                self.player.y = new_y&#10;&#10;&#10;        # 파티클 생성&#10;        self.particle_spawn_timer += dt&#10;        if self.particle_spawn_timer &gt;= self.particle_spawn_interval:&#10;            self.particle_spawn_timer -= self.particle_spawn_interval&#10;            # 플레이어 발밑에 파티클 생성 (월드 좌표 사용)&#10;            # y 오프셋을 줄여서 발 위치에 더 가깝게 배치&#10;            particle_x = self.player.x + random.uniform(-10, 10)&#10;            particle_y = self.player.y - 20 + random.uniform(-5, 5)  # -40에서 -20으로 조정&#10;            new_particle = VFX_Run_Particle(particle_x, particle_y, self.particle_frames, 0.05, 2.0)&#10;            self.player.particles.append(new_particle)&#10;&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;&#10;        # camera 가져오기 - play_mode 우선, lobby_mode로 폴백&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            print(f&quot;\033[91m[player Idle] 카메라 가져오기 실패\033[0m&quot;)&#10;&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;class Dash:&#10;    &quot;&quot;&quot;대시 상태: 스페이스바로 활성화, 빠른 속도로 짧은 거리 이동&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix, path):&#10;            files = sorted([f for f in os.listdir(path)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(path, f)) for f in files]&#10;&#10;        # 대시용 애니메이션 프레임 (Run과 동일한 프레임 사용)&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Dash frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.03  # Run보다 2배 빠른 애니메이션&#10;&#10;        # 대시 설정&#10;        self.dash_duration = 0.15  # 대시 지속 시간 (0.15초)&#10;        self.dash_timer = 0.0  # 대시 경과 시간&#10;        self.dash_speed_multiplier = 4  # Run 속도의 4배&#10;&#10;        # 대시 방향 저장 (enter에서 설정)&#10;        self.dash_direction = [1, 0]  # 기본값: 오른쪽&#10;        self.return_to_idle = False  # Idle로 복귀할지 Run으로 복귀할지&#10;&#10;        # 잔상 이펙트 타이머&#10;        self.trail_timer = 0.0  # 잔상 생성 타이머&#10;        self.trail_interval = 0.04  # 잔상 생성 간격&#10;&#10;    def enter(self, e):&#10;        &quot;&quot;&quot;대시 상태 진입&quot;&quot;&quot;&#10;        # 대시 타이머 초기화&#10;        self.dash_timer = 0.0&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;&#10;        # 잔상 타이머 초기화&#10;        self.trail_timer = 0.0&#10;&#10;        # 무적 시간 활성화 (0.15초)&#10;        self.player.invincible = True&#10;        self.player.invincible_timer = 0.3&#10;        print(f&quot;[Dash] 무적 시간 활성화 (0.3초)&quot;)&#10;&#10;        # 대시 방향 결정&#10;        # Run 상태에서 왔으면 현재 이동 방향으로 대시&#10;        # Idle 상태에서 왔으면 오른쪽(face_dir)으로 대시&#10;        if self.player.dir[0] != 0 or self.player.dir[1] != 0:&#10;            # 이동 중이었으면 그 방향으로 대시&#10;            self.dash_direction = self.player.dir.copy()&#10;            self.return_to_idle = False&#10;            print(f&quot;[Dash] Run에서 대시 시작 - 방향: ({self.dash_direction[0]}, {self.dash_direction[1]})&quot;)&#10;        else:&#10;            # 정지 상태였으면 face_dir 방향으로 대시&#10;            self.dash_direction = [self.player.face_dir, 0]&#10;            self.return_to_idle = True&#10;            print(f&quot;[Dash] Idle에서 대시 시작 - 방향: 오른쪽({self.player.face_dir})&quot;)&#10;&#10;    def exit(self, e):&#10;        &quot;&quot;&quot;대시 상태 종료&quot;&quot;&quot;&#10;        print(f&quot;[Dash] 대시 종료 - {'Idle' if self.return_to_idle else 'Run'}로 복귀&quot;)&#10;        pass&#10;&#10;    def do(self):&#10;        &quot;&quot;&quot;대시 업데이트: 빠른 속도로 이동하고 시간이 지나면 종료&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 대시 타이머 업데이트&#10;        self.dash_timer += dt&#10;&#10;        # 잔상 타이머 업데이트 및 생성&#10;        self.trail_timer += dt&#10;        if self.trail_timer &gt;= self.trail_interval:&#10;            self.trail_timer -= self.trail_interval&#10;            # 잔상 이펙트 생성&#10;            self._create_trail_effect()&#10;&#10;        # 애니메이션 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;        # 대시 이동 처리&#10;        # 현재 스탯 기반 이동 속도 사용&#10;        base_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else 300&#10;        dash_speed = base_speed * self.dash_speed_multiplier&#10;&#10;        # 방향 정규화&#10;        dir_magnitude = (self.dash_direction[0] ** 2 + self.dash_direction[1] ** 2) ** 0.5&#10;        if dir_magnitude &gt; 0:&#10;            norm_dir_x = self.dash_direction[0] / dir_magnitude&#10;            norm_dir_y = self.dash_direction[1] / dir_magnitude&#10;            new_x = self.player.x + norm_dir_x * dash_speed * dt&#10;            new_y = self.player.y + norm_dir_y * dash_speed * dt&#10;&#10;            # 맵 경계 체크 및 벽 충돌 체크 (Run과 동일한 로직)&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                if world['bg']:&#10;                    bg = world['bg'][0]&#10;                    map_width = bg.image.w * bg.scale&#10;                    map_height = bg.image.h * bg.scale&#10;                    map_left = -map_width / 2&#10;                    map_right = map_width / 2&#10;                    map_bottom = -map_height / 2&#10;                    map_top = map_height / 2&#10;&#10;                    if new_x &lt; map_left:&#10;                        new_x = map_left&#10;                    elif new_x &gt; map_right:&#10;                        new_x = map_right&#10;                    if new_y &lt; map_bottom:&#10;                        new_y = map_bottom&#10;                    elif new_y &gt; map_top:&#10;                        new_y = map_top&#10;            except Exception:&#10;                if new_x &gt; get_canvas_width():&#10;                    new_x = get_canvas_width()&#10;                elif new_x &lt; 0:&#10;                    new_x = 0&#10;                if new_y &gt; get_canvas_height():&#10;                    new_y = get_canvas_height()&#10;                elif new_y &lt; 0:&#10;                    new_y = 0&#10;&#10;            # 벽 충돌 체크&#10;            collided = False&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                for wall in world['walls']:&#10;                    if wall.check_collision(new_x - 32//2, new_y - 48//2, 32, 48):&#10;                        collided = True&#10;                        break&#10;            except Exception:&#10;                pass&#10;&#10;            if not collided:&#10;                self.player.x = new_x&#10;                self.player.y = new_y&#10;&#10;        # 대시 지속 시간이 끝나면 상태 전환&#10;        if self.dash_timer &gt;= self.dash_duration:&#10;            # DASH_END 이벤트 발생&#10;            self.player.state_machine.handle_state_event(('DASH_END', None))&#10;&#10;    def _create_trail_effect(self):&#10;        &quot;&quot;&quot;대시 잔상 이펙트를 생성하여 world의 effects_back 레이어에 추가&quot;&quot;&quot;&#10;        try:&#10;            # vfx 모듈에서 DashTrailEffect import&#10;            from .vfx import DashTrailEffect&#10;&#10;            # 현재 플레이어 위치에 잔상 생성&#10;            trail = DashTrailEffect(&#10;                x=self.player.x,&#10;                y=self.player.y,&#10;                face_dir=self.player.face_dir,&#10;                scale=self.player.scale_factor&#10;            )&#10;&#10;            # world의 effects_back 레이어에 추가&#10;            if hasattr(self.player, 'world') and self.player.world:&#10;                if 'effects_back' in self.player.world:&#10;                    self.player.world['effects_back'].append(trail)&#10;                    print(f&quot;[Dash] 잔상 이펙트 생성 at ({self.player.x:.1f}, {self.player.y:.1f})&quot;)&#10;                else:&#10;                    print(f&quot;\033[93m[Dash] world에 effects_back 레이어가 없습니다\033[0m&quot;)&#10;            else:&#10;                print(f&quot;\033[93m[Dash] player.world가 설정되지 않았습니다\033[0m&quot;)&#10;        except Exception as ex:&#10;            print(f&quot;\033[91m[Dash] 잔상 이펙트 생성 실패: {ex}\033[0m&quot;)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;대시 상태 그리기 (Run과 동일한 스타일)&quot;&quot;&quot;&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;&#10;        # camera 가져오기&#10;        camera = None&#10;        try:&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            pass&#10;&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip, draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip, draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip, draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip, draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;class Idle:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix):&#10;            files = sorted([f for f in os.listdir(folder)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(folder, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Idle_Lower')&#10;        self.upper_frames = load_seq('Player_Adventurer_Idle_Upper')&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Idle frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.12&#10;&#10;    def enter(self, e):&#10;        self.player.dir = [0, 0]&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.frame_time_acc += dt&#10;        while self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;&#10;        # camera 가져오기 - play_mode 우선, lobby_mode로 폴백&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            print(f&quot;\033[91m[player Idle] 카메라 가져오기 실패\033[0m&quot;)&#10;&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;&#10;class Inventory:&#10;    &quot;&quot;&quot;인벤토리 상태: enter에서 이미지 로드, draw에서 중앙 오른쪽에 표시 (시뮬레이션 정지 없음)&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.image = None&#10;        self.scale = 1.0&#10;        self.prev_state = None  # 이전 상태 저장용&#10;&#10;    def enter(self, e):&#10;        # 현재 상태를 이전 상태로 저장 (복귀용)&#10;        self.prev_state = self.player.state_machine.cur_state&#10;&#10;        # 이미지 지연 로드(오버레이에서도 사용 가능하도록 유지하되, 여기서는 그리지 않음)&#10;        if self.image is None:&#10;            img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Inventory', 'InventoryBase_New1.png')&#10;            try:&#10;                self.image = load_image(img_path)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load inventory image: {img_path}, {ex}\033[0m&quot;)&#10;                self.image = None&#10;&#10;        # 인벤토리 표시 플래그만 설정 (이동은 유지)&#10;        self.player.inventory_open = True&#10;&#10;    def exit(self, e):&#10;        # 표시 플래그만 해제&#10;        self.player.inventory_open = False&#10;&#10;    def do(self):&#10;        # 현재 키 상태에 따라 Idle/Run의 do를 동적으로 실행&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.do()&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 현재 키 상태에 따라 Idle/Run의 draw를 먼저 실행 (플레이어 표시)&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.draw(draw_x, draw_y)&#10;        # 인벤토리 이미지를 화면 오른쪽에 표시 (카메라 스크롤 영향 없음)&#10;        # if self.image:&#10;        #     canvas_w = get_canvas_width()&#10;        #     canvas_h = get_canvas_height()&#10;        #     inv_x = canvas_w - self.image.w * self.scale // 2 - 20&#10;        #     inv_y = canvas_h // 2&#10;        #     self.image.draw(inv_x, inv_y, self.image.w * self.scale, self.image.h * self.scale)&#10;        pass&#10;&#10;class Death:&#10;    &quot;&quot;&quot;플레이어 사망 상태&quot;&quot;&quot;&#10;    image = None&#10;    hit_fx_images = None  # PlayerHitFX 이미지들&#10;    heart_hit_images = None  # HeartHit 이미지들&#10;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.world = getattr(player, 'world', None)  # play_mode에서 할당된 world 참조&#10;&#10;        if Death.image is None:&#10;            try:&#10;                Death.image = load_image('resources/Texture_organize/Player_character/Adventurer/Player_Adventurer_Down00.png')&#10;                print(f&quot;[Player Death] Loaded Down00 image&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] Failed to load image: {e}\033[0m&quot;)&#10;                Death.image = None&#10;&#10;        # PlayerHitFX 이미지 로드 (1 ~ 9)&#10;        if Death.hit_fx_images is None:&#10;            Death.hit_fx_images = []&#10;            try:&#10;                for i in range(1, 10):  # PlayerHitFX01 ~ PlayerHitFX09&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Die_Animation', f'PlayerHitFX0{i}.png')&#10;                    img = load_image(img_path)&#10;                    Death.hit_fx_images.append(img)&#10;                print(f&quot;[Player Death] PlayerHitFX 이미지 로드 완료: {len(Death.hit_fx_images)}개&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] PlayerHitFX 이미지 로드 실패: {e}\033[0m&quot;)&#10;                Death.hit_fx_images = []&#10;&#10;        # HeartHit 이미지 로드 (0 ~ 8)&#10;        if Death.heart_hit_images is None:&#10;            Death.heart_hit_images = []&#10;            try:&#10;                for i in range(9):  # HeartHit0_0 ~ HeartHit8_0&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Hit_verdict', f'HeartHit{i}_0.png')&#10;                    img = load_image(img_path)&#10;                    Death.heart_hit_images.append(img)&#10;                print(f&quot;[Player Death] HeartHit 이미지 로드 완료: {len(Death.heart_hit_images)}개&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] HeartHit 이미지 로드 실패: {e}\033[0m&quot;)&#10;                Death.heart_hit_images = []&#10;&#10;        self.death_timer = 0.0&#10;        self.death_conversion = 2.0  # 2초 후 변환&#10;        self.death_duration = 6.0  # 6초 후 종료&#10;        self.game_over_conversion_triggered = False&#10;        self.game_over_triggered = False&#10;&#10;        # 넉백 관련 변수 (강한 넉백)&#10;        self.knockback_dx = 0&#10;        self.knockback_dy = 0&#10;        self.knockback_speed = 400  # 강한 넉백&#10;        self.knockback_duration = 0.5  # 0.5초 동안&#10;        self.knockback_timer = 0.0&#10;&#10;        # 애니메이션 관련 변수&#10;        self.hit_fx_frame = 0&#10;        self.hit_fx_time = 0.0&#10;        self.hit_fx_duration = 0.08  # 각 프레임당 0.08초&#10;&#10;        self.heart_hit_frame = 0&#10;        self.heart_hit_time = 0.0&#10;        self.heart_hit_duration = 0.1  # 각 프레임당 0.1초&#10;&#10;        # 사망 위치 저장 (이동 제거, 죽은 자리에서 유지)&#10;        self.death_x = 0&#10;        self.death_y = 0&#10;&#10;        # 사망 모드용 배경 이미지 클래스&#10;        class BGimage:&#10;            &quot;&quot;&quot;사망 모드용 배경 이미지 클래스&quot;&quot;&quot;&#10;&#10;            def __init__(self, image_path):&#10;                try:&#10;                    self.image = load_image(image_path)&#10;                except Exception as e:&#10;                    print(f&quot;[Defeat Mode BG] 이미지 로드 실패: {e}&quot;)&#10;                    self.image = None&#10;&#10;                self.alpha = 0.0 # 투명도 초기값&#10;&#10;            def do(self):&#10;                pass&#10;&#10;            def update(self):&#10;                # 점진적으로 투명도 증가 / 3초 동안 완전 불투명&#10;                if self.alpha &lt; 1.0:&#10;                    self.alpha += framework.get_delta_time() / 3.0 * 2  # 3초에 걸쳐 1.0 도달&#10;                    if self.alpha &gt; 1.0:&#10;                        self.alpha = 1.0&#10;&#10;            def draw(self):&#10;                if self.image:&#10;                    canvas_w = get_canvas_width()&#10;                    canvas_h = get_canvas_height()&#10;                    self.image.opacify(self.alpha)&#10;                    self.image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)&#10;                    self.image.opacify(1.0)&#10;&#10;        # 배경 이미지 인스턴스 생성&#10;        self.BG = BGimage('resources/Texture_organize/UI/Stage_Loading/BlackBG.png')&#10;&#10;    def enter(self, e):&#10;        self.death_timer = 0.0&#10;        self.game_over_triggered = False&#10;        self.knockback_timer = 0.0&#10;&#10;        # 애니메이션 초기화&#10;        self.hit_fx_frame = 0&#10;        self.hit_fx_time = 0.0&#10;        self.heart_hit_frame = 0&#10;        self.heart_hit_time = 0.0&#10;&#10;        # 사망 위치 저장 (현재 월드 좌표 그대로 유지)&#10;        self.death_x = self.player.x&#10;        self.death_y = self.player.y&#10;&#10;        # 플레이어 무장 해제&#10;        self.player.equipment_manager.unequip_all()&#10;&#10;        # 넉백 방향 계산&#10;        if e and len(e) &gt; 1 and e[1] is not None:&#10;            attacker = e[1]&#10;            attacker_x = attacker.x if hasattr(attacker, 'x') else self.player.x&#10;            attacker_y = attacker.y if hasattr(attacker, 'y') else self.player.y&#10;&#10;            if hasattr(attacker, 'owner') and attacker.owner:&#10;                attacker_x = attacker.owner.x&#10;                attacker_y = attacker.owner.y&#10;&#10;            import math&#10;            dx = self.player.x - attacker_x&#10;            dy = self.player.y - attacker_y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            if distance &gt; 0:&#10;                self.knockback_dx = dx / distance&#10;                self.knockback_dy = dy / distance&#10;            else:&#10;                self.knockback_dx = 1.0&#10;                self.knockback_dy = 0.0&#10;        else:&#10;            self.knockback_dx = 1.0&#10;            self.knockback_dy = 0.0&#10;&#10;        print(f&quot;[Player Death State] 사망 상태 시작 (6초 후 defeat_mode로 전환) - 넉백 적용&quot;)&#10;        print(f&quot;[Player Death State] 사망 위치: ({self.death_x:.1f}, {self.death_y:.1f})&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.death_timer += dt&#10;&#10;        # 넉백 효과 적용 (사망 초기 0.5초만, 이후엔 그 자리에 고정)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            # 부드러운 감속&#10;            current_speed = self.knockback_speed * (1.0 - progress) ** 1.5&#10;            self.player.x += self.knockback_dx * current_speed * dt&#10;            self.player.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;        # 넉백 끝난 후에는 위치 고정 (중앙 이동 로직 제거)&#10;&#10;        # PlayerHitFX 애니메이션 업데이트&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#10;            self.hit_fx_time += dt&#10;            if self.hit_fx_time &gt;= self.hit_fx_duration:&#10;                self.hit_fx_time -= self.hit_fx_duration&#10;                self.hit_fx_frame += 1&#10;&#10;        # HeartHit 애니메이션 업데이트&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#10;            self.heart_hit_time += dt&#10;            if self.heart_hit_time &gt;= self.heart_hit_duration:&#10;                self.heart_hit_time -= self.heart_hit_duration&#10;                self.heart_hit_frame += 1&#10;&#10;        # 2초 후 배경 어둡게 시작 (extra_bg 레이어에 배경 추가)&#10;        if self.death_timer &gt;= self.death_conversion and not self.game_over_conversion_triggered:&#10;            self.game_over_conversion_triggered = True&#10;            print(f&quot;[Player Death State] 2초 경과, 배경 어둡게 시작&quot;)&#10;            from .play_mode import world&#10;            # 배경을 extra_bg 레이어에 추가하여 점진적으로 어둡게&#10;            world['extra_bg'].append(self.BG)&#10;            # 플레이어를 extras 레이어로 이동 (UI보다 아래, 배경보다 위에 그려지도록)&#10;            world['extras'].append(self.player)&#10;            if self.player in self.world['entities']:&#10;                world['entities'].remove(self.player)&#10;&#10;        # 6초 후 defeat_mode로 전환&#10;        if self.death_timer &gt;= self.death_duration and not self.game_over_triggered:&#10;            self.game_over_triggered = True&#10;            print(f&quot;[Player Death State] 6초 경과, 패배 모드로 전환&quot;)&#10;            import game_framework&#10;            from . import defeat_mode, play_mode&#10;            # play_mode의 경과 시간을 가져와서 defeat_mode로 전달&#10;            survival_time = getattr(play_mode, 'elapsed_time', 0.0)&#10;            print(f&quot;[Player Death State] 생존 시간: {survival_time:.2f}초&quot;)&#10;            game_framework.change_state(defeat_mode, self.player, survival_time)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 플레이어 사망 이미지 (바닥에 누운 모습)&#10;        # draw_x, draw_y는 이미 카메라가 적용된 화면 좌표이므로 그대로 사용&#10;        if Death.image is not None:&#10;            Death.image.draw(draw_x, draw_y,&#10;                           Death.image.w * self.player.scale_factor,&#10;                           Death.image.h * self.player.scale_factor)&#10;&#10;        # PlayerHitFX 이펙트 (플레이어 위치에 크게)&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#10;            hit_fx_img = Death.hit_fx_images[self.hit_fx_frame]&#10;            scale = 3.0&#10;            hit_fx_img.draw(&#10;                draw_x,&#10;                draw_y,&#10;                hit_fx_img.w * scale,&#10;                hit_fx_img.h * scale&#10;            )&#10;&#10;        # HeartHit 이펙트 (플레이어 위치 기준)&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#10;            heart_hit_img = Death.heart_hit_images[self.heart_hit_frame]&#10;            scale = 3.0&#10;            heart_hit_img.draw(&#10;                draw_x,&#10;                draw_y,&#10;                heart_hit_img.w * scale,&#10;                heart_hit_img.h * scale&#10;            )&#10;&#10;&#10;# 사망 이벤트 predicate&#10;def die(e):&#10;    return e[0] == 'DIE'&#10;&#10;&#10;class Player:&#10;    def __init__(self):&#10;        self.x = get_canvas_width() // 2&#10;        self.y = get_canvas_height() // 2&#10;        self.death_x = self.x&#10;        self.death_y = self.y&#10;        self.frame = 0&#10;        self.dir = [0, 0]  # x, y 방향 벡터&#10;        self.face_dir = 1&#10;        self.scale_factor = 3.0&#10;        self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;        self.moving = False # 이동 상태 플래그&#10;        self.particles = [] # 파티클 리스트를 Player로 이동&#10;        self.attack_effects = [] # 공격 이펙트 리스트&#10;        self.dash_stack_max = 3 # 대시 최대 스택&#10;        self.dash_stack = self.dash_stack_max # 대시 스택 초기화&#10;        self.dash_recharge_time = 3.0 # 대시 재충전 시간(초당 1회 충전)&#10;        self.dash_recharge_timer = 0.0 # 대시 재충전 타이머&#10;&#10;        # 플레이어 히트박스 변수&#10;        self.collision_width = 15 * self.scale_factor&#10;        self.collision_height = 15 * self.scale_factor&#10;&#10;        # 무적시간 관련 변수&#10;        self.invincible = False  # 무적 상태인지&#10;        self.invincible_timer = 0.0  # 무적 시간 타이머&#10;        self.invincible_duration = 0.3  # 무적 시간 지속 시간 (0.3초)&#10;&#10;        # 넉백 관련 변수 (방패 방어 시 사용)&#10;        self.knockback_dx = 0.0&#10;        self.knockback_dy = 0.0&#10;        self.knockback_speed = 0.0&#10;        self.knockback_duration = 0.0&#10;        self.knockback_timer = 0.0&#10;&#10;        # 방패 깨짐 상태 변수&#10;        self.shield_broken = False  # 방패가 깨졌는지 여부&#10;&#10;        # 아이템별 개별 쿨타임 관리 시스템&#10;        # key: item.id (아이템 고유 ID), value: 남은 쿨타임 시간(초)&#10;        self.item_cooldowns = {}  # 각 아이템의 남은 쿨타임을 저장&#10;&#10;        # 인벤토리 데이터 생성 및 디버그 아이템 채우기&#10;        self.inventory = InventoryData(cols=6, rows=5)&#10;        try:&#10;            seed_debug_inventory(self.inventory)&#10;        except Exception as ex:&#10;            print('[Player] 디버그 인벤토리 시드 실패:', ex)&#10;&#10;        # 스탯 시스템&#10;        self.stats = PlayerStats()&#10;        # 인벤토리 패시브 적용&#10;        try:&#10;            self.rebuild_inventory_passives()&#10;        except Exception as ex:&#10;            print('[Player] 패시브 재구성 실패:', ex)&#10;&#10;        # 장비 매니저 초기화&#10;        self.equipment_manager = EquipmentManager(self)&#10;&#10;        # 기본 무기 장착 (Tier1 검과 방패)&#10;        sword_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Sword_Tier1.png')&#10;        shield_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Shield_Tier1.png')&#10;&#10;        self.sword = Sword(self, sword_path, scale=3.0)&#10;        self.shield = Shield(self, shield_path, scale=3.0)&#10;&#10;        self.equipment_manager.equip(self.sword)&#10;        self.equipment_manager.equip(self.shield)&#10;&#10;        # 상태 정의&#10;        self.IDLE = Idle(self)&#10;        self.RUN = Run(self)&#10;        self.DASH = Dash(self)  # 대시 상태 추가&#10;        self.INVENTORY = Inventory(self)&#10;        self.DEATH = Death(self)&#10;&#10;        # 전투 플래그(전투중엔 인벤토리 안 염)&#10;        self.in_combat = False&#10;        self.inventory_open = False&#10;&#10;        # 상태 전환에 대한 매핑&#10;        self.state_machine = StateMachine(&#10;            self.IDLE,&#10;            {&#10;                self.IDLE: {move_event: self.RUN, dash_event: self.DASH, Tab_down: self.INVENTORY, die: self.DEATH},&#10;                self.RUN: {stop_event: self.IDLE, dash_event: self.DASH, Tab_down: self.INVENTORY, die: self.DEATH},&#10;                self.DASH: {dash_end_event: None, die: self.DEATH},  # DASH_END에서 이전 상태로 복귀 (None = 동적 처리)&#10;                self.INVENTORY: {Tab_down: None, die: self.DEATH},&#10;                self.DEATH: {},  # 사망 상태에서는 전환 없음&#10;            }&#10;        )&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 이동 전 위치 저장 (벽 충돌 시 롤백용)&#10;        prev_x = self.x&#10;        prev_y = self.y&#10;&#10;        # 넉백 효과 적용 (방패 방어 시)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            current_speed = self.knockback_speed * (1.0 - progress)&#10;            self.x += self.knockback_dx * current_speed * dt&#10;            self.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;&#10;        # 무적시간 업데이트&#10;        if self.invincible:&#10;            self.invincible_timer -= dt&#10;            if self.invincible_timer &lt;= 0:&#10;                self.invincible = False&#10;                self.invincible_timer = 0.0&#10;&#10;        # 대시 재충전 업데이트&#10;        if self.dash_stack &lt; self.dash_stack_max:&#10;            self.dash_recharge_timer += dt&#10;            if self.dash_recharge_timer &gt;= self.dash_recharge_time:&#10;                self.dash_stack += 1&#10;                self.dash_recharge_timer -= self.dash_recharge_time&#10;                print(f'\033[92m[Player] 대시 스택 충전: {self.dash_stack}/{self.dash_stack_max}\033[0m')&#10;&#10;        # 아이템별 개별 쿨타임 업데이트&#10;        # item_cooldowns 딕셔너리의 각 아이템 ID에 대해 쿨타임 감소&#10;        for item_id in list(self.item_cooldowns.keys()):&#10;            self.item_cooldowns[item_id] -= dt&#10;            if self.item_cooldowns[item_id] &lt;= 0:&#10;                # 쿨타임이 끝나면 딕셔너리에서 제거&#10;                del self.item_cooldowns[item_id]&#10;                print(f'\033[92m[Player] 아이템 사용 가능: {item_id} (쿨타임 종료)\033[0m')&#10;&#10;        self.state_machine.update()&#10;&#10;        # 벽 충돌 검사 (world 참조가 있는 경우)&#10;        if hasattr(self, 'world') and self.world and 'walls' in self.world:&#10;            # 플레이어 히트박스 (중심 기준)&#10;            player_w = 32  # 플레이어 너비 (필요시 조정)&#10;            player_h = 32  # 플레이어 높이 (필요시 조정)&#10;            player_left = self.x - player_w / 2&#10;            player_right = self.x + player_w / 2&#10;            player_bottom = self.y - player_h / 2&#10;            player_top = self.y + player_h / 2&#10;&#10;            # 모든 벽과 충돌 검사&#10;            collision_detected = False&#10;            for wall in self.world['walls']:&#10;                if hasattr(wall, 'check_collision'):&#10;                    # 벽의 히트박스 (중심 기준)&#10;                    wall_left = wall.x - wall.w / 2&#10;                    wall_right = wall.x + wall.w / 2&#10;                    wall_bottom = wall.y - wall.h / 2&#10;                    wall_top = wall.y + wall.h / 2&#10;&#10;                    # AABB 충돌 검사&#10;                    if (player_right &gt; wall_left and player_left &lt; wall_right and&#10;                        player_top &gt; wall_bottom and player_bottom &lt; wall_top):&#10;                        collision_detected = True&#10;                        break&#10;&#10;            # 충돌이 감지되면 이전 위치로 롤백&#10;            if collision_detected:&#10;                self.x = prev_x&#10;                self.y = prev_y&#10;                # 디버그 출력 (필요시 주석 해제)&#10;                # print(f&quot;[Player] 벽 충돌 감지! 위치 롤백: ({self.x:.1f}, {self.y:.1f})&quot;)&#10;&#10;        # 스탯 버프 업데이트(소비형 지속시간 관리)&#10;        if hasattr(self, 'stats'):&#10;            old_mana = self.stats.get('mana')&#10;            self.stats.update()&#10;            new_mana = self.stats.get('mana')&#10;&#10;            # 마나가 0에서 최대로 회복되면 방패 복구&#10;            if hasattr(self, 'shield_broken') and self.shield_broken:&#10;                if new_mana &gt;= 50:&#10;                    self.shield_broken = False&#10;                    print(f'\033[92m[Player] 방패 복구됨 (마나 회복)\033[0m')&#10;                else:&#10;                    # 마나가 아직 최대가 아니면 복구 불가&#10;                    pass&#10;&#10;        # 파티클 업데이트 (상태와 무관하게 항상 실행)&#10;        for p in self.particles:&#10;            p.update()&#10;        self.particles = [p for p in self.particles if p.life &gt; 0]&#10;&#10;        # 공격 이펙트 업데이트&#10;        for effect in self.attack_effects:&#10;            effect.update()&#10;        self.attack_effects = [e for e in self.attack_effects if e.life &gt; 0]&#10;&#10;        # 장비 업데이트&#10;        self.equipment_manager.update()&#10;&#10;    # 인벤토리 패시브 재적용&#10;    def rebuild_inventory_passives(self):&#10;        prefix = 'passive:'&#10;        self.stats.clear_by_prefix(prefix)&#10;        # 모든 슬롯 순회&#10;        try:&#10;            for r in range(self.inventory.rows):&#10;                for c in range(self.inventory.cols):&#10;                    slot = self.inventory.get_slot(r, c)&#10;                    if slot.is_empty():&#10;                        continue&#10;                    item = slot.item&#10;                    if getattr(item, 'passive', None):&#10;                        # 수량만큼 배수 적용(스택형 패시브 고려)&#10;                        qty = max(1, slot.quantity)&#10;                        values = {k: v * qty for k, v in item.passive.items()}&#10;                        mod_id = f'{prefix}{item.id}:{r},{c}'&#10;                        self.stats.add_modifier(StatModifier(mod_id, values, duration=None))&#10;        except Exception as ex:&#10;            print(f&quot;\033[91m[Player] 패시브 적용 중 오류: {ex}\033[0m&quot;)&#10;&#10;    # 소비형 아이템 사용 처리&#10;    def consume_item_at(self, r: int, c: int):&#10;        try:&#10;            slot = self.inventory.get_slot(r, c)&#10;        except Exception as ex:&#10;            print('[Player] 소비 실패: 잘못된 슬롯', ex)&#10;            return False&#10;&#10;        if slot.is_empty() or not getattr(slot.item, 'consumable', None):&#10;            return False&#10;&#10;        item = slot.item&#10;&#10;        # 아이템별 개별 쿨타임 체크&#10;        if item.id in self.item_cooldowns:&#10;            remaining_time = self.item_cooldowns[item.id]&#10;            print(f'\033[93m[Player] {item.name} 쿨타임 중! (남은 시간: {remaining_time:.1f}초)\033[0m')&#10;            return False&#10;&#10;        # 소비형 스탯 적용&#10;        values = dict(item.consumable)&#10;        duration = item.consume_duration&#10;        &#10;        # health와 mana는 즉시 회복 (최대값 제한)&#10;        instant_stats = {}&#10;        modifier_stats = {}&#10;        &#10;        for key, value in values.items():&#10;            if key == 'health':&#10;                # 현재 체력에 회복량을 더하되 최대 체력을 넘지 않도록&#10;                current_health = self.stats.base.get('health', 0.0)&#10;                max_health = self.stats.get('max_health')&#10;                new_health = min(max_health, current_health + value)&#10;                self.stats.base['health'] = new_health&#10;                instant_stats[key] = value&#10;                print(f'[Player] 체력 회복: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})')&#10;            elif key == 'mana':&#10;                # 현재 마나에 회복량을 더하되 최대 마나를 넘지 않도록&#10;                current_mana = self.stats.base.get('mana', 0.0)&#10;                max_mana = self.stats.get('max_mana')&#10;                new_mana = min(max_mana, current_mana + value)&#10;                self.stats.base['mana'] = new_mana&#10;                instant_stats[key] = value&#10;                print(f'[Player] 마나 회복: {current_mana:.1f} -&gt; {new_mana:.1f} (최대: {max_mana:.1f})')&#10;            else:&#10;                # 다른 스탯은 일시적 버프로 적용&#10;                modifier_stats[key] = value&#10;        &#10;        # 일시적 버프가 있는 경우에만 modifier 추가&#10;        if modifier_stats:&#10;            mod_id = f'consumable:{item.id}:{r},{c}:{int(time.time()*1000)%100000}'&#10;            # 아이템 정보를 modifier에 저장 (아이콘, 이름 등)&#10;            item_info = {&#10;                'id': item.id,&#10;                'name': getattr(item, 'name', 'Unknown'),&#10;                'icon': item.get_icon() if hasattr(item, 'get_icon') else None,&#10;                'icon_path': getattr(item, 'icon_path', None)&#10;            }&#10;            self.stats.add_modifier(StatModifier(mod_id, modifier_stats, duration=duration, item_info=item_info))&#10;&#10;        # 1개 소모&#10;        self.inventory.remove_from(r, c, 1)&#10;&#10;        # 아이템별 쿨타임 시작 (아이템에 cooldown 속성이 있는 경우)&#10;        if hasattr(item, 'cooldown') and item.cooldown is not None and item.cooldown &gt; 0:&#10;            self.item_cooldowns[item.id] = item.cooldown&#10;            print(f'\033[93m[Player] {item.name} 사용! 쿨타임 시작 ({item.cooldown}초)\033[0m')&#10;        else:&#10;            print(f'\033[93m[Player] {item.name} 사용! (쿨타임 없음)\033[0m')&#10;&#10;        # 아이템의 이펙트 재생(있다면)&#10;        vfx_fn = (getattr(item, 'on_consume_vfx', None)&#10;                  or getattr(item, '_play_consume_vfx', None)&#10;                  or getattr(item, 'consume_effect', None))&#10;        if callable(vfx_fn):&#10;            try:&#10;                # prefer self.world (assigned by play_mode) so VFX are appended to the correct world dict&#10;                vfx_world = getattr(self, 'world', None)&#10;                # debug log&#10;                try:&#10;                    print(f&quot;[Player] triggering vfx for {getattr(item, 'name', item.id if hasattr(item,'id') else 'Unknown')} world={'set' if vfx_world is not None else 'None'})&quot;)&#10;                except Exception:&#10;                    pass&#10;                vfx_fn(self, world=vfx_world, x=getattr(self, 'x', None), y=getattr(self, 'y', None))&#10;            except Exception as ex:&#10;                print(f'[Player] 아이템 소비 이펙트 오류 ({item.name}):', ex)&#10;&#10;        # 패시브 재적용(수량 변화로 인한 패시브 변경 가능성 고려)&#10;        self.rebuild_inventory_passives()&#10;        print(f&quot;[Player] 소비: {item.name} -&gt; {values} ({duration}s)&quot;)&#10;        return True&#10;&#10;    # 신규: 입력 처리 - 상태머신과 장비 매니저로 이벤트 전달, 이동 벡터 관리&#10;    def handle_event(self, event):&#10;        try:&#10;            from sdl2 import SDL_KEYDOWN, SDL_KEYUP, SDLK_w, SDLK_a, SDLK_s, SDLK_d, SDLK_SPACE&#10;        except Exception:&#10;            SDL_KEYDOWN = SDL_KEYUP = None&#10;            SDLK_w = SDLK_a = SDLK_s = SDLK_d = SDLK_SPACE = None&#10;&#10;        # 1) 스페이스바 입력 처리 - 대시 실행&#10;        try:&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN and event.key == SDLK_SPACE:&#10;                # 대시 스택이 있고, Dash 상태가 아닐 때만 대시 가능&#10;                if self.dash_stack &gt; 0 and not isinstance(self.state_machine.cur_state, Dash):&#10;                    # 대시 스택 소모&#10;                    self.dash_stack -= 1&#10;                    print(f'\033[96m[Player] 대시 사용! 남은 스택: {self.dash_stack}/{self.dash_stack_max}\033[0m')&#10;                    # 대시 재충전 타이머 초기화&#10;                    self.dash_recharge_timer = 0.0&#10;                    # DASH 이벤트 발생&#10;                    if hasattr(self, 'state_machine'):&#10;                        self.state_machine.handle_state_event(('DASH', None))&#10;                elif self.dash_stack &lt;= 0:&#10;                    print(f'\033[93m[Player] 대시 스택 부족! ({self.dash_stack}/{self.dash_stack_max})\033[0m')&#10;        except Exception as ex:&#10;            print('[Player] 스페이스바 입력 처리 오류:', ex)&#10;&#10;        # 2) 장비 매니저에 항상 전달(매니저 내부에서 인벤토리 오픈시 무시 처리)&#10;        try:&#10;            if hasattr(self, 'equipment_manager') and hasattr(self.equipment_manager, 'handle_event'):&#10;                self.equipment_manager.handle_event(event)&#10;        except Exception as ex:&#10;            print('[Player] equipment_manager.handle_event 오류:', ex)&#10;&#10;        # 3) 상태머신으로 원본 입력 이벤트 전달(Tab 매핑 등 predicates가 처리)&#10;        try:&#10;            if hasattr(self, 'state_machine') and hasattr(self.state_machine, 'handle_state_event'):&#10;                self.state_machine.handle_state_event(('INPUT', event))&#10;        except Exception as ex:&#10;            print('[Player] state_machine 입력 이벤트 처리 오류:', ex)&#10;&#10;        # 4) WASD 이동 상태 관리 -&gt; MOVE/STOP 이벤트 생성&#10;        moved_before = any(self.keys_down.values())&#10;        try:&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = True&#10;                    self.dir[1] = 1&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = True&#10;                    self.dir[1] = -1&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = True&#10;                    self.dir[0] = -1&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = True&#10;                    self.dir[0] = 1&#10;            elif SDL_KEYUP is not None and event.type == SDL_KEYUP:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;&#10;        except Exception as ex:&#10;            print('[Player] 이동 입력 처리 오류:', ex)&#10;&#10;        moved_after = any(self.keys_down.values())&#10;        try:&#10;            if not moved_before and moved_after:&#10;                # 시작 이동&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('MOVE', None))&#10;            elif moved_before and not moved_after:&#10;                # 이동 종료&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('STOP', None))&#10;        except Exception as ex:&#10;            print('[Player] MOVE/STOP 이벤트 처리 오류:', ex)&#10;&#10;    # 신규: 렌더링 - 장비/플레이어/이펙트 순서대로 그리기&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표이므로 그대로 사용&#10;&#10;        # 디버그 로그 - 카메라 정보 포함&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except:&#10;            print(f'\033[93m[Player] 카메라 정보 가져오기 실패 (디버그 로그 생략)\033[0m')&#10;&#10;        # if camera is not None:&#10;        #     print(f'[Player] draw at screen ({draw_x:.1f}, {draw_y:.1f}), '&#10;        #           f'world ({self.x:.1f}, {self.y:.1f}), '&#10;        #           f'camera ({camera.x:.1f}, {camera.y:.1f})')&#10;        # else:&#10;        #     print(f'[Player] draw at ({draw_x:.1f}, {draw_y:.1f}), world ({self.x:.1f}, {self.y:.1f}) (NO CAMERA)')&#10;&#10;        # 1) 장비(뒤쪽) 그리기&#10;        if hasattr(self, 'equipment_manager'):&#10;            self.equipment_manager.draw_back(draw_x, draw_y)&#10;&#10;        # 2) 현재 상태 스프라이트(Idle/Run/Inventory)&#10;        try:&#10;            if hasattr(self, 'state_machine'):&#10;                if self.state_machine.current_state is not self.DEATH:&#10;                    self.death_x, self.death_y = draw_x, draw_y&#10;                self.state_machine.draw(draw_x, draw_y)&#10;        except Exception as ex:&#10;            print(f'\033[91m[Player] 상태머신 그리기 오류 발생 : {ex}\033[0m')&#10;&#10;        # 3) 장비(앞쪽) 그리기&#10;        if hasattr(self, 'equipment_manager'):&#10;            self.equipment_manager.draw_front(draw_x, draw_y)&#10;&#10;        # 4) 파티클/공격 이펙트 (카메라 적용)&#10;        try:&#10;            # 위에서 이미 가져온 camera 사용&#10;            for p in getattr(self, 'particles', []):&#10;                if hasattr(p, 'draw'):&#10;                    if camera is not None:&#10;                        particle_draw_x, particle_draw_y = camera.apply(p.x, p.y)&#10;                        p.draw(particle_draw_x, particle_draw_y)&#10;                    else:&#10;                        p.draw(p.x, p.y)&#10;            for e in getattr(self, 'attack_effects', []):&#10;                if hasattr(e, 'draw'):&#10;                    if camera is not None:&#10;                        effect_draw_x, effect_draw_y = camera.apply(e.x, e.y)&#10;                        e.draw(effect_draw_x, effect_draw_y)&#10;                    else:&#10;                        e.draw(e.x, e.y)&#10;        except Exception:&#10;            print(f'\033[91m[Player] 파티클/이펙트 그리기 오류 발생 : {ex}\033[0m')&#10;&#10;        # 화면에 표시되는 히트박스 (카메라 적용된 좌표 사용)&#10;        # player_left = draw_x - self.collision_width / 2&#10;        # player_right = draw_x + self.collision_width / 2&#10;        # player_bottom = draw_y - self.collision_height / 2&#10;        # player_top = draw_y + self.collision_height / 2&#10;        # draw_rectangle(player_left, player_bottom, player_right, player_top)&#10;&#10;    def check_collision_with_projectile(self, projectile):&#10;        &quot;&quot;&quot;몬스터 발사체와의 충돌 감지&#10;&#10;        Args:&#10;            projectile: Projectile을 상속받은 발사체 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 먼저 방패로 방어할 수 있는지 체크&#10;        if hasattr(self, 'shield') and self.shield:&#10;            if self.shield.check_projectile_block(projectile):&#10;                # 방패로 막았으면 투사체를 제거하고 충돌 처리 종료&#10;                return True&#10;&#10;        # 무적 상태이면 충돌 무시&#10;        if hasattr(self, 'invincible') and self.invincible:&#10;            return False&#10;&#10;        # 발사체 크기 (Projectile의 get_collision_box 메서드 사용)&#10;        if hasattr(projectile, 'get_collision_box'):&#10;            projectile_width, projectile_height = projectile.get_collision_box()&#10;        else:&#10;            projectile_width = 30&#10;            projectile_height = 30&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        player_left = self.x - self.collision_width / 2&#10;        player_right = self.x + self.collision_width / 2&#10;        player_bottom = self.y - self.collision_height / 2&#10;        player_top = self.y + self.collision_height / 2&#10;&#10;        proj_left = projectile.x - projectile_width / 2&#10;        proj_right = projectile.x + projectile_width / 2&#10;        proj_bottom = projectile.y - projectile_height / 2&#10;        proj_top = projectile.y + projectile_height / 2&#10;&#10;        # 충돌 검사&#10;        if (player_left &lt; proj_right and player_right &gt; proj_left and&#10;            player_bottom &lt; proj_top and player_top &gt; proj_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(projectile)&#10;            return True&#10;&#10;        return False&#10;&#10;    def check_collision_with_effect(self, effect):&#10;        &quot;&quot;&quot;몬스터 공격 이펙트와의 충돌 감지 (CatThiefSwingEffect 등)&#10;&#10;        Args:&#10;            effect: 공격 이펙트 객체 (get_collision_box 메서드를 가진 이펙트)&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 먼저 방패로 방어할 수 있는지 체크&#10;        if hasattr(self, 'shield') and self.shield:&#10;            # 방패의 방향과 이펙트 위치를 고려하여 방어 판정&#10;            if hasattr(self.shield, 'check_effect_block'):&#10;                if self.shield.check_effect_block(effect):&#10;                    # 방패로 막았으면 충돌 처리 종료&#10;                    print(f&quot;[Player] 방패로 {effect.__class__.__name__} 방어!&quot;)&#10;                    return True&#10;&#10;        # 무적 상태이면 충돌 무시&#10;        if hasattr(self, 'invincible') and self.invincible:&#10;            return False&#10;&#10;        # 이펙트 크기 (get_collision_box 메서드 사용)&#10;        if hasattr(effect, 'get_collision_box'):&#10;            effect_width, effect_height = effect.get_collision_box()&#10;        else:&#10;            # 기본값&#10;            effect_width = 100&#10;            effect_height = 100&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        player_left = self.x - self.collision_width / 2&#10;        player_right = self.x + self.collision_width / 2&#10;        player_bottom = self.y - self.collision_height / 2&#10;        player_top = self.y + self.collision_height / 2&#10;&#10;        effect_left = effect.x - effect_width / 2&#10;        effect_right = effect.x + effect_width / 2&#10;        effect_bottom = effect.y - effect_height / 2&#10;        effect_top = effect.y + effect_height / 2&#10;&#10;        # 충돌 검사&#10;        if (player_left &lt; effect_right and player_right &gt; effect_left and&#10;            player_bottom &lt; effect_top and player_top &gt; effect_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(effect)&#10;            return True&#10;&#10;        return False&#10;&#10;    def on_hit(self, attacker):&#10;        &quot;&quot;&quot;피격 시 호출되는 메서드&#10;&#10;        Args:&#10;            attacker: 공격한 객체 (투사체, 이펙트 등)&#10;        &quot;&quot;&quot;&#10;        # 무적 상태라면 무시&#10;        if self.invincible:&#10;            print(f&quot;[Player] 무적 상태로 피격 무시 (남은 무적시간: {self.invincible_timer:.2f}초)&quot;)&#10;            return&#10;&#10;        # 사망 상태면 무시&#10;        if isinstance(self.state_machine.cur_state, Death):&#10;            return&#10;&#10;        # 무적시간 활성화&#10;        self.invincible = True&#10;        self.invincible_timer = self.invincible_duration&#10;&#10;        # 데미지 계산&#10;        damage = 0&#10;        if hasattr(attacker, 'damage'):&#10;            damage = attacker.damage&#10;        elif hasattr(attacker, 'owner') and hasattr(attacker.owner, 'stats'):&#10;            # 공격자의 스탯에서 데미지 가져오기&#10;            damage = attacker.owner.stats.get('attack_damage')&#10;        else:&#10;            damage = 10.0  # 기본 데미지&#10;&#10;        # 방어력 적산&#10;        defense = self.stats.get('defense') if hasattr(self, 'stats') else 0&#10;        final_damage = max(1.0, damage - defense)&#10;&#10;        # 넉백 효과 적용 (공격자로부터 밀려나는 방향)&#10;        import math&#10;        knockback_distance = 100.0  # 넉백 거리&#10;        knockback_duration = 0.3  # 넉백 지속 시간 (초)&#10;&#10;        # 공격자의 위치 파악&#10;        attacker_x = attacker.x if hasattr(attacker, 'x') else self.x&#10;        attacker_y = attacker.y if hasattr(attacker, 'y') else self.y&#10;&#10;        # 넉백 방향 계산 (공격자 -&gt; 플레이어 방향)&#10;        dx = self.x - attacker_x&#10;        dy = self.y - attacker_y&#10;        distance = math.sqrt(dx * dx + dy * dy)&#10;&#10;        if distance &gt; 0:&#10;            # 정규화된 방향 벡터&#10;            self.knockback_dx = dx / distance&#10;            self.knockback_dy = dy / distance&#10;        else:&#10;            # 공격자와 위치가 같으면 랜덤 방향&#10;            angle = random.uniform(0, 2 * math.pi)&#10;            self.knockback_dx = math.cos(angle)&#10;            self.knockback_dy = math.sin(angle)&#10;&#10;        self.knockback_speed = knockback_distance / knockback_duration&#10;        self.knockback_duration = knockback_duration&#10;        self.knockback_timer = 0.0&#10;&#10;        # 스텟 업데이트 - 체력 감소, 마나 감소 등&#10;        if hasattr(self, 'stats'):&#10;            current_health = self.stats.get('health')&#10;            max_health = self.stats.get('max_health')&#10;            new_health = max(0, current_health - final_damage)&#10;            self.stats.set_base('health', new_health)&#10;&#10;            # 피격 정보 출력&#10;            attacker_name = attacker.__class__.__name__&#10;            DebugPrint = True&#10;            if DebugPrint:&#10;                print(f&quot;\n{'='*60}&quot;)&#10;                print(f&quot;[Player 피격]&quot;)&#10;                print(f&quot;  공격자: {attacker_name}&quot;)&#10;                print(f&quot;  원본 데미지: {damage:.1f}&quot;)&#10;                print(f&quot;  방어력: {defense:.1f}&quot;)&#10;                print(f&quot;  최종 데미지: {final_damage:.1f}&quot;)&#10;                print(f&quot;  체력 변화: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})&quot;)&#10;                print(f&quot;  체력 비율: {(new_health/max_health)*100:.1f}%&quot;)&#10;                print(f&quot;  무적시간: {self.invincible_duration}초 활성화&quot;)&#10;                print(f&quot;  넉백: 거리 {knockback_distance:.1f}px, 지속시간 {knockback_duration:.2f}초&quot;)&#10;&#10;            # 체력이 0 이하면 사망 상태로 전환&#10;            if new_health &lt;= 0:&#10;                print(f&quot;  &gt;&gt;&gt; Player 체력 0 - 사망 상태로 전환&quot;)&#10;                print(f&quot;{'='*60}\n&quot;)&#10;                self.state_machine.handle_state_event(('DIE', attacker))&#10;                return  # 사망 시 이펙트 생성하지 않음&#10;            else:&#10;                print(f&quot;{'='*60}\n&quot;)&#10;        else:&#10;            attacker_name = attacker.__class__.__name__&#10;            print(f&quot;[Player] 피격당함! 공격자: {attacker_name} (스탯 시스템 없음)&quot;)&#10;&#10;        # 피격 이펙트 재생 - Wound Particle 생성 (4개)&#10;        for i in range(4):&#10;            # 랜덤한 방향으로 파티클 발사&#10;            angle = random.uniform(0, 2 * math.pi)&#10;            speed = random.uniform(80, 150)  # 속도 랜덤&#10;            vx = math.cos(angle) * speed&#10;            vy = math.sin(angle) * speed + random.uniform(50, 100) # 위쪽으로 약간 더 많이&#10;&#10;            # 플레이어 위치에서 약간 랜덤한 오프셋&#10;            offset_x = random.uniform(-10, 10)&#10;            offset_y = random.uniform(-10, 10)&#10;&#10;            wound_particle = VFX_Wound_Particle(&#10;                self.x + offset_x,&#10;                self.y + offset_y,&#10;                vx, vy,&#10;                scale=3.0&#10;            )&#10;            self.particles.append(wound_particle)&#10;&#10;        print(f&quot;[Player] 피격 이펙트 생성 완료 (Wound Particle x4)&quot;)&#10;&#10;        # 데미지 인디케이터 생성&#10;        try:&#10;            if hasattr(self, 'world') and self.world and 'effects_front' in self.world:&#10;                dmg_indicator = DamageIndicator(&#10;                    x=self.x,&#10;                    y=self.y,&#10;                    damage=final_damage,&#10;                    font_size=20&#10;                )&#10;                self.world['effects_front'].append(dmg_indicator)&#10;                print(f&quot;[Player] 데미지 인디케이터 생성: {final_damage:.1f} 데미지&quot;)&#10;        except Exception as ex:&#10;            print(f'\033[91m[Player] 데미지 인디케이터 생성 실패: {ex}\033[0m')&#10;            pass&#10;&#10;        # TODO: 추후 추가 가능&#10;        # - 피격 사운드&#10;&#10;    def on_death(self):&#10;        &quot;&quot;&quot;사망 처리 - 상태 머신을 통해 Death 상태로 전환&quot;&quot;&quot;&#10;        print(&quot;[Player] on_death 호출 - Death 상태로 전환&quot;)&#10;        self.state_machine.handle_state_event(('DIE', None))&#10;&#10;class VFX_Run_Particle:&#10;    def __init__(self, x, y, frames, frame_duration, scale):&#10;        self.x, self.y = x, y&#10;        self.frames = frames&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = frame_duration&#10;        self.scale_factor = scale&#10;        self.life = len(frames) * frame_duration&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt; 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.frames)&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.draw(draw_x, draw_y, image.w * self.scale_factor, image.h * self.scale_factor)&#10;&#10;&#10;class VFX_Wound_Particle:&#10;    &quot;&quot;&quot;피격 시 출혈 파티클 이펙트 (개별 이미지 파일 사용)&quot;&quot;&quot;&#10;    _frames = None  # 클래스 변수로 이미지 프레임 공유&#10;&#10;    def __init__(self, x, y, vx, vy, scale=3.0):&#10;        # 이미지 프레임 로드 (최초 1회만)&#10;        if VFX_Wound_Particle._frames is None:&#10;            VFX_Wound_Particle._frames = []&#10;            wound_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Wound_Particle')&#10;            try:&#10;                for i in range(5):  # WoundParticle_0 ~ WoundParticle_4&#10;                    img_path = os.path.join(wound_folder, f'WoundParticle_{i}.png')&#10;                    frame = load_image(img_path)&#10;                    VFX_Wound_Particle._frames.append(frame)&#10;                print(f&quot;[WoundParticle] 이미지 로드 완료: {len(VFX_Wound_Particle._frames)}개 프레임&quot;)&#10;            except Exception as ex:&#10;                print(f&quot;[WoundParticle] 이미지 로드 실패: {ex}&quot;)&#10;                VFX_Wound_Particle._frames = []&#10;&#10;        self.x = x&#10;        self.y = y&#10;        self.vx = vx  # x 방향 속도&#10;        self.vy = vy  # y 방향 속도&#10;        self.scale_factor = scale&#10;&#10;        # 애니메이션 설정&#10;        self.total_frames = 5  # 총 프레임 수&#10;        self.current_frame = 0&#10;        self.frame_duration = 0.08  # 각 프레임당 0.08초&#10;        self.frame_time_acc = 0.0&#10;        self.life = self.total_frames * self.frame_duration  # 총 수명&#10;&#10;        # 중력 효과&#10;        self.gravity = 200.0  # 픽셀/초^2&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 수명 감소&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False&#10;&#10;        # 물리 업데이트&#10;        self.x += self.vx * dt&#10;        self.y += self.vy * dt&#10;        self.vy -= self.gravity * dt  # 중력 적용&#10;&#10;        # 애니메이션 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.current_frame += 1&#10;            if self.current_frame &gt;= self.total_frames:&#10;                self.current_frame = self.total_frames - 1  # 마지막 프레임 유지&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if not VFX_Wound_Particle._frames or len(VFX_Wound_Particle._frames) == 0:&#10;            return&#10;&#10;        if self.current_frame &lt; len(VFX_Wound_Particle._frames):&#10;            image = VFX_Wound_Particle._frames[self.current_frame]&#10;            image.draw(&#10;                draw_x, draw_y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;&#10;&#10;# VFX 전역 배율 설정: 전체 이펙트 크기와 거리(범위)를 일괄 조정&#10;VFX_GLOBAL_SCALE_MULT = 0.7   # 이펙트 크기 0.7배&#10;VFX_GLOBAL_RANGE_MULT = 0.8   # 이펙트 거리 0.8배&#10;&#10;class VFX_Tier1_Sword_Swing:&#10;    &quot;&quot;&quot;검 공격 이펙트 VFX&quot;&quot;&quot;&#10;    def __init__(self, x, y, angle, flip, scale=4.5, range_factor=60, variant=1, owner=None):&#10;        import math&#10;&#10;        # 공격자 정보 저장&#10;        self.owner = owner&#10;&#10;        # 데미지 설정 (owner의 스탯에서 가져오거나 기본값 사용)&#10;        if owner and hasattr(owner, 'stats'):&#10;            self.damage = owner.stats.get('attack_damage')&#10;        else:&#10;            self.damage = 20.0  # 기본 데미지&#10;&#10;        # 전역 배율을 적용한 range_factor/scale 사용&#10;        range_factor = range_factor * VFX_GLOBAL_RANGE_MULT&#10;        scale = scale * VFX_GLOBAL_SCALE_MULT&#10;&#10;        # 받은 위치에서 angle 방향으로 range_factor만큼 떨어진 위치 계산&#10;        temp_x = range_factor * math.cos(angle)&#10;        temp_y = range_factor * math.sin(angle)&#10;&#10;        self.x = x + temp_x&#10;        self.y = y + temp_y&#10;&#10;        # 각도 조정: 마우스가 오른쪽(0도~90도, 270도~360도)일 때 -90도, 왼쪽일 때 +90도&#10;        angle_deg = math.degrees(angle) % 360&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽&#10;            self.angle = angle + math.radians(90)&#10;        else:  # 오른쪽&#10;            self.angle = angle - math.radians(90)&#10;&#10;        self.flip = flip&#10;        self.scale_factor = scale&#10;&#10;        # 이펙트 이미지 로드&#10;        fx_folder = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Swing_FX')&#10;        if variant == 1:&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;        elif variant == 2:&#10;            # 콤보 전용 스프라이트&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_1.png'))&#10;            ]&#10;        elif variant == 3:&#10;            # Heavy swing (3스테이지) - 여러 프레임&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_1.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_2.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_3.png'))&#10;            ]&#10;        else:&#10;            # 안전망: 기본으로 variant 1 사용&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.05  # 각 프레임당 0.05초&#10;        self.life = len(self.frames) * self.frame_duration  # 총 수명&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame += 1&#10;            if self.frame &gt;= len(self.frames):&#10;                self.frame = len(self.frames) - 1  # 마지막 프레임 유지&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.clip_composite_draw(&#10;                0, 0, image.w, image.h,&#10;                self.angle, self.flip,&#10;                draw_x, draw_y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;" />
              <option name="updatedContent" value="# 패키지 내부 모듈을 직접 실행할 경우 친절한 안내 후 종료&#10;if __name__ == &quot;__main__&quot; and (__package__ is None or __package__ == &quot;&quot;):&#10;    import sys&#10;    print(&quot;이 모듈은 game_logic 패키지 내부 모듈입니다. 프로젝트 루트에서 main.py를 실행하세요.&quot;)&#10;    sys.exit(1)&#10;&#10;import ctypes&#10;import os&#10;import random&#10;import time&#10;&#10;from pico2d import load_image, get_canvas_height, get_canvas_width, draw_rectangle&#10;from sdl2 import (SDL_KEYDOWN, SDL_KEYUP, SDLK_a, SDLK_d, SDLK_w, SDLK_s, SDLK_TAB, SDLK_SPACE, SDL_GetMouseState,&#10;                   SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT)&#10;&#10;from .equipment import EquipmentManager, Sword, Shield&#10;from .state_machine import StateMachine&#10;import game_framework as framework&#10;# 인벤토리 데이터 모델 import&#10;from .inventory import InventoryData, seed_debug_inventory&#10;from .stats import PlayerStats, StatModifier&#10;from .damage_indicator import DamageIndicator&#10;&#10;def Akey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_a&#10;def Akey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_a&#10;def Dkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_d&#10;def Dkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_d&#10;def Wkey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_w&#10;def Wkey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_w&#10;def Skey_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_s&#10;def Skey_up(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYUP and e[1].key == SDLK_s&#10;&#10;# 스페이스바 입력 검사용 predicate&#10;def Space_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_SPACE&#10;&#10;# 커스텀 이벤트 정의&#10;def move_event(e):&#10;    return e[0] == 'MOVE'&#10;&#10;def stop_event(e):&#10;    return e[0] == 'STOP'&#10;&#10;# 대시 이벤트 정의&#10;def dash_event(e):&#10;    return e[0] == 'DASH'&#10;&#10;def dash_end_event(e):&#10;    return e[0] == 'DASH_END'&#10;&#10;# Tab 키 입력 검사용 predicate (StateMachine 매핑용)&#10;def Tab_down(e):&#10;    return e[0] == 'INPUT' and e[1].type == SDL_KEYDOWN and e[1].key == SDLK_TAB&#10;&#10;class Run:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix, path):&#10;            files = sorted([f for f in os.listdir(path)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(path, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#10;&#10;        # 파티클 리소스 로드&#10;        particle_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Run_Dust')&#10;        self.particle_frames = load_seq('RunDust_Ver2_', particle_folder)&#10;        self.particle_spawn_timer = 0.0&#10;        self.particle_spawn_interval = 0.15 # 파티클 생성 간격&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Move frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.06&#10;        self.moving_speed = 300 # 초당 픽셀&#10;&#10;    def enter(self, e):&#10;        # 파티클 타이머만 초기화&#10;        self.particle_spawn_timer = 0.0&#10;&#10;    def exit(self, e):&#10;        # 파티클을 제거하지 않고 그대로 둠&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 플레이어 애니메이션 및 위치 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;        # 현재 스탯 기반 이동 속도 사용&#10;        moving_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else self.moving_speed&#10;        dir_magnitude = (self.player.dir[0] ** 2 + self.player.dir[1] ** 2) ** 0.5&#10;        if dir_magnitude &gt; 0:&#10;            norm_dir_x = self.player.dir[0] / dir_magnitude&#10;            norm_dir_y = self.player.dir[1] / dir_magnitude&#10;            new_x = self.player.x + norm_dir_x * moving_speed * dt&#10;            new_y = self.player.y + norm_dir_y * moving_speed * dt&#10;&#10;            # 맵 경계 체크 (카메라/월드 좌표 기반)&#10;            # lobby_mode에서 맵 크기를 가져와 경계 체크&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                # 배경 오브젝트에서 맵 크기 계산&#10;                if world['bg']:&#10;                    bg = world['bg'][0]&#10;                    map_width = bg.image.w * bg.scale&#10;                    map_height = bg.image.h * bg.scale&#10;                    # 맵의 중심이 (0, 0)이므로 경계는 ±map_width/2, ±map_height/2&#10;                    map_left = -map_width / 2&#10;                    map_right = map_width / 2&#10;                    map_bottom = -map_height / 2&#10;                    map_top = map_height / 2&#10;&#10;                    # 플레이어가 맵 경계를 벗어나지 않도록 제한&#10;                    if new_x &lt; map_left:&#10;                        new_x = map_left&#10;                    elif new_x &gt; map_right:&#10;                        new_x = map_right&#10;                    if new_y &lt; map_bottom:&#10;                        new_y = map_bottom&#10;                    elif new_y &gt; map_top:&#10;                        new_y = map_top&#10;            except Exception:&#10;                # 맵 정보를 가져올 수 없으면 화면 경계로 폴백&#10;                if new_x &gt; get_canvas_width():&#10;                    new_x = get_canvas_width()&#10;                elif new_x &lt; 0:&#10;                    new_x = 0&#10;                if new_y &gt; get_canvas_height():&#10;                    new_y = get_canvas_height()&#10;                elif new_y &lt; 0:&#10;                    new_y = 0&#10;&#10;            # 벽 충돌 체크 (플레이어 크기 32x48)&#10;            collided = False&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                for wall in world['walls']:&#10;                    if wall.check_collision(new_x - 32//2, new_y - 48//2, 32, 48):&#10;                        collided = True&#10;                        break&#10;            except Exception:&#10;                pass&#10;            if not collided:&#10;                self.player.x = new_x&#10;                self.player.y = new_y&#10;&#10;&#10;        # 파티클 생성&#10;        self.particle_spawn_timer += dt&#10;        if self.particle_spawn_timer &gt;= self.particle_spawn_interval:&#10;            self.particle_spawn_timer -= self.particle_spawn_interval&#10;            # 플레이어 발밑에 파티클 생성 (월드 좌표 사용)&#10;            # y 오프셋을 줄여서 발 위치에 더 가깝게 배치&#10;            particle_x = self.player.x + random.uniform(-10, 10)&#10;            particle_y = self.player.y - 20 + random.uniform(-5, 5)  # -40에서 -20으로 조정&#10;            new_particle = VFX_Run_Particle(particle_x, particle_y, self.particle_frames, 0.05, 2.0)&#10;            self.player.particles.append(new_particle)&#10;&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;&#10;        # camera 가져오기 - play_mode 우선, lobby_mode로 폴백&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            print(f&quot;\033[91m[player Idle] 카메라 가져오기 실패\033[0m&quot;)&#10;&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;class Dash:&#10;    &quot;&quot;&quot;대시 상태: 스페이스바로 활성화, 빠른 속도로 짧은 거리 이동&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix, path):&#10;            files = sorted([f for f in os.listdir(path)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(path, f)) for f in files]&#10;&#10;        # 대시용 애니메이션 프레임 (Run과 동일한 프레임 사용)&#10;        self.lower_frames = load_seq('Player_Adventurer_Move_Lower', folder)&#10;        self.upper_frames = load_seq('Player_Adventurer_Move_Upper', folder)&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Dash frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.03  # Run보다 2배 빠른 애니메이션&#10;&#10;        # 대시 설정&#10;        self.dash_duration = 0.15  # 대시 지속 시간 (0.15초)&#10;        self.dash_timer = 0.0  # 대시 경과 시간&#10;        self.dash_speed_multiplier = 4  # Run 속도의 4배&#10;&#10;        # 대시 방향 저장 (enter에서 설정)&#10;        self.dash_direction = [1, 0]  # 기본값: 오른쪽&#10;        self.return_to_idle = False  # Idle로 복귀할지 Run으로 복귀할지&#10;&#10;        # 잔상 이펙트 타이머&#10;        self.trail_timer = 0.0  # 잔상 생성 타이머&#10;        self.trail_interval = 0.04  # 잔상 생성 간격&#10;&#10;    def enter(self, e):&#10;        &quot;&quot;&quot;대시 상태 진입&quot;&quot;&quot;&#10;        # 대시 타이머 초기화&#10;        self.dash_timer = 0.0&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;&#10;        # 잔상 타이머 초기화&#10;        self.trail_timer = 0.0&#10;&#10;        # 무적 시간 활성화 (0.15초)&#10;        self.player.invincible = True&#10;        self.player.invincible_timer = 0.3&#10;        print(f&quot;[Dash] 무적 시간 활성화 (0.3초)&quot;)&#10;&#10;        # 대시 방향 결정&#10;        # Run 상태에서 왔으면 현재 이동 방향으로 대시&#10;        # Idle 상태에서 왔으면 오른쪽(face_dir)으로 대시&#10;        if self.player.dir[0] != 0 or self.player.dir[1] != 0:&#10;            # 이동 중이었으면 그 방향으로 대시&#10;            self.dash_direction = self.player.dir.copy()&#10;            self.return_to_idle = False&#10;            print(f&quot;[Dash] Run에서 대시 시작 - 방향: ({self.dash_direction[0]}, {self.dash_direction[1]})&quot;)&#10;        else:&#10;            # 정지 상태였으면 face_dir 방향으로 대시&#10;            self.dash_direction = [self.player.face_dir, 0]&#10;            self.return_to_idle = True&#10;            print(f&quot;[Dash] Idle에서 대시 시작 - 방향: 오른쪽({self.player.face_dir})&quot;)&#10;&#10;    def exit(self, e):&#10;        &quot;&quot;&quot;대시 상태 종료&quot;&quot;&quot;&#10;        print(f&quot;[Dash] 대시 종료 - {'Idle' if self.return_to_idle else 'Run'}로 복귀&quot;)&#10;        pass&#10;&#10;    def do(self):&#10;        &quot;&quot;&quot;대시 업데이트: 빠른 속도로 이동하고 시간이 지나면 종료&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 대시 타이머 업데이트&#10;        self.dash_timer += dt&#10;&#10;        # 잔상 타이머 업데이트 및 생성&#10;        self.trail_timer += dt&#10;        if self.trail_timer &gt;= self.trail_interval:&#10;            self.trail_timer -= self.trail_interval&#10;            # 잔상 이펙트 생성&#10;            self._create_trail_effect()&#10;&#10;        # 애니메이션 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;        # 대시 이동 처리&#10;        # 현재 스탯 기반 이동 속도 사용&#10;        base_speed = self.player.stats.get('move_speed') if hasattr(self.player, 'stats') else 300&#10;        dash_speed = base_speed * self.dash_speed_multiplier&#10;&#10;        # 방향 정규화&#10;        dir_magnitude = (self.dash_direction[0] ** 2 + self.dash_direction[1] ** 2) ** 0.5&#10;        if dir_magnitude &gt; 0:&#10;            norm_dir_x = self.dash_direction[0] / dir_magnitude&#10;            norm_dir_y = self.dash_direction[1] / dir_magnitude&#10;            new_x = self.player.x + norm_dir_x * dash_speed * dt&#10;            new_y = self.player.y + norm_dir_y * dash_speed * dt&#10;&#10;            # 맵 경계 체크 및 벽 충돌 체크 (Run과 동일한 로직)&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                if world['bg']:&#10;                    bg = world['bg'][0]&#10;                    map_width = bg.image.w * bg.scale&#10;                    map_height = bg.image.h * bg.scale&#10;                    map_left = -map_width / 2&#10;                    map_right = map_width / 2&#10;                    map_bottom = -map_height / 2&#10;                    map_top = map_height / 2&#10;&#10;                    if new_x &lt; map_left:&#10;                        new_x = map_left&#10;                    elif new_x &gt; map_right:&#10;                        new_x = map_right&#10;                    if new_y &lt; map_bottom:&#10;                        new_y = map_bottom&#10;                    elif new_y &gt; map_top:&#10;                        new_y = map_top&#10;            except Exception:&#10;                if new_x &gt; get_canvas_width():&#10;                    new_x = get_canvas_width()&#10;                elif new_x &lt; 0:&#10;                    new_x = 0&#10;                if new_y &gt; get_canvas_height():&#10;                    new_y = get_canvas_height()&#10;                elif new_y &lt; 0:&#10;                    new_y = 0&#10;&#10;            # 벽 충돌 체크&#10;            collided = False&#10;            try:&#10;                from game_logic.lobby_mode import world&#10;                for wall in world['walls']:&#10;                    if wall.check_collision(new_x - 32//2, new_y - 48//2, 32, 48):&#10;                        collided = True&#10;                        break&#10;            except Exception:&#10;                pass&#10;&#10;            if not collided:&#10;                self.player.x = new_x&#10;                self.player.y = new_y&#10;&#10;        # 대시 지속 시간이 끝나면 상태 전환&#10;        if self.dash_timer &gt;= self.dash_duration:&#10;            # DASH_END 이벤트 발생&#10;            self.player.state_machine.handle_state_event(('DASH_END', None))&#10;&#10;    def _create_trail_effect(self):&#10;        &quot;&quot;&quot;대시 잔상 이펙트를 생성하여 world의 effects_back 레이어에 추가&quot;&quot;&quot;&#10;        try:&#10;            # vfx 모듈에서 DashTrailEffect import&#10;            from .vfx import DashTrailEffect&#10;&#10;            # 현재 플레이어 위치에 잔상 생성&#10;            trail = DashTrailEffect(&#10;                x=self.player.x,&#10;                y=self.player.y,&#10;                face_dir=self.player.face_dir,&#10;                scale=self.player.scale_factor&#10;            )&#10;&#10;            # world의 effects_back 레이어에 추가&#10;            if hasattr(self.player, 'world') and self.player.world:&#10;                if 'effects_back' in self.player.world:&#10;                    self.player.world['effects_back'].append(trail)&#10;                    print(f&quot;[Dash] 잔상 이펙트 생성 at ({self.player.x:.1f}, {self.player.y:.1f})&quot;)&#10;                else:&#10;                    print(f&quot;\033[93m[Dash] world에 effects_back 레이어가 없습니다\033[0m&quot;)&#10;            else:&#10;                print(f&quot;\033[93m[Dash] player.world가 설정되지 않았습니다\033[0m&quot;)&#10;        except Exception as ex:&#10;            print(f&quot;\033[91m[Dash] 잔상 이펙트 생성 실패: {ex}\033[0m&quot;)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;대시 상태 그리기 (Run과 동일한 스타일)&quot;&quot;&quot;&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;&#10;        # camera 가져오기&#10;        camera = None&#10;        try:&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            pass&#10;&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip, draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip, draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip, draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip, draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;class Idle:&#10;    def __init__(self, player):&#10;        self.player = player&#10;        folder = os.path.join('resources', 'Texture_organize', 'Player_character', 'Adventurer')&#10;&#10;        def load_seq(prefix):&#10;            files = sorted([f for f in os.listdir(folder)&#10;                           if isinstance(f, str) and f.startswith(prefix) and f.lower().endswith('.png')])&#10;            return [load_image(os.path.join(folder, f)) for f in files]&#10;&#10;        self.lower_frames = load_seq('Player_Adventurer_Idle_Lower')&#10;        self.upper_frames = load_seq('Player_Adventurer_Idle_Upper')&#10;&#10;        if not self.lower_frames or not self.upper_frames:&#10;            raise RuntimeError(f'Idle frames not found in {folder}')&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.12&#10;&#10;    def enter(self, e):&#10;        self.player.dir = [0, 0]&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.frame_time_acc += dt&#10;        while self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.lower_frames)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 마우스 위치 읽기&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_w = get_canvas_width()&#10;        canvas_h = get_canvas_height()&#10;&#10;        # camera 가져오기 - play_mode 우선, lobby_mode로 폴백&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except Exception:&#10;            print(f&quot;\033[91m[player Idle] 카메라 가져오기 실패\033[0m&quot;)&#10;&#10;        # 마우스 좌표를 월드 좌표로 변환&#10;        if camera is not None:&#10;            mouse_game_x = mx.value + (camera.x - canvas_w // 2)&#10;            mouse_game_y = (canvas_h - my.value) + (camera.y - canvas_h // 2)&#10;        else:&#10;            mouse_game_x = mx.value&#10;            mouse_game_y = canvas_h - my.value&#10;&#10;        # 마우스 x좌표 기준 face_dir 결정&#10;        if mouse_game_x &lt; self.player.x:&#10;            self.player.face_dir = -1&#10;        else:&#10;            self.player.face_dir = 1&#10;        flip = '' if self.player.face_dir == 1 else 'h'&#10;        lower = self.lower_frames[self.frame]&#10;        upper = self.upper_frames[self.frame]&#10;        lw, lh = lower.w, lower.h&#10;        uw, uh = upper.w, upper.h&#10;&#10;        # 마우스 y좌표 기준 upper/lower 순서 결정&#10;        if mouse_game_y &gt; self.player.y:&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;        else:&#10;            upper.clip_composite_draw(0, 0, uw, uh, 0, flip,draw_x, draw_y,&#10;                                      uw * self.player.scale_factor, uh * self.player.scale_factor)&#10;            lower.clip_composite_draw(0, 0, lw, lh, 0, flip,draw_x, draw_y,&#10;                                      lw * self.player.scale_factor, lh * self.player.scale_factor)&#10;&#10;&#10;class Inventory:&#10;    &quot;&quot;&quot;인벤토리 상태: enter에서 이미지 로드, draw에서 중앙 오른쪽에 표시 (시뮬레이션 정지 없음)&quot;&quot;&quot;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.image = None&#10;        self.scale = 1.0&#10;        self.prev_state = None  # 이전 상태 저장용&#10;&#10;    def enter(self, e):&#10;        # 현재 상태를 이전 상태로 저장 (복귀용)&#10;        self.prev_state = self.player.state_machine.cur_state&#10;&#10;        # 이미지 지연 로드(오버레이에서도 사용 가능하도록 유지하되, 여기서는 그리지 않음)&#10;        if self.image is None:&#10;            img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Inventory', 'InventoryBase_New1.png')&#10;            try:&#10;                self.image = load_image(img_path)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load inventory image: {img_path}, {ex}\033[0m&quot;)&#10;                self.image = None&#10;&#10;        # 인벤토리 표시 플래그만 설정 (이동은 유지)&#10;        self.player.inventory_open = True&#10;&#10;    def exit(self, e):&#10;        # 표시 플래그만 해제&#10;        self.player.inventory_open = False&#10;&#10;    def do(self):&#10;        # 현재 키 상태에 따라 Idle/Run의 do를 동적으로 실행&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.do()&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 현재 키 상태에 따라 Idle/Run의 draw를 먼저 실행 (플레이어 표시)&#10;        active_state = self.player.RUN if any(self.player.keys_down.values()) else self.player.IDLE&#10;        active_state.draw(draw_x, draw_y)&#10;        # 인벤토리 이미지를 화면 오른쪽에 표시 (카메라 스크롤 영향 없음)&#10;        # if self.image:&#10;        #     canvas_w = get_canvas_width()&#10;        #     canvas_h = get_canvas_height()&#10;        #     inv_x = canvas_w - self.image.w * self.scale // 2 - 20&#10;        #     inv_y = canvas_h // 2&#10;        #     self.image.draw(inv_x, inv_y, self.image.w * self.scale, self.image.h * self.scale)&#10;        pass&#10;&#10;class Death:&#10;    &quot;&quot;&quot;플레이어 사망 상태&quot;&quot;&quot;&#10;    image = None&#10;    hit_fx_images = None  # PlayerHitFX 이미지들&#10;    heart_hit_images = None  # HeartHit 이미지들&#10;&#10;    def __init__(self, player):&#10;        self.player = player&#10;        self.world = getattr(player, 'world', None)  # play_mode에서 할당된 world 참조&#10;&#10;        if Death.image is None:&#10;            try:&#10;                Death.image = load_image('resources/Texture_organize/Player_character/Adventurer/Player_Adventurer_Down00.png')&#10;                print(f&quot;[Player Death] Loaded Down00 image&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] Failed to load image: {e}\033[0m&quot;)&#10;                Death.image = None&#10;&#10;        # PlayerHitFX 이미지 로드 (1 ~ 9)&#10;        if Death.hit_fx_images is None:&#10;            Death.hit_fx_images = []&#10;            try:&#10;                for i in range(1, 10):  # PlayerHitFX01 ~ PlayerHitFX09&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Die_Animation', f'PlayerHitFX0{i}.png')&#10;                    img = load_image(img_path)&#10;                    Death.hit_fx_images.append(img)&#10;                print(f&quot;[Player Death] PlayerHitFX 이미지 로드 완료: {len(Death.hit_fx_images)}개&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] PlayerHitFX 이미지 로드 실패: {e}\033[0m&quot;)&#10;                Death.hit_fx_images = []&#10;&#10;        # HeartHit 이미지 로드 (0 ~ 8)&#10;        if Death.heart_hit_images is None:&#10;            Death.heart_hit_images = []&#10;            try:&#10;                for i in range(9):  # HeartHit0_0 ~ HeartHit8_0&#10;                    img_path = os.path.join('resources', 'Texture_organize', 'UI', 'Hit_verdict', f'HeartHit{i}_0.png')&#10;                    img = load_image(img_path)&#10;                    Death.heart_hit_images.append(img)&#10;                print(f&quot;[Player Death] HeartHit 이미지 로드 완료: {len(Death.heart_hit_images)}개&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[Player Death] HeartHit 이미지 로드 실패: {e}\033[0m&quot;)&#10;                Death.heart_hit_images = []&#10;&#10;        self.death_timer = 0.0&#10;        self.death_conversion = 2.0  # 2초 후 변환&#10;        self.death_duration = 6.0  # 6초 후 종료&#10;        self.game_over_conversion_triggered = False&#10;        self.game_over_triggered = False&#10;&#10;        # 넉백 관련 변수 (강한 넉백)&#10;        self.knockback_dx = 0&#10;        self.knockback_dy = 0&#10;        self.knockback_speed = 400  # 강한 넉백&#10;        self.knockback_duration = 0.5  # 0.5초 동안&#10;        self.knockback_timer = 0.0&#10;&#10;        # 애니메이션 관련 변수&#10;        self.hit_fx_frame = 0&#10;        self.hit_fx_time = 0.0&#10;        self.hit_fx_duration = 0.08  # 각 프레임당 0.08초&#10;&#10;        self.heart_hit_frame = 0&#10;        self.heart_hit_time = 0.0&#10;        self.heart_hit_duration = 0.1  # 각 프레임당 0.1초&#10;&#10;        # 사망 위치 저장 (이동 제거, 죽은 자리에서 유지)&#10;        self.death_x = 0&#10;        self.death_y = 0&#10;&#10;        # 사망 모드용 배경 이미지 클래스&#10;        class BGimage:&#10;            &quot;&quot;&quot;사망 모드용 배경 이미지 클래스&quot;&quot;&quot;&#10;&#10;            def __init__(self, image_path):&#10;                try:&#10;                    self.image = load_image(image_path)&#10;                except Exception as e:&#10;                    print(f&quot;[Defeat Mode BG] 이미지 로드 실패: {e}&quot;)&#10;                    self.image = None&#10;&#10;                self.alpha = 0.0 # 투명도 초기값&#10;&#10;            def do(self):&#10;                pass&#10;&#10;            def update(self):&#10;                # 점진적으로 투명도 증가 / 3초 동안 완전 불투명&#10;                if self.alpha &lt; 1.0:&#10;                    self.alpha += framework.get_delta_time() / 3.0 * 2  # 3초에 걸쳐 1.0 도달&#10;                    if self.alpha &gt; 1.0:&#10;                        self.alpha = 1.0&#10;&#10;            def draw(self):&#10;                if self.image:&#10;                    canvas_w = get_canvas_width()&#10;                    canvas_h = get_canvas_height()&#10;                    self.image.opacify(self.alpha)&#10;                    self.image.draw(canvas_w // 2, canvas_h // 2, canvas_w, canvas_h)&#10;                    self.image.opacify(1.0)&#10;&#10;        # 배경 이미지 인스턴스 생성&#10;        self.BG = BGimage('resources/Texture_organize/UI/Stage_Loading/BlackBG.png')&#10;&#10;    def enter(self, e):&#10;        self.death_timer = 0.0&#10;        self.game_over_triggered = False&#10;        self.knockback_timer = 0.0&#10;&#10;        # 애니메이션 초기화&#10;        self.hit_fx_frame = 0&#10;        self.hit_fx_time = 0.0&#10;        self.heart_hit_frame = 0&#10;        self.heart_hit_time = 0.0&#10;&#10;        # 사망 위치 저장 (현재 월드 좌표 그대로 유지)&#10;        self.death_x = self.player.x&#10;        self.death_y = self.player.y&#10;&#10;        # 플레이어 무장 해제&#10;        self.player.equipment_manager.unequip_all()&#10;&#10;        # 넉백 방향 계산&#10;        if e and len(e) &gt; 1 and e[1] is not None:&#10;            attacker = e[1]&#10;            attacker_x = attacker.x if hasattr(attacker, 'x') else self.player.x&#10;            attacker_y = attacker.y if hasattr(attacker, 'y') else self.player.y&#10;&#10;            if hasattr(attacker, 'owner') and attacker.owner:&#10;                attacker_x = attacker.owner.x&#10;                attacker_y = attacker.owner.y&#10;&#10;            import math&#10;            dx = self.player.x - attacker_x&#10;            dy = self.player.y - attacker_y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            if distance &gt; 0:&#10;                self.knockback_dx = dx / distance&#10;                self.knockback_dy = dy / distance&#10;            else:&#10;                self.knockback_dx = 1.0&#10;                self.knockback_dy = 0.0&#10;        else:&#10;            self.knockback_dx = 1.0&#10;            self.knockback_dy = 0.0&#10;&#10;        print(f&quot;[Player Death State] 사망 상태 시작 (6초 후 defeat_mode로 전환) - 넉백 적용&quot;)&#10;        print(f&quot;[Player Death State] 사망 위치: ({self.death_x:.1f}, {self.death_y:.1f})&quot;)&#10;&#10;    def exit(self, e):&#10;        pass&#10;&#10;    def do(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        self.death_timer += dt&#10;&#10;        # 넉백 효과 적용 (사망 초기 0.5초만, 이후엔 그 자리에 고정)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            # 부드러운 감속&#10;            current_speed = self.knockback_speed * (1.0 - progress) ** 1.5&#10;            self.player.x += self.knockback_dx * current_speed * dt&#10;            self.player.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;        # 넉백 끝난 후에는 위치 고정 (중앙 이동 로직 제거)&#10;&#10;        # PlayerHitFX 애니메이션 업데이트&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#10;            self.hit_fx_time += dt&#10;            if self.hit_fx_time &gt;= self.hit_fx_duration:&#10;                self.hit_fx_time -= self.hit_fx_duration&#10;                self.hit_fx_frame += 1&#10;&#10;        # HeartHit 애니메이션 업데이트&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#10;            self.heart_hit_time += dt&#10;            if self.heart_hit_time &gt;= self.heart_hit_duration:&#10;                self.heart_hit_time -= self.heart_hit_duration&#10;                self.heart_hit_frame += 1&#10;&#10;        # 2초 후 배경 어둡게 시작 (extra_bg 레이어에 배경 추가)&#10;        if self.death_timer &gt;= self.death_conversion and not self.game_over_conversion_triggered:&#10;            self.game_over_conversion_triggered = True&#10;            print(f&quot;[Player Death State] 2초 경과, 배경 어둡게 시작&quot;)&#10;            from .play_mode import world&#10;            # 배경을 extra_bg 레이어에 추가하여 점진적으로 어둡게&#10;            world['extra_bg'].append(self.BG)&#10;            # 플레이어를 extras 레이어로 이동 (UI보다 아래, 배경보다 위에 그려지도록)&#10;            world['extras'].append(self.player)&#10;            if self.player in self.world['entities']:&#10;                world['entities'].remove(self.player)&#10;&#10;        # 6초 후 defeat_mode로 전환&#10;        if self.death_timer &gt;= self.death_duration and not self.game_over_triggered:&#10;            self.game_over_triggered = True&#10;            print(f&quot;[Player Death State] 6초 경과, 패배 모드로 전환&quot;)&#10;            import game_framework&#10;            from . import defeat_mode, play_mode&#10;            # play_mode의 경과 시간을 가져와서 defeat_mode로 전달&#10;            survival_time = getattr(play_mode, 'elapsed_time', 0.0)&#10;            print(f&quot;[Player Death State] 생존 시간: {survival_time:.2f}초&quot;)&#10;            game_framework.change_state(defeat_mode, self.player, survival_time)&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # 플레이어 사망 이미지 (바닥에 누운 모습)&#10;        # draw_x, draw_y는 이미 카메라가 적용된 화면 좌표이므로 그대로 사용&#10;        if Death.image is not None:&#10;            Death.image.draw(draw_x, draw_y,&#10;                           Death.image.w * self.player.scale_factor,&#10;                           Death.image.h * self.player.scale_factor)&#10;&#10;        # PlayerHitFX 이펙트 (플레이어 위치에 크게)&#10;        if Death.hit_fx_images and self.hit_fx_frame &lt; len(Death.hit_fx_images):&#10;            hit_fx_img = Death.hit_fx_images[self.hit_fx_frame]&#10;            scale = 3.0&#10;            hit_fx_img.draw(&#10;                draw_x,&#10;                draw_y,&#10;                hit_fx_img.w * scale,&#10;                hit_fx_img.h * scale&#10;            )&#10;&#10;        # HeartHit 이펙트 (플레이어 위치 기준)&#10;        if Death.heart_hit_images and self.heart_hit_frame &lt; len(Death.heart_hit_images):&#10;            heart_hit_img = Death.heart_hit_images[self.heart_hit_frame]&#10;            scale = 3.0&#10;            heart_hit_img.draw(&#10;                draw_x,&#10;                draw_y,&#10;                heart_hit_img.w * scale,&#10;                heart_hit_img.h * scale&#10;            )&#10;&#10;&#10;# 사망 이벤트 predicate&#10;def die(e):&#10;    return e[0] == 'DIE'&#10;&#10;&#10;class Player:&#10;    def __init__(self):&#10;        self.x = get_canvas_width() // 2&#10;        self.y = get_canvas_height() // 2&#10;        self.death_x = self.x&#10;        self.death_y = self.y&#10;        self.frame = 0&#10;        self.dir = [0, 0]  # x, y 방향 벡터&#10;        self.face_dir = 1&#10;        self.scale_factor = 3.0&#10;        self.keys_down = {'w': False, 'a': False, 's': False, 'd': False}&#10;        self.moving = False # 이동 상태 플래그&#10;        self.particles = [] # 파티클 리스트를 Player로 이동&#10;        self.attack_effects = [] # 공격 이펙트 리스트&#10;        self.dash_stack_max = 3 # 대시 최대 스택&#10;        self.dash_stack = self.dash_stack_max # 대시 스택 초기화&#10;        self.dash_recharge_time = 3.0 # 대시 재충전 시간(초당 1회 충전)&#10;        self.dash_recharge_timer = 0.0 # 대시 재충전 타이머&#10;&#10;        # 플레이어 히트박스 변수&#10;        self.collision_width = 15 * self.scale_factor&#10;        self.collision_height = 15 * self.scale_factor&#10;&#10;        # 무적시간 관련 변수&#10;        self.invincible = False  # 무적 상태인지&#10;        self.invincible_timer = 0.0  # 무적 시간 타이머&#10;        self.invincible_duration = 0.3  # 무적 시간 지속 시간 (0.3초)&#10;&#10;        # 넉백 관련 변수 (방패 방어 시 사용)&#10;        self.knockback_dx = 0.0&#10;        self.knockback_dy = 0.0&#10;        self.knockback_speed = 0.0&#10;        self.knockback_duration = 0.0&#10;        self.knockback_timer = 0.0&#10;&#10;        # 방패 깨짐 상태 변수&#10;        self.shield_broken = False  # 방패가 깨졌는지 여부&#10;&#10;        # 아이템별 개별 쿨타임 관리 시스템&#10;        # key: item.id (아이템 고유 ID), value: 남은 쿨타임 시간(초)&#10;        self.item_cooldowns = {}  # 각 아이템의 남은 쿨타임을 저장&#10;&#10;        # 인벤토리 데이터 생성 및 디버그 아이템 채우기&#10;        self.inventory = InventoryData(cols=6, rows=5)&#10;        try:&#10;            seed_debug_inventory(self.inventory)&#10;        except Exception as ex:&#10;            print('[Player] 디버그 인벤토리 시드 실패:', ex)&#10;&#10;        # 스탯 시스템&#10;        self.stats = PlayerStats()&#10;        # 인벤토리 패시브 적용&#10;        try:&#10;            self.rebuild_inventory_passives()&#10;        except Exception as ex:&#10;            print('[Player] 패시브 재구성 실패:', ex)&#10;&#10;        # 장비 매니저 초기화&#10;        self.equipment_manager = EquipmentManager(self)&#10;&#10;        # 기본 무기 장착 (Tier1 검과 방패)&#10;        sword_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Sword_Tier1.png')&#10;        shield_path = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Tier1', 'Shield_Tier1.png')&#10;&#10;        self.sword = Sword(self, sword_path, scale=3.0)&#10;        self.shield = Shield(self, shield_path, scale=3.0)&#10;&#10;        self.equipment_manager.equip(self.sword)&#10;        self.equipment_manager.equip(self.shield)&#10;&#10;        # 상태 정의&#10;        self.IDLE = Idle(self)&#10;        self.RUN = Run(self)&#10;        self.DASH = Dash(self)  # 대시 상태 추가&#10;        self.INVENTORY = Inventory(self)&#10;        self.DEATH = Death(self)&#10;&#10;        # 전투 플래그(전투중엔 인벤토리 안 염)&#10;        self.in_combat = False&#10;        self.inventory_open = False&#10;&#10;        # 상태 전환에 대한 매핑&#10;        self.state_machine = StateMachine(&#10;            self.IDLE,&#10;            {&#10;                self.IDLE: {move_event: self.RUN, dash_event: self.DASH, Tab_down: self.INVENTORY, die: self.DEATH},&#10;                self.RUN: {stop_event: self.IDLE, dash_event: self.DASH, Tab_down: self.INVENTORY, die: self.DEATH},&#10;                self.DASH: {dash_end_event: None, die: self.DEATH},  # DASH_END에서 이전 상태로 복귀 (None = 동적 처리)&#10;                self.INVENTORY: {Tab_down: None, die: self.DEATH},&#10;                self.DEATH: {},  # 사망 상태에서는 전환 없음&#10;            }&#10;        )&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 이동 전 위치 저장 (벽 충돌 시 롤백용)&#10;        prev_x = self.x&#10;        prev_y = self.y&#10;&#10;        # 넉백 효과 적용 (방패 방어 시)&#10;        if self.knockback_timer &lt; self.knockback_duration:&#10;            progress = self.knockback_timer / self.knockback_duration&#10;            current_speed = self.knockback_speed * (1.0 - progress)&#10;            self.x += self.knockback_dx * current_speed * dt&#10;            self.y += self.knockback_dy * current_speed * dt&#10;            self.knockback_timer += dt&#10;&#10;        # 무적시간 업데이트&#10;        if self.invincible:&#10;            self.invincible_timer -= dt&#10;            if self.invincible_timer &lt;= 0:&#10;                self.invincible = False&#10;                self.invincible_timer = 0.0&#10;&#10;        # 대시 재충전 업데이트&#10;        if self.dash_stack &lt; self.dash_stack_max:&#10;            self.dash_recharge_timer += dt&#10;            if self.dash_recharge_timer &gt;= self.dash_recharge_time:&#10;                self.dash_stack += 1&#10;                self.dash_recharge_timer -= self.dash_recharge_time&#10;                print(f'\033[92m[Player] 대시 스택 충전: {self.dash_stack}/{self.dash_stack_max}\033[0m')&#10;&#10;        # 아이템별 개별 쿨타임 업데이트&#10;        # item_cooldowns 딕셔너리의 각 아이템 ID에 대해 쿨타임 감소&#10;        for item_id in list(self.item_cooldowns.keys()):&#10;            self.item_cooldowns[item_id] -= dt&#10;            if self.item_cooldowns[item_id] &lt;= 0:&#10;                # 쿨타임이 끝나면 딕셔너리에서 제거&#10;                del self.item_cooldowns[item_id]&#10;                print(f'\033[92m[Player] 아이템 사용 가능: {item_id} (쿨타임 종료)\033[0m')&#10;&#10;        self.state_machine.update()&#10;&#10;        # 벽 충돌 검사 (world 참조가 있는 경우)&#10;        if hasattr(self, 'world') and self.world and 'walls' in self.world:&#10;            # 플레이어 히트박스 (중심 기준)&#10;            player_w = 32  # 플레이어 너비 (필요시 조정)&#10;            player_h = 32  # 플레이어 높이 (필요시 조정)&#10;            player_left = self.x - player_w / 2&#10;            player_right = self.x + player_w / 2&#10;            player_bottom = self.y - player_h / 2&#10;            player_top = self.y + player_h / 2&#10;&#10;            # 모든 벽과 충돌 검사&#10;            collision_detected = False&#10;            for wall in self.world['walls']:&#10;                if hasattr(wall, 'check_collision'):&#10;                    # 벽의 히트박스 (중심 기준)&#10;                    wall_left = wall.x - wall.w / 2&#10;                    wall_right = wall.x + wall.w / 2&#10;                    wall_bottom = wall.y - wall.h / 2&#10;                    wall_top = wall.y + wall.h / 2&#10;&#10;                    # AABB 충돌 검사&#10;                    if (player_right &gt; wall_left and player_left &lt; wall_right and&#10;                        player_top &gt; wall_bottom and player_bottom &lt; wall_top):&#10;                        collision_detected = True&#10;                        break&#10;&#10;            # 충돌이 감지되면 이전 위치로 롤백&#10;            if collision_detected:&#10;                self.x = prev_x&#10;                self.y = prev_y&#10;                # 디버그 출력 (필요시 주석 해제)&#10;                # print(f&quot;[Player] 벽 충돌 감지! 위치 롤백: ({self.x:.1f}, {self.y:.1f})&quot;)&#10;&#10;        # 스탯 버프 업데이트(소비형 지속시간 관리)&#10;        if hasattr(self, 'stats'):&#10;            old_mana = self.stats.get('mana')&#10;            self.stats.update()&#10;            new_mana = self.stats.get('mana')&#10;&#10;            # 마나가 0에서 최대로 회복되면 방패 복구&#10;            if hasattr(self, 'shield_broken') and self.shield_broken:&#10;                if new_mana &gt;= 50:&#10;                    self.shield_broken = False&#10;                    print(f'\033[92m[Player] 방패 복구됨 (마나 회복)\033[0m')&#10;                else:&#10;                    # 마나가 아직 최대가 아니면 복구 불가&#10;                    pass&#10;&#10;        # 파티클 업데이트 (상태와 무관하게 항상 실행)&#10;        for p in self.particles:&#10;            p.update()&#10;        self.particles = [p for p in self.particles if p.life &gt; 0]&#10;&#10;        # 공격 이펙트 업데이트&#10;        for effect in self.attack_effects:&#10;            effect.update()&#10;        self.attack_effects = [e for e in self.attack_effects if e.life &gt; 0]&#10;&#10;        # 장비 업데이트&#10;        self.equipment_manager.update()&#10;&#10;    # 인벤토리 패시브 재적용&#10;    def rebuild_inventory_passives(self):&#10;        prefix = 'passive:'&#10;        self.stats.clear_by_prefix(prefix)&#10;        # 모든 슬롯 순회&#10;        try:&#10;            for r in range(self.inventory.rows):&#10;                for c in range(self.inventory.cols):&#10;                    slot = self.inventory.get_slot(r, c)&#10;                    if slot.is_empty():&#10;                        continue&#10;                    item = slot.item&#10;                    if getattr(item, 'passive', None):&#10;                        # 수량만큼 배수 적용(스택형 패시브 고려)&#10;                        qty = max(1, slot.quantity)&#10;                        values = {k: v * qty for k, v in item.passive.items()}&#10;                        mod_id = f'{prefix}{item.id}:{r},{c}'&#10;                        self.stats.add_modifier(StatModifier(mod_id, values, duration=None))&#10;        except Exception as ex:&#10;            print(f&quot;\033[91m[Player] 패시브 적용 중 오류: {ex}\033[0m&quot;)&#10;&#10;    # 소비형 아이템 사용 처리&#10;    def consume_item_at(self, r: int, c: int):&#10;        try:&#10;            slot = self.inventory.get_slot(r, c)&#10;        except Exception as ex:&#10;            print('[Player] 소비 실패: 잘못된 슬롯', ex)&#10;            return False&#10;&#10;        if slot.is_empty() or not getattr(slot.item, 'consumable', None):&#10;            return False&#10;&#10;        item = slot.item&#10;&#10;        # 아이템별 개별 쿨타임 체크&#10;        if item.id in self.item_cooldowns:&#10;            remaining_time = self.item_cooldowns[item.id]&#10;            print(f'\033[93m[Player] {item.name} 쿨타임 중! (남은 시간: {remaining_time:.1f}초)\033[0m')&#10;            return False&#10;&#10;        # 소비형 스탯 적용&#10;        values = dict(item.consumable)&#10;        duration = item.consume_duration&#10;        &#10;        # health와 mana는 즉시 회복 (최대값 제한)&#10;        instant_stats = {}&#10;        modifier_stats = {}&#10;        &#10;        for key, value in values.items():&#10;            if key == 'health':&#10;                # 현재 체력에 회복량을 더하되 최대 체력을 넘지 않도록&#10;                current_health = self.stats.base.get('health', 0.0)&#10;                max_health = self.stats.get('max_health')&#10;                new_health = min(max_health, current_health + value)&#10;                self.stats.base['health'] = new_health&#10;                instant_stats[key] = value&#10;                print(f'[Player] 체력 회복: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})')&#10;            elif key == 'mana':&#10;                # 현재 마나에 회복량을 더하되 최대 마나를 넘지 않도록&#10;                current_mana = self.stats.base.get('mana', 0.0)&#10;                max_mana = self.stats.get('max_mana')&#10;                new_mana = min(max_mana, current_mana + value)&#10;                self.stats.base['mana'] = new_mana&#10;                instant_stats[key] = value&#10;                print(f'[Player] 마나 회복: {current_mana:.1f} -&gt; {new_mana:.1f} (최대: {max_mana:.1f})')&#10;            else:&#10;                # 다른 스탯은 일시적 버프로 적용&#10;                modifier_stats[key] = value&#10;        &#10;        # 일시적 버프가 있는 경우에만 modifier 추가&#10;        if modifier_stats:&#10;            mod_id = f'consumable:{item.id}:{r},{c}:{int(time.time()*1000)%100000}'&#10;            # 아이템 정보를 modifier에 저장 (아이콘, 이름 등)&#10;            item_info = {&#10;                'id': item.id,&#10;                'name': getattr(item, 'name', 'Unknown'),&#10;                'icon': item.get_icon() if hasattr(item, 'get_icon') else None,&#10;                'icon_path': getattr(item, 'icon_path', None)&#10;            }&#10;            self.stats.add_modifier(StatModifier(mod_id, modifier_stats, duration=duration, item_info=item_info))&#10;&#10;        # 1개 소모&#10;        self.inventory.remove_from(r, c, 1)&#10;&#10;        # 아이템별 쿨타임 시작 (아이템에 cooldown 속성이 있는 경우)&#10;        if hasattr(item, 'cooldown') and item.cooldown is not None and item.cooldown &gt; 0:&#10;            self.item_cooldowns[item.id] = item.cooldown&#10;            print(f'\033[93m[Player] {item.name} 사용! 쿨타임 시작 ({item.cooldown}초)\033[0m')&#10;        else:&#10;            print(f'\033[93m[Player] {item.name} 사용! (쿨타임 없음)\033[0m')&#10;&#10;        # 아이템의 이펙트 재생(있다면)&#10;        vfx_fn = (getattr(item, 'on_consume_vfx', None)&#10;                  or getattr(item, '_play_consume_vfx', None)&#10;                  or getattr(item, 'consume_effect', None))&#10;        if callable(vfx_fn):&#10;            try:&#10;                # prefer self.world (assigned by play_mode) so VFX are appended to the correct world dict&#10;                vfx_world = getattr(self, 'world', None)&#10;                # debug log&#10;                try:&#10;                    print(f&quot;[Player] triggering vfx for {getattr(item, 'name', item.id if hasattr(item,'id') else 'Unknown')} world={'set' if vfx_world is not None else 'None'})&quot;)&#10;                except Exception:&#10;                    pass&#10;                vfx_fn(self, world=vfx_world, x=getattr(self, 'x', None), y=getattr(self, 'y', None))&#10;            except Exception as ex:&#10;                print(f'[Player] 아이템 소비 이펙트 오류 ({item.name}):', ex)&#10;&#10;        # 패시브 재적용(수량 변화로 인한 패시브 변경 가능성 고려)&#10;        self.rebuild_inventory_passives()&#10;        print(f&quot;[Player] 소비: {item.name} -&gt; {values} ({duration}s)&quot;)&#10;        return True&#10;&#10;    # 신규: 입력 처리 - 상태머신과 장비 매니저로 이벤트 전달, 이동 벡터 관리&#10;    def handle_event(self, event):&#10;        try:&#10;            from sdl2 import SDL_KEYDOWN, SDL_KEYUP, SDLK_w, SDLK_a, SDLK_s, SDLK_d, SDLK_SPACE&#10;        except Exception:&#10;            SDL_KEYDOWN = SDL_KEYUP = None&#10;            SDLK_w = SDLK_a = SDLK_s = SDLK_d = SDLK_SPACE = None&#10;&#10;        # 1) 스페이스바 입력 처리 - 대시 실행&#10;        try:&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN and event.key == SDLK_SPACE:&#10;                # 대시 스택이 있고, Dash 상태가 아닐 때만 대시 가능&#10;                if self.dash_stack &gt; 0 and not isinstance(self.state_machine.cur_state, Dash):&#10;                    # 대시 스택 소모&#10;                    self.dash_stack -= 1&#10;                    print(f'\033[96m[Player] 대시 사용! 남은 스택: {self.dash_stack}/{self.dash_stack_max}\033[0m')&#10;                    # 대시 재충전 타이머 초기화&#10;                    self.dash_recharge_timer = 0.0&#10;                    # DASH 이벤트 발생&#10;                    if hasattr(self, 'state_machine'):&#10;                        self.state_machine.handle_state_event(('DASH', None))&#10;                elif self.dash_stack &lt;= 0:&#10;                    print(f'\033[93m[Player] 대시 스택 부족! ({self.dash_stack}/{self.dash_stack_max})\033[0m')&#10;        except Exception as ex:&#10;            print('[Player] 스페이스바 입력 처리 오류:', ex)&#10;&#10;        # 2) 장비 매니저에 항상 전달(매니저 내부에서 인벤토리 오픈시 무시 처리)&#10;        try:&#10;            if hasattr(self, 'equipment_manager') and hasattr(self.equipment_manager, 'handle_event'):&#10;                self.equipment_manager.handle_event(event)&#10;        except Exception as ex:&#10;            print('[Player] equipment_manager.handle_event 오류:', ex)&#10;&#10;        # 3) 상태머신으로 원본 입력 이벤트 전달(Tab 매핑 등 predicates가 처리)&#10;        try:&#10;            if hasattr(self, 'state_machine') and hasattr(self.state_machine, 'handle_state_event'):&#10;                self.state_machine.handle_state_event(('INPUT', event))&#10;        except Exception as ex:&#10;            print('[Player] state_machine 입력 이벤트 처리 오류:', ex)&#10;&#10;        # 4) WASD 이동 상태 관리 -&gt; MOVE/STOP 이벤트 생성&#10;        moved_before = any(self.keys_down.values())&#10;        try:&#10;            if SDL_KEYDOWN is not None and event.type == SDL_KEYDOWN:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = True&#10;                    self.dir[1] = 1&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = True&#10;                    self.dir[1] = -1&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = True&#10;                    self.dir[0] = -1&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = True&#10;                    self.dir[0] = 1&#10;            elif SDL_KEYUP is not None and event.type == SDL_KEYUP:&#10;                if event.key == SDLK_w:&#10;                    self.keys_down['w'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_s:&#10;                    self.keys_down['s'] = False&#10;                    self.dir[1] = 1 if self.keys_down['w'] else ( -1 if self.keys_down['s'] else 0)&#10;                elif event.key == SDLK_a:&#10;                    self.keys_down['a'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;                elif event.key == SDLK_d:&#10;                    self.keys_down['d'] = False&#10;                    self.dir[0] = -1 if self.keys_down['a'] else ( 1 if self.keys_down['d'] else 0)&#10;&#10;        except Exception as ex:&#10;            print('[Player] 이동 입력 처리 오류:', ex)&#10;&#10;        moved_after = any(self.keys_down.values())&#10;        try:&#10;            if not moved_before and moved_after:&#10;                # 시작 이동&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('MOVE', None))&#10;            elif moved_before and not moved_after:&#10;                # 이동 종료&#10;                if hasattr(self, 'state_machine'):&#10;                    self.state_machine.handle_state_event(('STOP', None))&#10;        except Exception as ex:&#10;            print('[Player] MOVE/STOP 이벤트 처리 오류:', ex)&#10;&#10;    # 신규: 렌더링 - 장비/플레이어/이펙트 순서대로 그리기&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표이므로 그대로 사용&#10;&#10;        # 디버그 로그 - 카메라 정보 포함&#10;        camera = None&#10;        try:&#10;            # 먼저 play_mode에서 카메라 가져오기 시도&#10;            import game_logic.play_mode as play&#10;            camera = getattr(play, 'camera', None)&#10;&#10;            # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;            if camera is None:&#10;                import game_logic.lobby_mode as lobby&#10;                camera = getattr(lobby, 'camera', None)&#10;        except:&#10;            print(f'\033[93m[Player] 카메라 정보 가져오기 실패 (디버그 로그 생략)\033[0m')&#10;&#10;        # if camera is not None:&#10;        #     print(f'[Player] draw at screen ({draw_x:.1f}, {draw_y:.1f}), '&#10;        #           f'world ({self.x:.1f}, {self.y:.1f}), '&#10;        #           f'camera ({camera.x:.1f}, {camera.y:.1f})')&#10;        # else:&#10;        #     print(f'[Player] draw at ({draw_x:.1f}, {draw_y:.1f}), world ({self.x:.1f}, {self.y:.1f}) (NO CAMERA)')&#10;&#10;        # 1) 장비(뒤쪽) 그리기&#10;        if hasattr(self, 'equipment_manager'):&#10;            self.equipment_manager.draw_back(draw_x, draw_y)&#10;&#10;        # 2) 현재 상태 스프라이트(Idle/Run/Inventory)&#10;        try:&#10;            if hasattr(self, 'state_machine'):&#10;                if self.state_machine.current_state is not self.DEATH:&#10;                    self.death_x, self.death_y = draw_x, draw_y&#10;                self.state_machine.draw(draw_x, draw_y)&#10;        except Exception as ex:&#10;            print(f'\033[91m[Player] 상태머신 그리기 오류 발생 : {ex}\033[0m')&#10;&#10;        # 3) 장비(앞쪽) 그리기&#10;        if hasattr(self, 'equipment_manager'):&#10;            self.equipment_manager.draw_front(draw_x, draw_y)&#10;&#10;        # 4) 파티클/공격 이펙트 (카메라 적용)&#10;        try:&#10;            # 위에서 이미 가져온 camera 사용&#10;            for p in getattr(self, 'particles', []):&#10;                if hasattr(p, 'draw'):&#10;                    if camera is not None:&#10;                        particle_draw_x, particle_draw_y = camera.apply(p.x, p.y)&#10;                        p.draw(particle_draw_x, particle_draw_y)&#10;                    else:&#10;                        p.draw(p.x, p.y)&#10;            for e in getattr(self, 'attack_effects', []):&#10;                if hasattr(e, 'draw'):&#10;                    if camera is not None:&#10;                        effect_draw_x, effect_draw_y = camera.apply(e.x, e.y)&#10;                        e.draw(effect_draw_x, effect_draw_y)&#10;                    else:&#10;                        e.draw(e.x, e.y)&#10;        except Exception:&#10;            print(f'\033[91m[Player] 파티클/이펙트 그리기 오류 발생 : {ex}\033[0m')&#10;&#10;        # 화면에 표시되는 히트박스 (카메라 적용된 좌표 사용)&#10;        # player_left = draw_x - self.collision_width / 2&#10;        # player_right = draw_x + self.collision_width / 2&#10;        # player_bottom = draw_y - self.collision_height / 2&#10;        # player_top = draw_y + self.collision_height / 2&#10;        # draw_rectangle(player_left, player_bottom, player_right, player_top)&#10;&#10;    def check_collision_with_projectile(self, projectile):&#10;        &quot;&quot;&quot;몬스터 발사체와의 충돌 감지&#10;&#10;        Args:&#10;            projectile: Projectile을 상속받은 발사체 객체&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 먼저 방패로 방어할 수 있는지 체크&#10;        if hasattr(self, 'shield') and self.shield:&#10;            if self.shield.check_projectile_block(projectile):&#10;                # 방패로 막았으면 투사체를 제거하고 충돌 처리 종료&#10;                return True&#10;&#10;        # 무적 상태이면 충돌 무시&#10;        if hasattr(self, 'invincible') and self.invincible:&#10;            return False&#10;&#10;        # 발사체 크기 (Projectile의 get_collision_box 메서드 사용)&#10;        if hasattr(projectile, 'get_collision_box'):&#10;            projectile_width, projectile_height = projectile.get_collision_box()&#10;        else:&#10;            projectile_width = 30&#10;            projectile_height = 30&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        player_left = self.x - self.collision_width / 2&#10;        player_right = self.x + self.collision_width / 2&#10;        player_bottom = self.y - self.collision_height / 2&#10;        player_top = self.y + self.collision_height / 2&#10;&#10;        proj_left = projectile.x - projectile_width / 2&#10;        proj_right = projectile.x + projectile_width / 2&#10;        proj_bottom = projectile.y - projectile_height / 2&#10;        proj_top = projectile.y + projectile_height / 2&#10;&#10;        # 충돌 검사&#10;        if (player_left &lt; proj_right and player_right &gt; proj_left and&#10;            player_bottom &lt; proj_top and player_top &gt; proj_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(projectile)&#10;            return True&#10;&#10;        return False&#10;&#10;    def check_collision_with_effect(self, effect):&#10;        &quot;&quot;&quot;몬스터 공격 이펙트와의 충돌 감지 (CatThiefSwingEffect 등)&#10;&#10;        Args:&#10;            effect: 공격 이펙트 객체 (get_collision_box 메서드를 가진 이펙트)&#10;&#10;        Returns:&#10;            bool: 충돌 여부&#10;        &quot;&quot;&quot;&#10;        # 먼저 방패로 방어할 수 있는지 체크&#10;        if hasattr(self, 'shield') and self.shield:&#10;            # 방패의 방향과 이펙트 위치를 고려하여 방어 판정&#10;            if hasattr(self.shield, 'check_effect_block'):&#10;                if self.shield.check_effect_block(effect):&#10;                    # 방패로 막았으면 충돌 처리 종료&#10;                    print(f&quot;[Player] 방패로 {effect.__class__.__name__} 방어!&quot;)&#10;                    return True&#10;&#10;        # 무적 상태이면 충돌 무시&#10;        if hasattr(self, 'invincible') and self.invincible:&#10;            return False&#10;&#10;        # 이펙트 크기 (get_collision_box 메서드 사용)&#10;        if hasattr(effect, 'get_collision_box'):&#10;            effect_width, effect_height = effect.get_collision_box()&#10;        else:&#10;            # 기본값&#10;            effect_width = 100&#10;            effect_height = 100&#10;&#10;        # AABB (Axis-Aligned Bounding Box) 충돌 감지&#10;        player_left = self.x - self.collision_width / 2&#10;        player_right = self.x + self.collision_width / 2&#10;        player_bottom = self.y - self.collision_height / 2&#10;        player_top = self.y + self.collision_height / 2&#10;&#10;        effect_left = effect.x - effect_width / 2&#10;        effect_right = effect.x + effect_width / 2&#10;        effect_bottom = effect.y - effect_height / 2&#10;        effect_top = effect.y + effect_height / 2&#10;&#10;        # 충돌 검사&#10;        if (player_left &lt; effect_right and player_right &gt; effect_left and&#10;            player_bottom &lt; effect_top and player_top &gt; effect_bottom):&#10;            # 충돌 시 피격 처리&#10;            self.on_hit(effect)&#10;            return True&#10;&#10;        return False&#10;&#10;    def on_hit(self, attacker):&#10;        &quot;&quot;&quot;피격 시 호출되는 메서드&#10;&#10;        Args:&#10;            attacker: 공격한 객체 (투사체, 이펙트 등)&#10;        &quot;&quot;&quot;&#10;        # 무적 상태라면 무시&#10;        if self.invincible:&#10;            print(f&quot;[Player] 무적 상태로 피격 무시 (남은 무적시간: {self.invincible_timer:.2f}초)&quot;)&#10;            return&#10;&#10;        # 사망 상태면 무시&#10;        if isinstance(self.state_machine.cur_state, Death):&#10;            return&#10;&#10;        # 무적시간 활성화&#10;        self.invincible = True&#10;        self.invincible_timer = self.invincible_duration&#10;&#10;        # 데미지 계산&#10;        damage = 0&#10;        if hasattr(attacker, 'damage'):&#10;            damage = attacker.damage&#10;        elif hasattr(attacker, 'owner') and hasattr(attacker.owner, 'stats'):&#10;            # 공격자의 스탯에서 데미지 가져오기&#10;            damage = attacker.owner.stats.get('attack_damage')&#10;        else:&#10;            damage = 10.0  # 기본 데미지&#10;&#10;        # 방어력 적산&#10;        defense = self.stats.get('defense') if hasattr(self, 'stats') else 0&#10;        final_damage = max(1.0, damage - defense)&#10;&#10;        # 넉백 효과 적용 (공격자로부터 밀려나는 방향)&#10;        import math&#10;        knockback_distance = 100.0  # 넉백 거리&#10;        knockback_duration = 0.3  # 넉백 지속 시간 (초)&#10;&#10;        # 공격자의 위치 파악&#10;        attacker_x = attacker.x if hasattr(attacker, 'x') else self.x&#10;        attacker_y = attacker.y if hasattr(attacker, 'y') else self.y&#10;&#10;        # 넉백 방향 계산 (공격자 -&gt; 플레이어 방향)&#10;        dx = self.x - attacker_x&#10;        dy = self.y - attacker_y&#10;        distance = math.sqrt(dx * dx + dy * dy)&#10;&#10;        if distance &gt; 0:&#10;            # 정규화된 방향 벡터&#10;            self.knockback_dx = dx / distance&#10;            self.knockback_dy = dy / distance&#10;        else:&#10;            # 공격자와 위치가 같으면 랜덤 방향&#10;            angle = random.uniform(0, 2 * math.pi)&#10;            self.knockback_dx = math.cos(angle)&#10;            self.knockback_dy = math.sin(angle)&#10;&#10;        self.knockback_speed = knockback_distance / knockback_duration&#10;        self.knockback_duration = knockback_duration&#10;        self.knockback_timer = 0.0&#10;&#10;        # 스텟 업데이트 - 체력 감소, 마나 감소 등&#10;        if hasattr(self, 'stats'):&#10;            current_health = self.stats.get('health')&#10;            max_health = self.stats.get('max_health')&#10;            new_health = max(0, current_health - final_damage)&#10;            self.stats.set_base('health', new_health)&#10;&#10;            # 피격 정보 출력&#10;            attacker_name = attacker.__class__.__name__&#10;            DebugPrint = True&#10;            if DebugPrint:&#10;                print(f&quot;\n{'='*60}&quot;)&#10;                print(f&quot;[Player 피격]&quot;)&#10;                print(f&quot;  공격자: {attacker_name}&quot;)&#10;                print(f&quot;  원본 데미지: {damage:.1f}&quot;)&#10;                print(f&quot;  방어력: {defense:.1f}&quot;)&#10;                print(f&quot;  최종 데미지: {final_damage:.1f}&quot;)&#10;                print(f&quot;  체력 변화: {current_health:.1f} -&gt; {new_health:.1f} (최대: {max_health:.1f})&quot;)&#10;                print(f&quot;  체력 비율: {(new_health/max_health)*100:.1f}%&quot;)&#10;                print(f&quot;  무적시간: {self.invincible_duration}초 활성화&quot;)&#10;                print(f&quot;  넉백: 거리 {knockback_distance:.1f}px, 지속시간 {knockback_duration:.2f}초&quot;)&#10;&#10;            # 체력이 0 이하면 사망 상태로 전환&#10;            if new_health &lt;= 0:&#10;                print(f&quot;  &gt;&gt;&gt; Player 체력 0 - 사망 상태로 전환&quot;)&#10;                print(f&quot;{'='*60}\n&quot;)&#10;                self.state_machine.handle_state_event(('DIE', attacker))&#10;                return  # 사망 시 이펙트 생성하지 않음&#10;            else:&#10;                print(f&quot;{'='*60}\n&quot;)&#10;        else:&#10;            attacker_name = attacker.__class__.__name__&#10;            print(f&quot;[Player] 피격당함! 공격자: {attacker_name} (스탯 시스템 없음)&quot;)&#10;&#10;        # 피격 이펙트 재생 - Wound Particle 생성 (4개)&#10;        for i in range(4):&#10;            # 랜덤한 방향으로 파티클 발사&#10;            angle = random.uniform(0, 2 * math.pi)&#10;            speed = random.uniform(80, 150)  # 속도 랜덤&#10;            vx = math.cos(angle) * speed&#10;            vy = math.sin(angle) * speed + random.uniform(50, 100) # 위쪽으로 약간 더 많이&#10;&#10;            # 플레이어 위치에서 약간 랜덤한 오프셋&#10;            offset_x = random.uniform(-10, 10)&#10;            offset_y = random.uniform(-10, 10)&#10;&#10;            wound_particle = VFX_Wound_Particle(&#10;                self.x + offset_x,&#10;                self.y + offset_y,&#10;                vx, vy,&#10;                scale=3.0&#10;            )&#10;            self.particles.append(wound_particle)&#10;&#10;        print(f&quot;[Player] 피격 이펙트 생성 완료 (Wound Particle x4)&quot;)&#10;&#10;        # 데미지 인디케이터 생성&#10;        try:&#10;            if hasattr(self, 'world') and self.world and 'effects_front' in self.world:&#10;                dmg_indicator = DamageIndicator(&#10;                    x=self.x,&#10;                    y=self.y,&#10;                    damage=final_damage,&#10;                    font_size=20&#10;                )&#10;                self.world['effects_front'].append(dmg_indicator)&#10;                print(f&quot;[Player] 데미지 인디케이터 생성: {final_damage:.1f} 데미지&quot;)&#10;        except Exception as ex:&#10;            print(f'\033[91m[Player] 데미지 인디케이터 생성 실패: {ex}\033[0m')&#10;            pass&#10;&#10;        # TODO: 추후 추가 가능&#10;        # - 피격 사운드&#10;&#10;    def on_death(self):&#10;        &quot;&quot;&quot;사망 처리 - 상태 머신을 통해 Death 상태로 전환&quot;&quot;&quot;&#10;        print(&quot;[Player] on_death 호출 - Death 상태로 전환&quot;)&#10;        self.state_machine.handle_state_event(('DIE', None))&#10;&#10;class VFX_Run_Particle:&#10;    def __init__(self, x, y, frames, frame_duration, scale):&#10;        self.x, self.y = x, y&#10;        self.frames = frames&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = frame_duration&#10;        self.scale_factor = scale&#10;        self.life = len(frames) * frame_duration&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt; 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame = (self.frame + 1) % len(self.frames)&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.draw(draw_x, draw_y, image.w * self.scale_factor, image.h * self.scale_factor)&#10;&#10;&#10;class VFX_Wound_Particle:&#10;    &quot;&quot;&quot;피격 시 출혈 파티클 이펙트 (개별 이미지 파일 사용)&quot;&quot;&quot;&#10;    _frames = None  # 클래스 변수로 이미지 프레임 공유&#10;&#10;    def __init__(self, x, y, vx, vy, scale=3.0):&#10;        # 이미지 프레임 로드 (최초 1회만)&#10;        if VFX_Wound_Particle._frames is None:&#10;            VFX_Wound_Particle._frames = []&#10;            wound_folder = os.path.join('resources', 'Texture_organize', 'VFX', 'Wound_Particle')&#10;            try:&#10;                for i in range(5):  # WoundParticle_0 ~ WoundParticle_4&#10;                    img_path = os.path.join(wound_folder, f'WoundParticle_{i}.png')&#10;                    frame = load_image(img_path)&#10;                    VFX_Wound_Particle._frames.append(frame)&#10;                print(f&quot;[WoundParticle] 이미지 로드 완료: {len(VFX_Wound_Particle._frames)}개 프레임&quot;)&#10;            except Exception as ex:&#10;                print(f&quot;[WoundParticle] 이미지 로드 실패: {ex}&quot;)&#10;                VFX_Wound_Particle._frames = []&#10;&#10;        self.x = x&#10;        self.y = y&#10;        self.vx = vx  # x 방향 속도&#10;        self.vy = vy  # y 방향 속도&#10;        self.scale_factor = scale&#10;&#10;        # 애니메이션 설정&#10;        self.total_frames = 5  # 총 프레임 수&#10;        self.current_frame = 0&#10;        self.frame_duration = 0.08  # 각 프레임당 0.08초&#10;        self.frame_time_acc = 0.0&#10;        self.life = self.total_frames * self.frame_duration  # 총 수명&#10;&#10;        # 중력 효과&#10;        self.gravity = 200.0  # 픽셀/초^2&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;&#10;        # 수명 감소&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False&#10;&#10;        # 물리 업데이트&#10;        self.x += self.vx * dt&#10;        self.y += self.vy * dt&#10;        self.vy -= self.gravity * dt  # 중력 적용&#10;&#10;        # 애니메이션 업데이트&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.current_frame += 1&#10;            if self.current_frame &gt;= self.total_frames:&#10;                self.current_frame = self.total_frames - 1  # 마지막 프레임 유지&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if not VFX_Wound_Particle._frames or len(VFX_Wound_Particle._frames) == 0:&#10;            return&#10;&#10;        if self.current_frame &lt; len(VFX_Wound_Particle._frames):&#10;            image = VFX_Wound_Particle._frames[self.current_frame]&#10;            image.draw(&#10;                draw_x, draw_y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;&#10;&#10;# VFX 전역 배율 설정: 전체 이펙트 크기와 거리(범위)를 일괄 조정&#10;VFX_GLOBAL_SCALE_MULT = 0.7   # 이펙트 크기 0.7배&#10;VFX_GLOBAL_RANGE_MULT = 0.8   # 이펙트 거리 0.8배&#10;&#10;class VFX_Tier1_Sword_Swing:&#10;    &quot;&quot;&quot;검 공격 이펙트 VFX&quot;&quot;&quot;&#10;    def __init__(self, x, y, angle, flip, scale=4.5, range_factor=60, variant=1, owner=None):&#10;        import math&#10;&#10;        # 공격자 정보 저장&#10;        self.owner = owner&#10;&#10;        # 데미지 설정 (owner의 스탯에서 가져오거나 기본값 사용)&#10;        if owner and hasattr(owner, 'stats'):&#10;            self.damage = owner.stats.get('attack_damage')&#10;        else:&#10;            self.damage = 20.0  # 기본 데미지&#10;&#10;        # 전역 배율을 적용한 range_factor/scale 사용&#10;        range_factor = range_factor * VFX_GLOBAL_RANGE_MULT&#10;        scale = scale * VFX_GLOBAL_SCALE_MULT&#10;&#10;        # 받은 위치에서 angle 방향으로 range_factor만큼 떨어진 위치 계산&#10;        temp_x = range_factor * math.cos(angle)&#10;        temp_y = range_factor * math.sin(angle)&#10;&#10;        self.x = x + temp_x&#10;        self.y = y + temp_y&#10;&#10;        # 각도 조정: 마우스가 오른쪽(0도~90도, 270도~360도)일 때 -90도, 왼쪽일 때 +90도&#10;        angle_deg = math.degrees(angle) % 360&#10;        if 90 &lt; angle_deg &lt; 270:  # 왼쪽&#10;            self.angle = angle + math.radians(90)&#10;        else:  # 오른쪽&#10;            self.angle = angle - math.radians(90)&#10;&#10;        self.flip = flip&#10;        self.scale_factor = scale&#10;&#10;        # 이펙트 이미지 로드&#10;        fx_folder = os.path.join('resources', 'Texture_organize', 'Weapon', 'SwordANDShield', 'Swing_FX')&#10;        if variant == 1:&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;        elif variant == 2:&#10;            # 콤보 전용 스프라이트&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing2_1.png'))&#10;            ]&#10;        elif variant == 3:&#10;            # Heavy swing (3스테이지) - 여러 프레임&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_1.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_2.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_HeavySwingN_3.png'))&#10;            ]&#10;        else:&#10;            # 안전망: 기본으로 variant 1 사용&#10;            self.frames = [&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing0.png')),&#10;                load_image(os.path.join(fx_folder, 'Sword0_Swing1.png'))&#10;            ]&#10;&#10;        self.frame = 0&#10;        self.frame_time_acc = 0.0&#10;        self.frame_duration = 0.05  # 각 프레임당 0.05초&#10;        self.life = len(self.frames) * self.frame_duration  # 총 수명&#10;&#10;    def update(self):&#10;        dt = framework.get_delta_time()&#10;        self.life -= dt&#10;        if self.life &lt;= 0:&#10;            return False  # 수명이 다하면 False 반환&#10;&#10;        self.frame_time_acc += dt&#10;        if self.frame_time_acc &gt;= self.frame_duration:&#10;            self.frame_time_acc -= self.frame_duration&#10;            self.frame += 1&#10;            if self.frame &gt;= len(self.frames):&#10;                self.frame = len(self.frames) - 1  # 마지막 프레임 유지&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        # draw_x, draw_y는 카메라가 적용된 화면 좌표&#10;        if self.frame &lt; len(self.frames):&#10;            image = self.frames[self.frame]&#10;            image.clip_composite_draw(&#10;                0, 0, image.w, image.h,&#10;                self.angle, self.flip,&#10;                draw_x, draw_y,&#10;                image.w * self.scale_factor,&#10;                image.h * self.scale_factor&#10;            )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/state_machine.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/state_machine.py" />
              <option name="originalContent" value="from .event_to_string import event_to_string&#10;import game_framework&#10;from .inventory import InventoryData&#10;&#10;&#10;class StateMachine:&#10;    def __init__(self, start_state, rules):&#10;        self.cur_state = start_state&#10;        self.rules = rules&#10;        self.cur_state.enter(('START', None))&#10;&#10;    def update(self):&#10;        self.cur_state.do()&#10;&#10;    def draw(self, draw_x = None, draw_y = None):&#10;        self.cur_state.draw(draw_x, draw_y)&#10;&#10;    def current_state(self):&#10;        return self.cur_state&#10;&#10;    def set_state(self, state):&#10;        self.cur_state = state&#10;&#10;    def handle_state_event(self, state_event):&#10;        processed_event = False&#10;        for check_event in self.rules[self.cur_state].keys():&#10;            if check_event(state_event):&#10;                next_state = self.rules[self.cur_state][check_event]&#10;&#10;                # 특수 처리: INVENTORY 상태에서 Tab_down이면 prev_state로 복귀&#10;                if next_state is None and hasattr(self.cur_state, 'prev_state') and self.cur_state.prev_state is not None:&#10;                    next_state = self.cur_state.prev_state&#10;&#10;                # 특수 처리: DASH 상태에서 DASH_END이면 return_to_idle에 따라 IDLE 또는 RUN으로 복귀&#10;                if next_state is None and hasattr(self.cur_state, 'return_to_idle'):&#10;                    # Dash의 return_to_idle 플래그 확인&#10;                    if self.cur_state.return_to_idle:&#10;                        # Idle로 복귀&#10;                        next_state = self.cur_state.player.IDLE&#10;                    else:&#10;                        # Run으로 복귀&#10;                        next_state = self.cur_state.player.RUN&#10;&#10;                self.cur_state.exit(state_event)&#10;                next_state.enter(state_event)&#10;&#10;                print(f'{self.cur_state.__class__.__name__}'&#10;                      f' ======{event_to_string(state_event)}======&gt; '&#10;                      f'{next_state.__class__.__name__}')&#10;                self.cur_state = next_state&#10;                processed_event = True&#10;                return&#10;        if not processed_event:&#10;            event_str = event_to_string(state_event)&#10;            es = event_str.upper() if isinstance(event_str, str) else ''&#10;            is_mouse_motion = ('MOUSE' in es and 'MOTION' in es) or ('MOUSEMOTION' in es)&#10;            if not is_mouse_motion:&#10;                # print('Refused Event:', self.cur_state.__class__.__name__, 'Input : ', event_to_string(state_event))&#10;                pass&#10;" />
              <option name="updatedContent" value="from .event_to_string import event_to_string&#13;&#10;import game_framework&#13;&#10;from .inventory import InventoryData&#13;&#10;&#13;&#10;&#13;&#10;class StateMachine:&#13;&#10;    def __init__(self, start_state, rules):&#13;&#10;        self.cur_state = start_state&#13;&#10;        self.rules = rules&#13;&#10;        self.cur_state.enter(('START', None))&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        self.cur_state.do()&#13;&#10;&#13;&#10;    def draw(self, draw_x = None, draw_y = None):&#13;&#10;        self.cur_state.draw(draw_x, draw_y)&#13;&#10;&#13;&#10;    def current_state(self):&#13;&#10;        return self.cur_state&#13;&#10;&#13;&#10;    def set_state(self, state):&#13;&#10;        self.cur_state = state&#13;&#10;&#13;&#10;    def handle_state_event(self, state_event):&#13;&#10;        processed_event = False&#13;&#10;        for check_event in self.rules[self.cur_state].keys():&#13;&#10;            if check_event(state_event):&#13;&#10;                next_state = self.rules[self.cur_state][check_event]&#13;&#10;&#13;&#10;                # 특수 처리: INVENTORY 상태에서 Tab_down이면 prev_state로 복귀&#13;&#10;                if next_state is None and hasattr(self.cur_state, 'prev_state') and self.cur_state.prev_state is not None:&#13;&#10;                    next_state = self.cur_state.prev_state&#13;&#10;&#13;&#10;                # 특수 처리: DASH 상태에서 DASH_END이면 return_to_idle에 따라 IDLE 또는 RUN으로 복귀&#13;&#10;                if next_state is None and hasattr(self.cur_state, 'return_to_idle'):&#13;&#10;                    # Dash의 return_to_idle 플래그 확인&#13;&#10;                    if self.cur_state.return_to_idle:&#13;&#10;                        # Idle로 복귀&#13;&#10;                        next_state = self.cur_state.player.IDLE&#13;&#10;                    else:&#13;&#10;                        # Run으로 복귀&#13;&#10;                        next_state = self.cur_state.player.RUN&#13;&#10;&#13;&#10;                self.cur_state.exit(state_event)&#13;&#10;                next_state.enter(state_event)&#13;&#10;&#13;&#10;                print(f'{self.cur_state.__class__.__name__}'&#13;&#10;                      f' ======{event_to_string(state_event)}======&gt; '&#13;&#10;                      f'{next_state.__class__.__name__}')&#13;&#10;                self.cur_state = next_state&#13;&#10;                processed_event = True&#13;&#10;                return&#13;&#10;        if not processed_event:&#13;&#10;            event_str = event_to_string(state_event)&#13;&#10;            es = event_str.upper() if isinstance(event_str, str) else ''&#13;&#10;            is_mouse_motion = ('MOUSE' in es and 'MOTION' in es) or ('MOUSEMOTION' in es)&#13;&#10;            if not is_mouse_motion:&#13;&#10;                # print('Refused Event:', self.cur_state.__class__.__name__, 'Input : ', event_to_string(state_event))&#13;&#10;                pass" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/stats.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/stats.py" />
              <option name="originalContent" value="# 간단한 스탯/버프 시스템&#10;from typing import Dict, Optional&#10;import game_framework&#10;&#10;class StatModifier:&#10;    def __init__(self, id: str, values: Dict[str, float], duration: Optional[float] = None, item_info: Optional[dict] = None):&#10;        self.id = id&#10;        self.values = dict(values)&#10;        self.duration = duration&#10;        self.time_left = duration&#10;        # 아이템 정보 저장 (아이콘, 이름 등)&#10;        self.item_info = item_info or {}&#10;&#10;    def update(self, dt: float) -&gt; bool:&#10;        if self.duration is None:&#10;            return False&#10;        self.time_left -= dt&#10;        return self.time_left &lt;= 0&#10;&#10;    @property&#10;    def expired(self) -&gt; bool:&#10;        return self.duration is not None and self.time_left is not None and self.time_left &lt;= 0&#10;    &#10;    @property&#10;    def remaining_duration(self) -&gt; float:&#10;        &quot;&quot;&quot;남은 시간 반환&quot;&quot;&quot;&#10;        if self.time_left is not None:&#10;            return max(0.0, self.time_left)&#10;        return 0.0&#10;&#10;&#10;class PlayerStats:&#10;    def __init__(self, base: Optional[Dict[str, float]] = None):&#10;        self.base = base or {&#10;            'max_health': 100.0,&#10;            'max_mana': 50.0,&#10;            'health_regen': 0.2,&#10;            'mana_regen': 0.5,&#10;            'health': 100.0,&#10;            'mana': 50.0,&#10;            'move_speed': 250.0,&#10;            'attack_speed': 1.0,&#10;            'attack_damage': 10.0,&#10;            'defense': 0.0,&#10;            'crit_chance': 0.05,&#10;            'crit_damage': 1.5,&#10;        }&#10;        self._mods: Dict[str, StatModifier] = {}&#10;&#10;    def set_base(self, key: str, value: float):&#10;        self.base[key] = value&#10;&#10;    def add_modifier(self, mod: StatModifier):&#10;        self._mods[mod.id] = mod&#10;&#10;    def remove_modifier(self, mod_id: str):&#10;        if mod_id in self._mods:&#10;            del self._mods[mod_id]&#10;&#10;    def clear_by_prefix(self, prefix: str):&#10;        ids = [k for k in self._mods.keys() if k.startswith(prefix)]&#10;        for k in ids:&#10;            del self._mods[k]&#10;&#10;    def get(self, key: str) -&gt; float:&#10;        v = self.base.get(key, 0.0)&#10;        for mod in self._mods.values():&#10;            v += mod.values.get(key, 0.0)&#10;        return v&#10;&#10;    def __getitem__(self, key: str) -&gt; float:&#10;        &quot;&quot;&quot;딕셔너리처럼 stats['key'] 형태로 접근 가능하도록 함&quot;&quot;&quot;&#10;        return self.get(key)&#10;&#10;    def __setitem__(self, key: str, value: float):&#10;        &quot;&quot;&quot;딕셔너리처럼 stats['key'] = value 형태로 설정 가능하도록 함&quot;&quot;&quot;&#10;        self.set_base(key, value)&#10;&#10;    def update(self):&#10;        dt = game_framework.get_delta_time()&#10;        to_remove = []&#10;        for k, mod in self._mods.items():&#10;            if mod.duration is not None:&#10;                if mod.update(dt):&#10;                    to_remove.append(k)&#10;        for k in to_remove:&#10;            del self._mods[k]&#10;&#10;        # 자연 회복 처리&#10;        self.base['health'] = min(self.get('max_health'), self.base['health'] + self.get('health_regen') * dt)&#10;        self.base['mana'] = min(self.get('max_mana'), self.base['mana'] + self.get('mana_regen') * dt)&#10;&#10;&#10;class MonsterStats:&#10;    &quot;&quot;&quot;몬스터용 스탯 시스템&quot;&quot;&quot;&#10;    def __init__(self, base: Optional[Dict[str, float]] = None):&#10;        self.base = base or {&#10;            'max_health': 50.0,&#10;            'health': 50.0,&#10;            'move_speed': 100.0,&#10;            'attack_damage': 5.0,&#10;            'defense': 0.0,&#10;            'attack_speed': 1.0,&#10;            'attack_range': 300.0,&#10;        }&#10;        self._mods: Dict[str, StatModifier] = {}&#10;&#10;    def set_base(self, key: str, value: float):&#10;        self.base[key] = value&#10;&#10;    def add_modifier(self, mod: StatModifier):&#10;        self._mods[mod.id] = mod&#10;&#10;    def remove_modifier(self, mod_id: str):&#10;        if mod_id in self._mods:&#10;            del self._mods[mod_id]&#10;&#10;    def clear_by_prefix(self, prefix: str):&#10;        ids = [k for k in self._mods.keys() if k.startswith(prefix)]&#10;        for k in ids:&#10;            del self._mods[k]&#10;&#10;    def get(self, key: str) -&gt; float:&#10;        v = self.base.get(key, 0.0)&#10;        for mod in self._mods.values():&#10;            v += mod.values.get(key, 0.0)&#10;        return v&#10;&#10;    def update(self):&#10;        dt = game_framework.get_delta_time()&#10;        to_remove = []&#10;        for k, mod in self._mods.items():&#10;            if mod.duration is not None:&#10;                if mod.update(dt):&#10;                    to_remove.append(k)&#10;        for k in to_remove:&#10;            del self._mods[k]&#10;&#10;    # 유틸리티 함수&#10;    def is_dead(self) -&gt; bool:&#10;        return self.get('health') &lt;= 0.0&#10;&#10;&#10;class CatAssassinStats(MonsterStats):&#10;    &quot;&quot;&quot;CatAssassin 전용 스탯&quot;&quot;&quot;&#10;    def __init__(self):&#10;        super().__init__({&#10;            'max_health': 50.0,&#10;            'health': 50.0,&#10;            'move_speed': 100.0,&#10;            'attack_damage': 20.0,&#10;            'defense': 2.0,&#10;            'attack_speed': 1.2,&#10;            'attack_range': 400.0,&#10;        })&#10;&#10;class CatThiefStats(MonsterStats):&#10;    &quot;&quot;&quot;CatThief 전용 스탯&quot;&quot;&quot;&#10;    def __init__(self):&#10;        super().__init__({&#10;            'max_health': 70.0,&#10;            'health': 70.0,&#10;            'move_speed': 120.0,&#10;            'attack_damage': 20.0,&#10;            'defense': 2.0,&#10;            'attack_speed': 1.2,&#10;            'attack_range': 400.0,&#10;        })&#10;&#10;&#10;class PantherAssassinStats(MonsterStats):&#10;    &quot;&quot;&quot;PantherAssassin 전용 스탯&quot;&quot;&quot;&#10;    def __init__(self):&#10;        super().__init__({&#10;            'max_health': 500.0,&#10;            'health': 500.0,&#10;            'move_speed': 150.0,&#10;            'attack_damage': 20.0,&#10;            'defense': 5.0,&#10;            'attack_speed': 1.5,&#10;            'attack_range': 800.0,&#10;        })" />
              <option name="updatedContent" value="# 간단한 스탯/버프 시스템&#10;from typing import Dict, Optional&#10;import game_framework&#10;&#10;class StatModifier:&#10;    def __init__(self, id: str, values: Dict[str, float], duration: Optional[float] = None, item_info: Optional[dict] = None):&#10;        self.id = id&#10;        self.values = dict(values)&#10;        self.duration = duration&#10;        self.time_left = duration&#10;        # 아이템 정보 저장 (아이콘, 이름 등)&#10;        self.item_info = item_info or {}&#10;&#10;    def update(self, dt: float) -&gt; bool:&#10;        if self.duration is None:&#10;            return False&#10;        self.time_left -= dt&#10;        return self.time_left &lt;= 0&#10;&#10;    @property&#10;    def expired(self) -&gt; bool:&#10;        return self.duration is not None and self.time_left is not None and self.time_left &lt;= 0&#10;    &#10;    @property&#10;    def remaining_duration(self) -&gt; float:&#10;        &quot;&quot;&quot;남은 시간 반환&quot;&quot;&quot;&#10;        if self.time_left is not None:&#10;            return max(0.0, self.time_left)&#10;        return 0.0&#10;&#10;&#10;class PlayerStats:&#10;    def __init__(self, base: Optional[Dict[str, float]] = None):&#10;        self.base = base or {&#10;            'max_health': 100.0,&#10;            'max_mana': 50.0,&#10;            'health_regen': 0.2,&#10;            'mana_regen': 0.5,&#10;            'health': 100.0,&#10;            'mana': 50.0,&#10;            'move_speed': 250.0,&#10;            'attack_speed': 1.0,&#10;            'attack_damage': 10.0,&#10;            'defense': 0.0,&#10;            'crit_chance': 0.05,&#10;            'crit_damage': 1.5,&#10;        }&#10;        self._mods: Dict[str, StatModifier] = {}&#10;&#10;    def set_base(self, key: str, value: float):&#10;        self.base[key] = value&#10;&#10;    def add_modifier(self, mod: StatModifier):&#10;        self._mods[mod.id] = mod&#10;&#10;    def remove_modifier(self, mod_id: str):&#10;        if mod_id in self._mods:&#10;            del self._mods[mod_id]&#10;&#10;    def clear_by_prefix(self, prefix: str):&#10;        ids = [k for k in self._mods.keys() if k.startswith(prefix)]&#10;        for k in ids:&#10;            del self._mods[k]&#10;&#10;    def get(self, key: str) -&gt; float:&#10;        v = self.base.get(key, 0.0)&#10;        for mod in self._mods.values():&#10;            v += mod.values.get(key, 0.0)&#10;        return v&#10;&#10;    def __getitem__(self, key: str) -&gt; float:&#10;        &quot;&quot;&quot;딕셔너리처럼 stats['key'] 형태로 접근 가능하도록 함&quot;&quot;&quot;&#10;        return self.get(key)&#10;&#10;    def __setitem__(self, key: str, value: float):&#10;        &quot;&quot;&quot;딕셔너리처럼 stats['key'] = value 형태로 설정 가능하도록 함&quot;&quot;&quot;&#10;        self.set_base(key, value)&#10;&#10;    def update(self):&#10;        dt = game_framework.get_delta_time()&#10;        to_remove = []&#10;        for k, mod in self._mods.items():&#10;            if mod.duration is not None:&#10;                if mod.update(dt):&#10;                    to_remove.append(k)&#10;        for k in to_remove:&#10;            del self._mods[k]&#10;&#10;        # 자연 회복 처리&#10;        self.base['health'] = min(self.get('max_health'), self.base['health'] + self.get('health_regen') * dt)&#10;        self.base['mana'] = min(self.get('max_mana'), self.base['mana'] + self.get('mana_regen') * dt)&#10;&#10;&#10;class MonsterStats:&#10;    &quot;&quot;&quot;몬스터용 스탯 시스템&quot;&quot;&quot;&#10;    def __init__(self, base: Optional[Dict[str, float]] = None):&#10;        self.base = base or {&#10;            'max_health': 50.0,&#10;            'health': 50.0,&#10;            'move_speed': 100.0,&#10;            'attack_damage': 5.0,&#10;            'defense': 0.0,&#10;            'attack_speed': 1.0,&#10;            'attack_range': 300.0,&#10;        }&#10;        self._mods: Dict[str, StatModifier] = {}&#10;&#10;    def set_base(self, key: str, value: float):&#10;        self.base[key] = value&#10;&#10;    def add_modifier(self, mod: StatModifier):&#10;        self._mods[mod.id] = mod&#10;&#10;    def remove_modifier(self, mod_id: str):&#10;        if mod_id in self._mods:&#10;            del self._mods[mod_id]&#10;&#10;    def clear_by_prefix(self, prefix: str):&#10;        ids = [k for k in self._mods.keys() if k.startswith(prefix)]&#10;        for k in ids:&#10;            del self._mods[k]&#10;&#10;    def get(self, key: str) -&gt; float:&#10;        v = self.base.get(key, 0.0)&#10;        for mod in self._mods.values():&#10;            v += mod.values.get(key, 0.0)&#10;        return v&#10;&#10;    def update(self):&#10;        dt = game_framework.get_delta_time()&#10;        to_remove = []&#10;        for k, mod in self._mods.items():&#10;            if mod.duration is not None:&#10;                if mod.update(dt):&#10;                    to_remove.append(k)&#10;        for k in to_remove:&#10;            del self._mods[k]&#10;&#10;    # 유틸리티 함수&#10;    def is_dead(self) -&gt; bool:&#10;        return self.get('health') &lt;= 0.0&#10;&#10;&#10;class CatAssassinStats(MonsterStats):&#10;    &quot;&quot;&quot;CatAssassin 전용 스탯&quot;&quot;&quot;&#10;    def __init__(self):&#10;        super().__init__({&#10;            'max_health': 50.0,&#10;            'health': 50.0,&#10;            'move_speed': 100.0,&#10;            'attack_damage': 20.0,&#10;            'defense': 2.0,&#10;            'attack_speed': 1.2,&#10;            'attack_range': 400.0,&#10;        })&#10;&#10;class CatThiefStats(MonsterStats):&#10;    &quot;&quot;&quot;CatThief 전용 스탯&quot;&quot;&quot;&#10;    def __init__(self):&#10;        super().__init__({&#10;            'max_health': 70.0,&#10;            'health': 70.0,&#10;            'move_speed': 120.0,&#10;            'attack_damage': 20.0,&#10;            'defense': 2.0,&#10;            'attack_speed': 1.2,&#10;            'attack_range': 400.0,&#10;        })&#10;&#10;&#10;class PantherAssassinStats(MonsterStats):&#10;    &quot;&quot;&quot;PantherAssassin 전용 스탯&quot;&quot;&quot;&#10;    def __init__(self):&#10;        super().__init__({&#10;            'max_health': 500.0,&#10;            'health': 500.0,&#10;            'move_speed': 150.0,&#10;            'attack_damage': 20.0,&#10;            'defense': 5.0,&#10;            'attack_speed': 1.5,&#10;            'attack_range': 800.0,&#10;        })" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/vfx.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/vfx.py" />
              <option name="originalContent" value="import os&#10;from pico2d import load_image&#10;import pico2d as p2&#10;import game_framework&#10;&#10;class AnimatedVFX:&#10;    &quot;&quot;&quot;간단한 프레임 애니메이션 VFX 엔티티&#10;    - folder: 폴더 경로 (예: resources/Texture_organize/VFX/Potion_Common)&#10;    - prefix: 파일명 접두사 (예: 'Potion_Back_FX')&#10;    - frames: 프레임 수&#10;    - frame_time: 각 프레임 지속 시간&#10;    - x,y: 위치&#10;    - scale: 크기 배율&#10;    &quot;&quot;&quot;&#10;    def __init__(self, folder, prefix, frames, frame_time, x, y, scale=1.0, life=None):&#10;        self.folder = folder&#10;        self.prefix = prefix&#10;        self.frames_count = frames&#10;        self.frame_time = frame_time&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;        self.images = []&#10;        self.frame = 0&#10;        self.acc = 0.0&#10;        self.life = life if life is not None else frames * frame_time&#10;        self._load_frames()&#10;&#10;    def _load_frames(self):&#10;        self.images = []&#10;        for i in range(self.frames_count):&#10;            name1 = f&quot;{self.prefix}{i:02d}.png&quot;&#10;            path = os.path.join(self.folder, name1)&#10;            try:&#10;                img = load_image(path)&#10;                self.images.append(img)&#10;            except Exception:&#10;                # 로드 실패하면 다음 프레임도 시도하지만 중단&#10;                print(f'\033[91m[AnimatedVFX] Failed to load frame: {path}\033[0m')&#10;                break&#10;        # fallback: 만약 아무 프레임도 로드되지 않으면 try single file without index&#10;        if not self.images:&#10;            single = os.path.join(self.folder, f&quot;{self.prefix}.png&quot;)&#10;            try:&#10;                img = load_image(single)&#10;                self.images.append(img)&#10;            except Exception:&#10;                print(f'\033[91m[AnimatedVFX] Failed to load single image: {single}\033[0m')&#10;        # adjust frames_count to actual loaded&#10;        self.frames_count = len(self.images)&#10;&#10;    def update(self, dt=None):&#10;        # dt None이면 framework에서 값을 가져옴 (main.update_world가 인자로 주지 않으므로)&#10;        if dt is None:&#10;            dt = game_framework.get_delta_time()&#10;        if self.life &lt;= 0:&#10;            return False&#10;        self.life -= dt&#10;        if self.frames_count == 0:&#10;            return self.life &gt; 0&#10;        self.acc += dt&#10;        while self.acc &gt;= self.frame_time and self.frame &lt; self.frames_count - 1:&#10;            self.acc -= self.frame_time&#10;            self.frame += 1&#10;        return self.life &gt; 0&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        if self.images and 0 &lt;= self.frame &lt; len(self.images):&#10;            img = self.images[self.frame]&#10;            img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#10;&#10;&#10;class GuardFX:&#10;    &quot;&quot;&quot;방패 방어 성공 시 표시되는 이펙트&quot;&quot;&quot;&#10;    images = None&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if GuardFX.images is None:&#10;            GuardFX.images = []&#10;            try:&#10;                for i in range(5):  # GuardFX1_0.png ~ GuardFX1_4.png&#10;                    img = p2.load_image(f'resources/Texture_organize/Weapon/SwordANDShield/Guard_FX/GuardFX1_{i}.png')&#10;                    GuardFX.images.append(img)&#10;                print(f&quot;[GuardFX] Loaded {len(GuardFX.images)} images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[GuardFX] Failed to load images: {e}\033[0m&quot;)&#10;                GuardFX.images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 20  # 빠르게 재생 (20 FPS)&#10;        self.finished = False&#10;&#10;        print(f&quot;[GuardFX] 생성됨 at world({int(x)}, {int(y)}), 총 프레임: {len(GuardFX.images) if GuardFX.images else 0}&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#10;        if self.finished:&#10;            return False&#10;&#10;        dt = game_framework.get_delta_time()&#10;        self.animation_time += dt&#10;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            self.frame += 1&#10;            self.animation_time = 0&#10;&#10;            # 애니메이션이 끝나면 제거&#10;            if GuardFX.images and self.frame &gt;= len(GuardFX.images):&#10;                self.finished = True&#10;                return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        이펙트 그리기&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if not GuardFX.images or len(GuardFX.images) == 0:&#10;            print(&quot;[GuardFX] 이미지가 없음!&quot;)&#10;            return&#10;&#10;        if self.finished:&#10;            return&#10;&#10;        frame_idx = min(self.frame, len(GuardFX.images) - 1)&#10;        try:&#10;            # 카메라가 적용된 좌표(draw_x, draw_y)를 사용하여 그리기&#10;            GuardFX.images[frame_idx].draw(&#10;                draw_x, draw_y,&#10;                GuardFX.images[frame_idx].w * self.scale,&#10;                GuardFX.images[frame_idx].h * self.scale&#10;            )&#10;        except Exception as e:&#10;            print(f&quot;\033[91m[GuardFX] draw 에러: {e}\033[0m&quot;)&#10;&#10;&#10;class ShieldCrashEffect:&#10;    &quot;&quot;&quot;방패가 깨질 때 표시되는 이펙트 (Crash_Blue)&quot;&quot;&quot;&#10;    front_images = None&#10;    back_images = None&#10;&#10;    def __init__(self, x, y, scale=3.0):&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#10;        self.x = x&#10;        self.y = y&#10;        self.scale = scale&#10;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if ShieldCrashEffect.front_images is None:&#10;            ShieldCrashEffect.front_images = []&#10;            try:&#10;                for i in range(11):  # Crash_Blue_Front_FX00 ~ FX10 (0~10)&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Front_FX0{i}.png')&#10;                    ShieldCrashEffect.front_images.append(img)&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.front_images)} front images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load front images: {e}\033[0m&quot;)&#10;                ShieldCrashEffect.front_images = []&#10;&#10;        if ShieldCrashEffect.back_images is None:&#10;            ShieldCrashEffect.back_images = []&#10;            try:&#10;                for i in range(3, 9):  # Crash_Blue_Back_FX03 ~ FX08 (3~8)&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Back_FX0{i}.png')&#10;                    ShieldCrashEffect.back_images.append(img)&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.back_images)} back images&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load back images: {e}\033[0m&quot;)&#10;                ShieldCrashEffect.back_images = []&#10;&#10;        self.frame = 0&#10;        self.animation_time = 0&#10;        self.animation_speed = 20  # 빠른 애니메이션 (20 FPS)&#10;        self.finished = False&#10;&#10;        print(f&quot;[ShieldCrashEffect] 생성됨 at world({int(x)}, {int(y)})&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#10;        if self.finished:&#10;            return False&#10;&#10;        dt = game_framework.get_delta_time()&#10;        self.animation_time += dt&#10;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#10;            self.frame += 1&#10;            self.animation_time = 0&#10;&#10;            # Front 이미지 기준으로 애니메이션이 끝나면 제거&#10;            if ShieldCrashEffect.front_images and self.frame &gt;= len(ShieldCrashEffect.front_images):&#10;                self.finished = True&#10;                return False&#10;&#10;        return True&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        이펙트 그리기 (Front와 Back을 레이어링)&#10;&#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if self.finished:&#10;            return&#10;&#10;        # Front 이미지 그리기 (0~10 프레임)&#10;        if ShieldCrashEffect.front_images and self.frame &lt; len(ShieldCrashEffect.front_images):&#10;            try:&#10;                ShieldCrashEffect.front_images[self.frame].draw(&#10;                    draw_x, draw_y,&#10;                    ShieldCrashEffect.front_images[self.frame].w * self.scale,&#10;                    ShieldCrashEffect.front_images[self.frame].h * self.scale&#10;                )&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[ShieldCrashEffect] front draw 에러: {e}\033[0m&quot;)&#10;&#10;        # Back 이미지 그리기 (Front 프레임 3부터 시작)&#10;        # Front frame 3 = Back index 0 (Back_FX03)&#10;        # Front frame 4 = Back index 1 (Back_FX04) ...&#10;        if self.frame &gt;= 3:&#10;            back_index = self.frame - 3&#10;            if ShieldCrashEffect.back_images and back_index &lt; len(ShieldCrashEffect.back_images):&#10;                try:&#10;                    ShieldCrashEffect.back_images[back_index].draw(&#10;                        draw_x, draw_y,&#10;                        ShieldCrashEffect.back_images[back_index].w * self.scale,&#10;                        ShieldCrashEffect.back_images[back_index].h * self.scale&#10;                    )&#10;                except Exception as e:&#10;                    print(f&quot;\033[91m[ShieldCrashEffect] back draw 에러: {e}\033[0m&quot;)&#10;&#10;&#10;class DashTrailEffect:&#10;    &quot;&quot;&quot;대시 시 남는 잔상 이펙트 - 0.3초간 알파값이 1에서 0으로 페이드아웃&quot;&quot;&quot;&#10;    trail_image = None  # 클래스 변수로 이미지 한 번만 로드&#10;&#10;    def __init__(self, x, y, face_dir, scale=3.0):&#10;        &quot;&quot;&quot;&#10;        대시 잔상 이펙트 생성&#10;        &#10;        Args:&#10;            x: 월드 X 좌표&#10;            y: 월드 Y 좌표&#10;            face_dir: 플레이어의 방향 (1: 오른쪽, -1: 왼쪽)&#10;            scale: 이미지 크기 배율&#10;        &quot;&quot;&quot;&#10;        self.x = x&#10;        self.y = y&#10;        self.face_dir = face_dir&#10;        self.scale = scale&#10;        &#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#10;        if DashTrailEffect.trail_image is None:&#10;            try:&#10;                img_path = os.path.join('resources', 'Texture_organize', 'Player_character', 'PlayerDashTrailFx0.png')&#10;                DashTrailEffect.trail_image = load_image(img_path)&#10;                print(f&quot;[DashTrailEffect] 이미지 로드 성공: {img_path}&quot;)&#10;            except Exception as e:&#10;                print(f&quot;\033[91m[DashTrailEffect] 이미지 로드 실패: {e}\033[0m&quot;)&#10;                DashTrailEffect.trail_image = None&#10;        &#10;        # 페이드아웃 설정&#10;        self.fade_duration = 0.3  # 0.3초간 페이드아웃&#10;        self.elapsed_time = 0.0&#10;        self.alpha = 1.0  # 초기 알파값 1.0 (완전 불투명)&#10;    &#10;    def update(self):&#10;        &quot;&quot;&quot;&#10;        이펙트 업데이트 - 알파값을 시간에 따라 감소&#10;        &#10;        Returns:&#10;            bool: True면 계속 유지, False면 제거&#10;        &quot;&quot;&quot;&#10;        dt = game_framework.get_delta_time()&#10;        self.elapsed_time += dt&#10;        &#10;        # 알파값 계산 (1.0 -&gt; 0.0으로 선형 감소)&#10;        if self.elapsed_time &lt; self.fade_duration:&#10;            self.alpha = 1.0 - (self.elapsed_time / self.fade_duration)&#10;        else:&#10;            self.alpha = 0.0&#10;            return False  # 알파값이 0이 되면 제거&#10;        &#10;        return True&#10;    &#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        잔상 이펙트 그리기&#10;        &#10;        Args:&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#10;        &quot;&quot;&quot;&#10;        if not DashTrailEffect.trail_image:&#10;            return&#10;        &#10;        # 알파값이 0이면 그리지 않음&#10;        if self.alpha &lt;= 0:&#10;            return&#10;        &#10;        # 방향에 따라 flip 설정&#10;        flip = '' if self.face_dir == 1 else 'h'&#10;        &#10;        # 알파값 설정하여 그리기&#10;        DashTrailEffect.trail_image.opacify(self.alpha)&#10;        DashTrailEffect.trail_image.clip_composite_draw(&#10;            0, 0, &#10;            DashTrailEffect.trail_image.w, &#10;            DashTrailEffect.trail_image.h,&#10;            0, flip,&#10;            draw_x, draw_y,&#10;            DashTrailEffect.trail_image.w * self.scale,&#10;            DashTrailEffect.trail_image.h * self.scale&#10;        )&#10;        # 알파값 복원 (다른 이미지에 영향 주지 않도록)&#10;        DashTrailEffect.trail_image.opacify(1.0)" />
              <option name="updatedContent" value="import os&#13;&#10;from pico2d import load_image&#13;&#10;import pico2d as p2&#13;&#10;import game_framework&#13;&#10;&#13;&#10;class AnimatedVFX:&#13;&#10;    &quot;&quot;&quot;간단한 프레임 애니메이션 VFX 엔티티&#13;&#10;    - folder: 폴더 경로 (예: resources/Texture_organize/VFX/Potion_Common)&#13;&#10;    - prefix: 파일명 접두사 (예: 'Potion_Back_FX')&#13;&#10;    - frames: 프레임 수&#13;&#10;    - frame_time: 각 프레임 지속 시간&#13;&#10;    - x,y: 위치&#13;&#10;    - scale: 크기 배율&#13;&#10;    &quot;&quot;&quot;&#13;&#10;    def __init__(self, folder, prefix, frames, frame_time, x, y, scale=1.0, life=None):&#13;&#10;        self.folder = folder&#13;&#10;        self.prefix = prefix&#13;&#10;        self.frames_count = frames&#13;&#10;        self.frame_time = frame_time&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;        self.images = []&#13;&#10;        self.frame = 0&#13;&#10;        self.acc = 0.0&#13;&#10;        self.life = life if life is not None else frames * frame_time&#13;&#10;        self._load_frames()&#13;&#10;&#13;&#10;    def _load_frames(self):&#13;&#10;        self.images = []&#13;&#10;        for i in range(self.frames_count):&#13;&#10;            name1 = f&quot;{self.prefix}{i:02d}.png&quot;&#13;&#10;            path = os.path.join(self.folder, name1)&#13;&#10;            try:&#13;&#10;                img = load_image(path)&#13;&#10;                self.images.append(img)&#13;&#10;            except Exception:&#13;&#10;                # 로드 실패하면 다음 프레임도 시도하지만 중단&#13;&#10;                print(f'\033[91m[AnimatedVFX] Failed to load frame: {path}\033[0m')&#13;&#10;                break&#13;&#10;        # fallback: 만약 아무 프레임도 로드되지 않으면 try single file without index&#13;&#10;        if not self.images:&#13;&#10;            single = os.path.join(self.folder, f&quot;{self.prefix}.png&quot;)&#13;&#10;            try:&#13;&#10;                img = load_image(single)&#13;&#10;                self.images.append(img)&#13;&#10;            except Exception:&#13;&#10;                print(f'\033[91m[AnimatedVFX] Failed to load single image: {single}\033[0m')&#13;&#10;        # adjust frames_count to actual loaded&#13;&#10;        self.frames_count = len(self.images)&#13;&#10;&#13;&#10;    def update(self, dt=None):&#13;&#10;        # dt None이면 framework에서 값을 가져옴 (main.update_world가 인자로 주지 않으므로)&#13;&#10;        if dt is None:&#13;&#10;            dt = game_framework.get_delta_time()&#13;&#10;        if self.life &lt;= 0:&#13;&#10;            return False&#13;&#10;        self.life -= dt&#13;&#10;        if self.frames_count == 0:&#13;&#10;            return self.life &gt; 0&#13;&#10;        self.acc += dt&#13;&#10;        while self.acc &gt;= self.frame_time and self.frame &lt; self.frames_count - 1:&#13;&#10;            self.acc -= self.frame_time&#13;&#10;            self.frame += 1&#13;&#10;        return self.life &gt; 0&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        if self.images and 0 &lt;= self.frame &lt; len(self.images):&#13;&#10;            img = self.images[self.frame]&#13;&#10;            img.draw(draw_x, draw_y, img.w * self.scale, img.h * self.scale)&#13;&#10;&#13;&#10;&#13;&#10;class GuardFX:&#13;&#10;    &quot;&quot;&quot;방패 방어 성공 시 표시되는 이펙트&quot;&quot;&quot;&#13;&#10;    images = None&#13;&#10;&#13;&#10;    def __init__(self, x, y, scale=3.0):&#13;&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;&#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if GuardFX.images is None:&#13;&#10;            GuardFX.images = []&#13;&#10;            try:&#13;&#10;                for i in range(5):  # GuardFX1_0.png ~ GuardFX1_4.png&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/Weapon/SwordANDShield/Guard_FX/GuardFX1_{i}.png')&#13;&#10;                    GuardFX.images.append(img)&#13;&#10;                print(f&quot;[GuardFX] Loaded {len(GuardFX.images)} images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[GuardFX] Failed to load images: {e}\033[0m&quot;)&#13;&#10;                GuardFX.images = []&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.animation_time = 0&#13;&#10;        self.animation_speed = 20  # 빠르게 재생 (20 FPS)&#13;&#10;        self.finished = False&#13;&#10;&#13;&#10;        print(f&quot;[GuardFX] 생성됨 at world({int(x)}, {int(y)}), 총 프레임: {len(GuardFX.images) if GuardFX.images else 0}&quot;)&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return False&#13;&#10;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.animation_time += dt&#13;&#10;&#13;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;            self.frame += 1&#13;&#10;            self.animation_time = 0&#13;&#10;&#13;&#10;            # 애니메이션이 끝나면 제거&#13;&#10;            if GuardFX.images and self.frame &gt;= len(GuardFX.images):&#13;&#10;                self.finished = True&#13;&#10;                return False&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 그리기&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not GuardFX.images or len(GuardFX.images) == 0:&#13;&#10;            print(&quot;[GuardFX] 이미지가 없음!&quot;)&#13;&#10;            return&#13;&#10;&#13;&#10;        if self.finished:&#13;&#10;            return&#13;&#10;&#13;&#10;        frame_idx = min(self.frame, len(GuardFX.images) - 1)&#13;&#10;        try:&#13;&#10;            # 카메라가 적용된 좌표(draw_x, draw_y)를 사용하여 그리기&#13;&#10;            GuardFX.images[frame_idx].draw(&#13;&#10;                draw_x, draw_y,&#13;&#10;                GuardFX.images[frame_idx].w * self.scale,&#13;&#10;                GuardFX.images[frame_idx].h * self.scale&#13;&#10;            )&#13;&#10;        except Exception as e:&#13;&#10;            print(f&quot;\033[91m[GuardFX] draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;class ShieldCrashEffect:&#13;&#10;    &quot;&quot;&quot;방패가 깨질 때 표시되는 이펙트 (Crash_Blue)&quot;&quot;&quot;&#13;&#10;    front_images = None&#13;&#10;    back_images = None&#13;&#10;&#13;&#10;    def __init__(self, x, y, scale=3.0):&#13;&#10;        # 월드 좌표 저장 (카메라 적용 전 좌표)&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.scale = scale&#13;&#10;&#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if ShieldCrashEffect.front_images is None:&#13;&#10;            ShieldCrashEffect.front_images = []&#13;&#10;            try:&#13;&#10;                for i in range(11):  # Crash_Blue_Front_FX00 ~ FX10 (0~10)&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Front_FX0{i}.png')&#13;&#10;                    ShieldCrashEffect.front_images.append(img)&#13;&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.front_images)} front images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load front images: {e}\033[0m&quot;)&#13;&#10;                ShieldCrashEffect.front_images = []&#13;&#10;&#13;&#10;        if ShieldCrashEffect.back_images is None:&#13;&#10;            ShieldCrashEffect.back_images = []&#13;&#10;            try:&#13;&#10;                for i in range(3, 9):  # Crash_Blue_Back_FX03 ~ FX08 (3~8)&#13;&#10;                    img = p2.load_image(f'resources/Texture_organize/VFX/Crash_Effect/Crash_Blue_Back_FX0{i}.png')&#13;&#10;                    ShieldCrashEffect.back_images.append(img)&#13;&#10;                print(f&quot;[ShieldCrashEffect] Loaded {len(ShieldCrashEffect.back_images)} back images&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] Failed to load back images: {e}\033[0m&quot;)&#13;&#10;                ShieldCrashEffect.back_images = []&#13;&#10;&#13;&#10;        self.frame = 0&#13;&#10;        self.animation_time = 0&#13;&#10;        self.animation_speed = 20  # 빠른 애니메이션 (20 FPS)&#13;&#10;        self.finished = False&#13;&#10;&#13;&#10;        print(f&quot;[ShieldCrashEffect] 생성됨 at world({int(x)}, {int(y)})&quot;)&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;이펙트 애니메이션 업데이트&quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return False&#13;&#10;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.animation_time += dt&#13;&#10;&#13;&#10;        if self.animation_time &gt;= 1.0 / self.animation_speed:&#13;&#10;            self.frame += 1&#13;&#10;            self.animation_time = 0&#13;&#10;&#13;&#10;            # Front 이미지 기준으로 애니메이션이 끝나면 제거&#13;&#10;            if ShieldCrashEffect.front_images and self.frame &gt;= len(ShieldCrashEffect.front_images):&#13;&#10;                self.finished = True&#13;&#10;                return False&#13;&#10;&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 그리기 (Front와 Back을 레이어링)&#13;&#10;&#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if self.finished:&#13;&#10;            return&#13;&#10;&#13;&#10;        # Front 이미지 그리기 (0~10 프레임)&#13;&#10;        if ShieldCrashEffect.front_images and self.frame &lt; len(ShieldCrashEffect.front_images):&#13;&#10;            try:&#13;&#10;                ShieldCrashEffect.front_images[self.frame].draw(&#13;&#10;                    draw_x, draw_y,&#13;&#10;                    ShieldCrashEffect.front_images[self.frame].w * self.scale,&#13;&#10;                    ShieldCrashEffect.front_images[self.frame].h * self.scale&#13;&#10;                )&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[ShieldCrashEffect] front draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;        # Back 이미지 그리기 (Front 프레임 3부터 시작)&#13;&#10;        # Front frame 3 = Back index 0 (Back_FX03)&#13;&#10;        # Front frame 4 = Back index 1 (Back_FX04) ...&#13;&#10;        if self.frame &gt;= 3:&#13;&#10;            back_index = self.frame - 3&#13;&#10;            if ShieldCrashEffect.back_images and back_index &lt; len(ShieldCrashEffect.back_images):&#13;&#10;                try:&#13;&#10;                    ShieldCrashEffect.back_images[back_index].draw(&#13;&#10;                        draw_x, draw_y,&#13;&#10;                        ShieldCrashEffect.back_images[back_index].w * self.scale,&#13;&#10;                        ShieldCrashEffect.back_images[back_index].h * self.scale&#13;&#10;                    )&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91m[ShieldCrashEffect] back draw 에러: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;class DashTrailEffect:&#13;&#10;    &quot;&quot;&quot;대시 시 남는 잔상 이펙트 - 0.3초간 알파값이 1에서 0으로 페이드아웃&quot;&quot;&quot;&#13;&#10;    trail_image = None  # 클래스 변수로 이미지 한 번만 로드&#13;&#10;&#13;&#10;    def __init__(self, x, y, face_dir, scale=3.0):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        대시 잔상 이펙트 생성&#13;&#10;        &#13;&#10;        Args:&#13;&#10;            x: 월드 X 좌표&#13;&#10;            y: 월드 Y 좌표&#13;&#10;            face_dir: 플레이어의 방향 (1: 오른쪽, -1: 왼쪽)&#13;&#10;            scale: 이미지 크기 배율&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.x = x&#13;&#10;        self.y = y&#13;&#10;        self.face_dir = face_dir&#13;&#10;        self.scale = scale&#13;&#10;        &#13;&#10;        # 이미지 로드 (클래스 변수로 한 번만 로드)&#13;&#10;        if DashTrailEffect.trail_image is None:&#13;&#10;            try:&#13;&#10;                img_path = os.path.join('resources', 'Texture_organize', 'Player_character', 'PlayerDashTrailFx0.png')&#13;&#10;                DashTrailEffect.trail_image = load_image(img_path)&#13;&#10;                print(f&quot;[DashTrailEffect] 이미지 로드 성공: {img_path}&quot;)&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;\033[91m[DashTrailEffect] 이미지 로드 실패: {e}\033[0m&quot;)&#13;&#10;                DashTrailEffect.trail_image = None&#13;&#10;        &#13;&#10;        # 페이드아웃 설정&#13;&#10;        self.fade_duration = 0.3  # 0.3초간 페이드아웃&#13;&#10;        self.elapsed_time = 0.0&#13;&#10;        self.alpha = 1.0  # 초기 알파값 1.0 (완전 불투명)&#13;&#10;    &#13;&#10;    def update(self):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        이펙트 업데이트 - 알파값을 시간에 따라 감소&#13;&#10;        &#13;&#10;        Returns:&#13;&#10;            bool: True면 계속 유지, False면 제거&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        dt = game_framework.get_delta_time()&#13;&#10;        self.elapsed_time += dt&#13;&#10;        &#13;&#10;        # 알파값 계산 (1.0 -&gt; 0.0으로 선형 감소)&#13;&#10;        if self.elapsed_time &lt; self.fade_duration:&#13;&#10;            self.alpha = 1.0 - (self.elapsed_time / self.fade_duration)&#13;&#10;        else:&#13;&#10;            self.alpha = 0.0&#13;&#10;            return False  # 알파값이 0이 되면 제거&#13;&#10;        &#13;&#10;        return True&#13;&#10;    &#13;&#10;    def draw(self, draw_x, draw_y):&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        잔상 이펙트 그리기&#13;&#10;        &#13;&#10;        Args:&#13;&#10;            draw_x: 카메라가 적용된 화면 X 좌표&#13;&#10;            draw_y: 카메라가 적용된 화면 Y 좌표&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not DashTrailEffect.trail_image:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # 알파값이 0이면 그리지 않음&#13;&#10;        if self.alpha &lt;= 0:&#13;&#10;            return&#13;&#10;        &#13;&#10;        # 방향에 따라 flip 설정&#13;&#10;        flip = '' if self.face_dir == 1 else 'h'&#13;&#10;        &#13;&#10;        # 알파값 설정하여 그리기&#13;&#10;        DashTrailEffect.trail_image.opacify(self.alpha)&#13;&#10;        DashTrailEffect.trail_image.clip_composite_draw(&#13;&#10;            0, 0, &#13;&#10;            DashTrailEffect.trail_image.w, &#13;&#10;            DashTrailEffect.trail_image.h,&#13;&#10;            0, flip,&#13;&#10;            draw_x, draw_y,&#13;&#10;            DashTrailEffect.trail_image.w * self.scale,&#13;&#10;            DashTrailEffect.trail_image.h * self.scale&#13;&#10;        )&#13;&#10;        # 알파값 복원 (다른 이미지에 영향 주지 않도록)&#13;&#10;        DashTrailEffect.trail_image.opacify(1.0)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>