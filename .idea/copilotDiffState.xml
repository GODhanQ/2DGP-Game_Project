<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/game_logic/cursor.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/cursor.py" />
              <option name="originalContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False&#10;" />
              <option name="updatedContent" value="import ctypes&#10;import os&#10;import math&#10;import pico2d as p2&#10;from pico2d import load_image, get_canvas_height, get_canvas_width&#10;from sdl2 import SDL_GetMouseState, SDL_ShowCursor, SDL_DISABLE, SDL_MOUSEBUTTONDOWN, SDL_MOUSEBUTTONUP, SDL_BUTTON_LEFT, SDL_BUTTON_RIGHT&#10;import game_framework as framework&#10;&#10;class Cursor:&#10;    def __init__(self, player=None):&#10;        # 기본 커서(인벤토리 닫힘 상태에서 사용)&#10;        self.image = load_image('resources/Texture_organize/UI/Cursor_Combat0.png')&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0 # 커서 크기 배율&#10;        SDL_ShowCursor(SDL_DISABLE) # 기본 시스템 커서 숨기기&#10;&#10;        # 플레이어 참조(인벤토리 열림 여부 확인용)&#10;        self.player = player&#10;        self.last_inventory_open = False&#10;        self.shield_available = True&#10;&#10;        # 인벤토리 전용 커서 애니메이션 프레임 로드&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.inv_frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.inv_frames.append(load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91mFailed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.inv_frames = []&#10;                break&#10;&#10;        # 인벤토리 커서 핫스팟(앵커) 비율: (ax, ay) in [0,1]&#10;        # - ax=0은 이미지의 가장 왼쪽, ax=1은 가장 오른쪽&#10;        # - ay=0은 이미지의 가장 아래, ay=1은 가장 위쪽&#10;        # 팁이 좌측 상단 쪽에 있을 것으로 가정하여 기본 (0.10, 0.90)으로 설정&#10;        self.inv_anchor = (0.10, 0.90)&#10;&#10;        # 방패 범위 이미지 (최상단 오버레이로 그리기)&#10;        try:&#10;            if self.shield_available:&#10;                self.shield_range_image = load_image('resources/Texture_organize/Weapon/shieldRange.png')&#10;        except Exception as ex:&#10;            print(f&quot;\033[91mFailed to load shield range image in cursor: {ex}\033[0m&quot;)&#10;            self.shield_range_image = None&#10;        self.shield_range_scale = 4.0&#10;&#10;        # 애니메이션 상태&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.frame_idx = 6            # idle은 마지막 프레임(6) 유지&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06    # 프레임당 시간&#10;        self.mouse_down = False&#10;&#10;    def update(self):&#10;        # 마우스 위치 갱신&#10;        mx = ctypes.c_int(0)&#10;        my = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;        canvas_h = get_canvas_height()&#10;        self.x = mx.value&#10;        self.y = canvas_h - 1 - my.value # pico2d 좌표계로 변환&#10;&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;&#10;        # 방패 사용 가능 여부 체크 (플레이어의 shield_broken 플래그 확인)&#10;        if self.player and hasattr(self.player, 'shield_broken'):&#10;            self.shield_available = not self.player.shield_broken&#10;        else:&#10;            self.shield_available = True&#10;&#10;        # 인벤토리 토글 시 애니메이션 상태 초기화&#10;        if inv_open != self.last_inventory_open:&#10;            self.anim_state = 'idle_up'&#10;            self.frame_idx = 6&#10;            self.frame_timer = 0.0&#10;            self.mouse_down = False&#10;            self.last_inventory_open = inv_open&#10;&#10;        # 인벤토리 열렸을 때만 애니메이션 적용&#10;        if inv_open and self.inv_frames:&#10;            dt = framework.get_delta_time()&#10;            self.frame_timer += dt&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생 후, 눌려있는 동안 1 유지&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;                # 눌린 상태 유지 시 frame 1 고정&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되었다면 업 애니메이션으로 전환&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6까지 재생 후 idle_up로 전환&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;    def draw(self, draw_x=None, draw_y=None):&#10;        if draw_x is None:&#10;            draw_x = self.x&#10;        if draw_y is None:&#10;            draw_y = self.y&#10;        # 방패 전개 범위 오버레이(항상 최상단). 단, 엔티티 레이어에서 그릴 경우 여기서는 생략&#10;        right_held = False&#10;        try:&#10;            mx = ctypes.c_int(0)&#10;            my = ctypes.c_int(0)&#10;            state = SDL_GetMouseState(ctypes.byref(mx), ctypes.byref(my))&#10;            right_mask = 1 &lt;&lt; (SDL_BUTTON_RIGHT - 1)&#10;            right_held = bool(state &amp; right_mask)&#10;        except Exception:&#10;            right_held = False&#10;&#10;        shield_block = False&#10;        draw_in_entity = False&#10;        if self.player and hasattr(self.player, 'shield') and self.player.shield:&#10;            shield_block = getattr(self.player.shield, 'blocking', False)&#10;            draw_in_entity = getattr(self.player.shield, 'draw_range_in_entity', False)&#10;&#10;        # 우클릭을 홀드할 때만 방패 범위 이미지를 플레이어 주변에 생성 (카메라 적용)&#10;        # 방패가 깨진 상태(shield_available=False)이면 쉴드 이펙트를 그리지 않음&#10;        if right_held and self.shield_available and self.shield_range_image is not None and not draw_in_entity:&#10;            # 카메라 가져오기 - play_mode와 lobby_mode 모두 지원&#10;            camera = None&#10;            try:&#10;                # 먼저 play_mode에서 카메라 가져오기 시도&#10;                import game_logic.play_mode as play&#10;                camera = getattr(play, 'camera', None)&#10;&#10;                # play_mode 카메라가 없으면 lobby_mode에서 시도&#10;                if camera is None:&#10;                    import game_logic.lobby_mode as lobby&#10;                    camera = getattr(lobby, 'camera', None)&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[Cursor] 카메라 가져오기 실패: {ex}\033[0m&quot;)&#10;                camera = None&#10;&#10;            # 마우스 화면 좌표 가져오기&#10;            mx2 = ctypes.c_int(0)&#10;            my2 = ctypes.c_int(0)&#10;            SDL_GetMouseState(ctypes.byref(mx2), ctypes.byref(my2))&#10;&#10;            canvas_h = get_canvas_height()&#10;            canvas_w = get_canvas_width()&#10;            mouse_screen_x = mx2.value&#10;            mouse_screen_y = canvas_h - my2.value&#10;&#10;            # 마우스 화면 좌표를 월드 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                mouse_world_x = mouse_screen_x - half_w + camera.x&#10;                mouse_world_y = mouse_screen_y - half_h + camera.y&#10;            else:&#10;                mouse_world_x = mouse_screen_x&#10;                mouse_world_y = mouse_screen_y&#10;&#10;            # 플레이어(월드 좌표)에서 마우스(월드 좌표)로 향하는 벡터 계산&#10;            dx = mouse_world_x - self.player.x&#10;            dy = mouse_world_y - self.player.y&#10;&#10;            # 각도 계산&#10;            angle = math.atan2(dy, dx)&#10;            base_offset = -math.pi / 2&#10;            theta = angle + base_offset&#10;&#10;            # 플레이어의 월드 좌표를 화면 좌표로 변환&#10;            if camera is not None:&#10;                half_w = canvas_w // 2&#10;                half_h = canvas_h // 2&#10;                player_screen_x = self.player.x - camera.x + half_w&#10;                player_screen_y = self.player.y - camera.y + half_h&#10;            else:&#10;                player_screen_x = self.player.x&#10;                player_screen_y = self.player.y&#10;&#10;            # 방패 이펙트를 플레이어의 화면 좌표 기준으로 그리기&#10;            half_h_scaled = (self.shield_range_image.h * self.shield_range_scale) * 0.5&#10;            draw_x_shield = player_screen_x - half_h_scaled * math.sin(theta)&#10;            draw_y_shield = player_screen_y + half_h_scaled * math.cos(theta)&#10;&#10;            self.shield_range_image.clip_composite_draw(&#10;                0, 0, self.shield_range_image.w, self.shield_range_image.h,&#10;                theta, '',&#10;                draw_x_shield, draw_y_shield,&#10;                self.shield_range_image.w * self.shield_range_scale,&#10;                self.shield_range_image.h * self.shield_range_scale&#10;            )&#10;            # 디버그 로그 - 카메라 정보 추가&#10;            # if camera is not None:&#10;            #     print(f'[Cursor] Drew shield range at screen ({draw_x_shield:.1f}, {draw_y_shield:.1f}), '&#10;            #           f'player world ({self.player.x:.1f}, {self.player.y:.1f}), '&#10;            #           f'player screen ({player_screen_x:.1f}, {player_screen_y:.1f}), '&#10;            #           f'camera ({camera.x:.1f}, {camera.y:.1f}), angle {theta:.2f}')&#10;            # else:&#10;            #     print(f'[Cursor] Drew shield range at ({draw_x_shield:.1f}, {draw_y_shield:.1f}) with angle {theta:.2f} (NO CAMERA)')&#10;&#10;        # 인벤토리 열림 + 프레임 로드 성공 시 전용 커서 사용 (팁 위치를 마우스 좌표에 정렬)&#10;        if self.player and getattr(self.player, 'inventory_open', False) and self.inv_frames:&#10;            img = self.inv_frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;            ax, ay = self.inv_anchor&#10;            cx = self.x + (0.5 - ax) * w&#10;            cy = self.y + (0.5 - ay) * h&#10;            img.draw(cx, cy, w, h)&#10;        else:&#10;            self.image.draw(draw_x, draw_y, self.image.w * self.scale_factor, self.image.h * self.scale_factor)&#10;&#10;    def handle_event(self, event):&#10;        # 인벤토리 열렸을 때만 클릭 애니메이션 처리&#10;        inv_open = bool(getattr(self.player, 'inventory_open', False)) if self.player else False&#10;        if not inv_open:&#10;            return&#10;        if not self.inv_frames:&#10;            return&#10;        # 마우스 좌클릭 이벤트 처리&#10;        if event.type == SDL_MOUSEBUTTONDOWN and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = True&#10;            self.anim_state = 'down'&#10;            self.frame_idx = 0&#10;            self.frame_timer = 0.0&#10;        elif event.type == SDL_MOUSEBUTTONUP and event.button == SDL_BUTTON_LEFT:&#10;            self.mouse_down = False&#10;            # 업 애니메이션 시작 (2부터)&#10;            self.anim_state = 'up'&#10;            self.frame_idx = 2&#10;            self.frame_timer = 0.0&#10;&#10;&#10;# 타이틀 화면 전용 커서&#10;class TitleCursor:&#10;    &quot;&quot;&quot;타이틀 화면용 커서 - 인벤토리 커서 이미지 사용&quot;&quot;&quot;&#10;    def __init__(self):&#10;        self.x, self.y = 0, 0&#10;        self.scale_factor = 2.0&#10;        from sdl2 import SDL_ShowCursor, SDL_DISABLE&#10;        SDL_ShowCursor(SDL_DISABLE)  # 시스템 커서 숨기기&#10;&#10;        # 인벤토리 커서 애니메이션 프레임 로드&#10;        import os&#10;        mouse_folder = os.path.join('resources', 'Texture_organize', 'UI', 'Mouse_Arrow')&#10;        self.frames = []&#10;        for i in range(0, 7):&#10;            path = os.path.join(mouse_folder, f'Multi_Arrow_UI_14_Mouse_{i}.png')&#10;            try:&#10;                self.frames.append(p2.load_image(path))&#10;            except Exception as ex:&#10;                print(f&quot;\033[91m[TitleCursor] Failed to load cursor frame: {path}, {ex}\033[0m&quot;)&#10;                self.frames = []&#10;                break&#10;&#10;        # 애니메이션 상태&#10;        self.frame_idx = 6  # idle 상태 (마지막 프레임)&#10;        self.frame_timer = 0.0&#10;        self.frame_duration = 0.06&#10;        self.anim_state = 'idle_up'  # 'down', 'up', 'idle_up'&#10;        self.mouse_down = False&#10;&#10;        # 커서 핫스팟 (팁 위치)&#10;        self.anchor = (0.10, 0.90)&#10;&#10;        print(f&quot;[TitleCursor] 커서 프레임 {len(self.frames)}개 로드 완료&quot;)&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;마우스 위치 업데이트 및 애니메이션&quot;&quot;&quot;&#10;        # 마우스 위치 갱신&#10;        mx_ptr = ctypes.c_int(0)&#10;        my_ptr = ctypes.c_int(0)&#10;        SDL_GetMouseState(ctypes.byref(mx_ptr), ctypes.byref(my_ptr))&#10;        self.x = mx_ptr.value&#10;        self.y = p2.get_canvas_height() - my_ptr.value&#10;&#10;        # 애니메이션 업데이트&#10;        if self.frames:&#10;            dt = framework.delta_time if hasattr(framework, 'delta_time') else 0.016&#10;            self.frame_timer += dt&#10;&#10;            if self.anim_state == 'down':&#10;                # 0 -&gt; 1 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 1:&#10;                        self.frame_idx += 1&#10;&#10;                if self.mouse_down:&#10;                    self.frame_idx = max(self.frame_idx, 1)&#10;                else:&#10;                    # 버튼 해제되면 up 애니메이션으로&#10;                    self.anim_state = 'up'&#10;                    self.frame_idx = 2&#10;                    self.frame_timer = 0.0&#10;&#10;            elif self.anim_state == 'up':&#10;                # 2 -&gt; 6 재생&#10;                if self.frame_timer &gt;= self.frame_duration:&#10;                    self.frame_timer -= self.frame_duration&#10;                    if self.frame_idx &lt; 6:&#10;                        self.frame_idx += 1&#10;                    if self.frame_idx &gt;= 6:&#10;                        self.anim_state = 'idle_up'&#10;                        self.frame_idx = 6&#10;&#10;            else:&#10;                # idle_up: 프레임 6 유지&#10;                self.frame_idx = 6&#10;&#10;        return True&#10;&#10;    def draw(self):&#10;        &quot;&quot;&quot;커서 그리기&quot;&quot;&quot;&#10;        if self.frames and 0 &lt;= self.frame_idx &lt; len(self.frames):&#10;            img = self.frames[self.frame_idx]&#10;            w = img.w * self.scale_factor&#10;            h = img.h * self.scale_factor&#10;&#10;            # 핫스팟(팁) 위치를 마우스 좌표에 맞추기&#10;            ax, ay = self.anchor&#10;            draw_x = self.x - w * ax&#10;            draw_y = self.y - h * ay&#10;&#10;            img.draw(draw_x + w * 0.5, draw_y + h * 0.5, w, h)&#10;&#10;    def handle_event(self, e):&#10;        &quot;&quot;&quot;마우스 이벤트 처리&quot;&quot;&quot;&#10;        if e.type == SDL_MOUSEBUTTONDOWN:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = True&#10;                self.anim_state = 'down'&#10;                self.frame_idx = 0&#10;                self.frame_timer = 0.0&#10;        elif e.type == SDL_MOUSEBUTTONUP:&#10;            if e.button == SDL_BUTTON_LEFT:&#10;                self.mouse_down = False" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/map.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/map.py" />
              <option name="originalContent" value="# map.py&#10;# Room.txt 기반 간단한 맵 로더 및 타일 엔티티 빌더&#10;# 작성자: 자동 생성&#10;# 사용 가정(중요):&#10;# - Room.txt 파일은 섹션 단위(예: [ground], [upper_ground], [walls], [cliff], [props])의 텍스트로 존재하며,&#10;#   각 섹션 밑에는 콤마(,)로 구분된 정수 타일 인덱스 행들이 있음.&#10;#   예:&#10;#   [ground]&#10;#   1,1,1,0,0&#10;#   1,2,2,0,0&#10;#&#10;# - 0은 빈 타일(배치 없음)을 의미.&#10;# - props 섹션은 현재 무시합니다.&#10;#&#10;# 제공하는 기능:&#10;# - Map.load_from_room_txt(path): Room.txt 파싱&#10;# - Map.build_into_world(world, tile_size=32, origin=(0,0)): world의 레이어들에 타일 엔티티를 추가&#10;# - TileEntity: 최소한의 update()/draw() 인터페이스(프로젝트의 실제 렌더링 파이프라인에 맞춰 확장 가능)&#10;&#10;import os&#10;from typing import Dict, List, Tuple, Optional&#10;&#10;try:&#10;    from pico2d import draw_rectangle&#10;except Exception:&#10;    # pico2d가 없으면 draw_rectangle을 대체하는 더미 함수로 허용&#10;    def draw_rectangle(l, b, r, t):&#10;        # no-op in headless/static analysis&#10;        return&#10;&#10;&#10;SUPPORTED_SECTIONS = ['ground', 'upper_ground', 'walls', 'cliff', 'props']&#10;&#10;&#10;class TileEntity:&#10;    &quot;&quot;&quot;맵에 배치되는 간단한 타일 엔티티.&#10;    실제 프로젝트에서는 이미지(tileset)과 애니메이션, 충돌박스 등을 연결해서 사용하면 됩니다.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, tile_id: int, x: int, y: int, size: int, layer: str):&#10;        self.tile_id = int(tile_id)&#10;        self.x = int(x)&#10;        self.y = int(y)&#10;        self.size = int(size)&#10;        self.layer = layer&#10;&#10;    def update(self):&#10;        # 기본 타일은 고정이므로 True를 반환하여 계속 유지&#10;        return True&#10;&#10;    def draw(self):&#10;        # 디버그용 간단한 사각형 그리기 (pico2d가 있으면 보임)&#10;        l = self.x&#10;        b = self.y&#10;        r = self.x + self.size&#10;        t = self.y + self.size&#10;        draw_rectangle(l, b, r, t)&#10;&#10;&#10;class Map:&#10;    def __init__(self, tile_size: int = 32):&#10;        self.tile_size = int(tile_size)&#10;        # 각 섹션에 대해 2D 리스트(행 리스트)로 타일 인덱스를 보관&#10;        self.layers: Dict[str, List[List[int]]] = {s: [] for s in SUPPORTED_SECTIONS}&#10;        self.width = 0&#10;        self.height = 0&#10;&#10;    @staticmethod&#10;    def _normalize_section_name(name: str) -&gt; str:&#10;        return name.strip().lower()&#10;&#10;    def load_from_room_txt(self, path: str) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Room.txt 형식(간단한 INI 스타일)을 파싱하여 self.layers에 채웁니다.&#10;        빈 라인 또는 주석(//, ;, #)은 무시합니다.&#10;&#10;        변경: 토큰 구분자는 공백(whitespace)을 사용합니다. 라인 내의 ','는 공백으로 대체되어&#10;        기존 콤마 형식과도 호환됩니다. 토큰 '0' 및 'X'/'x'는 빈 타일(0)으로 처리됩니다.&#10;        &quot;&quot;&quot;&#10;        if not os.path.isfile(path):&#10;            raise FileNotFoundError(f&quot;Room file not found: {path}&quot;)&#10;&#10;        current = None&#10;        with open(path, 'r', encoding='utf-8') as f:&#10;            for raw_line in f:&#10;                line = raw_line.strip()&#10;                if not line:&#10;                    continue&#10;                if line.startswith('//') or line.startswith('#') or line.startswith(';'):&#10;                    continue&#10;                if line.startswith('[') and line.endswith(']'):&#10;                    sec = self._normalize_section_name(line[1:-1])&#10;                    if sec not in SUPPORTED_SECTIONS:&#10;                        # 새 섹션을 만드려 하지 말고 지원되는 섹션만 처리&#10;                        current = None&#10;                        continue&#10;                    current = sec&#10;                    # reset existing content for the section&#10;                    self.layers[current] = []&#10;                    continue&#10;&#10;                if current is None:&#10;                    # 섹션 밖의 데이터는 무시&#10;                    continue&#10;&#10;                # ',' 구분자를 공백으로 바꿔 공백 분할을 사용하여 유연하게 처리&#10;                normalized = line.replace(',', ' ')&#10;                parts = [p.strip() for p in normalized.split() if p.strip() != '']&#10;                if not parts:&#10;                    continue&#10;                row: List[int] = []&#10;                for p in parts:&#10;                    # '0' 과 'X' 또는 'x' 를 빈타일로 처리&#10;                    if p == '0' or p.lower() == 'x':&#10;                        row.append(0)&#10;                        continue&#10;                    try:&#10;                        row.append(int(p))&#10;                    except ValueError:&#10;                        # 숫자로 변환할 수 없는 토큰이 있으면 빈타일로 처리&#10;                        row.append(0)&#10;                self.layers[current].append(row)&#10;&#10;        # 맵 전체 크기 계산 (가장 큰 폭/높이 사용)&#10;        max_w = 0&#10;        max_h = 0&#10;        for sec in SUPPORTED_SECTIONS:&#10;            h = len(self.layers.get(sec, []))&#10;            if h &gt; max_h:&#10;                max_h = h&#10;            for row in self.layers.get(sec, []):&#10;                if len(row) &gt; max_w:&#10;                    max_w = len(row)&#10;        self.width = max_w&#10;        self.height = max_h&#10;&#10;    def build_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0), replace: bool = True) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        파싱된 레이어 데이터를 바탕으로 `world` 딕셔너리의 레이어 리스트에 TileEntity들을 추가합니다.&#10;        - world: main.py에서 사용되는 world 딕셔너리 (예: keys: 'ground','upper_ground','walls',...)&#10;        - tile_size: 맵의 타일 픽셀 크기 (기본은 Map.tile_size)&#10;        - origin: (x0,y0) 맵 원점 좌표 (왼쪽 하단 기준)&#10;        - replace: True이면 이 함수가 추가할 레이어(ground/upper_ground/walls)의 기존 리스트를 비우고 새로 채웁니다.&#10;&#10;        이 함수는 props 섹션은 현재 무시합니다.&#10;        &quot;&quot;&quot;&#10;        ts = int(tile_size) if tile_size is not None else self.tile_size&#10;        x0, y0 = origin&#10;&#10;        target_layers = ['ground', 'upper_ground', 'walls']&#10;        if replace:&#10;            for tl in target_layers:&#10;                if tl in world and isinstance(world[tl], list):&#10;                    world[tl].clear()&#10;&#10;        # 맵 데이터의 행렬은 텍스트 상에서는 보통 위에서 아래로 작성됨을 가정.&#10;        # 여기서는 텍스트 행(0)이 맵의 &quot;상단&quot;이라고 가정하고 화면 좌표로는 높이를 고려해 y를 계산합니다.&#10;        for sec in ['ground', 'upper_ground', 'walls', 'cliff']:&#10;            rows = self.layers.get(sec, [])&#10;            h = len(rows)&#10;            for row_idx, row in enumerate(rows):&#10;                # 텍스트의 첫 행 -&gt; 맵 상단이므로 y 계산&#10;                # 맵 상단을 origin_y + (height - 1 - row_idx) * ts 로 배치&#10;                for col_idx, tile_id in enumerate(row):&#10;                    if tile_id == 0:&#10;                        continue&#10;                    # compute position&#10;                    # bottom-left origin&#10;                    x = x0 + col_idx * ts&#10;                    y = y0 + (self.height - 1 - row_idx) * ts&#10;                    ent = TileEntity(tile_id=tile_id, x=x, y=y, size=ts, layer=sec)&#10;                    # 저장된 그리드 좌표를 붙여 두면 나중에 크기 변경 시 재계산에 사용 가능&#10;                    ent._grid_col = col_idx&#10;                    ent._grid_row = row_idx&#10;                    ent._map_height = self.height&#10;                    ent._origin = (x0, y0)&#10;                    # 월드에 맞는 레이어 키가 존재하면 append&#10;                    if sec == 'ground':&#10;                        world.setdefault('ground', []).append(ent)&#10;                    elif sec == 'upper_ground':&#10;                        world.setdefault('upper_ground', []).append(ent)&#10;                    elif sec == 'walls' or sec == 'cliff':&#10;                        # 벽/절벽은 충돌 처리용으로 walls 레이어에 넣음&#10;                        world.setdefault('walls', []).append(ent)&#10;                    else:&#10;                        # props 등은 현재 무시&#10;                        pass&#10;&#10;    def rebuild_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        편의 메서드: 기존 내용을 교체(replace=True)하여 다시 빌드합니다.&#10;        &quot;&quot;&quot;&#10;        self.build_into_world(world, tile_size=tile_size, origin=origin, replace=True)&#10;&#10;    def apply_tile_size_to_world(self, world: Dict[str, list], new_tile_size: int, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        기존에 world에 배치된 TileEntity들이 그리드 좌표를 가지고 있다면,&#10;        각 엔티티의 size와 x,y를 새 타일 크기에 맞게 in-place로 갱신합니다.&#10;        - world: 월드 딕셔너리&#10;        - new_tile_size: 적용할 새 타일 크기&#10;        - origin: 맵 원점&#10;&#10;        이 방법은 엔티티를 새로 생성하지 않으므로 외부 참조가 유지됩니다.&#10;        만약 엔티티에 그리드 좌표가 없다면 동작하지 않습니다(그럴 경우 재빌드 필요).&#10;        &quot;&quot;&quot;&#10;        ts = int(new_tile_size)&#10;        x0, y0 = origin&#10;        layers = ['ground', 'upper_ground', 'walls']&#10;        updated = 0&#10;        for layer in layers:&#10;            for ent in list(world.get(layer, [])):&#10;                # ent가 grid 정보(_grid_col/_grid_row/_map_height)를 가지고 있으면 위치 재계산&#10;                if hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height'):&#10;                    col = int(ent._grid_col)&#10;                    row = int(ent._grid_row)&#10;                    map_h = int(ent._map_height)&#10;                    ent.size = ts&#10;                    ent.x = x0 + col * ts&#10;                    ent.y = y0 + (map_h - 1 - row) * ts&#10;                    # update stored origin too&#10;                    ent._origin = (x0, y0)&#10;                    updated += 1&#10;                else:&#10;                    # grid 정보가 없으면 이 엔티티는 무시 (재빌드를 권장)&#10;                    continue&#10;        try:&#10;            print(f&quot;apply_tile_size_to_world: applied new_tile_size={ts}, updated_entities={updated}&quot;)&#10;        except Exception:&#10;            pass&#10;&#10;    def set_tile_size(self, new_tile_size: int, world: Optional[Dict[str, list]] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Map의 기본 타일 크기를 변경합니다. 만약 `world`를 전달하면 해당 월드에 대해&#10;        가능한 경우 in-place로 크기/위치를 갱신하고, grid 정보가 부족하면 재빌드를 수행합니다.&#10;        &quot;&quot;&quot;&#10;        self.tile_size = int(new_tile_size)&#10;        if world is not None:&#10;            # 먼저 시도: in-place 적용 (grid 좌표가 있는 경우)&#10;            # 검사: 모든 엔티티들이 grid 좌표를 가지고 있는지 확인&#10;            ok = True&#10;            total = 0&#10;            for layer in ['ground', 'upper_ground', 'walls']:&#10;                for ent in world.get(layer, []):&#10;                    total += 1&#10;                    if not (hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height')):&#10;                        ok = False&#10;                        break&#10;                if not ok:&#10;                    break&#10;            if ok:&#10;                try:&#10;                    self.apply_tile_size_to_world(world, self.tile_size, origin)&#10;                    print(f&quot;set_tile_size: in-place applied to {total} entities, new_tile_size={self.tile_size}&quot;)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91mset_tile_size: in-place apply failed: {e}\033[0m&quot;)&#10;            else:&#10;                # 일부 엔티티에 grid 정보가 없으면 안전하게 재빌드&#10;                try:&#10;                    self.rebuild_into_world(world, tile_size=self.tile_size, origin=origin)&#10;                    print(f&quot;set_tile_size: rebuilt world with new_tile_size={self.tile_size}&quot;)&#10;                except Exception as e:&#10;                    print(f&quot;\033[91mset_tile_size: rebuild failed: {e}\033[0m&quot;)&#10;&#10;&#10;# 간단한 자기검증 스크립트&#10;if __name__ == '__main__':&#10;    # 간단한 Room 텍스트 샘플을 메모리로 만들고 파싱 테스트&#10;    sample = '''&#10;[ground]&#10;1,1,1,0,0&#10;1,2,2,0,0&#10;&#10;[upper_ground]&#10;0,0,3,3,0&#10;&#10;[walls]&#10;0,4,0,0,0&#10;'''&#10;    import tempfile&#10;&#10;    p = tempfile.gettempdir() + os.sep + 'sample_room.txt'&#10;    with open(p, 'w', encoding='utf-8') as f:&#10;        f.write(sample)&#10;&#10;    m = Map(tile_size=128)&#10;    m.load_from_room_txt(p)&#10;    print('width,height:', m.width, m.height)&#10;    world = {k: [] for k in ['ground', 'upper_ground', 'walls', 'effects_back', 'effects_front', 'ui', 'cursor']}&#10;    m.build_into_world(world, origin=(0, 0))&#10;    for k in world:&#10;        print(k, len(world[k]))&#10;" />
              <option name="updatedContent" value="# map.py&#13;&#10;# Room.txt 기반 간단한 맵 로더 및 타일 엔티티 빌더&#13;&#10;# 작성자: 자동 생성&#13;&#10;# 사용 가정(중요):&#13;&#10;# - Room.txt 파일은 섹션 단위(예: [ground], [upper_ground], [walls], [cliff], [props])의 텍스트로 존재하며,&#13;&#10;#   각 섹션 밑에는 콤마(,)로 구분된 정수 타일 인덱스 행들이 있음.&#13;&#10;#   예:&#13;&#10;#   [ground]&#13;&#10;#   1,1,1,0,0&#13;&#10;#   1,2,2,0,0&#13;&#10;#&#13;&#10;# - 0은 빈 타일(배치 없음)을 의미.&#13;&#10;# - props 섹션은 현재 무시합니다.&#13;&#10;#&#13;&#10;# 제공하는 기능:&#13;&#10;# - Map.load_from_room_txt(path): Room.txt 파싱&#13;&#10;# - Map.build_into_world(world, tile_size=32, origin=(0,0)): world의 레이어들에 타일 엔티티를 추가&#13;&#10;# - TileEntity: 최소한의 update()/draw() 인터페이스(프로젝트의 실제 렌더링 파이프라인에 맞춰 확장 가능)&#13;&#10;&#13;&#10;import os&#13;&#10;from typing import Dict, List, Tuple, Optional&#13;&#10;&#13;&#10;try:&#13;&#10;    from pico2d import draw_rectangle&#13;&#10;except Exception:&#13;&#10;    # pico2d가 없으면 draw_rectangle을 대체하는 더미 함수로 허용&#13;&#10;    def draw_rectangle(l, b, r, t):&#13;&#10;        # no-op in headless/static analysis&#13;&#10;        return&#13;&#10;&#13;&#10;&#13;&#10;SUPPORTED_SECTIONS = ['ground', 'upper_ground', 'walls', 'cliff', 'props']&#13;&#10;&#13;&#10;&#13;&#10;class TileEntity:&#13;&#10;    &quot;&quot;&quot;맵에 배치되는 간단한 타일 엔티티.&#13;&#10;    실제 프로젝트에서는 이미지(tileset)과 애니메이션, 충돌박스 등을 연결해서 사용하면 됩니다.&#13;&#10;    &quot;&quot;&quot;&#13;&#10;&#13;&#10;    def __init__(self, tile_id: int, x: int, y: int, size: int, layer: str):&#13;&#10;        self.tile_id = int(tile_id)&#13;&#10;        self.x = int(x)&#13;&#10;        self.y = int(y)&#13;&#10;        self.size = int(size)&#13;&#10;        self.layer = layer&#13;&#10;&#13;&#10;    def update(self):&#13;&#10;        # 기본 타일은 고정이므로 True를 반환하여 계속 유지&#13;&#10;        return True&#13;&#10;&#13;&#10;    def draw(self):&#13;&#10;        # 디버그용 간단한 사각형 그리기 (pico2d가 있으면 보임)&#13;&#10;        l = self.x&#13;&#10;        b = self.y&#13;&#10;        r = self.x + self.size&#13;&#10;        t = self.y + self.size&#13;&#10;        draw_rectangle(l, b, r, t)&#13;&#10;&#13;&#10;&#13;&#10;class Map:&#13;&#10;    def __init__(self, tile_size: int = 32):&#13;&#10;        self.tile_size = int(tile_size)&#13;&#10;        # 각 섹션에 대해 2D 리스트(행 리스트)로 타일 인덱스를 보관&#13;&#10;        self.layers: Dict[str, List[List[int]]] = {s: [] for s in SUPPORTED_SECTIONS}&#13;&#10;        self.width = 0&#13;&#10;        self.height = 0&#13;&#10;&#13;&#10;    @staticmethod&#13;&#10;    def _normalize_section_name(name: str) -&gt; str:&#13;&#10;        return name.strip().lower()&#13;&#10;&#13;&#10;    def load_from_room_txt(self, path: str) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Room.txt 형식(간단한 INI 스타일)을 파싱하여 self.layers에 채웁니다.&#13;&#10;        빈 라인 또는 주석(//, ;, #)은 무시합니다.&#13;&#10;&#13;&#10;        변경: 토큰 구분자는 공백(whitespace)을 사용합니다. 라인 내의 ','는 공백으로 대체되어&#13;&#10;        기존 콤마 형식과도 호환됩니다. 토큰 '0' 및 'X'/'x'는 빈 타일(0)으로 처리됩니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        if not os.path.isfile(path):&#13;&#10;            raise FileNotFoundError(f&quot;Room file not found: {path}&quot;)&#13;&#10;&#13;&#10;        current = None&#13;&#10;        with open(path, 'r', encoding='utf-8') as f:&#13;&#10;            for raw_line in f:&#13;&#10;                line = raw_line.strip()&#13;&#10;                if not line:&#13;&#10;                    continue&#13;&#10;                if line.startswith('//') or line.startswith('#') or line.startswith(';'):&#13;&#10;                    continue&#13;&#10;                if line.startswith('[') and line.endswith(']'):&#13;&#10;                    sec = self._normalize_section_name(line[1:-1])&#13;&#10;                    if sec not in SUPPORTED_SECTIONS:&#13;&#10;                        # 새 섹션을 만드려 하지 말고 지원되는 섹션만 처리&#13;&#10;                        current = None&#13;&#10;                        continue&#13;&#10;                    current = sec&#13;&#10;                    # reset existing content for the section&#13;&#10;                    self.layers[current] = []&#13;&#10;                    continue&#13;&#10;&#13;&#10;                if current is None:&#13;&#10;                    # 섹션 밖의 데이터는 무시&#13;&#10;                    continue&#13;&#10;&#13;&#10;                # ',' 구분자를 공백으로 바꿔 공백 분할을 사용하여 유연하게 처리&#13;&#10;                normalized = line.replace(',', ' ')&#13;&#10;                parts = [p.strip() for p in normalized.split() if p.strip() != '']&#13;&#10;                if not parts:&#13;&#10;                    continue&#13;&#10;                row: List[int] = []&#13;&#10;                for p in parts:&#13;&#10;                    # '0' 과 'X' 또는 'x' 를 빈타일로 처리&#13;&#10;                    if p == '0' or p.lower() == 'x':&#13;&#10;                        row.append(0)&#13;&#10;                        continue&#13;&#10;                    try:&#13;&#10;                        row.append(int(p))&#13;&#10;                    except ValueError:&#13;&#10;                        # 숫자로 변환할 수 없는 토큰이 있으면 빈타일로 처리&#13;&#10;                        row.append(0)&#13;&#10;                self.layers[current].append(row)&#13;&#10;&#13;&#10;        # 맵 전체 크기 계산 (가장 큰 폭/높이 사용)&#13;&#10;        max_w = 0&#13;&#10;        max_h = 0&#13;&#10;        for sec in SUPPORTED_SECTIONS:&#13;&#10;            h = len(self.layers.get(sec, []))&#13;&#10;            if h &gt; max_h:&#13;&#10;                max_h = h&#13;&#10;            for row in self.layers.get(sec, []):&#13;&#10;                if len(row) &gt; max_w:&#13;&#10;                    max_w = len(row)&#13;&#10;        self.width = max_w&#13;&#10;        self.height = max_h&#13;&#10;&#13;&#10;    def build_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0), replace: bool = True) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        파싱된 레이어 데이터를 바탕으로 `world` 딕셔너리의 레이어 리스트에 TileEntity들을 추가합니다.&#13;&#10;        - world: main.py에서 사용되는 world 딕셔너리 (예: keys: 'ground','upper_ground','walls',...)&#13;&#10;        - tile_size: 맵의 타일 픽셀 크기 (기본은 Map.tile_size)&#13;&#10;        - origin: (x0,y0) 맵 원점 좌표 (왼쪽 하단 기준)&#13;&#10;        - replace: True이면 이 함수가 추가할 레이어(ground/upper_ground/walls)의 기존 리스트를 비우고 새로 채웁니다.&#13;&#10;&#13;&#10;        이 함수는 props 섹션은 현재 무시합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        ts = int(tile_size) if tile_size is not None else self.tile_size&#13;&#10;        x0, y0 = origin&#13;&#10;&#13;&#10;        target_layers = ['ground', 'upper_ground', 'walls']&#13;&#10;        if replace:&#13;&#10;            for tl in target_layers:&#13;&#10;                if tl in world and isinstance(world[tl], list):&#13;&#10;                    world[tl].clear()&#13;&#10;&#13;&#10;        # 맵 데이터의 행렬은 텍스트 상에서는 보통 위에서 아래로 작성됨을 가정.&#13;&#10;        # 여기서는 텍스트 행(0)이 맵의 &quot;상단&quot;이라고 가정하고 화면 좌표로는 높이를 고려해 y를 계산합니다.&#13;&#10;        for sec in ['ground', 'upper_ground', 'walls', 'cliff']:&#13;&#10;            rows = self.layers.get(sec, [])&#13;&#10;            h = len(rows)&#13;&#10;            for row_idx, row in enumerate(rows):&#13;&#10;                # 텍스트의 첫 행 -&gt; 맵 상단이므로 y 계산&#13;&#10;                # 맵 상단을 origin_y + (height - 1 - row_idx) * ts 로 배치&#13;&#10;                for col_idx, tile_id in enumerate(row):&#13;&#10;                    if tile_id == 0:&#13;&#10;                        continue&#13;&#10;                    # compute position&#13;&#10;                    # bottom-left origin&#13;&#10;                    x = x0 + col_idx * ts&#13;&#10;                    y = y0 + (self.height - 1 - row_idx) * ts&#13;&#10;                    ent = TileEntity(tile_id=tile_id, x=x, y=y, size=ts, layer=sec)&#13;&#10;                    # 저장된 그리드 좌표를 붙여 두면 나중에 크기 변경 시 재계산에 사용 가능&#13;&#10;                    ent._grid_col = col_idx&#13;&#10;                    ent._grid_row = row_idx&#13;&#10;                    ent._map_height = self.height&#13;&#10;                    ent._origin = (x0, y0)&#13;&#10;                    # 월드에 맞는 레이어 키가 존재하면 append&#13;&#10;                    if sec == 'ground':&#13;&#10;                        world.setdefault('ground', []).append(ent)&#13;&#10;                    elif sec == 'upper_ground':&#13;&#10;                        world.setdefault('upper_ground', []).append(ent)&#13;&#10;                    elif sec == 'walls' or sec == 'cliff':&#13;&#10;                        # 벽/절벽은 충돌 처리용으로 walls 레이어에 넣음&#13;&#10;                        world.setdefault('walls', []).append(ent)&#13;&#10;                    else:&#13;&#10;                        # props 등은 현재 무시&#13;&#10;                        pass&#13;&#10;&#13;&#10;    def rebuild_into_world(self, world: Dict[str, list], tile_size: Optional[int] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        편의 메서드: 기존 내용을 교체(replace=True)하여 다시 빌드합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.build_into_world(world, tile_size=tile_size, origin=origin, replace=True)&#13;&#10;&#13;&#10;    def apply_tile_size_to_world(self, world: Dict[str, list], new_tile_size: int, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        기존에 world에 배치된 TileEntity들이 그리드 좌표를 가지고 있다면,&#13;&#10;        각 엔티티의 size와 x,y를 새 타일 크기에 맞게 in-place로 갱신합니다.&#13;&#10;        - world: 월드 딕셔너리&#13;&#10;        - new_tile_size: 적용할 새 타일 크기&#13;&#10;        - origin: 맵 원점&#13;&#10;&#13;&#10;        이 방법은 엔티티를 새로 생성하지 않으므로 외부 참조가 유지됩니다.&#13;&#10;        만약 엔티티에 그리드 좌표가 없다면 동작하지 않습니다(그럴 경우 재빌드 필요).&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        ts = int(new_tile_size)&#13;&#10;        x0, y0 = origin&#13;&#10;        layers = ['ground', 'upper_ground', 'walls']&#13;&#10;        updated = 0&#13;&#10;        for layer in layers:&#13;&#10;            for ent in list(world.get(layer, [])):&#13;&#10;                # ent가 grid 정보(_grid_col/_grid_row/_map_height)를 가지고 있으면 위치 재계산&#13;&#10;                if hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height'):&#13;&#10;                    col = int(ent._grid_col)&#13;&#10;                    row = int(ent._grid_row)&#13;&#10;                    map_h = int(ent._map_height)&#13;&#10;                    ent.size = ts&#13;&#10;                    ent.x = x0 + col * ts&#13;&#10;                    ent.y = y0 + (map_h - 1 - row) * ts&#13;&#10;                    # update stored origin too&#13;&#10;                    ent._origin = (x0, y0)&#13;&#10;                    updated += 1&#13;&#10;                else:&#13;&#10;                    # grid 정보가 없으면 이 엔티티는 무시 (재빌드를 권장)&#13;&#10;                    continue&#13;&#10;        try:&#13;&#10;            print(f&quot;apply_tile_size_to_world: applied new_tile_size={ts}, updated_entities={updated}&quot;)&#13;&#10;        except Exception:&#13;&#10;            pass&#13;&#10;&#13;&#10;    def set_tile_size(self, new_tile_size: int, world: Optional[Dict[str, list]] = None, origin: Tuple[int, int] = (0, 0)) -&gt; None:&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        Map의 기본 타일 크기를 변경합니다. 만약 `world`를 전달하면 해당 월드에 대해&#13;&#10;        가능한 경우 in-place로 크기/위치를 갱신하고, grid 정보가 부족하면 재빌드를 수행합니다.&#13;&#10;        &quot;&quot;&quot;&#13;&#10;        self.tile_size = int(new_tile_size)&#13;&#10;        if world is not None:&#13;&#10;            # 먼저 시도: in-place 적용 (grid 좌표가 있는 경우)&#13;&#10;            # 검사: 모든 엔티티들이 grid 좌표를 가지고 있는지 확인&#13;&#10;            ok = True&#13;&#10;            total = 0&#13;&#10;            for layer in ['ground', 'upper_ground', 'walls']:&#13;&#10;                for ent in world.get(layer, []):&#13;&#10;                    total += 1&#13;&#10;                    if not (hasattr(ent, '_grid_col') and hasattr(ent, '_grid_row') and hasattr(ent, '_map_height')):&#13;&#10;                        ok = False&#13;&#10;                        break&#13;&#10;                if not ok:&#13;&#10;                    break&#13;&#10;            if ok:&#13;&#10;                try:&#13;&#10;                    self.apply_tile_size_to_world(world, self.tile_size, origin)&#13;&#10;                    print(f&quot;set_tile_size: in-place applied to {total} entities, new_tile_size={self.tile_size}&quot;)&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91mset_tile_size: in-place apply failed: {e}\033[0m&quot;)&#13;&#10;            else:&#13;&#10;                # 일부 엔티티에 grid 정보가 없으면 안전하게 재빌드&#13;&#10;                try:&#13;&#10;                    self.rebuild_into_world(world, tile_size=self.tile_size, origin=origin)&#13;&#10;                    print(f&quot;set_tile_size: rebuilt world with new_tile_size={self.tile_size}&quot;)&#13;&#10;                except Exception as e:&#13;&#10;                    print(f&quot;\033[91mset_tile_size: rebuild failed: {e}\033[0m&quot;)&#13;&#10;&#13;&#10;&#13;&#10;# 간단한 자기검증 스크립트&#13;&#10;if __name__ == '__main__':&#13;&#10;    # 간단한 Room 텍스트 샘플을 메모리로 만들고 파싱 테스트&#13;&#10;    sample = '''&#13;&#10;[ground]&#13;&#10;1,1,1,0,0&#13;&#10;1,2,2,0,0&#13;&#10;&#13;&#10;[upper_ground]&#13;&#10;0,0,3,3,0&#13;&#10;&#13;&#10;[walls]&#13;&#10;0,4,0,0,0&#13;&#10;'''&#13;&#10;    import tempfile&#13;&#10;&#13;&#10;    p = tempfile.gettempdir() + os.sep + 'sample_room.txt'&#13;&#10;    with open(p, 'w', encoding='utf-8') as f:&#13;&#10;        f.write(sample)&#13;&#10;&#13;&#10;    m = Map(tile_size=128)&#13;&#10;    m.load_from_room_txt(p)&#13;&#10;    print('width,height:', m.width, m.height)&#13;&#10;    world = {k: [] for k in ['ground', 'upper_ground', 'walls', 'effects_back', 'effects_front', 'ui', 'cursor']}&#13;&#10;    m.build_into_world(world, origin=(0, 0))&#13;&#10;    for k in world:&#13;&#10;        print(k, len(world[k]))" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/game_logic/monsters/panther_assassin.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/game_logic/monsters/panther_assassin.py" />
              <option name="originalContent" value="import pico2d as p2&#10;import math&#10;import random&#10;import game_framework as framework&#10;from ..behavior_tree import BehaviorTree, Selector, Sequence, Action, Condition, RandomSelector&#10;from ..projectile import Projectile&#10;from .. import image_asset_manager as iam&#10;&#10;&#10;# ==================== BT Action Wrapper 클래스 ====================&#10;&#10;class BTActionWrapper(Action):&#10;    &quot;&quot;&quot;&#10;    BT Action Wrapper 클래스&#10;&#10;    행동 트리의 Action 노드가 패턴 클래스의 update() 메서드를 호출할 수 있도록&#10;    래핑하는 헬퍼 클래스입니다.&#10;&#10;    사용 목적:&#10;    - BT 프레임워크는 Action 노드를 인자 없이 호출하는 구조&#10;    - 패턴 클래스는 인스턴스 메서드로 상태를 관리&#10;    - 이 래퍼가 둘 사이의 다리 역할을 수행&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, name, action_instance):&#10;        &quot;&quot;&quot;&#10;        BTActionWrapper 초기화&#10;&#10;        Args:&#10;            name: 노드 이름 (디버깅용)&#10;            action_instance: 실제 패턴 Action 클래스의 인스턴스&#10;                            (예: AttackPattern1Action의 인스턴스)&#10;        &quot;&quot;&quot;&#10;        self.name = name&#10;        self.action_instance = action_instance&#10;        self.value = BehaviorTree.UNDEF&#10;        self.has_condition = False&#10;&#10;    def tag_condition(self):&#10;        &quot;&quot;&quot;Action 노드는 조건 노드가 아님&quot;&quot;&quot;&#10;        self.has_condition = False&#10;&#10;    def reset(self):&#10;        &quot;&quot;&quot;노드 상태 초기화&quot;&quot;&quot;&#10;        self.value = BehaviorTree.UNDEF&#10;&#10;    def add_child(self, child, probability=1.0):&#10;        &quot;&quot;&quot;Leaf 노드에는 자식을 추가할 수 없음&quot;&quot;&quot;&#10;        print(&quot;ERROR: you cannot add child node to leaf node&quot;)&#10;&#10;    def add_children(self, *children):&#10;        &quot;&quot;&quot;Leaf 노드에는 자식을 추가할 수 없음&quot;&quot;&quot;&#10;        print(&quot;ERROR: you cannot add children node to leaf node&quot;)&#10;&#10;    def run(self):&#10;        &quot;&quot;&quot;&#10;        Action 실행: 패턴 인스턴스의 update() 메서드 호출&#10;&#10;        Returns:&#10;            BehaviorTree.SUCCESS, BehaviorTree.RUNNING, 또는 BehaviorTree.FAIL&#10;        &quot;&quot;&quot;&#10;        # 현재 실행 중인 패턴 인스턴스를 PantherAssassin에 저장&#10;        # 이를 통해 PantherAssassin.draw()에서 패턴의 draw() 메서드를 호출할 수 있음&#10;        self.action_instance.panther.current_action_instance = self.action_instance&#10;&#10;        self.value = self.action_instance.update()&#10;        return self.value&#10;&#10;&#10;# ==================== 공격 패턴 클래스 ====================&#10;&#10;class AttackPattern1Action:&#10;    &quot;&quot;&quot;&#10;    패턴1 - 90도 방사형으로 플레이어를 향해 2단 표창 투척&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 돌진 관련 변수&#10;        self.dash_dx = 0.0&#10;        self.dash_dy = 0.0&#10;        self.dash_speed = 0.0&#10;        self.dash_duration = 0.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 1 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화: 돌진 방향 설정&#10;            if self.panther.target:&#10;                dx = self.panther.target.x - self.panther.x&#10;                dy = self.panther.target.y - self.panther.y&#10;                dist = math.sqrt(dx**2 + dy**2)&#10;&#10;                if dist &gt; 0:&#10;                    self.dash_dx = dx / dist&#10;                    self.dash_dy = dy / dist&#10;                else:&#10;                    self.dash_dx = 1&#10;                    self.dash_dy = 0&#10;&#10;                self.dash_speed = 800  # 돌진 속도&#10;                self.dash_duration = 0.5  # 돌진 지속 시간&#10;                self.timer = 0.0&#10;                self.phase = 1&#10;                print(&quot;[Pattern1] 돌진 시작!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 돌진 중&#10;            self.panther.x += self.dash_dx * self.dash_speed * dt&#10;            self.panther.y += self.dash_dy * self.dash_speed * dt&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.dash_duration:&#10;                # 돌진 완료&#10;                self.phase = 0&#10;                self.panther.attack_timer = self.panther.attack_cooldown&#10;                print(&quot;[Pattern1] 돌진 완료!&quot;)&#10;                return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 1 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # Pattern 1 Draw Logic: 돌진 공격 시각 효과&#10;        if self.phase == 1:  # 돌진 중일 때만 표시&#10;            # 돌진 방향을 나타내는 화살표/궤적 표시&#10;            trail_length = 100&#10;            end_x = draw_x - self.dash_dx * trail_length&#10;            end_y = draw_y - self.dash_dy * trail_length&#10;&#10;            # 돌진 궤적 라인 (빨간색)&#10;            p2.draw_line(draw_x, draw_y, end_x, end_y)&#10;&#10;            # 돌진 이펙트 원 (진행도에 따라 크기 변화)&#10;            progress = self.timer / self.dash_duration&#10;            effect_radius = 30 + progress * 20&#10;            p2.draw_circle(draw_x, draw_y, int(effect_radius))&#10;&#10;&#10;class AttackPattern2Action:&#10;    &quot;&quot;&quot;&#10;    패턴2 - 은신 후 다른 곳에서 나타나 플레이어를 향해 강한 돌진 공격 2회&#10;    &quot;&quot;&quot;&#10;&#10;    dash_img_seq = []&#10;    dash_img_seq_count = 8&#10;    swing_img_seq = []&#10;    swing_img_seq_count = 10&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 수리검 발사 관련 변수&#10;        self.shot_count = 0&#10;        self.max_shots = 0&#10;        self.shot_interval = 0.0&#10;&#10;        # 이미지 시퀀스 로드&#10;        if not AttackPattern2Action.dash_img_seq:&#10;            try:&#10;                for i in range(self.dash_img_seq_count):&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_BladeAttack{i:02d}.png')&#10;                    AttackPattern2Action.dash_img_seq.append(img)&#10;                for i in range(self.swing_img_seq_count):&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_BladeAttack{i+8:02d}.png')&#10;                    AttackPattern2Action.swing_img_seq.append(img)&#10;            except FileNotFoundError as e:&#10;                print(f'\033[91m[Pattern2] 이미지 로드 실패: {e}\033[0m')&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 2 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화: 발사 준비&#10;            self.shot_count = 0&#10;            self.max_shots = 5&#10;            self.shot_interval = 0.15  # 발사 간격&#10;            self.timer = 0.0&#10;            self.phase = 1&#10;            print(&quot;[Pattern2] 연속 수리검 시작!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 수리검 발사&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.shot_interval:&#10;                # 수리검 발사&#10;                if self.panther.target and self.panther.world:&#10;                    projectile = Projectile(&#10;                        self.panther.x, self.panther.y,&#10;                        self.panther.target.x, self.panther.target.y,&#10;                        speed=500,&#10;                        from_player=False&#10;                    )&#10;                    self.panther.world.get('projectiles', []).append(projectile)&#10;                    print(f&quot;[Pattern2] 수리검 발사 {self.shot_count + 1}/{self.max_shots}&quot;)&#10;&#10;                self.shot_count += 1&#10;                self.timer = 0.0&#10;&#10;                if self.shot_count &gt;= self.max_shots:&#10;                    # 모든 수리검 발사 완료&#10;                    self.phase = 0&#10;                    self.panther.attack_timer = self.panther.attack_cooldown&#10;                    print(&quot;[Pattern2] 연속 수리검 완료!&quot;)&#10;                    return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 2 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # Pattern 2 Draw Logic: 연속 수리검 발사 시각 효과&#10;        if self.phase == 1:  # 발사 중일 때&#10;            # 타겟 방향 조준선 표시&#10;            if self.panther.target:&#10;                p2.draw_line(draw_x, draw_y, self.panther.target.x, self.panther.target.y)&#10;&#10;            # 발사 카운트 표시 (원형 인디케이터)&#10;            progress = self.shot_count / self.max_shots&#10;            indicator_radius = 20 + progress * 30&#10;            p2.draw_circle(draw_x, draw_y + 60, int(indicator_radius))&#10;&#10;&#10;class AttackPattern3Action:&#10;    &quot;&quot;&quot;&#10;    BTActionWrapper: 패턴3 - 은신 후 다른 곳에서 나타나 플레이어를 향해 돌 진 후 8방향 방사형으로 수리검 투척&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 차징 관련 변수&#10;        self.charge_time = 0.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 3 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화&#10;            self.timer = 0.0&#10;            self.charge_time = 0.8  # 차징 시간&#10;            self.phase = 1&#10;            print(&quot;[Pattern3] 원형 투사체 차징 시작!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 차징 중&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.charge_time:&#10;                # 차징 완료 - 8방향 발사&#10;                if self.panther.world:&#10;                    directions = 8&#10;                    for i in range(directions):&#10;                        angle = (360 / directions) * i&#10;                        rad = math.radians(angle)&#10;&#10;                        target_x = self.panther.x + math.cos(rad) * 1000&#10;                        target_y = self.panther.y + math.sin(rad) * 1000&#10;&#10;                        projectile = Projectile(&#10;                            self.panther.x, self.panther.y,&#10;                            target_x, target_y,&#10;                            speed=400,&#10;                            from_player=False&#10;                        )&#10;                        self.panther.world.get('projectiles', []).append(projectile)&#10;&#10;                    print(&quot;[Pattern3] 원형 투사체 발사!&quot;)&#10;&#10;                self.phase = 0&#10;                self.panther.attack_timer = self.panther.attack_cooldown&#10;                return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 3 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # Pattern 3 Draw Logic: 원형 투사체 발사 시각 효과&#10;        if self.phase == 1:  # 차징 중일 때&#10;            # 차징 진행도에 따른 원형 링 표시&#10;            progress = self.timer / self.charge_time&#10;            charge_radius = 50 + progress * 100&#10;&#10;            # 8방향 예측선 표시 (차징 중)&#10;            directions = 8&#10;            for i in range(directions):&#10;                angle = (360 / directions) * i&#10;                rad = math.radians(angle)&#10;                end_x = draw_x + math.cos(rad) * charge_radius&#10;                end_y = draw_y + math.sin(rad) * charge_radius&#10;                p2.draw_line(draw_x, draw_y, end_x, end_y)&#10;&#10;            # 차징 중심 원&#10;            p2.draw_circle(draw_x, draw_y, int(charge_radius))&#10;&#10;&#10;class AttackPattern4Action:&#10;    &quot;&quot;&quot;&#10;    패턴4 - 은신과 분신 2체를 랜덤 위치에 소환 후 플레이어를 향해 수리검 10회 연속 투척 이후 본체 은신 풀림&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 텔레포트 관련 변수&#10;        self.teleport_delay = 0.0&#10;        self.attack_delay = 0.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 4 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화&#10;            self.timer = 0.0&#10;            self.teleport_delay = 0.3  # 텔레포트 딜레이&#10;            self.phase = 1&#10;            print(&quot;[Pattern4] 텔레포트 준비!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 텔레포트 딜레이&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.teleport_delay:&#10;                # 텔레포트 실행&#10;                if self.panther.target:&#10;                    # 타겟 근처 랜덤 위치로 이동&#10;                    angle = random.uniform(0, 360)&#10;                    rad = math.radians(angle)&#10;                    offset = 150&#10;&#10;                    self.panther.x = self.panther.target.x + math.cos(rad) * offset&#10;                    self.panther.y = self.panther.target.y + math.sin(rad) * offset&#10;                    print(f&quot;[Pattern4] 텔레포트 완료! ({self.panther.x:.0f}, {self.panther.y:.0f})&quot;)&#10;&#10;                self.timer = 0.0&#10;                self.attack_delay = 0.2&#10;                self.phase = 2&#10;&#10;        elif self.phase == 2:&#10;            # 공격 딜레이&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.attack_delay:&#10;                # 근접 공격 (충돌 체크는 update에서 처리)&#10;                print(&quot;[Pattern4] 근접 공격!&quot;)&#10;                self.phase = 0&#10;                self.panther.attack_timer = self.panther.attack_cooldown&#10;                return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 4 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # Pattern 4 Draw Logic: 텔레포트 후 공격 시각 효과&#10;        if self.phase == 1:  # 텔레포트 준비 중&#10;            # 텔레포트 징표 (깜빡이는 원)&#10;            blink = int(self.timer * 10) % 2&#10;            if blink == 0:&#10;                p2.draw_circle(draw_x, draw_y, 60)&#10;                p2.draw_circle(draw_x, draw_y, 40)&#10;&#10;        elif self.phase == 2:  # 공격 준비 중&#10;            # 공격 범위 표시 (확장되는 원)&#10;            attack_radius = 80 * (self.timer / self.attack_delay)&#10;            p2.draw_circle(draw_x, draw_y, int(attack_radius))&#10;&#10;&#10;class AttackPattern5Action:&#10;    &quot;&quot;&quot;&#10;    패턴5 - 분신 1체 랜덤 위치에 소환후 모든 방향 방사형으로 수리검 투척 2회 ( 두 번째 투척 수리검의 속도는 첫 번째 투척 속도의 반 )&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 충격파 관련 변수&#10;        self.charge_time = 0.0&#10;        self.shockwave_radius = 0.0&#10;        self.max_radius = 0.0&#10;        self.expand_speed = 0.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 5 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화&#10;            self.timer = 0.0&#10;            self.charge_time = 1.0  # 차징 시간&#10;            self.phase = 1&#10;            print(&quot;[Pattern5] 충격파 차징 시작!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 차징 중&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.charge_time:&#10;                # 충격파 발동&#10;                self.shockwave_radius = 0&#10;                self.max_radius = 500&#10;                self.expand_speed = 800&#10;                self.timer = 0.0&#10;                self.phase = 2&#10;                print(&quot;[Pattern5] 충격파 발동!&quot;)&#10;&#10;        elif self.phase == 2:&#10;            # 충격파 확산&#10;            self.shockwave_radius += self.expand_speed * dt&#10;&#10;            # 타겟과의 거리 체크 (충돌 판정)&#10;            if self.panther.target:&#10;                dx = self.panther.target.x - self.panther.x&#10;                dy = self.panther.target.y - self.panther.y&#10;                dist = math.sqrt(dx**2 + dy**2)&#10;&#10;                # 충격파가 타겟을 스쳐 지나가는지 확인&#10;                if abs(dist - self.shockwave_radius) &lt; 50:&#10;                    print(f&quot;[Pattern5] 충격파 적중! (거리: {dist:.0f})&quot;)&#10;&#10;            if self.shockwave_radius &gt;= self.max_radius:&#10;                # 충격파 완료&#10;                self.phase = 0&#10;                self.panther.attack_timer = self.panther.attack_cooldown&#10;                print(&quot;[Pattern5] 충격파 완료!&quot;)&#10;                return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 5 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # Pattern 5 Draw Logic: 광역 충격파 시각 효과&#10;        if self.phase == 1:  # 차징 중&#10;            # 차징 이펙트 (맥동하는 원)&#10;            pulse = (self.timer / self.charge_time) * 50&#10;            p2.draw_circle(draw_x, draw_y, int(50 + pulse))&#10;            p2.draw_circle(draw_x, draw_y, int(30 + pulse))&#10;&#10;        elif self.phase == 2:  # 충격파 확산 중&#10;            # 확산되는 충격파 원 그리기&#10;            p2.draw_circle(draw_x, draw_y, int(self.shockwave_radius))&#10;&#10;            # 내부 충격파 (투명도 효과를 위한 다중 원)&#10;            if self.shockwave_radius &gt; 20:&#10;                p2.draw_circle(draw_x, draw_y, int(self.shockwave_radius - 20))&#10;&#10;&#10;class AttackPattern6Action:&#10;    &quot;&quot;&quot;&#10;    패턴6 - 분신 2체 램덤 위치에 소환후 본체, 분신 2체 번갈아 가며 플레이어를 향해 수리검 5개 방사형으로 3회씩 투척&#10;    &quot;&quot;&quot;&#10;    img_seq = []&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 분신 소환 관련 변수&#10;        self.summon_time = 0.0&#10;        self.duration = 0.0&#10;        # 분신 이미지 시퀀스 로드&#10;        self.img_count = 8&#10;        # if not AttackPattern6Action.img_seq:&#10;        #     try:&#10;        #         for i in range(self.img_count):&#10;        #             img = p2.load_image(f'')&#10;        #             AttackPattern6Action.img_seq.append(img)&#10;        #     except FileNotFoundError as e:&#10;        #         print(f'\033[91m[Pattern6] 이미지 로드 실패: {e}\033[0m')&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 6 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화&#10;            self.timer = 0.0&#10;            self.summon_time = 0.5  # 소환 시간&#10;            self.phase = 1&#10;            print(&quot;[Pattern6] 분신 소환 시작!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 소환 중&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.summon_time:&#10;                # 분신 소환 완료&#10;                if self.panther.world and self.panther.target:&#10;                    # 분신 위치 계산&#10;                    offset = 200&#10;                    clone_positions = [&#10;                        (self.panther.x - offset, self.panther.y),&#10;                        (self.panther.x + offset, self.panther.y)&#10;                    ]&#10;&#10;                    # 분신에서 타겟으로 투사체 발사&#10;                    for clone_x, clone_y in clone_positions:&#10;                        projectile = Projectile(&#10;                            clone_x, clone_y,&#10;                            self.panther.target.x, self.panther.target.y,&#10;                            speed=450,&#10;                            from_player=False&#10;                        )&#10;                        self.panther.world.get('projectiles', []).append(projectile)&#10;&#10;                    print(&quot;[Pattern6] 분신 공격 발사!&quot;)&#10;&#10;                self.timer = 0.0&#10;                self.duration = 1.0  # 분신 유지 시간&#10;                self.phase = 2&#10;&#10;        elif self.phase == 2:&#10;            # 분신 유지&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.duration:&#10;                # 분신 소멸&#10;                self.phase = 0&#10;                self.panther.attack_timer = self.panther.attack_cooldown&#10;                print(&quot;[Pattern6] 분신 소멸!&quot;)&#10;                return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 6 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # 공격 패턴 전용 이미지가 있다면 사용, 없다면 기본 드로잉 사용&#10;&#10;&#10;        # Pattern 6 Draw Logic: 그림자 분신 소환 시각 효과&#10;        if self.phase == 1:  # 소환 중&#10;            # 소환 진행도 표시&#10;            progress = self.timer / self.summon_time&#10;            summon_radius = 40 + progress * 60&#10;&#10;            # 분신 소환 위치에 원 표시&#10;            offset = 200&#10;            clone_positions = [&#10;                (draw_x - offset, draw_y),&#10;                (draw_x + offset, draw_y)&#10;            ]&#10;&#10;            for clone_x, clone_y in clone_positions:&#10;                p2.draw_circle(clone_x, clone_y, summon_radius)&#10;                p2.draw_line(draw_x, draw_y, clone_x, clone_y)&#10;&#10;        elif self.phase == 2:  # 분신 유지 중&#10;            # 분신 위치 표시 (반투명 효과를 위한 다중 원)&#10;            offset = 200&#10;            clone_positions = [&#10;                (draw_x - offset, draw_y),&#10;                (draw_x + offset, draw_y)&#10;            ]&#10;&#10;            for clone_x, clone_y in clone_positions:&#10;                p2.draw_circle(clone_x, clone_y, 70)&#10;                p2.draw_circle(clone_x, clone_y, 50)&#10;&#10;&#10;# ==================== PantherAssassin 보스 클래스 ====================&#10;&#10;class PantherAssassin:&#10;    &quot;&quot;&quot;&#10;    팬서 암살자 보스 몬스터&#10;&#10;    특징:&#10;    - 6가지 공격 패턴을 랜덤하게 사용&#10;    - 행동 트리 기반 AI&#10;    - 높은 체력과 공격력&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, x, y):&#10;        &quot;&quot;&quot;&#10;        PantherAssassin 초기화&#10;&#10;        Args:&#10;            x, y: 스폰 위치&#10;        &quot;&quot;&quot;&#10;        # 위치 및 기본 속성&#10;        self.x = x&#10;        self.y = y&#10;        self.spawn_x = x  # 스폰 위치 기억&#10;        self.spawn_y = y&#10;&#10;        # 스탯&#10;        from ..stats import PantherAssassinStats&#10;        self.stat = PantherAssassinStats()&#10;&#10;        # 애니메이션&#10;        self.frame = 0&#10;        self.frame_timer = 0.0&#10;        self.frame_speed = 15.0  # 초당 프레임 수&#10;        self.scale_factor = 4.0&#10;        self.animation_frames = 11 # 애니메이션 프레임 수&#10;&#10;        # 충돌 박스&#10;        self.collision_width = 24 * self.scale_factor&#10;        self.collision_height = 26 * self.scale_factor&#10;        self.collision_box_offset_x = 0&#10;        self.collision_box_offset_y = -10 * self.scale_factor&#10;&#10;        # 타겟 (플레이어)&#10;        self.target = None&#10;&#10;        # 월드 참조 (투사체 생성을 위해)&#10;        from ..play_mode import world&#10;        self.world = world&#10;&#10;        # 공격 관련&#10;        self.recognition_distance = 400 # 플레이어 인식 거리&#10;        self.unrecognition_distance = 800 # 플레이어 미인식 거리&#10;        self.attack_range = 800  # 공격 범위 (추가)&#10;        self.attack_cooldown = 2.0  # 공격 쿨타임 (초)&#10;        self.attack_timer = 0.0  # 현재 쿨타임 타이머&#10;&#10;        # 현재 실행 중인 공격 패턴 인스턴스 (드로잉 책임 위임용)&#10;        self.current_action_instance = None&#10;&#10;        # 6가지 공격 패턴 클래스 인스턴스 생성&#10;        self.pattern1_action = AttackPattern1Action(self)&#10;        self.pattern2_action = AttackPattern2Action(self)&#10;        self.pattern3_action = AttackPattern3Action(self)&#10;        self.pattern4_action = AttackPattern4Action(self)&#10;        self.pattern5_action = AttackPattern5Action(self)&#10;        self.pattern6_action = AttackPattern6Action(self)&#10;&#10;        # 임시 스프라이트 (실제 게임에서는 이미지 로드)&#10;        # 일반적으로 Idle 애니메이션 스프라이트 시트 사용&#10;        # 사망시 Death 애니메이션 스프라이트 시트 사용&#10;        self.images = None&#10;        self.clone_images = None&#10;&#10;        try:&#10;            for i in range(self.animation_frames):&#10;                try:&#10;                    img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_Idle{i:02d}.png'&#10;                    img = p2.load_image(img_path)&#10;                    if self.images is None:&#10;                        self.images = []&#10;                    self.images.append(img)&#10;&#10;                    # 경로 등록 후 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)  # 경로 등록 (반환값 없음)&#10;                    clone_img = iam.make_dark(img)  # 어두운 이미지 생성&#10;                    if self.clone_images is None:&#10;                        self.clone_images = []&#10;                    self.clone_images.append(clone_img)&#10;&#10;                    # DEBUG: 이미지 로드 확인&#10;                    print(f'[PantherAssassin] 이미지 로드 성공: PantherAssassin_Idle{i:02d}.png')&#10;&#10;                except FileNotFoundError as e:&#10;                    print(f'\033[91m[PantherAssassin] 이미지 로드 실패: {e}\033[0m')&#10;        except Exception as e:&#10;            print(f'\033[91m[PantherAssassin] 이미지 로드 중 오류 발생: {e}\033[0m')&#10;&#10;        # 행동 트리 빌드&#10;        self.build_behavior_tree()&#10;&#10;        print(f&quot;[PantherAssassin] 생성됨 at ({x}, {y})&quot;)&#10;&#10;    def build_behavior_tree(self):&#10;        &quot;&quot;&quot;&#10;        행동 트리 구축&#10;&#10;        구조:&#10;        Root Selector&#10;        ├── Attack Sequence (공격 시도)&#10;        │   ├── Condition: 쿨타임 준비됨&#10;        │   ├── Condition: 공격 범위 내&#10;        │   └── RandomSelector: 6가지 패턴 중 랜덤 선택&#10;        │       ├── BTActionWrapper: 패턴1 - 90도 방사형으로 플레이어를 향해 2단 표창 투척&#10;        │       ├── BTActionWrapper: 패턴2 - 은신 후 다른 곳에서 나타나 플레이어를 향해 강한 돌진 공격 2회&#10;        │       ├── BTActionWrapper: 패턴3 - 은신 후 다른 곳에서 나타나 플레이어를 향해 돌 진 후 8방향 방사형으로 수리검 투척&#10;        │       │   # 그림자 분신과 함꼐하는 패턴 4, 5, 6&#10;        │       ├── BTActionWrapper: 패턴4 - 은신과 분신 2체를 랜덤 위치에 소환 후 플레이어를 향해 수리검 10회 연속 투척 이후 본체 은신 풀림&#10;        │       ├── BTActionWrapper: 패턴5 - 분신 1체 랜덤 위치에 소환후 모든 방향 방사형으로 수리검 투척 2회 ( 두 번째 투척 수리검의 속도는 첫 번째 투척 속도의 반 )&#10;        │       └── BTActionWrapper: 패턴6 - 분신 2체 램덤 위치에 소환후 본체, 분신 2체 번갈아 가며 플레이어를 향해 수리검 5개 방사형으로 3회씩 투척&#10;        └── Action: 대기 ( Idle )&#10;&#10;        ★ 핵심: BTActionWrapper를 사용하여 패턴 클래스 인스턴스를 BT에 연결&#10;        &quot;&quot;&quot;&#10;&#10;        # 6가지 공격 패턴을 RandomSelector로 구성&#10;        # BTActionWrapper를 사용하여 패턴 클래스 인스턴스를 감쌈&#10;        attack_pattern_selector = RandomSelector(&#10;            &quot;Random Attack Pattern&quot;,&#10;            BTActionWrapper(&quot;Pattern1: Dash&quot;, self.pattern1_action),&#10;            BTActionWrapper(&quot;Pattern2: Shuriken&quot;, self.pattern2_action),&#10;            BTActionWrapper(&quot;Pattern3: Circular&quot;, self.pattern3_action),&#10;            BTActionWrapper(&quot;Pattern4: Teleport&quot;, self.pattern4_action),&#10;            BTActionWrapper(&quot;Pattern5: Shockwave&quot;, self.pattern5_action),&#10;            BTActionWrapper(&quot;Pattern6: Shadow Clone&quot;, self.pattern6_action)&#10;        )&#10;&#10;        # 공격 시퀀스: 쿨타임 체크 -&gt; 범위 체크 -&gt; 패턴 실행&#10;        attack_sequence = Sequence(&#10;            &quot;Try Attack&quot;,&#10;            Condition(&quot;Attack Ready&quot;, self.is_attack_ready),&#10;            Condition(&quot;In Attack Range&quot;, self.is_in_attack_range),&#10;            attack_pattern_selector&#10;        )&#10;&#10;        # 루트 셀렉터: 공격 가능하면 공격, 아니면 대기/순찰&#10;        root = Selector(&#10;            &quot;Root&quot;,&#10;            attack_sequence,&#10;            Action(&quot;Idle or Patrol&quot;, self.handle_idle_action)&#10;        )&#10;&#10;        # 행동 트리 생성&#10;        self.behavior_tree = BehaviorTree(root)&#10;        print(&quot;[PantherAssassin] 행동 트리 빌드 완료 (BTActionWrapper 적용 완료)&quot;)&#10;&#10;    # ==================== 조건 체크 메서드 ====================&#10;&#10;    def is_attack_ready(self):&#10;        &quot;&quot;&quot;공격 쿨타임이 준비되었는지 확인&quot;&quot;&quot;&#10;        return self.attack_timer &lt;= 0.0&#10;&#10;    def is_in_attack_range(self):&#10;        &quot;&quot;&quot;타겟이 공격 범위 내에 있는지 확인&quot;&quot;&quot;&#10;        if self.target is None:&#10;            return False&#10;&#10;        dx = self.target.x - self.x&#10;        dy = self.target.y - self.y&#10;        distance = math.sqrt(dx**2 + dy**2)&#10;&#10;        return distance &lt;= self.attack_range&#10;&#10;    # ==================== 행동 액션 메서드 ====================&#10;&#10;    def handle_idle_action(self):&#10;        &quot;&quot;&quot;&#10;        대기 또는 순찰 행동&#10;        타겟을 향해 천천히 이동&#10;        &quot;&quot;&quot;&#10;        if self.target is None:&#10;            return BehaviorTree.SUCCESS&#10;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 타겟을 향해 이동&#10;        dx = self.target.x - self.x&#10;        dy = self.target.y - self.y&#10;        distance = math.sqrt(dx**2 + dy**2)&#10;&#10;        if distance &gt; 50:  # 최소 거리 유지&#10;            move_x = (dx / distance) * self.stat.get('move_speed') * dt&#10;            move_y = (dy / distance) * self.stat.get('move_speed') * dt&#10;            self.x += move_x&#10;            self.y += move_y&#10;&#10;        return BehaviorTree.SUCCESS&#10;&#10;    # ==================== 업데이트 &amp; 렌더링 ====================&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;매 프레임 업데이트&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 쿨타임 업데이트&#10;        if self.attack_timer &gt; 0:&#10;            self.attack_timer -= dt&#10;&#10;        # 애니메이션 프레임 업데이트&#10;        self.frame_timer += dt&#10;        if self.frame_timer &gt;= 1.0 / self.frame_speed:&#10;            # 이미지가 로드되었을 때만 프레임 업데이트&#10;            if self.images and len(self.images) &gt; 0:&#10;                self.frame = (self.frame + 1) % len(self.images)&#10;            else:&#10;                self.frame = 0&#10;            self.frame_timer = 0.0&#10;&#10;        # 플레이어 인식 거리 체크 (target이 None일 때 예외 처리)&#10;        if self.target is not None:&#10;            dx = self.target.x - self.x&#10;            dy = self.target.y - self.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            # 인식 거리를 벗어나면 타겟 해제&#10;            if distance &gt;= self.unrecognition_distance:&#10;                self.set_target(None)&#10;                print(f'[PantherAssassin] 타겟 상실 (거리: {distance:.1f})')&#10;        else:&#10;            # 타겟이 없을 때 플레이어 탐색&#10;            if self.world and 'player' in self.world:&#10;                player = self.world['player']&#10;                dx = player.x - self.x&#10;                dy = player.y - self.y&#10;                distance = math.sqrt(dx**2 + dy**2)&#10;&#10;                # 인식 거리 내에 들어오면 타겟 설정&#10;                if distance &lt;= self.recognition_distance:&#10;                    self.set_target(player)&#10;                    print(f'[PantherAssassin] 타겟 인식: 플레이어 at ({player.x}, {player.y}), 거리: {distance:.1f}')&#10;&#10;        # 행동 트리 실행&#10;        if self.behavior_tree:&#10;            self.behavior_tree.run()&#10;&#10;&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;몬스터 렌더링&quot;&quot;&quot;&#10;        &quot;&quot;&quot;&#10;        일반적 Hit 일땐 대미지만 적용, (hit 판정의 이미지 시퀀스 x )&#10;        Death 상태 일땐 현재 이미지 시퀀스를 Death 이미지로 교체 후 재생&#10;        1. Hit 판정시 이미지 시퀀스 교체 없이 대미지만 적용&#10;        2. Death 판정시 이미지 시퀀스를 Death 이미지로 교체&#10;        3. Death 이미지 시퀀스 재생 후 3초 후 몬스터 제거&#10;        &#10;        TODO: 1. 몬스터 사망 후 아이템 드랍 구현&#10;        &quot;&quot;&quot;&#10;        # 몬스터 본체 드로잉&#10;        if self.images and len(self.images) &gt; 0:&#10;            # 프레임 인덱스가 범위를 벗어나지 않도록 보정&#10;            if self.frame &gt;= len(self.images):&#10;                self.frame = 0&#10;&#10;            img = self.images[self.frame]&#10;            img.draw(draw_x, draw_y, img.w * self.scale_factor, img.h * self.scale_factor)&#10;&#10;        else:&#10;            # 디버그 렌더링 (이미지 없을 때)&#10;            p2.draw_rectangle(&#10;                self.x - self.collision_width / 2,&#10;                self.y - self.collision_height / 2,&#10;                self.x + self.collision_width / 2,&#10;                self.y + self.collision_height / 2&#10;            )&#10;&#10;        # 현재 실행 중인 패턴 인스턴스의 이펙트 드로잉 (드로잉 책임 위임)&#10;        if self.current_action_instance is not None:&#10;            # 패턴 인스턴스가 draw 메서드를 가지고 있는지 확인 후 호출&#10;            if hasattr(self.current_action_instance, 'draw'):&#10;                self.current_action_instance.draw(draw_x, draw_y)&#10;&#10;        # DEBUG : 충돌 박스 및 플레이어 인식 범위 그리기&#10;        # 충돌 박스 : 카메라 좌표계로 변환 후 그리기&#10;        Left, Bottom, Right, Top = self.get_bb()&#10;        Left -= self.x - draw_x&#10;        Right -= self.x - draw_x&#10;        Bottom -= self.y - draw_y&#10;        Top -= self.y - draw_y&#10;        p2.draw_rectangle(Left, Bottom, Right, Top, r=255, g=0, b=0)&#10;&#10;        # 공격 범위&#10;        radius = self.recognition_distance&#10;        p2.draw_circle(draw_x, draw_y, int(radius), r=255, g=255, b=0)&#10;&#10;        # 타겟 놓치는 거리&#10;        radius = self.unrecognition_distance&#10;        p2.draw_circle(draw_x, draw_y, int(radius), r=0, g=255, b=255)&#10;&#10;        # 분신 드로잉 (디버그용)&#10;        # if self.clone_images:&#10;        #     offset = 200&#10;        #     self.clone_images[self.frame].draw(draw_x - offset, draw_y,&#10;        #                                        self.clone_images[self.frame].w * self.scale_factor,&#10;        #                                        self.clone_images[self.frame].h * self.scale_factor)&#10;        #&#10;&#10;    def get_bb(self):&#10;        &quot;&quot;&quot;충돌 박스 반환 (left, bottom, right, top)&quot;&quot;&quot;&#10;        half_w = self.collision_width / 2&#10;        half_h = self.collision_height / 2&#10;        return (&#10;            self.x - half_w + self.collision_box_offset_x,&#10;            self.y - half_h + self.collision_box_offset_y,&#10;            self.x + half_w + self.collision_box_offset_x,&#10;            self.y + half_h + self.collision_box_offset_y&#10;        )&#10;&#10;    def take_damage(self, damage):&#10;        &quot;&quot;&quot;피해를 받음&quot;&quot;&quot;&#10;        current_health = self.stat.get('health')&#10;        self.stat.set_base('health', max(0, current_health - damage))&#10;        print(f&quot;[PantherAssassin] 피해 {damage}, 남은 HP: {self.stat.get('health')}/{self.stat.get('max_health')}&quot;)&#10;&#10;        if self.stat.get('health') &lt;= 0:&#10;            print(&quot;[PantherAssassin] 처치됨!&quot;)&#10;            return True  # 사망&#10;        return False&#10;&#10;    def set_target(self, target):&#10;        &quot;&quot;&quot;타겟 설정 (주로 플레이어)&quot;&quot;&quot;&#10;        self.target = target&#10;" />
              <option name="updatedContent" value="import pico2d as p2&#10;import math&#10;import random&#10;import game_framework as framework&#10;from ..behavior_tree import BehaviorTree, Selector, Sequence, Action, Condition, RandomSelector&#10;from ..projectile import Projectile&#10;from .. import image_asset_manager as iam&#10;&#10;&#10;# ==================== BT Action Wrapper 클래스 ====================&#10;&#10;class BTActionWrapper(Action):&#10;    &quot;&quot;&quot;&#10;    BT Action Wrapper 클래스&#10;&#10;    행동 트리의 Action 노드가 패턴 클래스의 update() 메서드를 호출할 수 있도록&#10;    래핑하는 헬퍼 클래스입니다.&#10;&#10;    사용 목적:&#10;    - BT 프레임워크는 Action 노드를 인자 없이 호출하는 구조&#10;    - 패턴 클래스는 인스턴스 메서드로 상태를 관리&#10;    - 이 래퍼가 둘 사이의 다리 역할을 수행&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, name, action_instance):&#10;        &quot;&quot;&quot;&#10;        BTActionWrapper 초기화&#10;&#10;        Args:&#10;            name: 노드 이름 (디버깅용)&#10;            action_instance: 실제 패턴 Action 클래스의 인스턴스&#10;                            (예: AttackPattern1Action의 인스턴스)&#10;        &quot;&quot;&quot;&#10;        self.name = name&#10;        self.action_instance = action_instance&#10;        self.value = BehaviorTree.UNDEF&#10;        self.has_condition = False&#10;&#10;    def tag_condition(self):&#10;        &quot;&quot;&quot;Action 노드는 조건 노드가 아님&quot;&quot;&quot;&#10;        self.has_condition = False&#10;&#10;    def reset(self):&#10;        &quot;&quot;&quot;노드 상태 초기화&quot;&quot;&quot;&#10;        self.value = BehaviorTree.UNDEF&#10;&#10;    def add_child(self, child, probability=1.0):&#10;        &quot;&quot;&quot;Leaf 노드에는 자식을 추가할 수 없음&quot;&quot;&quot;&#10;        print(&quot;ERROR: you cannot add child node to leaf node&quot;)&#10;&#10;    def add_children(self, *children):&#10;        &quot;&quot;&quot;Leaf 노드에는 자식을 추가할 수 없음&quot;&quot;&quot;&#10;        print(&quot;ERROR: you cannot add children node to leaf node&quot;)&#10;&#10;    def run(self):&#10;        &quot;&quot;&quot;&#10;        Action 실행: 패턴 인스턴스의 update() 메서드 호출&#10;&#10;        Returns:&#10;            BehaviorTree.SUCCESS, BehaviorTree.RUNNING, 또는 BehaviorTree.FAIL&#10;        &quot;&quot;&quot;&#10;        # 현재 실행 중인 패턴 인스턴스를 PantherAssassin에 저장&#10;        # 이를 통해 PantherAssassin.draw()에서 패턴의 draw() 메서드를 호출할 수 있음&#10;        self.action_instance.panther.current_action_instance = self.action_instance&#10;&#10;        self.value = self.action_instance.update()&#10;        return self.value&#10;&#10;&#10;# ==================== 공격 패턴 클래스 ====================&#10;&#10;class AttackPattern1Action:&#10;    &quot;&quot;&quot;&#10;    패턴1 - 90도 방사형으로 플레이어를 향해 2단 표창 투척&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 돌진 관련 변수&#10;        self.dash_dx = 0.0&#10;        self.dash_dy = 0.0&#10;        self.dash_speed = 0.0&#10;        self.dash_duration = 0.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 1 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화: 돌진 방향 설정&#10;            if self.panther.target:&#10;                dx = self.panther.target.x - self.panther.x&#10;                dy = self.panther.target.y - self.panther.y&#10;                dist = math.sqrt(dx**2 + dy**2)&#10;&#10;                if dist &gt; 0:&#10;                    self.dash_dx = dx / dist&#10;                    self.dash_dy = dy / dist&#10;                else:&#10;                    self.dash_dx = 1&#10;                    self.dash_dy = 0&#10;&#10;                self.dash_speed = 800  # 돌진 속도&#10;                self.dash_duration = 0.5  # 돌진 지속 시간&#10;                self.timer = 0.0&#10;                self.phase = 1&#10;                print(&quot;[Pattern1] 돌진 시작!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 돌진 중&#10;            self.panther.x += self.dash_dx * self.dash_speed * dt&#10;            self.panther.y += self.dash_dy * self.dash_speed * dt&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.dash_duration:&#10;                # 돌진 완료&#10;                self.phase = 0&#10;                self.panther.attack_timer = self.panther.attack_cooldown&#10;                print(&quot;[Pattern1] 돌진 완료!&quot;)&#10;                return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 1 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # Pattern 1 Draw Logic: 돌진 공격 시각 효과&#10;        if self.phase == 1:  # 돌진 중일 때만 표시&#10;            # 돌진 방향을 나타내는 화살표/궤적 표시&#10;            trail_length = 100&#10;            end_x = draw_x - self.dash_dx * trail_length&#10;            end_y = draw_y - self.dash_dy * trail_length&#10;&#10;            # 돌진 궤적 라인 (빨간색)&#10;            p2.draw_line(draw_x, draw_y, end_x, end_y)&#10;&#10;            # 돌진 이펙트 원 (진행도에 따라 크기 변화)&#10;            progress = self.timer / self.dash_duration&#10;            effect_radius = 30 + progress * 20&#10;            p2.draw_circle(draw_x, draw_y, int(effect_radius))&#10;&#10;&#10;class AttackPattern2Action:&#10;    &quot;&quot;&quot;&#10;    패턴2 - 은신 후 다른 곳에서 나타나 플레이어를 향해 강한 돌진 공격 2회&#10;    &quot;&quot;&quot;&#10;&#10;    dash_img_seq = []&#10;    dash_img_seq_count = 8&#10;    swing_img_seq = []&#10;    swing_img_seq_count = 10&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 수리검 발사 관련 변수&#10;        self.shot_count = 0&#10;        self.max_shots = 0&#10;        self.shot_interval = 0.0&#10;&#10;        # 이미지 시퀀스 로드&#10;        if not AttackPattern2Action.dash_img_seq:&#10;            try:&#10;                for i in range(self.dash_img_seq_count):&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_BladeAttack{i:02d}.png')&#10;                    AttackPattern2Action.dash_img_seq.append(img)&#10;                for i in range(self.swing_img_seq_count):&#10;                    img = p2.load_image(f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_BladeAttack{i+8:02d}.png')&#10;                    AttackPattern2Action.swing_img_seq.append(img)&#10;            except FileNotFoundError as e:&#10;                print(f'\033[91m[Pattern2] 이미지 로드 실패: {e}\033[0m')&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 2 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화: 발사 준비&#10;            self.shot_count = 0&#10;            self.max_shots = 5&#10;            self.shot_interval = 0.15  # 발사 간격&#10;            self.timer = 0.0&#10;            self.phase = 1&#10;            print(&quot;[Pattern2] 연속 수리검 시작!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 수리검 발사&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.shot_interval:&#10;                # 수리검 발사&#10;                if self.panther.target and self.panther.world:&#10;                    projectile = Projectile(&#10;                        self.panther.x, self.panther.y,&#10;                        self.panther.target.x, self.panther.target.y,&#10;                        speed=500,&#10;                        from_player=False&#10;                    )&#10;                    self.panther.world.get('projectiles', []).append(projectile)&#10;                    print(f&quot;[Pattern2] 수리검 발사 {self.shot_count + 1}/{self.max_shots}&quot;)&#10;&#10;                self.shot_count += 1&#10;                self.timer = 0.0&#10;&#10;                if self.shot_count &gt;= self.max_shots:&#10;                    # 모든 수리검 발사 완료&#10;                    self.phase = 0&#10;                    self.panther.attack_timer = self.panther.attack_cooldown&#10;                    print(&quot;[Pattern2] 연속 수리검 완료!&quot;)&#10;                    return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 2 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # Pattern 2 Draw Logic: 연속 수리검 발사 시각 효과&#10;        if self.phase == 1:  # 발사 중일 때&#10;            # 타겟 방향 조준선 표시&#10;            if self.panther.target:&#10;                p2.draw_line(draw_x, draw_y, self.panther.target.x, self.panther.target.y)&#10;&#10;            # 발사 카운트 표시 (원형 인디케이터)&#10;            progress = self.shot_count / self.max_shots&#10;            indicator_radius = 20 + progress * 30&#10;            p2.draw_circle(draw_x, draw_y + 60, int(indicator_radius))&#10;&#10;&#10;class AttackPattern3Action:&#10;    &quot;&quot;&quot;&#10;    BTActionWrapper: 패턴3 - 은신 후 다른 곳에서 나타나 플레이어를 향해 돌 진 후 8방향 방사형으로 수리검 투척&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 차징 관련 변수&#10;        self.charge_time = 0.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 3 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화&#10;            self.timer = 0.0&#10;            self.charge_time = 0.8  # 차징 시간&#10;            self.phase = 1&#10;            print(&quot;[Pattern3] 원형 투사체 차징 시작!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 차징 중&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.charge_time:&#10;                # 차징 완료 - 8방향 발사&#10;                if self.panther.world:&#10;                    directions = 8&#10;                    for i in range(directions):&#10;                        angle = (360 / directions) * i&#10;                        rad = math.radians(angle)&#10;&#10;                        target_x = self.panther.x + math.cos(rad) * 1000&#10;                        target_y = self.panther.y + math.sin(rad) * 1000&#10;&#10;                        projectile = Projectile(&#10;                            self.panther.x, self.panther.y,&#10;                            target_x, target_y,&#10;                            speed=400,&#10;                            from_player=False&#10;                        )&#10;                        self.panther.world.get('projectiles', []).append(projectile)&#10;&#10;                    print(&quot;[Pattern3] 원형 투사체 발사!&quot;)&#10;&#10;                self.phase = 0&#10;                self.panther.attack_timer = self.panther.attack_cooldown&#10;                return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 3 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # Pattern 3 Draw Logic: 원형 투사체 발사 시각 효과&#10;        if self.phase == 1:  # 차징 중일 때&#10;            # 차징 진행도에 따른 원형 링 표시&#10;            progress = self.timer / self.charge_time&#10;            charge_radius = 50 + progress * 100&#10;&#10;            # 8방향 예측선 표시 (차징 중)&#10;            directions = 8&#10;            for i in range(directions):&#10;                angle = (360 / directions) * i&#10;                rad = math.radians(angle)&#10;                end_x = draw_x + math.cos(rad) * charge_radius&#10;                end_y = draw_y + math.sin(rad) * charge_radius&#10;                p2.draw_line(draw_x, draw_y, end_x, end_y)&#10;&#10;            # 차징 중심 원&#10;            p2.draw_circle(draw_x, draw_y, int(charge_radius))&#10;&#10;&#10;class AttackPattern4Action:&#10;    &quot;&quot;&quot;&#10;    패턴4 - 은신과 분신 2체를 랜덤 위치에 소환 후 플레이어를 향해 수리검 10회 연속 투척 이후 본체 은신 풀림&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 텔레포트 관련 변수&#10;        self.teleport_delay = 0.0&#10;        self.attack_delay = 0.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 4 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화&#10;            self.timer = 0.0&#10;            self.teleport_delay = 0.3  # 텔레포트 딜레이&#10;            self.phase = 1&#10;            print(&quot;[Pattern4] 텔레포트 준비!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 텔레포트 딜레이&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.teleport_delay:&#10;                # 텔레포트 실행&#10;                if self.panther.target:&#10;                    # 타겟 근처 랜덤 위치로 이동&#10;                    angle = random.uniform(0, 360)&#10;                    rad = math.radians(angle)&#10;                    offset = 150&#10;&#10;                    self.panther.x = self.panther.target.x + math.cos(rad) * offset&#10;                    self.panther.y = self.panther.target.y + math.sin(rad) * offset&#10;                    print(f&quot;[Pattern4] 텔레포트 완료! ({self.panther.x:.0f}, {self.panther.y:.0f})&quot;)&#10;&#10;                self.timer = 0.0&#10;                self.attack_delay = 0.2&#10;                self.phase = 2&#10;&#10;        elif self.phase == 2:&#10;            # 공격 딜레이&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.attack_delay:&#10;                # 근접 공격 (충돌 체크는 update에서 처리)&#10;                print(&quot;[Pattern4] 근접 공격!&quot;)&#10;                self.phase = 0&#10;                self.panther.attack_timer = self.panther.attack_cooldown&#10;                return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 4 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # Pattern 4 Draw Logic: 텔레포트 후 공격 시각 효과&#10;        if self.phase == 1:  # 텔레포트 준비 중&#10;            # 텔레포트 징표 (깜빡이는 원)&#10;            blink = int(self.timer * 10) % 2&#10;            if blink == 0:&#10;                p2.draw_circle(draw_x, draw_y, 60)&#10;                p2.draw_circle(draw_x, draw_y, 40)&#10;&#10;        elif self.phase == 2:  # 공격 준비 중&#10;            # 공격 범위 표시 (확장되는 원)&#10;            attack_radius = 80 * (self.timer / self.attack_delay)&#10;            p2.draw_circle(draw_x, draw_y, int(attack_radius))&#10;&#10;&#10;class AttackPattern5Action:&#10;    &quot;&quot;&quot;&#10;    패턴5 - 분신 1체 랜덤 위치에 소환후 모든 방향 방사형으로 수리검 투척 2회 ( 두 번째 투척 수리검의 속도는 첫 번째 투척 속도의 반 )&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 충격파 관련 변수&#10;        self.charge_time = 0.0&#10;        self.shockwave_radius = 0.0&#10;        self.max_radius = 0.0&#10;        self.expand_speed = 0.0&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 5 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화&#10;            self.timer = 0.0&#10;            self.charge_time = 1.0  # 차징 시간&#10;            self.phase = 1&#10;            print(&quot;[Pattern5] 충격파 차징 시작!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 차징 중&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.charge_time:&#10;                # 충격파 발동&#10;                self.shockwave_radius = 0&#10;                self.max_radius = 500&#10;                self.expand_speed = 800&#10;                self.timer = 0.0&#10;                self.phase = 2&#10;                print(&quot;[Pattern5] 충격파 발동!&quot;)&#10;&#10;        elif self.phase == 2:&#10;            # 충격파 확산&#10;            self.shockwave_radius += self.expand_speed * dt&#10;&#10;            # 타겟과의 거리 체크 (충돌 판정)&#10;            if self.panther.target:&#10;                dx = self.panther.target.x - self.panther.x&#10;                dy = self.panther.target.y - self.panther.y&#10;                dist = math.sqrt(dx**2 + dy**2)&#10;&#10;                # 충격파가 타겟을 스쳐 지나가는지 확인&#10;                if abs(dist - self.shockwave_radius) &lt; 50:&#10;                    print(f&quot;[Pattern5] 충격파 적중! (거리: {dist:.0f})&quot;)&#10;&#10;            if self.shockwave_radius &gt;= self.max_radius:&#10;                # 충격파 완료&#10;                self.phase = 0&#10;                self.panther.attack_timer = self.panther.attack_cooldown&#10;                print(&quot;[Pattern5] 충격파 완료!&quot;)&#10;                return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 5 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # Pattern 5 Draw Logic: 광역 충격파 시각 효과&#10;        if self.phase == 1:  # 차징 중&#10;            # 차징 이펙트 (맥동하는 원)&#10;            pulse = (self.timer / self.charge_time) * 50&#10;            p2.draw_circle(draw_x, draw_y, int(50 + pulse))&#10;            p2.draw_circle(draw_x, draw_y, int(30 + pulse))&#10;&#10;        elif self.phase == 2:  # 충격파 확산 중&#10;            # 확산되는 충격파 원 그리기&#10;            p2.draw_circle(draw_x, draw_y, int(self.shockwave_radius))&#10;&#10;            # 내부 충격파 (투명도 효과를 위한 다중 원)&#10;            if self.shockwave_radius &gt; 20:&#10;                p2.draw_circle(draw_x, draw_y, int(self.shockwave_radius - 20))&#10;&#10;&#10;class AttackPattern6Action:&#10;    &quot;&quot;&quot;&#10;    패턴6 - 분신 2체 램덤 위치에 소환후 본체, 분신 2체 번갈아 가며 플레이어를 향해 수리검 5개 방사형으로 3회씩 투척&#10;    &quot;&quot;&quot;&#10;    img_seq = []&#10;    def __init__(self, panther):&#10;        &quot;&quot;&quot;&#10;        Args:&#10;            panther: PantherAssassin 인스턴스 참조&#10;        &quot;&quot;&quot;&#10;        self.panther = panther&#10;        self.phase = 0&#10;        self.timer = 0.0&#10;        # 분신 소환 관련 변수&#10;        self.summon_time = 0.0&#10;        self.duration = 0.0&#10;        # 분신 이미지 시퀀스 로드&#10;        self.img_count = 8&#10;        # if not AttackPattern6Action.img_seq:&#10;        #     try:&#10;        #         for i in range(self.img_count):&#10;        #             img = p2.load_image(f'')&#10;        #             AttackPattern6Action.img_seq.append(img)&#10;        #     except FileNotFoundError as e:&#10;        #         print(f'\033[91m[Pattern6] 이미지 로드 실패: {e}\033[0m')&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;패턴 6 로직 실행&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        if self.phase == 0:&#10;            # 초기화&#10;            self.timer = 0.0&#10;            self.summon_time = 0.5  # 소환 시간&#10;            self.phase = 1&#10;            print(&quot;[Pattern6] 분신 소환 시작!&quot;)&#10;&#10;        elif self.phase == 1:&#10;            # 소환 중&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.summon_time:&#10;                # 분신 소환 완료&#10;                if self.panther.world and self.panther.target:&#10;                    # 분신 위치 계산&#10;                    offset = 200&#10;                    clone_positions = [&#10;                        (self.panther.x - offset, self.panther.y),&#10;                        (self.panther.x + offset, self.panther.y)&#10;                    ]&#10;&#10;                    # 분신에서 타겟으로 투사체 발사&#10;                    for clone_x, clone_y in clone_positions:&#10;                        projectile = Projectile(&#10;                            clone_x, clone_y,&#10;                            self.panther.target.x, self.panther.target.y,&#10;                            speed=450,&#10;                            from_player=False&#10;                        )&#10;                        self.panther.world.get('projectiles', []).append(projectile)&#10;&#10;                    print(&quot;[Pattern6] 분신 공격 발사!&quot;)&#10;&#10;                self.timer = 0.0&#10;                self.duration = 1.0  # 분신 유지 시간&#10;                self.phase = 2&#10;&#10;        elif self.phase == 2:&#10;            # 분신 유지&#10;            self.timer += dt&#10;&#10;            if self.timer &gt;= self.duration:&#10;                # 분신 소멸&#10;                self.phase = 0&#10;                self.panther.attack_timer = self.panther.attack_cooldown&#10;                print(&quot;[Pattern6] 분신 소멸!&quot;)&#10;                return BehaviorTree.SUCCESS&#10;&#10;        return BehaviorTree.RUNNING&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;&#10;        패턴 6 시각 효과 드로잉&#10;&#10;        Args:&#10;            draw_x, draw_y: 보스의 현재 위치 (카메라 좌표계)&#10;        &quot;&quot;&quot;&#10;        # 공격 패턴 전용 이미지가 있다면 사용, 없다면 기본 드로잉 사용&#10;&#10;&#10;        # Pattern 6 Draw Logic: 그림자 분신 소환 시각 효과&#10;        if self.phase == 1:  # 소환 중&#10;            # 소환 진행도 표시&#10;            progress = self.timer / self.summon_time&#10;            summon_radius = 40 + progress * 60&#10;&#10;            # 분신 소환 위치에 원 표시&#10;            offset = 200&#10;            clone_positions = [&#10;                (draw_x - offset, draw_y),&#10;                (draw_x + offset, draw_y)&#10;            ]&#10;&#10;            for clone_x, clone_y in clone_positions:&#10;                p2.draw_circle(clone_x, clone_y, summon_radius)&#10;                p2.draw_line(draw_x, draw_y, clone_x, clone_y)&#10;&#10;        elif self.phase == 2:  # 분신 유지 중&#10;            # 분신 위치 표시 (반투명 효과를 위한 다중 원)&#10;            offset = 200&#10;            clone_positions = [&#10;                (draw_x - offset, draw_y),&#10;                (draw_x + offset, draw_y)&#10;            ]&#10;&#10;            for clone_x, clone_y in clone_positions:&#10;                p2.draw_circle(clone_x, clone_y, 70)&#10;                p2.draw_circle(clone_x, clone_y, 50)&#10;&#10;&#10;# ==================== PantherAssassin 보스 클래스 ====================&#10;&#10;class PantherAssassin:&#10;    &quot;&quot;&quot;&#10;    팬서 암살자 보스 몬스터&#10;&#10;    특징:&#10;    - 6가지 공격 패턴을 랜덤하게 사용&#10;    - 행동 트리 기반 AI&#10;    - 높은 체력과 공격력&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, x, y):&#10;        &quot;&quot;&quot;&#10;        PantherAssassin 초기화&#10;&#10;        Args:&#10;            x, y: 스폰 위치&#10;        &quot;&quot;&quot;&#10;        # 위치 및 기본 속성&#10;        self.x = x&#10;        self.y = y&#10;        self.spawn_x = x  # 스폰 위치 기억&#10;        self.spawn_y = y&#10;&#10;        # 스탯&#10;        from ..stats import PantherAssassinStats&#10;        self.stat = PantherAssassinStats()&#10;&#10;        # 애니메이션&#10;        self.frame = 0&#10;        self.frame_timer = 0.0&#10;        self.frame_speed = 15.0  # 초당 프레임 수&#10;        self.scale_factor = 4.0&#10;        self.animation_frames = 11 # 애니메이션 프레임 수&#10;&#10;        # 충돌 박스&#10;        self.collision_width = 24 * self.scale_factor&#10;        self.collision_height = 26 * self.scale_factor&#10;        self.collision_box_offset_x = 0&#10;        self.collision_box_offset_y = -10 * self.scale_factor&#10;&#10;        # 타겟 (플레이어)&#10;        self.target = None&#10;&#10;        # 월드 참조 (투사체 생성을 위해)&#10;        from ..play_mode import world&#10;        self.world = world&#10;&#10;        # 공격 관련&#10;        self.recognition_distance = 400 # 플레이어 인식 거리&#10;        self.unrecognition_distance = 800 # 플레이어 미인식 거리&#10;        self.attack_range = 800  # 공격 범위 (추가)&#10;        self.attack_cooldown = 2.0  # 공격 쿨타임 (초)&#10;        self.attack_timer = 0.0  # 현재 쿨타임 타이머&#10;&#10;        # 현재 실행 중인 공격 패턴 인스턴스 (드로잉 책임 위임용)&#10;        self.current_action_instance = None&#10;&#10;        # 6가지 공격 패턴 클래스 인스턴스 생성&#10;        self.pattern1_action = AttackPattern1Action(self)&#10;        self.pattern2_action = AttackPattern2Action(self)&#10;        self.pattern3_action = AttackPattern3Action(self)&#10;        self.pattern4_action = AttackPattern4Action(self)&#10;        self.pattern5_action = AttackPattern5Action(self)&#10;        self.pattern6_action = AttackPattern6Action(self)&#10;&#10;        # 임시 스프라이트 (실제 게임에서는 이미지 로드)&#10;        # 일반적으로 Idle 애니메이션 스프라이트 시트 사용&#10;        # 사망시 Death 애니메이션 스프라이트 시트 사용&#10;        self.images = None&#10;        self.clone_images = None&#10;&#10;        try:&#10;            for i in range(self.animation_frames):&#10;                try:&#10;                    img_path = f'resources/Texture_organize/Entity/Stage2_Forest_Boss/Panther_Assassin/Character/PantherAssassin_Idle{i:02d}.png'&#10;                    img = p2.load_image(img_path)&#10;                    if self.images is None:&#10;                        self.images = []&#10;                    self.images.append(img)&#10;&#10;                    # 경로 등록 후 어두운 버전 생성&#10;                    iam.register_image_path(img, img_path)  # 경로 등록 (반환값 없음)&#10;                    clone_img = iam.make_dark(img)  # 어두운 이미지 생성&#10;                    if self.clone_images is None:&#10;                        self.clone_images = []&#10;                    self.clone_images.append(clone_img)&#10;&#10;                    # DEBUG: 이미지 로드 확인&#10;                    print(f'[PantherAssassin] 이미지 로드 성공: PantherAssassin_Idle{i:02d}.png')&#10;&#10;                except FileNotFoundError as e:&#10;                    print(f'\033[91m[PantherAssassin] 이미지 로드 실패: {e}\033[0m')&#10;        except Exception as e:&#10;            print(f'\033[91m[PantherAssassin] 이미지 로드 중 오류 발생: {e}\033[0m')&#10;&#10;        # 행동 트리 빌드&#10;        self.build_behavior_tree()&#10;&#10;        print(f&quot;[PantherAssassin] 생성됨 at ({x}, {y})&quot;)&#10;&#10;    def build_behavior_tree(self):&#10;        &quot;&quot;&quot;&#10;        행동 트리 구축&#10;&#10;        구조:&#10;        Root Selector&#10;        ├── Attack Sequence (공격 시도)&#10;        │   ├── Condition: 쿨타임 준비됨&#10;        │   ├── Condition: 공격 범위 내&#10;        │   └── RandomSelector: 6가지 패턴 중 랜덤 선택&#10;        │       ├── BTActionWrapper: 패턴1 - 90도 방사형으로 플레이어를 향해 2단 표창 투척&#10;        │       ├── BTActionWrapper: 패턴2 - 은신 후 다른 곳에서 나타나 플레이어를 향해 강한 돌진 공격 2회&#10;        │       ├── BTActionWrapper: 패턴3 - 은신 후 다른 곳에서 나타나 플레이어를 향해 돌 진 후 8방향 방사형으로 수리검 투척&#10;        │       │   # 그림자 분신과 함꼐하는 패턴 4, 5, 6&#10;        │       ├── BTActionWrapper: 패턴4 - 은신과 분신 2체를 랜덤 위치에 소환 후 플레이어를 향해 수리검 10회 연속 투척 이후 본체 은신 풀림&#10;        │       ├── BTActionWrapper: 패턴5 - 분신 1체 랜덤 위치에 소환후 모든 방향 방사형으로 수리검 투척 2회 ( 두 번째 투척 수리검의 속도는 첫 번째 투척 속도의 반 )&#10;        │       └── BTActionWrapper: 패턴6 - 분신 2체 램덤 위치에 소환후 본체, 분신 2체 번갈아 가며 플레이어를 향해 수리검 5개 방사형으로 3회씩 투척&#10;        └── Action: 대기 ( Idle )&#10;&#10;        ★ 핵심: BTActionWrapper를 사용하여 패턴 클래스 인스턴스를 BT에 연결&#10;        &quot;&quot;&quot;&#10;&#10;        # 6가지 공격 패턴을 RandomSelector로 구성&#10;        # BTActionWrapper를 사용하여 패턴 클래스 인스턴스를 감쌈&#10;        attack_pattern_selector = RandomSelector(&#10;            &quot;Random Attack Pattern&quot;,&#10;            BTActionWrapper(&quot;Pattern1: Dash&quot;, self.pattern1_action),&#10;            BTActionWrapper(&quot;Pattern2: Shuriken&quot;, self.pattern2_action),&#10;            BTActionWrapper(&quot;Pattern3: Circular&quot;, self.pattern3_action),&#10;            BTActionWrapper(&quot;Pattern4: Teleport&quot;, self.pattern4_action),&#10;            BTActionWrapper(&quot;Pattern5: Shockwave&quot;, self.pattern5_action),&#10;            BTActionWrapper(&quot;Pattern6: Shadow Clone&quot;, self.pattern6_action)&#10;        )&#10;&#10;        # 공격 시퀀스: 쿨타임 체크 -&gt; 범위 체크 -&gt; 패턴 실행&#10;        attack_sequence = Sequence(&#10;            &quot;Try Attack&quot;,&#10;            Condition(&quot;Attack Ready&quot;, self.is_attack_ready),&#10;            Condition(&quot;In Attack Range&quot;, self.is_in_attack_range),&#10;            attack_pattern_selector&#10;        )&#10;&#10;        # 루트 셀렉터: 공격 가능하면 공격, 아니면 대기/순찰&#10;        root = Selector(&#10;            &quot;Root&quot;,&#10;            attack_sequence,&#10;            Action(&quot;Idle or Patrol&quot;, self.handle_idle_action)&#10;        )&#10;&#10;        # 행동 트리 생성&#10;        self.behavior_tree = BehaviorTree(root)&#10;        print(&quot;[PantherAssassin] 행동 트리 빌드 완료 (BTActionWrapper 적용 완료)&quot;)&#10;&#10;    # ==================== 조건 체크 메서드 ====================&#10;&#10;    def is_attack_ready(self):&#10;        &quot;&quot;&quot;공격 쿨타임이 준비되었는지 확인&quot;&quot;&quot;&#10;        return self.attack_timer &lt;= 0.0&#10;&#10;    def is_in_attack_range(self):&#10;        &quot;&quot;&quot;타겟이 공격 범위 내에 있는지 확인&quot;&quot;&quot;&#10;        if self.target is None:&#10;            return False&#10;&#10;        dx = self.target.x - self.x&#10;        dy = self.target.y - self.y&#10;        distance = math.sqrt(dx**2 + dy**2)&#10;&#10;        return distance &lt;= self.attack_range&#10;&#10;    # ==================== 행동 액션 메서드 ====================&#10;&#10;    def handle_idle_action(self):&#10;        &quot;&quot;&quot;&#10;        대기 또는 순찰 행동&#10;        타겟을 향해 천천히 이동&#10;        &quot;&quot;&quot;&#10;        if self.target is None:&#10;            return BehaviorTree.SUCCESS&#10;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 타겟을 향해 이동&#10;        dx = self.target.x - self.x&#10;        dy = self.target.y - self.y&#10;        distance = math.sqrt(dx**2 + dy**2)&#10;&#10;        if distance &gt; 50:  # 최소 거리 유지&#10;            move_x = (dx / distance) * self.stat.get('move_speed') * dt&#10;            move_y = (dy / distance) * self.stat.get('move_speed') * dt&#10;            self.x += move_x&#10;            self.y += move_y&#10;&#10;        return BehaviorTree.SUCCESS&#10;&#10;    # ==================== 업데이트 &amp; 렌더링 ====================&#10;&#10;    def update(self):&#10;        &quot;&quot;&quot;매 프레임 업데이트&quot;&quot;&quot;&#10;        dt = framework.get_delta_time()&#10;&#10;        # 쿨타임 업데이트&#10;        if self.attack_timer &gt; 0:&#10;            self.attack_timer -= dt&#10;&#10;        # 애니메이션 프레임 업데이트&#10;        self.frame_timer += dt&#10;        if self.frame_timer &gt;= 1.0 / self.frame_speed:&#10;            # 이미지가 로드되었을 때만 프레임 업데이트&#10;            if self.images and len(self.images) &gt; 0:&#10;                self.frame = (self.frame + 1) % len(self.images)&#10;            else:&#10;                self.frame = 0&#10;            self.frame_timer = 0.0&#10;&#10;        # 플레이어 인식 거리 체크 (target이 None일 때 예외 처리)&#10;        if self.target is not None:&#10;            dx = self.target.x - self.x&#10;            dy = self.target.y - self.y&#10;            distance = math.sqrt(dx**2 + dy**2)&#10;&#10;            # 인식 거리를 벗어나면 타겟 해제&#10;            if distance &gt;= self.unrecognition_distance:&#10;                self.set_target(None)&#10;                print(f'[PantherAssassin] 타겟 상실 (거리: {distance:.1f})')&#10;        else:&#10;            # 타겟이 없을 때 플레이어 탐색&#10;            if self.world and 'player' in self.world:&#10;                player = self.world['player']&#10;                dx = player.x - self.x&#10;                dy = player.y - self.y&#10;                distance = math.sqrt(dx**2 + dy**2)&#10;&#10;                # 인식 거리 내에 들어오면 타겟 설정&#10;                if distance &lt;= self.recognition_distance:&#10;                    self.set_target(player)&#10;                    print(f'[PantherAssassin] 타겟 인식: 플레이어 at ({player.x}, {player.y}), 거리: {distance:.1f}')&#10;&#10;        # 행동 트리 실행&#10;        if self.behavior_tree:&#10;            self.behavior_tree.run()&#10;&#10;&#10;&#10;    def draw(self, draw_x, draw_y):&#10;        &quot;&quot;&quot;몬스터 렌더링&quot;&quot;&quot;&#10;        &quot;&quot;&quot;&#10;        일반적 Hit 일땐 대미지만 적용, (hit 판정의 이미지 시퀀스 x )&#10;        Death 상태 일땐 현재 이미지 시퀀스를 Death 이미지로 교체 후 재생&#10;        1. Hit 판정시 이미지 시퀀스 교체 없이 대미지만 적용&#10;        2. Death 판정시 이미지 시퀀스를 Death 이미지로 교체&#10;        3. Death 이미지 시퀀스 재생 후 3초 후 몬스터 제거&#10;        &#10;        TODO: 1. 몬스터 사망 후 아이템 드랍 구현&#10;        &quot;&quot;&quot;&#10;        # 몬스터 본체 드로잉&#10;        if self.images and len(self.images) &gt; 0:&#10;            # 프레임 인덱스가 범위를 벗어나지 않도록 보정&#10;            if self.frame &gt;= len(self.images):&#10;                self.frame = 0&#10;&#10;            img = self.images[self.frame]&#10;            img.draw(draw_x, draw_y, img.w * self.scale_factor, img.h * self.scale_factor)&#10;&#10;        else:&#10;            # 디버그 렌더링 (이미지 없을 때)&#10;            p2.draw_rectangle(&#10;                self.x - self.collision_width / 2,&#10;                self.y - self.collision_height / 2,&#10;                self.x + self.collision_width / 2,&#10;                self.y + self.collision_height / 2&#10;            )&#10;&#10;        # 현재 실행 중인 패턴 인스턴스의 이펙트 드로잉 (드로잉 책임 위임)&#10;        if self.current_action_instance is not None:&#10;            # 패턴 인스턴스가 draw 메서드를 가지고 있는지 확인 후 호출&#10;            if hasattr(self.current_action_instance, 'draw'):&#10;                self.current_action_instance.draw(draw_x, draw_y)&#10;&#10;        # DEBUG : 충돌 박스 및 플레이어 인식 범위 그리기&#10;        # 충돌 박스 : 카메라 좌표계로 변환 후 그리기&#10;        Left, Bottom, Right, Top = self.get_bb()&#10;        Left -= self.x - draw_x&#10;        Right -= self.x - draw_x&#10;        Bottom -= self.y - draw_y&#10;        Top -= self.y - draw_y&#10;        p2.draw_rectangle(Left, Bottom, Right, Top, r=255, g=0, b=0)&#10;&#10;        # 공격 범위&#10;        radius = self.recognition_distance&#10;        p2.draw_circle(draw_x, draw_y, int(radius), r=255, g=255, b=0)&#10;&#10;        # 타겟 놓치는 거리&#10;        radius = self.unrecognition_distance&#10;        p2.draw_circle(draw_x, draw_y, int(radius), r=0, g=255, b=255)&#10;&#10;        # 분신 드로잉 (디버그용)&#10;        # if self.clone_images:&#10;        #     offset = 200&#10;        #     self.clone_images[self.frame].draw(draw_x - offset, draw_y,&#10;        #                                        self.clone_images[self.frame].w * self.scale_factor,&#10;        #                                        self.clone_images[self.frame].h * self.scale_factor)&#10;        #&#10;&#10;    def get_bb(self):&#10;        &quot;&quot;&quot;충돌 박스 반환 (left, bottom, right, top)&quot;&quot;&quot;&#10;        half_w = self.collision_width / 2&#10;        half_h = self.collision_height / 2&#10;        return (&#10;            self.x - half_w + self.collision_box_offset_x,&#10;            self.y - half_h + self.collision_box_offset_y,&#10;            self.x + half_w + self.collision_box_offset_x,&#10;            self.y + half_h + self.collision_box_offset_y&#10;        )&#10;&#10;    def take_damage(self, damage):&#10;        &quot;&quot;&quot;피해를 받음&quot;&quot;&quot;&#10;        current_health = self.stat.get('health')&#10;        self.stat.set_base('health', max(0, current_health - damage))&#10;        print(f&quot;[PantherAssassin] 피해 {damage}, 남은 HP: {self.stat.get('health')}/{self.stat.get('max_health')}&quot;)&#10;&#10;        if self.stat.get('health') &lt;= 0:&#10;            print(&quot;[PantherAssassin] 처치됨!&quot;)&#10;            return True  # 사망&#10;        return False&#10;&#10;    def set_target(self, target):&#10;        &quot;&quot;&quot;타겟 설정 (주로 플레이어)&quot;&quot;&quot;&#10;        self.target = target&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>